<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yanglinqi107.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="进程通信之信号">
<meta property="og:type" content="article">
<meta property="og:title" content="信号">
<meta property="og:url" content="http://yanglinqi107.github.io/Linux/Linux%E7%BC%96%E7%A8%8B/03%E4%BF%A1%E5%8F%B7/index.html">
<meta property="og:site_name" content="杨记">
<meta property="og:description" content="进程通信之信号">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220606163333924.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220606181553086.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220606215143352.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220606220448729.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220606225630013.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220607131624931.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220607201242736.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220607201351672.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608164808687.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608165414878.png">
<meta property="article:published_time" content="2022-06-05T08:33:19.540Z">
<meta property="article:modified_time" content="2022-08-01T12:22:56.646Z">
<meta property="article:author" content="yanglinqi">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220606163333924.png">

<link rel="canonical" href="http://yanglinqi107.github.io/Linux/Linux%E7%BC%96%E7%A8%8B/03%E4%BF%A1%E5%8F%B7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>信号 | 杨记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杨记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">碎片化学习令人焦虑，系统化学习使人进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">30</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">100</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yanglinqi107.github.io/Linux/Linux%E7%BC%96%E7%A8%8B/03%E4%BF%A1%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headpic.jpg">
      <meta itemprop="name" content="yanglinqi">
      <meta itemprop="description" content="用于做笔记，对学过的知识总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          信号
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-05 16:33:19" itemprop="dateCreated datePublished" datetime="2022-06-05T16:33:19+08:00">2022-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-01 20:22:56" itemprop="dateModified" datetime="2022-08-01T20:22:56+08:00">2022-08-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Linux%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Linux编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>进程通信之信号</p>
<span id="more"></span>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h3><p>信号在我们的生活中随处可见， 如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪……他们都有共性：</p>
<ol>
<li>简单 </li>
<li>不能携带大量信息 </li>
<li>满足某个特设条件才发送。</li>
</ol>
<p>信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。</p>
<p>Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&amp;T都对信号模型做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。</p>
<h4 id="信号的机制"><a href="#信号的机制" class="headerlink" title="信号的机制"></a>信号的机制</h4><p>A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。与硬件中断类似——异步模式。但<strong>信号是软件层面上实现的中断，早期常被称为“软中断”</strong>。</p>
<p><strong>信号的特质</strong>：由于信号是通过软件方法实现，其实现手段导致信号有很强的<strong>延时性</strong>。但对于用户来说，这个延迟时间非常短，不易察觉。</p>
<p><strong><font color=#ff0000>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</font></strong></p>
<h4 id="相关的事件和状态"><a href="#相关的事件和状态" class="headerlink" title="相关的事件和状态"></a>相关的事件和状态</h4><p><strong>产生信号</strong>: </p>
<ol>
<li><p>按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\</p>
</li>
<li><p>系统调用产生，如：kill、raise、abort</p>
</li>
<li><p>软件条件产生，如：定时器alarm</p>
</li>
<li><p>硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</p>
</li>
<li><p>命令产生，如：kill命令</p>
</li>
</ol>
<p><strong>递达</strong>：递送并且到达进程。</p>
<p><strong>未决</strong>：产生和递达之间的状态。主要由于阻塞（屏蔽）导致该状态。 </p>
<p><strong>信号的处理方式：</strong> </p>
<ol>
<li><p>执行默认动作 </p>
</li>
<li><p>忽略(丢弃) </p>
</li>
<li><p>捕捉(调用户处理函数)</p>
</li>
</ol>
<p>Linux内核的进程控制块PCB是一个结构体，<code>task_struct</code>，除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。</p>
<p><strong>阻塞信号集（信号屏蔽字）</strong>： 将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后（解除屏蔽后）</p>
<p><strong>未决信号集</strong>: </p>
<ol>
<li><p>信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。 </p>
</li>
<li><p>信号产生后由于某些原因（主要是阻塞）不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。   </p>
</li>
</ol>
<h4 id="信号的编号"><a href="#信号的编号" class="headerlink" title="信号的编号"></a>信号的编号</h4><p>可以使用<code>kill –l</code>命令查看当前系统可使用的信号有哪些。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>
<p>不存在编号为0的信号。其中1-31号信号称之为<strong>常规信号</strong>（也叫普通信号或标准信号），34-64称之为<strong>实时信号</strong>，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。</p>
<h4 id="信号4要素"><a href="#信号4要素" class="headerlink" title="信号4要素"></a>信号4要素</h4><p>与变量三要素类似的，每个信号也有其必备4要素，分别是：</p>
<p>1）编号  2）名称   3）事件   4）默认处理动作 </p>
<p>可通过<code>man 7 signal</code>查看帮助文档获取。也可查看<code>/usr/src/linux-headers-3.16.0-30/arch/s390/include/uapi/asm/signal.h</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Signal   	Value   Action  Comment</span><br><span class="line">────────────────────────────────────────────</span><br><span class="line">SIGHUP   	1       Term   Hangup detected on controlling terminal or death of controlling process</span><br><span class="line">SIGINT      2       Term   Interrupt from keyboard</span><br><span class="line">SIGQUIT   	3       Core   Quit from keyboard</span><br><span class="line">SIGILL    	4       Core   Illegal Instruction</span><br><span class="line">SIGFPE      8       Core   Floating point exception</span><br><span class="line">SIGKILL     9       Term   Kill signal</span><br><span class="line">SIGSEGV     11      Core   Invalid memory reference</span><br><span class="line">SIGPIPE     13      Term   Broken pipe: write to pipe with no readers</span><br><span class="line">SIGALRM  	14      Term   Timer signal from alarm(2)</span><br><span class="line">SIGTERM     15      Term   Termination signal</span><br><span class="line">SIGUSR1  30,10,16   Term   User-defined signal 1</span><br><span class="line">SIGUSR2  31,12,17   Term   User-defined signal 2</span><br><span class="line">SIGCHLD  20,17,18   Ign    Child stopped or terminated</span><br><span class="line">SIGCONT  19,18,25   Cont   Continue <span class="keyword">if</span> stopped</span><br><span class="line">SIGSTOP  17,19,23   Stop   Stop process</span><br><span class="line">SIGTSTP  18,20,24   Stop   Stop typed at terminal</span><br><span class="line">SIGTTIN  21,21,26   Stop   Terminal input <span class="keyword">for</span> background process</span><br><span class="line">SIGTTOU  22,22,27   Stop   Terminal output <span class="keyword">for</span> background process</span><br><span class="line">The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</span><br></pre></td></tr></table></figure>
<p>在标准信号中，有一些信号是有三个“Value”，第一个值通常对<code>alpha</code>和<code>sparc</code>架构有效，中间值针对<code>x86</code>、<code>arm</code>和其他架构，最后一个应用于<code>mips</code>架构。一个<code>-</code>表示在对应架构上尚未定义该信号。</p>
<p>不同的操作系统定义了不同的系统信号。因此有些信号出现在Unix系统内，也出现在Linux中，而有的信号出现在FreeBSD或Mac OS中却没有出现在Linux下。这里我们只研究Linux系统中的信号。</p>
<p><strong>默认动作</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Term：终止进程</span><br><span class="line"> Ign：忽略信号 (默认即时对该种信号忽略操作)</span><br><span class="line">Core：终止进程，生成Core文件。(查验进程死亡原因， 用于gdb调试)</span><br><span class="line">Stop：停止（暂停）进程</span><br><span class="line">Cont：继续运行进程</span><br></pre></td></tr></table></figure>
<p>这里特别强调了 <strong>9) SIGKILL 和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</strong></p>
<p><strong>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)，不应乱发信号！！</strong></p>
<h4 id="Linux常规信号表"><a href="#Linux常规信号表" class="headerlink" title="Linux常规信号表"></a>Linux常规信号表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) SIGHUP: 当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程</span><br><span class="line"><span class="number">2</span>) SIGINT：当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。</span><br><span class="line"><span class="number">3</span>) SIGQUIT：当用户按下&lt;ctrl+\&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号。默认动作为终止进程。</span><br><span class="line"><span class="number">4</span>) SIGILL：CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件</span><br><span class="line"><span class="number">5</span>) SIGTRAP：该信号由断点指令或其他 trap指令产生。默认动作为终止里程 并产生core文件。</span><br><span class="line"><span class="number">6</span>) SIGABRT: 调用<span class="built_in">abort</span>函数时产生该信号。默认动作为终止进程并产生core文件。</span><br><span class="line"><span class="number">7</span>) SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。</span><br><span class="line"><span class="number">8</span>) SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为<span class="number">0</span>等所有的算法错误。默认动作为终止进程并产生core文件。</span><br><span class="line"><span class="number">9</span>) SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。</span><br><span class="line"><span class="number">10</span>) SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。</span><br><span class="line"><span class="number">11</span>) SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生core文件。</span><br><span class="line"><span class="number">12</span>) SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。</span><br><span class="line"><span class="number">13</span>) SIGPIPE：Broken pipe向一个没有读端的管道写数据。默认动作为终止进程。</span><br><span class="line"><span class="number">14</span>) SIGALRM: 定时器超时，超时的时间 由系统调用alarm设置。默认动作为终止进程。</span><br><span class="line"><span class="number">15</span>) SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号。默认动作为终止进程。</span><br><span class="line"><span class="number">16</span>) SIGSTKFLT：Linux早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。</span><br><span class="line"><span class="number">17</span>) SIGCHLD：子进程结束时，父进程会收到这个信号。默认动作为忽略这个信号。</span><br><span class="line"><span class="number">18</span>) SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续/忽略。</span><br><span class="line"><span class="number">19</span>) SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。</span><br><span class="line"><span class="number">20</span>) SIGTSTP：停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号。默认动作为暂停进程。</span><br><span class="line"><span class="number">21</span>) SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。</span><br><span class="line"><span class="number">22</span>) SIGTTOU: 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。</span><br><span class="line"><span class="number">23</span>) SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。</span><br><span class="line"><span class="number">24</span>) SIGXCPU：进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程。默认动作为终止进程。</span><br><span class="line"><span class="number">25</span>) SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。</span><br><span class="line"><span class="number">26</span>) SIGVTALRM：虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间。默认动作为终止进程。</span><br><span class="line"><span class="number">27</span>) SGIPROF：类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间。默认动作为终止进程。</span><br><span class="line"><span class="number">28</span>) SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。</span><br><span class="line"><span class="number">29</span>) SIGIO：此信号向进程指示发出了一个异步IO事件。默认动作为忽略。</span><br><span class="line"><span class="number">30</span>) SIGPWR：关机。默认动作为终止进程。</span><br><span class="line"><span class="number">31</span>) SIGSYS：无效的系统调用。默认动作为终止进程并产生core文件。</span><br><span class="line"><span class="number">34</span>) SIGRTMIN ～ (<span class="number">64</span>) SIGRTMAX：LINUX的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程。</span><br></pre></td></tr></table></figure>
<h3 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h3><h4 id="终端按键产生信号"><a href="#终端按键产生信号" class="headerlink" title="终端按键产生信号"></a>终端按键产生信号</h4><p>  Ctrl + c  → 2) SIGINT（终止/中断）     “INT” ——Interrupt</p>
<p>  Ctrl + z  → 20) SIGTSTP（暂停/停止）  “T” ——Terminal 终端。</p>
<p>  Ctrl + \  → 3) SIGQUIT（退出）    </p>
<h4 id="硬件异常产生信号"><a href="#硬件异常产生信号" class="headerlink" title="硬件异常产生信号"></a>硬件异常产生信号</h4><p>  除0操作  → 8) SIGFPE (浮点数例外)    “F” ——-float 浮点数。</p>
<p>  非法访问内存  → 11) SIGSEGV (段错误)</p>
<p>  总线错误  → 7) SIGBUS    </p>
<h4 id="kill函数-命令"><a href="#kill函数-命令" class="headerlink" title="kill函数/命令"></a>kill函数/命令</h4><p><strong>kill命令</strong>产生信号：<code>kill -SIGKILL pid</code></p>
<p><strong>kill函数</strong>：给指定进程发送指定信号（不一定杀死）</p>
<p><code>man 2 kill</code></p>
<p>头文件：<code>#include &lt;signal.h&gt;</code></p>
<p>函数原型：<code>int kill(pid_t pid, int sig);</code> </p>
<ul>
<li><code>pid</code>：<ul>
<li><code>pid &gt; 0</code>：发送信号给指定的进程。</li>
<li><code>pid = 0</code>：发送信号给与调用kill函数进程属于同一进程组的所有进程。</li>
<li><code>pid &lt; -1</code>：取 <code>|pid|</code> 发给对应进程组的所有成员。</li>
<li><code>pid = -1</code>：发送给进程有权限发送的系统中所有进程。</li>
</ul>
</li>
<li><code>sig</code>：要发送的信号。不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</li>
<li>返回值：成功：0；失败：-1 (ID非法，信号非法，普通用户杀init进程等权级问题)，设置errno</li>
</ul>
<p><strong>进程组</strong>：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</p>
<p>权限保护：<code>root</code>用户可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。 <code>kill -9 root用户的pid</code> 是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。普通用户基本规则是：<strong>发送者实际或有效用户ID == 接收者实际或有效用户ID</strong></p>
<p><strong>示例：</strong>创建5个子进程，第3个子进程杀死父进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) <span class="comment">// 创建5个子进程</span></span><br><span class="line">	&#123;</span><br><span class="line">		pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">2</span>)  <span class="comment">// 第3个子进程向父进程发送 SIGKILL信号 杀死父进程</span></span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">3</span>);</span><br><span class="line">		kill(getppid(), SIGKILL);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;parent pid = %d\n&quot;</span>, getpid());</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child pid = %d\n&quot;</span>, getpid());</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="raise函数"><a href="#raise函数" class="headerlink" title="raise函数"></a>raise函数</h4><p><code>man 3 raise</code></p>
<p>头文件：<code>#include &lt;signal.h&gt;</code></p>
<p>函数原型：<code>int raise(int sig);</code></p>
<ul>
<li>返回值：成功0，失败非0</li>
</ul>
<p>作用：给当前进程发送指定信号（自己给自己发）：<code>raise(signo) &lt;==&gt; kill(getpid(), signo);</code></p>
<h4 id="abort函数"><a href="#abort函数" class="headerlink" title="abort函数"></a>abort函数</h4><p><code>man 3 abort</code></p>
<p>头文件：<code>#include &lt;stdlib.h&gt;</code></p>
<p>函数原型：<code>void abort(void);</code></p>
<p>作用：给自己发送异常终止信号 <code>6)SIGABRT</code> 信号，终止并产生core文件</p>
<h4 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h4><p>设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送 <code>14)SIGALRM</code>信号。进程收到该信号，默认动作终止。</p>
<font color=#ff0000>每个进程都有且只有唯一个定时器。</font>

<p><code>man 2 alarm</code></p>
<p>头文件：<code>#include &lt;unistd.h&gt;</code></p>
<p>函数原型：<code>unsigned int alarm(unsigned int seconds);</code></p>
<ul>
<li>返回0或上个闹钟剩余的秒数，无失败。</li>
</ul>
<p>常用：取消定时器<code>alarm(0)</code>，返回旧闹钟余下秒数。</p>
<p>定时，与进程状态无关(自然定时法)！就绪、运行、挂起(阻塞、暂停)、终止、僵尸…无论进程处于何种状态，alarm都计时。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alarm.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	alarm(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用time命令查看程序执行的时间。</strong>    </p>
<p>程序运行的瓶颈在于IO，优化程序，首选优化IO。</p>
<p><strong>实际执行时间 = 系统时间 + 用户时间 + 等待时间</strong></p>
<ul>
<li>等待时间可能包括：等CPU，等I/O，…</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220606163333924.png" alt="image-20220606163333924"></p>
<h4 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h4><p><code>man 2 setitimer</code></p>
<p><code>setitimer</code> 设置定时器的值。可代替alarm函数。精度微秒us，可以实现周期定时。</p>
<p><code>getitimer</code> 获取定时器的值</p>
<p>头文件：<code>#include &lt;sys/time.h&gt;</code></p>
<p>函数原型：</p>
<ul>
<li><code>int getitimer(int which, struct itimerval *curr_value);</code></li>
<li><code>int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);</code> </li>
</ul>
<p>说明：</p>
<ul>
<li><p>成功返回0，失败-1</p>
</li>
<li><p><code>which</code> 指定定时方式</p>
<ul>
<li><code>ITIMER_REAL</code>：自然定时（同alarm）→ <code>14)SIGLARM</code>  计算自然时间</li>
<li><code>ITIMER_VIRTUAL</code>：虚拟空间计时（用户空间）→  <code>26)SIGVTALRM</code> 只计算进程占用cpu的时间</li>
<li><code>ITIMER_PROF</code>：运行时计时（用户+内核）→ <code>27)SIGPROF</code>  计算占用cpu及执行系统调用的时间</li>
</ul>
</li>
<li><p>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">    <span class="comment">// 周期定时</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">/* next value */</span></span><br><span class="line">    <span class="comment">// 第一次启动时间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">/* current value */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="keyword">time_t</span> tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">	<span class="keyword">suseconds_t</span> tv_usec;   <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>it_interval</code>和<code>it_value</code>都设置为0，即清0操作。</p>
</li>
</ul>
<p><strong>示例一：</strong> </p>
<p>实现<code>alarm</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">my_alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> sec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">newValue</span>, <span class="title">oldValue</span>;</span></span><br><span class="line">	newValue.it_value.tv_sec = sec;</span><br><span class="line">	newValue.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">	newValue.it_interval.tv_sec = <span class="number">0</span>;</span><br><span class="line">	newValue.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = setitimer(ITIMER_REAL, &amp;newValue, &amp;oldValue);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> oldValue.it_value.tv_sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	my_alarm(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p><strong>示例二：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">	signal(SIGALRM, myfunc);   <span class="comment">//注册SIGALRM信号的捕捉处理函数。</span></span><br><span class="line"></span><br><span class="line">	it.it_value.tv_sec = <span class="number">5</span>;</span><br><span class="line">	it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	it.it_interval.tv_sec = <span class="number">3</span>;</span><br><span class="line">	it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(setitimer(ITIMER_REAL, &amp;it, &amp;oldit) == <span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;setitimer error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号集操作"><a href="#信号集操作" class="headerlink" title="信号集操作"></a>信号集操作</h3><p>内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字 <code>mask</code> 可以影响未决信号集。而我们可以在应用程序中自定义 <code>set</code> 来改变 <code>mask</code>。已达到屏蔽指定信号的目的。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220606181553086.png" alt="image-20220606181553086"></p>
<h4 id="信号集设定"><a href="#信号集设定" class="headerlink" title="信号集设定"></a>信号集设定</h4><p><code>man 3 sigemptyset</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span>;	<span class="comment">// typedef unsigned long sigset_t; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将set信号集清0    成功0，失败-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将set信号集置1		成功0，失败-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将某个信号加入信号集		成功0，失败-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将某个信号请出信号集		成功0，失败-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断某个信号是否在信号集中	在集合1，不在0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>sigset_t</code>类型的本质是<strong>位图</strong>。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</p>
<h4 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h4><p>用来<strong>屏蔽信号、解除屏蔽</strong>。其本质，读取或修改进程的信号屏蔽字（PCB中）</p>
<p><strong>严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。</strong></p>
<p><code>man 2 sigprocmask</code></p>
<p>头文件：<code>#include &lt;signal.h&gt;</code></p>
<p>函数原型：<code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code></p>
<ul>
<li><code>set</code>：传入参数，是一个位图，set中哪位置1，就表示当前进程屏蔽哪个信号</li>
<li><code>oldset</code>：传出参数，保存旧的信号屏蔽集</li>
<li><code>how</code>参数取值：假设当前的信号屏蔽字为<code>mask</code><ul>
<li><code>SIG_BLOCK</code>：当how设置为此值，set表示需要屏蔽的信号。相当于 <code>mask = mask|set</code></li>
<li><code>SIG_UNBLOCK</code>：当how设置为此，set表示需要解除屏蔽的信号。相当于 <code>mask = mask &amp; ~set</code></li>
<li><code>SIG_SETMASK</code>：当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于 <code>mask = set</code>若，调用<code>sigprocmask</code>解除了对当前若干个信号的阻塞，则在<code>sigprocmask</code>返回前，至少将其中一个信号递达</li>
</ul>
</li>
<li>成功：0；失败：-1</li>
</ul>
<h4 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h4><p>读取当前进程的<strong>未决</strong>信号集</p>
<p><code>man 2 sigpending</code></p>
<p>头文件：<code>#include &lt;signal.h&gt;</code></p>
<p>函数原型：<code>int sigpending(sigset_t *set);</code></p>
<ul>
<li><code>set</code>传出参数</li>
<li>成功返回0，失败-1</li>
</ul>
<h4 id="阻塞信号示例"><a href="#阻塞信号示例" class="headerlink" title="阻塞信号示例"></a>阻塞信号示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_set</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(sigismember(<span class="built_in">set</span>, i))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>, oldset, pedset;</span><br><span class="line">	</span><br><span class="line">	sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">	sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">	<span class="keyword">int</span> ret = sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oldset);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sigpending(&amp;pedset);</span><br><span class="line">		print_set(&amp;pedset);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220606215143352.png" alt="image-20220606215143352"></p>
<h3 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h3><h4 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h4><p><code>man 2 signal</code> </p>
<p>作用：<strong>注册</strong>一个信号捕捉函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line">					<span class="comment">// 捕捉的信号   信号捕捉函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：捕捉函数的句柄</li>
</ul>
<p>该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用<code>sigaction</code>函数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_catch</span><span class="params">(<span class="keyword">int</span> sign)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;catch you!! %d\n&quot;</span>, sign);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	signal(SIGINT, sig_catch);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220606220448729.png" alt="image-20220606220448729"></p>
<h4 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h4><p><code>man 2 sigaction</code> </p>
<p>作用：修改信号处理动作（通常在Linux用其来注册一个信号的捕捉函数）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);  <span class="comment">// 信号捕捉函数</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);  <span class="comment">// 可携带数据</span></span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;  <span class="comment">// 作用域为信号捕捉函数的信号集</span></span><br><span class="line">    <span class="keyword">int</span>        sa_flags; <span class="comment">//0 在信号捕捉函数处理signum信号期间，对再次到来的signum信号默认屏蔽</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct sigaction</span></span><br><span class="line"><span class="comment">	sa_handler</span></span><br><span class="line"><span class="comment">		捕捉函数名</span></span><br><span class="line"><span class="comment">  		SIG_IGN -- 忽略</span></span><br><span class="line"><span class="comment">  		SIG_DFL -- 默认动作</span></span><br><span class="line"><span class="comment">    sa_mask：捕捉函数执行期间的屏蔽字</span></span><br><span class="line"><span class="comment">	sa_flags：</span></span><br><span class="line"><span class="comment">  		0 -- 默认屏蔽要捕捉的信号</span></span><br><span class="line"><span class="comment">  		SA_SIGINFO -- 选用sa_sigaction来指定捕捉函数</span></span><br><span class="line"><span class="comment">  		SA_INTERRURT -- 系统调用被信号中断后，不重启</span></span><br><span class="line"><span class="comment">  		SA_RESTART -- 自动重启</span></span><br><span class="line"><span class="comment"> 	 	SA_DEFER -- 不自动屏蔽本信号 </span></span><br><span class="line"><span class="comment">    sa_sigaction: 指定带参数的信号捕捉函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>signum</code>：捕捉的信号</li>
<li><code>act</code>：传入参数，新的处理方式。</li>
<li><code>oldact</code>：传出参数，旧的处理方式</li>
<li>成功：0；失败：-1</li>
</ul>
<p><code>sa_restorer</code>：该元素是过时的，不应该使用，POSIX.1标准将不指定该元素。(弃用)</p>
<p><code>sa_sigaction</code>：当<code>sa_flags</code>被指定为<code>SA_SIGINFO</code>标志时，使用该信号处理程序。（很少使用）</p>
<p><strong>重点掌握</strong>：</p>
<p>① <code>sa_handler</code>：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作</p>
<p>② <code>sa_mask</code>: 调用信号处理函数时，所要屏蔽的信号集合（<code>sa_mask</code>和<code>mask</code>的并集）。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</p>
<p>③ <code>sa_flags</code>：通常设置为0，表使用默认属性。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_catch</span><span class="params">(<span class="keyword">int</span> sign)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;catch you!! %d\n&quot;</span>, sign);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    </span><br><span class="line">    act.sa_handler = sig_catch; <span class="comment">// 设置回调函数</span></span><br><span class="line">    sigemptyset(&amp;(act.sa_mask)); <span class="comment">// 清空sa_mask屏蔽字，只在sig_catch工作时有效</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;		<span class="comment">// 默认值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = sigaction(SIGQUIT, &amp;act, &amp;oldact); <span class="comment">// 注册信号捕捉函数</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号捕捉特性"><a href="#信号捕捉特性" class="headerlink" title="信号捕捉特性"></a>信号捕捉特性</h4><ol>
<li><p>进程正常运行时，默认PCB中有一个信号屏蔽字，假定为<code>mask</code>，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号以后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号由<code>mask</code>和<code>sa_mask</code>的并集来指定。调用完信号处理函数，再恢复为<code>mask</code>。</p>
</li>
<li><p>XXX信号捕捉函数执行期间，XXX信号自动被屏蔽。</p>
</li>
<li><p><strong>阻塞的常规信号不支持排队，产生多次只记录一次</strong>。（后32个实时信号支持排队）</p>
</li>
</ol>
<h4 id="捕捉信号过程"><a href="#捕捉信号过程" class="headerlink" title="捕捉信号过程"></a>捕捉信号过程</h4><p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220606225630013.png" alt="image-20220606225630013"></p>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><p><strong>竞态条件（时序竞态）</strong></p>
<h4 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a>pause函数</h4><p>调用该函数可以造成进程主动挂起，等待信号唤醒。调用该系统调用的进程将处于阻塞状态（主动放弃cpu）直到有信号递达将其唤醒</p>
<p><code>man 2 pause</code> </p>
<p>作用：挂起进程直到信号唤醒</p>
<p>头文件：<code>#include &lt;unistd.h&gt;</code></p>
<p>函数原型：<code>int pause(void);</code></p>
<ul>
<li>返回值：被信号唤醒，返回-1，<code>errno</code>设为<code>EINTR</code> </li>
<li>如果信号的默认处理动作是终止进程，则进程终止，<code>pause</code>函数没有有机会返回</li>
<li>如果信号的默认处理动作是忽略，进程继续处于挂起状态，<code>pause</code>函数不返回</li>
<li>如果信号的处理动作是捕捉，则调用完信号处理函数之后，<code>pause</code>返回-1，<code>errno</code>设置为<code>EINTR</code>，表示<strong>被信号中断</strong></li>
<li><code>pause</code>收到的信号不能被屏蔽，如果被屏蔽，那么pause就不能被唤醒</li>
</ul>
<p><strong>示例：</strong>使用<code>pause</code>和<code>alarm</code>实现<code>sleep</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_sigalrm</span><span class="params">(<span class="keyword">int</span> sign)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;catch SIGALRM %d\n&quot;</span>, sign);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">	act.sa_handler = catch_sigalrm;</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	ret = sigaction(SIGALRM, &amp;act, &amp;oldact);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	alarm(second);</span><br><span class="line">	</span><br><span class="line">	ret = pause(); <span class="comment">// 主动挂起 等信号</span></span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EINTR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pause success over\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = alarm(<span class="number">0</span>);</span><br><span class="line">	sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>); <span class="comment">// 恢复信号默认动作</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mysleep(<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：睡觉，alarm(10)闹铃。</p>
<ul>
<li>正常： 10后闹铃将我唤醒，这时额外设置alarm(0)取消闹铃，不会出错。</li>
<li>异常： 5分钟，被其他事物吵醒，alarm(0)取消闹铃防止打扰。</li>
</ul>
<h4 id="时序竞态"><a href="#时序竞态" class="headerlink" title="时序竞态"></a>时序竞态</h4><p><strong>前导例</strong></p>
<p>设想如下场景：欲睡觉，定闹钟10分钟，希望10分钟后闹铃将自己唤醒。</p>
<ul>
<li>正常：定时，睡觉，10分钟后被闹钟唤醒。    </li>
<li>异常：闹钟定好后，被唤走，外出劳动，20分钟后劳动结束。回来继续睡觉计划，但劳动期间闹钟已经响过，不会再将我唤醒。</li>
</ul>
<p><strong>时序问题分析</strong></p>
<p>回顾，借助<code>pause</code>和<code>alarm</code>实现的<code>mysleep</code>函数。设想如下时序：</p>
<ol>
<li><p>注册<code>SIGALRM</code>信号处理函数     （sigaction…)</p>
</li>
<li><p>调用<code>alarm(1)</code>函数设定闹钟1秒。</p>
</li>
<li><p>函数调用刚结束，开始倒计时1秒。当前进程失去cpu，内核调度优先级高的进程(有多个)取代当前进程。当前进程无法获得cpu，进入就绪态等待cpu。</p>
</li>
<li><p>1秒后，闹钟超时，内核向当前进程发送<code>SIGALRM</code>信号(自然定时法，与进程状态无关)，高优先级进程尚未执行完，当前进程仍处于就绪态，信号无法处理(未决)</p>
</li>
<li><p>优先级高的进程执行完，当前进程获得cpu资源，内核调度回当前进程执行。<code>SIGALRM</code>信号递达，信号设置捕捉，执行处理函数sig_alarm。</p>
</li>
<li><p>信号处理函数执行结束，返回当前进程主控流程，<code>pause()</code>被调用挂起等待。（欲等待<code>alarm</code>函数发送的<code>SIGALRM</code>信号将自己唤醒）</p>
</li>
<li><p><code>SIGALRM</code>信号已经处理完毕，<code>pause</code>不会等到。</p>
</li>
</ol>
<p><strong>解决时序问题</strong></p>
<p>可以通过设置屏蔽<code>SIGALRM</code>的方法来控制程序执行逻辑，但无论如何设置，程序都有可能在<strong>解除信号屏蔽</strong>与<strong>挂起等待信号</strong>这个两个操作间隙失去cpu资源。除非将这两步骤合并成一个<strong>原子操作</strong>。<code>sigsuspend</code>函数具备这个功能。在对时序要求严格的场合下都应该使用<code>sigsuspend</code>替换<code>pause</code>。 </p>
<h4 id="sigsuspend函数"><a href="#sigsuspend函数" class="headerlink" title="sigsuspend函数"></a>sigsuspend函数</h4><p>作用：挂起进程，等待信息</p>
<p><code>man 2 sigsuspend</code> </p>
<p>头文件：<code>#include &lt;signal.h&gt;</code></p>
<p>函数原型：<code>int sigsuspend(const sigset_t *mask);</code></p>
<ul>
<li>函数调用期间，进程信号屏蔽字由其<strong>参数mask</strong>指定。</li>
</ul>
<p>可将某个信号（如<code>SIGALRM</code>）从临时信号屏蔽字<code>mask</code>中删除，这样在调用<code>sigsuspend</code>时将解除对该信号的屏蔽，然后挂起等待，当<code>sigsuspend</code>返回时，进程的信号屏蔽字恢复为原来的值。如果原来对该信号是屏蔽态，<code>sigsuspend</code>函数返回后仍然屏蔽该信号。</p>
<p><strong>示例</strong>：<code>sleep.c</code>的改进，<code>sigsuspend.c</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_sigalrm</span><span class="params">(<span class="keyword">int</span> sign)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;catch SIGALRM %d\n&quot;</span>, sign);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">	<span class="keyword">sigset_t</span> newmask, oldmask, suspmask;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.为SIGALRM设置捕捉函数</span></span><br><span class="line">	newact.sa_handler = catch_sigalrm;</span><br><span class="line">	newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">	sigaction(SIGALRM, &amp;newact, &amp;oldact);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.设置阻塞信号集，阻塞SIGALRM信号</span></span><br><span class="line">	sigemptyset(&amp;newmask);</span><br><span class="line">	sigaddset(&amp;newmask, SIGALRM);</span><br><span class="line">	sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.定时n秒，到时产生SIGALRM信号</span></span><br><span class="line">	alarm(second);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4.构造一个调用sigsuspend临时有效的阻塞信号集</span></span><br><span class="line">	<span class="comment">//在临时阻塞信号集里解除SIGALRM的阻塞</span></span><br><span class="line">	suspmask = oldmask;</span><br><span class="line">	sigdelset(&amp;suspmask, SIGALRM);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.sigsuspend调用期间，采用临时阻塞信号集suspmask替换原有阻塞信号集</span></span><br><span class="line">	<span class="comment">//这个信号集不包含SIGALRM信号 挂起等待</span></span><br><span class="line">	<span class="comment">//当sigsuspend被信号唤醒返回时，恢复原有的阻塞信号集</span></span><br><span class="line">	sigsuspend(&amp;suspmask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//6.恢复SIGALRM原有的处理动作，呼应前面注释1</span></span><br><span class="line">	sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//7.解除对SIGALRM的阻塞，呼应前面注释2</span></span><br><span class="line">	sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	unslept = alarm(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> unslept;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mysleep(<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>竞态条件，跟系统负载有很紧密的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</p>
<p>不可靠由其实现原理所致。信号是通过软件方式实现(跟内核调度高度依赖，延时性强)，每次系统调用结束后，或中断处理处理结束后，需通过扫描PCB中的未决信号集，来判断是否应处理某个信号。当系统负载过重时，会出现时序混乱。</p>
<p>这种意外情况只能在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补。且由于该错误不具规律性，后期捕捉和重现十分困难。</p>
<h4 id="全局变量异步I-O"><a href="#全局变量异步I-O" class="headerlink" title="全局变量异步I/O"></a>全局变量异步I/O</h4><p>分析如下父子进程交替数数程序。当捕捉函数里面的sleep取消，程序即会出现问题。请分析原因。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am child  %d\t%d\n&quot;</span>, getpid(), n);</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_parent</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am parent %d\t%d\n&quot;</span>, getpid(), n);</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        act.sa_handler = do_sig_parent;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGUSR2, &amp;act, <span class="literal">NULL</span>); <span class="comment">//注册自己的信号捕捉函数  父使用SIGUSR2信号</span></span><br><span class="line">        do_sig_parent(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* wait for signal */</span>;</span><br><span class="line">           <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;             <span class="comment">//父进程数数完成</span></span><br><span class="line">                kill(pid, SIGUSR1);</span><br><span class="line">                flag = <span class="number">0</span>;               <span class="comment">//标志已经给子进程发送完信号</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        n = <span class="number">2</span>;</span><br><span class="line">        act.sa_handler = do_sig_child;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* waiting for a signal */</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                kill(getppid(), SIGUSR2);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例中，通过flag变量标记程序实行进度。flag置1表示数数完成。flag置0表示给对方发送信号完成。</p>
<p>问题出现的位置，在父子进程kill函数之后需要紧接着调用 flag，将其置0，标记信号已经发送。但，在这期间很有可能被kernel调度，失去执行权利，而对方获取了执行时间，通过发送信号回调捕捉函数，从而修改了全局的flag。</p>
<p>如何解决该问题呢？可以使用后续课程讲到的<strong>锁</strong>机制。当操作全局变量的时候，通过<strong>加锁、解锁</strong>来解决该问题。</p>
<p>现阶段，我们在编程期间如若使用全局变量，应在主观上注意<strong>全局变量的异步IO</strong>可能造成的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去掉flag，直接发送信号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am child  %d\t%d\n&quot;</span>, getpid(), n);</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    kill(getppid(), SIGUSR2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_parent</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am parent %d\t%d\n&quot;</span>, getpid(), n);</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    kill(getpid(), SIGUSR2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        act.sa_handler = do_sig_parent;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGUSR2, &amp;act, <span class="literal">NULL</span>);             <span class="comment">//注册自己的信号捕捉函数  父使用SIGUSR2信号</span></span><br><span class="line">        do_sig_parent(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        n = <span class="number">2</span>;</span><br><span class="line">        act.sa_handler = do_sig_child;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可-不可重入函数"><a href="#可-不可重入函数" class="headerlink" title="可/不可重入函数"></a>可/不可重入函数</h4><p>一个函数在被调用执行期间(尚未调用结束)，由于某种时序又被重复调用，称之为“重入”。根据函数实现的方法可分为“可重入函数”和“不可重入函数”两种。看如下时序。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220607131624931.png" alt="image-20220607131624931"></p>
<p>显然，insert函数是不可重入函数，重入调用，会导致意外结果呈现。究其原因，是<strong>该函数内部实现使用了全局变量</strong>。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><p>定义可重入函数，函数内不能含有全局变量及static变量，不能使用malloc、free</p>
</li>
<li><p>信号捕捉函数应设计为可重入函数</p>
</li>
<li><p>信号处理程序可以调用的可重入函数可参阅man 7 signal </p>
</li>
<li><p>没有包含在上述列表中的函数大多是不可重入的，其原因为：</p>
<ol>
<li>使用静态数据结构</li>
<li>调用了malloc或free</li>
<li>是标准I/O函数</li>
</ol>
</li>
</ol>
<h3 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h3><h4 id="SIGCHLD产生条件"><a href="#SIGCHLD产生条件" class="headerlink" title="SIGCHLD产生条件"></a>SIGCHLD产生条件</h4><p>子进程状态改变，都会向父进程发送<code>SIGCHLD</code>信号</p>
<ul>
<li>子进程终止时</li>
<li>子进程接收到<code>SIGSTOP</code>信号停止时</li>
<li>子进程处在停止态，接受到<code>SIGCONT</code>后唤醒时</li>
</ul>
<h4 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h4><p>子进程结束运行，其父进程会收到<code>SIGCHLD</code>信号。该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line"> 	<span class="comment">//if ((pid = waitpid(0, &amp;status, WNOHANG)) &gt; 0)</span></span><br><span class="line">	<span class="keyword">while</span>((pid = waitpid(<span class="number">0</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;-- child %d exit %d\n&quot;</span>, pid, WEXITSTATUS(status));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child %d cancel signal %d\n&quot;</span>, pid, WTERMSIG(status));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">//1.阻塞SIGCHLD </span></span><br><span class="line">    <span class="comment">// code here</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">			sys_err(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">// 10个子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child ID %d\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//注册信号捕捉函数</span></span><br><span class="line">		struct sigaction act;</span><br><span class="line">		act.sa_handler = do_sig_child;</span><br><span class="line">		sigemptyset(&amp;act.sa_mask);</span><br><span class="line">		act.sa_flags = <span class="number">0</span>;</span><br><span class="line">		sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//2.注册完信号捕捉函数，解除SIGCHLD屏蔽</span></span><br><span class="line">        <span class="comment">//code here</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Parent ID %d\n&quot;</span>, getpid());</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析该例子。结合 <code>17)SIGCHLD</code> 信号默认动作，掌握父使用捕捉函数回收子进程的方式。</p>
<p>如果每创建一个子进程后不使用<code>sleep</code>可以吗？</p>
<ul>
<li>不加<code>sleep</code>，可能父进程还未注册信号捕捉函数，子进程就结束。此时父进程对收到的信号默认忽略。</li>
</ul>
<p>可不可以将程序中，捕捉函数内部的while替换为if？为什么？ </p>
<ul>
<li>不能。信号不支持排队，当正在执行<code>SIGCHLD</code>捕捉函数时，若有多个子进程结束，父进程收到多个<code>SIGCHLD</code>信号，只会记录一次。用<code>if</code>只能回收一个在此期间结束的子进程，用<code>while</code>能回收全部</li>
</ul>
<p><strong>while</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220607201242736.png" alt="image-20220607201242736" style="zoom:80%;" /></p>
<p><strong>if</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220607201351672.png" alt="image-20220607201351672" style="zoom:80%;" /></p>
<h4 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h4><ol>
<li><p>子进程继承了父进程的信号屏蔽字和信号处理动作，但子进程没有继承未决信号集spending。</p>
</li>
<li><p>注意注册信号捕捉函数的位置。</p>
</li>
<li><p>应该在fork之前，阻塞<code>SIGCHLD</code>信号。注册完捕捉函数后解除阻塞。</p>
</li>
</ol>
<h3 id="信号传参"><a href="#信号传参" class="headerlink" title="信号传参"></a>信号传参</h3><p>发送信号传参：<code>sigqueue</code>函数</p>
<p>捕捉信号传参：<code>sigaction</code>函数</p>
<h4 id="sigqueue函数"><a href="#sigqueue函数" class="headerlink" title="sigqueue函数"></a>sigqueue函数</h4><p><code>sigqueue</code>函数对应kill函数，但可在向指定进程发送信号的同时携带参数</p>
<p><code>man 3 sigqueue</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigqueue</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig, <span class="keyword">const</span> <span class="keyword">union</span> sigval value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sigval</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   sival_int;</span><br><span class="line">    <span class="keyword">void</span> *sival_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>向指定进程发送指定信号的同时，携带数据。但，如传地址，需注意，不同进程之间虚拟地址空间各自独立，将当前进程地址传递给另一进程没有实际意义（传给自己则能操作该虚拟地址）。</p>
<h4 id="sigaction函数-1"><a href="#sigaction函数-1" class="headerlink" title="sigaction函数"></a>sigaction函数</h4><p>前面对<code>sigaction</code>有介绍，这里是捕捉函数传参的用法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;</span><br><span class="line">    <span class="keyword">int</span>        sa_flags;</span><br><span class="line">    <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">siginfo_t</span> &#123;</span><br><span class="line">    <span class="keyword">int</span>      si_signo;     <span class="comment">/* Signal number */</span></span><br><span class="line">    <span class="keyword">int</span>      si_errno;     <span class="comment">/* An errno value */</span></span><br><span class="line">    <span class="keyword">int</span>      si_code;      <span class="comment">/* Signal code */</span></span><br><span class="line">    <span class="keyword">int</span>      si_trapno;    <span class="comment">/* Trap number that caused</span></span><br><span class="line"><span class="comment">                                         hardware-generated signal</span></span><br><span class="line"><span class="comment">                                         (unused on most architectures) */</span></span><br><span class="line">    <span class="keyword">pid_t</span>    si_pid;       <span class="comment">/* Sending process ID */</span></span><br><span class="line">    <span class="keyword">uid_t</span>    si_uid;       <span class="comment">/* Real user ID of sending process */</span></span><br><span class="line">    <span class="keyword">int</span>      si_status;    <span class="comment">/* Exit value or signal */</span></span><br><span class="line">    <span class="keyword">clock_t</span>  si_utime;     <span class="comment">/* User time consumed */</span></span><br><span class="line">    <span class="keyword">clock_t</span>  si_stime;     <span class="comment">/* System time consumed */</span></span><br><span class="line">    <span class="keyword">sigval_t</span> si_value;     <span class="comment">/* Signal value */</span></span><br><span class="line">    <span class="keyword">int</span>      si_int;       <span class="comment">/* POSIX.1b signal */</span></span><br><span class="line">    <span class="keyword">void</span>    *si_ptr;       <span class="comment">/* POSIX.1b signal */</span></span><br><span class="line">    <span class="keyword">int</span>      si_overrun;   <span class="comment">/* Timer overrun count;</span></span><br><span class="line"><span class="comment">                                         POSIX.1b timers */</span></span><br><span class="line">    <span class="keyword">int</span>      si_timerid;   <span class="comment">/* Timer ID; POSIX.1b timers */</span></span><br><span class="line">    <span class="keyword">void</span>    *si_addr;      <span class="comment">/* Memory location which caused fault */</span></span><br><span class="line">    <span class="keyword">long</span>     si_band;      <span class="comment">/* Band event (was int in</span></span><br><span class="line"><span class="comment">                                         glibc 2.3.2 and earlier) */</span></span><br><span class="line">    <span class="keyword">int</span>      si_fd;        <span class="comment">/* File descriptor */</span></span><br><span class="line">    <span class="keyword">short</span>    si_addr_lsb;  <span class="comment">/* Least significant bit of address</span></span><br><span class="line"><span class="comment">                                         (since Linux 2.6.32) */</span></span><br><span class="line">    <span class="keyword">void</span>    *si_lower;     <span class="comment">/* Lower bound when address violation</span></span><br><span class="line"><span class="comment">                                         occurred (since Linux 3.19) */</span></span><br><span class="line">    <span class="keyword">void</span>    *si_upper;     <span class="comment">/* Upper bound when address violation</span></span><br><span class="line"><span class="comment">                                         occurred (since Linux 3.19) */</span></span><br><span class="line">    <span class="keyword">int</span>      si_pkey;      <span class="comment">/* Protection key on PTE that caused</span></span><br><span class="line"><span class="comment">                                         fault (since Linux 4.6) */</span></span><br><span class="line">    <span class="keyword">void</span>    *si_call_addr; <span class="comment">/* Address of system call instruction</span></span><br><span class="line"><span class="comment">                                         (since Linux 3.5) */</span></span><br><span class="line">    <span class="keyword">int</span>      si_syscall;   <span class="comment">/* Number of attempted system call</span></span><br><span class="line"><span class="comment">                                         (since Linux 3.5) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> si_arch;  <span class="comment">/* Architecture of attempted system call</span></span><br><span class="line"><span class="comment">                                         (since Linux 3.5) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当注册信号捕捉函数，希望获取更多信号相关信息，不应使用<code>sa_handler</code>而应该使用<code>sa_sigaction</code>。但此时的<code>sa_flags</code>必须指定为<code>SA_SIGINFO</code>。<code>siginfo_t</code>是一个成员十分丰富的结构体类型，可以携带各种与信号相关的数据。</p>
<h3 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h3><p>系统调用可分为两类：<strong>慢速系统调用</strong>和其他系统调用。</p>
<ol>
<li><p>慢速系统调用：可能会<strong>使进程永远阻塞</strong>的一类。如果在阻塞期间收到一个信号，该系统调用就被中断,不再继续执行(早期)；也可以设定系统调用是否重启。如，<code>read</code>、<code>write</code>、<code>pause</code>、<code>wait</code>…</p>
</li>
<li><p>其他系统调用：<code>getpid</code>、<code>getppid</code>、<code>fork</code>…</p>
</li>
</ol>
<p>结合<code>pause</code>，回顾慢速系统调用：</p>
<p>慢速系统调用被中断的相关行为，实际上就是pause的行为： 如，read</p>
<p>① 想中断pause，信号不能被屏蔽。</p>
<p>② 信号的处理方式必须是捕捉 (默认、忽略都不可以)</p>
<p>③ 中断后返回-1， 设置<code>errno</code>为<code>EINTR</code>(表“被信号中断”)</p>
<p>可修改<code>sa_flags</code>参数来设置被信号中断后系统调用是否重启。<code>SA_INTERRURT</code>不重启。 <code>SA_RESTART</code>重启。</p>
<p>扩展了解：</p>
<p><code>sa_flags</code>还有很多可选参数，适用于不同情况。如：捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该信号，可将<code>sa_flags</code>设置为<code>SA_NODEFER</code>，除非<code>sa_mask</code>中包含该信号。</p>
<h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><p>在<code>UNIX</code>系统中，用户通过终端登录系统后得到一个<code>Shell</code>进程，这个终端成为<code>Shell</code>进程的控制终端（<code>Controlling Terminal</code>），进程中，控制终端是保存在PCB中的信息，而fork会复制PCB中的信息，因此由Shell进程启动的其它进程的控制终端也是这个终端。默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。信号中还讲过，在控制终端输入一些特殊的控制键可以给前台进程发信号，例如<code>Ctrl-C</code>表示<code>SIGINT</code>，<code>Ctrl-\</code>表示<code>SIGQUIT</code>。</p>
<p>Alt + Ctrl + F1、F2、F3、F4、F5、F6    字符终端</p>
<p><code>pts</code>（<code>pseudo terminal slave</code>）指伪终端。</p>
<p>Alt + F7        图形终端</p>
<p>SSH、Telnet…        网络终端</p>
<h3 id="终端启动流程"><a href="#终端启动流程" class="headerlink" title="终端启动流程"></a>终端启动流程</h3><p>文件与I/O中讲过，每个进程都可以通过一个特殊的设备文件<code>/dev/tty</code>访问它的控制终端。事实上每个终端设备都对应一个不同的设备文件，<code>/dev/tty</code>提供了一个通用的接口，一个进程要访问它的控制终端既可以通过<code>/dev/tty</code>，也可以通过该终端设备所对应的设备文件来访问。<code>ttyname</code>函数可以由文件描述符查出对应的文件名，该文件描述符必须指向一个终端设备而不能是任意文件。</p>
<p>简单来说，一个Linux系统启动，大致经历如下的步骤：</p>
<p>init —&gt; fork —&gt; exec —&gt; getty —&gt; 用户输入帐号 —&gt; login —&gt; 输入密码 —&gt; exec —&gt; bash</p>
<p>硬件驱动程序负责读写实际的硬件设备，比如从键盘读入字符和把字符输出到显示器，<strong>线路规程</strong>像一个过滤器，对于某些特殊字符并不是让它直接通过，而是做特殊处理，比如在键盘上按下<code>Ctrl-z</code>，对应的字符并不会被用户程序的<code>read</code>读到，而是被线路规程截获，解释成<code>SIGTSTP</code>信号发给前台进程，通常会使该进程停止。线路规程应该过滤哪些字符和做哪些特殊处理是可以配置的。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608164808687.png" alt="image-20220608164808687"></p>
<p><code>line disciline</code>：线路规程，用来过滤键盘输入的内容。</p>
<h3 id="ttyname函数"><a href="#ttyname函数" class="headerlink" title="ttyname函数"></a>ttyname函数</h3><p><code>man 3 ttyname</code> </p>
<p>由文件描述符查出对应的文件名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ttyname</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">// 成功：终端名 失败: NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ttyname_r</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd 0: %s\n&quot;</span>, ttyname(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd 1: %s\n&quot;</span>, ttyname(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd 2: %s\n&quot;</span>, ttyname(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608165414878.png" alt="image-20220608165414878"></p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      
      
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">信号的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.1.</span> <span class="nav-text">信号的机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%8A%B6%E6%80%81"><span class="nav-number">1.1.2.</span> <span class="nav-text">相关的事件和状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%BC%96%E5%8F%B7"><span class="nav-number">1.1.3.</span> <span class="nav-text">信号的编号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B74%E8%A6%81%E7%B4%A0"><span class="nav-number">1.1.4.</span> <span class="nav-text">信号4要素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E5%B8%B8%E8%A7%84%E4%BF%A1%E5%8F%B7%E8%A1%A8"><span class="nav-number">1.1.5.</span> <span class="nav-text">Linux常规信号表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-number">1.2.</span> <span class="nav-text">信号的产生</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF%E6%8C%89%E9%94%AE%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.2.1.</span> <span class="nav-text">终端按键产生信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.2.2.</span> <span class="nav-text">硬件异常产生信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kill%E5%87%BD%E6%95%B0-%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.3.</span> <span class="nav-text">kill函数&#x2F;命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#raise%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.4.</span> <span class="nav-text">raise函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#abort%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.5.</span> <span class="nav-text">abort函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#alarm%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.6.</span> <span class="nav-text">alarm函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setitimer%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.7.</span> <span class="nav-text">setitimer函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.</span> <span class="nav-text">信号集操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E8%AE%BE%E5%AE%9A"><span class="nav-number">1.3.1.</span> <span class="nav-text">信号集设定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sigprocmask%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.2.</span> <span class="nav-text">sigprocmask函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sigpending%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.3.</span> <span class="nav-text">sigpending函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.3.4.</span> <span class="nav-text">阻塞信号示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="nav-number">1.4.</span> <span class="nav-text">信号捕捉</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#signal%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.1.</span> <span class="nav-text">signal函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sigaction%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.2.</span> <span class="nav-text">sigaction函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E7%89%B9%E6%80%A7"><span class="nav-number">1.4.3.</span> <span class="nav-text">信号捕捉特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7%E8%BF%87%E7%A8%8B"><span class="nav-number">1.4.4.</span> <span class="nav-text">捕捉信号过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.5.</span> <span class="nav-text">竞态条件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pause%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.1.</span> <span class="nav-text">pause函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E5%BA%8F%E7%AB%9E%E6%80%81"><span class="nav-number">1.5.2.</span> <span class="nav-text">时序竞态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sigsuspend%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.3.</span> <span class="nav-text">sigsuspend函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">1.5.4.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%BC%82%E6%AD%A5I-O"><span class="nav-number">1.5.5.</span> <span class="nav-text">全局变量异步I&#x2F;O</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.6.</span> <span class="nav-text">可&#x2F;不可重入函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.5.7.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.6.</span> <span class="nav-text">SIGCHLD信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SIGCHLD%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.6.1.</span> <span class="nav-text">SIGCHLD产生条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.6.2.</span> <span class="nav-text">回收子进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98"><span class="nav-number">1.6.3.</span> <span class="nav-text">注意问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E4%BC%A0%E5%8F%82"><span class="nav-number">1.7.</span> <span class="nav-text">信号传参</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sigqueue%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.1.</span> <span class="nav-text">sigqueue函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sigaction%E5%87%BD%E6%95%B0-1"><span class="nav-number">1.7.2.</span> <span class="nav-text">sigaction函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.8.</span> <span class="nav-text">中断系统调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF"><span class="nav-number">2.</span> <span class="nav-text">终端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">终端启动流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ttyname%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">ttyname函数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yanglinqi"
      src="/images/headpic.jpg">
  <p class="site-author-name" itemprop="name">yanglinqi</p>
  <div class="site-description" itemprop="description">用于做笔记，对学过的知识总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">100</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yanglinqi107" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanglinqi107" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yanglinqi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


  <script async src="/js/cursor/fireworks.js"></script>


</body>
</html>

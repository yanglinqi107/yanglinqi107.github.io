<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yanglinqi107.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="学自电子科技大学和黑马程序员，以下是一些补充内容和参考链接 C 语言中 void* 详解及应用 | 菜鸟教程 (runoob.com)  https:&#x2F;&#x2F;www.runoob.com&#x2F;w3cnote&#x2F;c-general-function.html  void  是什么？_杨博东的博客的博客-CSDN博客_void是什么  find &#x2F;usr&#x2F;include&#x2F; -name *.h | xargs g">
<meta property="og:type" content="article">
<meta property="og:title" content="进程和进程通信">
<meta property="og:url" content="http://yanglinqi107.github.io/Linux/Linux%E7%BC%96%E7%A8%8B/02%E8%BF%9B%E7%A8%8B/index.html">
<meta property="og:site_name" content="杨记">
<meta property="og:description" content="学自电子科技大学和黑马程序员，以下是一些补充内容和参考链接 C 语言中 void* 详解及应用 | 菜鸟教程 (runoob.com)  https:&#x2F;&#x2F;www.runoob.com&#x2F;w3cnote&#x2F;c-general-function.html  void  是什么？_杨博东的博客的博客-CSDN博客_void是什么  find &#x2F;usr&#x2F;include&#x2F; -name *.h | xargs g">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220527165812134.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220531114333095.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220531115154909.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220531115254667.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408152319518.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408152511000.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408153141627.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408153548237.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408153641182.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408153746262.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408153845177.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409105538106.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408154448602.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408154918504.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408155147072.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408155713660.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408160016081.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408170102390.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408151230066.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408171803255.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408175512633.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408191339232.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408210223114.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408210750881.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408212001229.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409111016348.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409111207007.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409110646792.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409121804687.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409203702015.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220611170415896.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220410122956953.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220611173018245.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220410124618074.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220611224521264.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220612141517746.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220410144858118.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220612153541618.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608150818204.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608153322335.png">
<meta property="article:published_time" content="2022-04-08T06:51:35.229Z">
<meta property="article:modified_time" content="2022-07-27T15:44:10.013Z">
<meta property="article:author" content="yanglinqi">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220527165812134.png">

<link rel="canonical" href="http://yanglinqi107.github.io/Linux/Linux%E7%BC%96%E7%A8%8B/02%E8%BF%9B%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>进程和进程通信 | 杨记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杨记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">碎片化学习令人焦虑，系统化学习使人进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">98</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yanglinqi107.github.io/Linux/Linux%E7%BC%96%E7%A8%8B/02%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headpic.jpg">
      <meta itemprop="name" content="yanglinqi">
      <meta itemprop="description" content="用于做笔记，对学过的知识总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          进程和进程通信
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-08 14:51:35" itemprop="dateCreated datePublished" datetime="2022-04-08T14:51:35+08:00">2022-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-27 23:44:10" itemprop="dateModified" datetime="2022-07-27T23:44:10+08:00">2022-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Linux%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Linux编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>学自电子科技大学和黑马程序员，以下是一些补充内容和参考链接</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/c-void-intro.html">C 语言中 void* 详解及应用 | 菜鸟教程 (runoob.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/c-general-function.html">https://www.runoob.com/w3cnote/c-general-function.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangbodong22011/article/details/53224856"> void <em> 是什么？_杨博东的博客的博客-CSDN博客_void</em>是什么</a> </p>
<p><code>find /usr/include/ -name *.h | xargs grep &#39;MRT6_INIT&#39;</code></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Qiuoooooo/article/details/60573433">IPC之信号量详解_Qiuoooooo的博客-CSDN博客_ipc信号量</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44522306/article/details/89643615">IPC之信号量_车小猿的博客-CSDN博客_ipc信号量</a></p>
<span id="more"></span>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h3><p><strong>程序</strong>：是指编译好的二进制文件，在磁盘上，不占用系统资源（cpu、内存、打开的文件、设备、锁….）</p>
<p><strong>进程</strong>：是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。当程序被操作系统装载到内存并分配给它一定资源后，此时可称为进程。</p>
<p>程序是静态概念，进程是动态概念。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>操作系统会为每个进程分配和维护虚拟内存地址</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220527165812134.png" alt="image-20220527165812134"></p>
<p>cpu 为什么要使用虚拟地址空间与物理地址空间映射？解决了什么样的问题？</p>
<ol>
<li>方便编译器和操作系统安排程序的地址分布。程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>
<li>方便进程之间隔离。不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程使用的物理内存。        </li>
<li>方便OS使用你那可怜的内存。程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
</ol>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。</p>
<p>例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220531114333095.png" alt="image-20220531114333095"></p>
<p><div align=center>【分时复用cpu】</p>
<h3 id="单道程序设计"><a href="#单道程序设计" class="headerlink" title="单道程序设计"></a>单道程序设计</h3><p>所有进程一个一个排队执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p>
<h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</p>
<p><strong>时钟中断</strong>即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。</p>
<p>在多道程序设计模型中，多个进程轮流使用CPU (分时复用CPU资源)。而当下常见CPU为纳秒级，1秒可以执行大约10亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</p>
<p>1s = 1000ms, 1ms = 1000us, 1us = 1000ns   1000000000 </p>
<p>实质上，并发是宏观并行，微观串行！——-推动了计算机蓬勃发展，将人类引入了多媒体时代。</p>
<h3 id="CPU和MMU"><a href="#CPU和MMU" class="headerlink" title="CPU和MMU"></a>CPU和MMU</h3><p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220531115154909.png" alt="image-20220531115154909"></p>
<p><div align=center>中央处理器(CPU)</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220531115254667.png" alt="image-20220531115254667"></p>
<p><div align=center>内存管理单元MMU</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h3><p>进程ID、用户ID、进程状态、调度信息、文件管理、虚拟内存管理、信号（进程间通信机制）、时间和定时器、……</p>
<p><strong>task_struct结构</strong>：Linux进程控制块（PCB）的结构体</p>
<ul>
<li>使用<code>grep -r &quot;task_struct &#123;&quot; /usr/src</code> 命令查找文件所在</li>
<li>所在文件：<code>/usr/src/linux-headers-5.4.0-26/include/linux/sched.h</code></li>
</ul>
<p>部分结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;	<span class="comment">// 进程id</span></span><br><span class="line"><span class="keyword">uid_t</span> uid,euid;	<span class="comment">// 用户id 有效用户id</span></span><br><span class="line"><span class="keyword">gid_t</span> gid,egid;	<span class="comment">// 用户组id 有效用户组id</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> state;	<span class="comment">// 进程状态</span></span><br><span class="line"><span class="keyword">int</span> exit_state;			<span class="comment">// 退出状态</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;	</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> policy;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">real_parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>,<span class="title">sibling</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span> 	<span class="comment">// 文件描述表 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span>	<span class="comment">// 文件表 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>	<span class="comment">// 内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span></span><br><span class="line"><span class="keyword">cputime_t</span> utime, stime;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start_time</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">real_start_time</span>;</span></span><br></pre></td></tr></table></figure>
<p><strong>task_struct主要内容：</strong></p>
<ul>
<li>进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。</li>
<li>进程的状态，有就绪、运行、挂起、停止等状态。</li>
<li>进程切换时需要保存和恢复的一些CPU寄存器。</li>
<li>描述虚拟地址空间的信息。</li>
<li>描述控制终端的信息。</li>
<li>当前进程工作目录（Current Working Directory）。</li>
<li>umask掩码。</li>
<li>文件描述符表，包含很多指向file结构体的指针。</li>
<li>和信号相关的信息。</li>
<li>用户id和组id。</li>
<li>会话（Session）和进程组。</li>
<li>进程可以使用的资源上限（Resource Limit）。</li>
</ul>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p><code>volatile long state;</code></p>
<ul>
<li><p>state成员的可能取值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING 0    		<span class="comment">// 可执行状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE 1   	<span class="comment">// 可中断等待状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE 2  <span class="comment">// 不可中断等待状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_ZOMBIE 4			<span class="comment">// 僵尸状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STOPPED 8			<span class="comment">// 停止状态</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://m.php.cn/article/490795.html">Linux进程状态</a></p>
<p><strong>Linux进程的5种状态</strong></p>
<p>在Linux系统中，一个进程被创建之后，在系统中可以有下面5种状态。进程的当前状态记录在进程控制块的state成员中。</p>
<p><strong>就绪状态和运行状态（可执行状态）</strong></p>
<p>就绪状态的状态标志state的值为<code>TASK_RUNNING</code>。此时，程序已被挂入运行队列，处于准备运行状态。一旦获得处理器使用权，即可进入运行状态。</p>
<p>当进程获得处理器而运行时 ，state<code>的</code>值仍然为<code>TASK_RUNNING</code>，并不发生改变；但Linux会把一个专门用来指向当前运行任务的指针<code>current</code>指向它，以表示它是一个正在运行的进程。</p>
<p><strong>可中断等待状态</strong></p>
<p>状态标志<code>state</code>的值为<code>TASK_INTERRUPTIBL</code>。此时，由于进程未获得它所申请的资源而处在等待状态。一旦资源有效或者有唤醒信号，进程会立即结束等待而进入就绪状态。</p>
<p><strong>不可中断等待状态</strong></p>
<p>状态标志state的值为<code>TASK_UNINTERRUPTIBL</code>。此时，进程也处于等待资源状态。一旦资源有效，进程会立即进入就绪状态。这个等待状态与可中断等待状态的区别在于：处于<code>TASK_UNINTERRUPTIBL</code>状态的进程不能被信号量或者中断所唤醒，只有当它申请的资源有效时才能被唤醒。</p>
<p>这个状态被应用在内核中某些场景中，比如当进程需要对磁盘进行读写，而此刻正在DMA中进行着数据到内存的拷贝，如果这时进程休眠被打断（比如强制退出信号）那么很可能会出现问题，所以这时进程就会处于不可被打断的状态下。</p>
<p><strong>停止状态</strong></p>
<p>状态标志state的值为<code>TASK_STOPPED</code>。当进程收到一个<code>SIGSTOP</code>信号后，就由运行状态进入停止状态，当受到一个<code>SIGCONT</code>信号时，又会恢复运行状态。这种状态主要用于程序的调试，又被叫做“暂停状态”、“挂起状态”。</p>
<p><strong>中止状态</strong></p>
<p>状态标志<code>state</code>的值为<code>TASK_DEAD</code>。进程因某种原因而中止运行，进程占有的所有资源将被回收，除了<code>task_struct</code>结构（以及少数资源）以外，并且系统对它不再予以理睬，所以这种状态也叫做“僵死状态”，进程成为僵尸进程。</p>
<p><strong>进程状态切换</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408152319518.png" alt="image-20220408152319518"></p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p><code>struct fs_struct *fs;     // 文件描述表</code></p>
<p><code>struct files_struct *files;    // 文件表</code> </p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408152511000.png" alt="image-20220408152511000"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408153141627.png" alt="image-20220408153141627"></p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p><code>struct mm_struct *mm;    // 内存</code></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408153548237.png" alt="image-20220408153548237"></p>
<h3 id="进程组织形式"><a href="#进程组织形式" class="headerlink" title="进程组织形式"></a>进程组织形式</h3><p><strong>进程控制块的物理组织结构</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408153641182.png" alt="image-20220408153641182"></p>
<p><strong>进程控制块的逻辑组织结构</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408153746262.png" alt="image-20220408153746262"></p>
<p>使用<code>pstree</code>查看当前进程的树形图</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408153845177.png" alt="image-20220408153845177" style="zoom: 80%;" /></p>
<p><strong>Linux中创建进程的方式：</strong></p>
<ul>
<li>在<code>shell</code>中执行命令或可执行文件<ul>
<li>由shell进程调用<code>fork</code>函数创建子进程</li>
</ul>
</li>
<li>在代码中（已经存在的进程中）调用<code>fork</code>函数创建子进程<ul>
<li>通过<code>fork</code>函数创建的进程为已经存在进程的子进程</li>
</ul>
</li>
</ul>
<p>Linux系统中进程0（PID=0）是由内核创建，其他所有进程都是由父进程调用<code>fork</code>函数所创建的</p>
<p>Linux系统中进程0在创建子进程（PID=1，<code>init</code>进程）后，进程0就转为交换进程或空闲进程</p>
<p>进程1（init进程）是系统中其他所有进程的共同祖先</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409105538106.png" alt="image-20220409105538106" style="zoom: 67%;" /></p>
<h3 id="进程属性"><a href="#进程属性" class="headerlink" title="进程属性"></a>进程属性</h3><p>使用<code>ps -aux</code>查看进程及其部分属性</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408154448602.png" alt="image-20220408154448602"></p>
<h4 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h4><p><strong>与进程相关联的用户ID包含以下类型</strong>：</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408154918504.png" alt="image-20220408154918504" style="zoom: 50%;" /></p>
<p><strong>真实用户与有效用户的关系</strong>：</p>
<ul>
<li>通常情况下，有效用户与真实用户相同（有效用户ID等于真实用户ID ），有效用户组与真实用户组相同（有效用户组ID等于真实用户组ID）</li>
<li>可执行文件的文件属性可以<strong>设置特殊属性域</strong>，定义为“当执行此文件时,将进程的有效用户设置为文件的所有者”，与此类似，组ID也有类似的情况，定义为“当执行此文件时,将进程的有效用户组置为文件所有者所在组”。这两个标志位称为：<strong>设置用户ID位</strong>（setuid）和<strong>设置组ID位</strong>（setgid）</li>
<li><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408155147072.png" alt="image-20220408155147072"></li>
<li><strong>设置用户ID是图中11位，设置组ID位是图中10位</strong></li>
</ul>
<p><strong>真实用户和真实用户组</strong></p>
<p>进程真实用户为执行命令/可执行文件的用户，真实用户组为真实用户所在的组</p>
<p><strong>有效用户和有效用户组</strong></p>
<font color=#ff0000>进程有效用户和有效用户组只有当可执行文件设置了`setuid`位或`setgid`位时才会发生变化</font>

<p>示例：<code>passwd</code>命令程序就设置了<strong>设置用户ID位</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408155713660.png" alt="image-20220408155713660"></p>
<p>使用<code>chmod</code>对可执行文件修改<strong>设置用户ID位</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408160016081.png" alt="image-20220408160016081" style="zoom:80%;" /></p>
<p><strong>普通用户能修改密码的原因</strong></p>
<ul>
<li><code>/etc/passwd</code>文件用来存储所有用户信息，<code>/etc/shadow</code>用来存储用户密码</li>
<li>所有用户都可以修改自己的密码（修改了<code>/etc/shadow</code>文件），但普通用户对<code>/etc/shadow</code>没有读写权限</li>
<li><p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408170102390.png" alt="image-20220408170102390"></p>
</li>
<li><p>用户通过执行passwd命令（ <code>/usr/bin/passwd</code>文件）来修改密码；该文件设置了<code>setuid</code>位，在执行此命令时，该进程的有效用户不等于真实用户，而等于文件所有者（root）</p>
</li>
<li>Linux根据进程的有效用户进行权限检查，有效用户等于root则允许任何操作（包括对<code>/ect/shadow</code>文件的读写操作）</li>
<li>如果清除掉<code>/usr/bin/passwd</code>文件的<code>setuid</code>权限位，普通用户就不能修改自己的密码了</li>
</ul>
<h3 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h3><p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408151230066.png" alt="image-20220408151230066" style="zoom:80%;" /></p>
<p>C程序的启动函数是<code>main</code>，也是进程代码的入口点</p>
<ul>
<li><code>main ( int argc, char *argv[] );</code></li>
</ul>
<p>当内核启动C程序时，会在调用main函数前调用<strong>特殊的启动函数</strong>来获取<code>main</code>函数地址和传递给<code>main</code>函数的参数，并且将这些信息填写到进程控制块中</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408171803255.png" alt="image-20220408171803255" style="zoom:80%;" /></p>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p><strong>正常终止</strong></p>
<ul>
<li>从<code>main</code>函数中返回</li>
<li>在任意代码中调用<code>exit</code>函数或<code>_exit</code>函数</li>
<li>最后一个线程从其启动例程中返回</li>
<li>最后一个线程调用<code>pthread_exit</code>函数</li>
</ul>
<p><strong>异常终止</strong></p>
<ul>
<li>在任意代码中调用<code>abort</code>函数</li>
<li>接收到终止信号</li>
</ul>
<h4 id="exit-exit函数"><a href="#exit-exit函数" class="headerlink" title="exit/_exit函数"></a>exit/_exit函数</h4><p><code>man 3 exit</code>，头文件<code>stdlib.h</code>，函数定义：<code>void exit( int status )</code></p>
<p><code>man 2 _exit</code>，头文件<code>unistd.h</code>，函数定义：<code>void _exit (int status )</code></p>
<ul>
<li>调用这两个函数均会正常地终止一个进程</li>
<li>调用<code>_exit</code>函数将会立即返回内核</li>
<li>调用<code>exit</code>函数：<ul>
<li>执行预先注册的<strong>终止处理函数</strong></li>
<li>执行文件I/O操作的善后工作，使得所有缓冲的输出数据被更新到相应的设备</li>
<li>返回内核</li>
</ul>
</li>
</ul>
<h4 id="exit与return"><a href="#exit与return" class="headerlink" title="exit与return"></a>exit与return</h4><ul>
<li><code>return</code>是C语言关键字，<code>exit</code>是POSIX API函数</li>
<li>在<code>main</code>函数中，执行<code>return</code>和调用<code>exit</code>函数会产生相同的效果</li>
<li>在子函数中，执行<code>return</code>仅仅从子函数中返回，而调用<code>exit</code>函数将会退出当前进程</li>
</ul>
<h4 id="终止处理函数"><a href="#终止处理函数" class="headerlink" title="终止处理函数"></a>终止处理函数</h4><p><strong>注册终止处理函数</strong>：</p>
<ul>
<li>当进程终止时，程序可能需要进行一些自身的清理工作，如日志登记、资源释放等</li>
<li>通过<code>atexit</code>函数或<code>on_exit</code>函数允许进程注册若干终止处理函数，当进程终止时，这些终止处理函数将会被自动调用</li>
</ul>
<p>注意：</p>
<ul>
<li><code>ANSI C</code>规定一个进程最多能注册<strong>32</strong>个终止处理函数</li>
<li>当<strong>显示调用</strong>或者<strong>隐含调用</strong><code>exit</code>函数（从<code>main</code>中返回、最后一个线程退出等）终止进程将会回调这些注册的终止处理函数（最先注册的函数最后被回调）</li>
<li><strong>显示调用<code>_exit</code>函数</strong>终止进程时将不会回调这些注册的终止函数</li>
</ul>
<h5 id="atexit函数"><a href="#atexit函数" class="headerlink" title="atexit函数"></a>atexit函数</h5><p><code>man 3 atexit</code></p>
<p>头文件：<code>#include &lt;stdlib.h&gt;</code></p>
<p>函数原型：<code>int atexit(void (*function)(void));</code></p>
<ul>
<li>返回值：成功0，失败非0</li>
</ul>
<p><strong>示例：<code>atexit</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//atexit_text.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func1 is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func2 is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func3 is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	atexit(func1);</span><br><span class="line">	atexit(func2);</span><br><span class="line">	atexit(func3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;process exit\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408175512633.png" alt="image-20220408175512633" style="zoom:80%;" /></p>
<h5 id="on-exit函数"><a href="#on-exit函数" class="headerlink" title="on_exit函数"></a>on_exit函数</h5><p><code>man 3 on_exit</code></p>
<p>头文件：<code>#include &lt;stdlib.h&gt;</code></p>
<p>函数原型：<code>int on_exit(void (*function)(int, void *), void *arg);</code> </p>
<ul>
<li><code>func</code>第一个参数是来自最后一个<code>exit()</code>函数调用中的<code>status</code>或 <code>return</code></li>
<li><code>func</code>第二个参数是来自<code>on_exit()</code>函数中的arg</li>
<li>返回值：成功0，失败非0</li>
</ul>
<p><strong>示例：<code>on_exit</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//on_exit_text.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j ,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func1 exit status is %d\n&quot;</span>, status);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func1 arg is %d\n&quot;</span>, *((<span class="keyword">int</span>*)arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func2 exit status is %d\n&quot;</span>, status);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func2 arg is %d\n&quot;</span>, *((<span class="keyword">int</span>*)arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func3 exit status is %d\n&quot;</span>, status);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func3 arg is %d\n&quot;</span>, *((<span class="keyword">int</span>*)arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> *argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i = <span class="number">3</span>;</span><br><span class="line">	on_exit(func1, (<span class="keyword">void</span>*)&amp;i);</span><br><span class="line">	j = <span class="number">4</span>;</span><br><span class="line">	on_exit(func2, (<span class="keyword">void</span>*)&amp;j);</span><br><span class="line">	k = <span class="number">5</span>;</span><br><span class="line">	on_exit(func3, (<span class="keyword">void</span>*)&amp;k);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 改成1的话，下面输出的 status值就为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408191339232.png" alt="image-20220408191339232"></p>
<h2 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>1、内核空间  2、内存空间</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408210223114.png" alt="image-20220408210223114" style="zoom:80%;" /></p>
<h3 id="用户空间布局"><a href="#用户空间布局" class="headerlink" title="用户空间布局"></a>用户空间布局</h3><p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408210750881.png" alt="image-20220408210750881"></p>
<ul>
<li>正文：CPU执行的代码部分，正文段通常是共享、只读的</li>
<li>初始化的数据：包含了程序中需明确赋初值的变量，如全局变量<code>int maxcount=99;</code></li>
<li>未初始化的数据：程序执行之前，将此段中的数据初始化为0，如全局变量<code>long sum[1000];</code></li>
<li>堆：用于动态分配内存</li>
<li>栈：主要用于支撑函数调用存放参数、局部变量等</li>
<li>命令行参数</li>
<li>环境变量</li>
</ul>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><ul>
<li><strong>命令行参数</strong>：命令后面的字符都是参数<ul>
<li><code>ls [参数] &lt;路径或文件名&gt;</code> ，<code>ls -l /home</code></li>
<li><code>mkdir [参数] &lt;目录名&gt;</code>， <code>mkdir -p /home/xiaokun/src</code></li>
<li><code>cp [参数] &lt;源文件路径&gt; &lt;目标文件路径&gt;</code>， <code>cp -r /usr/local/src /root</code></li>
</ul>
</li>
</ul>
<p><strong>C程序中main函数参数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myecho.C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Argument %d is %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408212001229.png" alt="image-20220408212001229"></p>
<font color=#ff0000>注意：</font>命令名也传入`main`中，占 0 位



### 环境变量

环境变量，是指在操作系统中用来指定操作系统运行环境的一些参数。通常具备以下特征：

① 字符串(本质) ② 有统一的格式：名=值[:值] ③ 值用来描述进程环境信息。

存储形式：与命令行参数类似。`char *[]`数组，数组名environ，内部存储字符串，`NULL`作为哨兵结尾。

使用形式：与命令行参数类似。

加载位置：与命令行参数类似。位于用户区，高于`stack`的起始位置。

引入环境变量表：须声明环境变量。`extern char ** environ;`        

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印所有环境变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; environ[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, environ[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**环境变量表**

![image-20220408212220015](https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408212220015.png)

- 每个进程都会有自己的环境变量表 
- 通过全局的环境指针 （environ）可以直接访问环境变量表（字符串数组）
  - 头文件`unistd.h` 
  - `extern char **environ;`
- 环境变量字符串形式为 `name=value`
  - `name`是环境变量名称
  - `value`为环境变量赋值

**常用环境变量**

1）**PATH**

可执行文件的搜索路径。ls命令也是一个程序，执行它不需要提供完整的路径名/bin/ls，然而通常我们执行当前目录下的程序a.out却需要提供完整的路径名./a.out，这是因为PATH环境变量的值里面包含了ls命令所在的目录/bin，却不包含a.out所在的目录。PATH环境变量的值可以包含多个目录，用:号隔开。在Shell中用echo命令可以查看这个环境变量的值：

`echo $PATH`

2）**SHELL**

当前Shell，它的值通常是`/bin/bash`

3）**TERM**

当前终端类型，在图形界面终端下它的值通常是xterm，终端类型决定了一些程序的输出显示方式，比如图形界面终端可以显示汉字，而字符终端一般不行。

4）**LANG**

语言和locale，决定了字符编码以及时间、货币等信息的显示格式。

5）**HOME**

当前用户主目录的路径，很多程序需要在主目录下保存配置文件，使得每个用户在运行该程序时都有自己的一套配置。



## 父子进程

**父子进程**：

- 子进程是父进程的副本
  - 子进程复制/拷贝父进程的PCB、数据空间（数据段、堆和栈）
  - 父子进程共享正文段（只读）
- 子进程和父进程继续执行`fork`函数调用之后的代码
- 为了提高效率，**fork后不并立即复制父进程数据段、堆和栈**，采用了**读时共享写时复制机制（Copy-On-Write）**
  - 当父子进程任意之一要修改数据段、堆、栈时，进行复制操作，并且仅复制修改区域

<img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409111016348.png" alt="image-20220409111016348" style="zoom:67%;" />



**父子进程异同**

父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式...

父子不同处: 1.进程ID  2.fork返回值  3.父进程ID   4.进程运行时间   5.闹钟(定时器)  6.未决信号集

- 子进程的 `tms_utime`, `tms_stime`,`tms_cutime`,`tms_ustime`值被设置为 0

【重点】：父子进程共享：1. 文件描述符(打开文件的结构体)  2. mmap建立的映射区 (进程间通信详解)



**父子进程共享文件**

<img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409111207007.png" alt="image-20220409111207007" style="zoom:67%;" />

父子进程对共享文件的常见处理方式：

- 父进程等待子进程完成。当子进程终止后，文件当前位置已经得到了相应的更新
- 父子进程各自执行不同的程序段，各自关闭不需要的文件



## 进程相关函数

1）

获取环境变量：`getenv`函数 或 `environ`变量访问环境表

设置或修改环境变量：`setenv`函数 或 `putenv`

删除环境变量：`unsetenv`函数

2）

创建进程：`fork`函数 或  `vfork`函数

获取进程ID：`getpid`函数

获取父进程ID：`getppid`函数（和`getpid`用法类似）

3）

头文件：

- `#include <unistd.h>`
- `#include <sys/types.h>` 

返回值：执行成功返回对应ID，失败返回-1（错误原因存储在error中）

获取真实用户ID：`uid_t getuid(void);`   `man 2 getuid` 

获取真实用户组ID：`uid_t getgid(void);`

获取有效用户ID：`uid_t geteuid(void);`

获取有效用户组ID：`uid_t getegid(void);`



### getenv函数

`man 3 getenv`

`getenv`函数用于获取环境变量值

头文件：`stdlib.h`

函数原型：`char* getenv(const char *name);`

- `name`指定环境变量名称，返回环境变量字符串指针，若未找到则返回`NULL`

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *path = getenv(<span class="string">&quot;PATH&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

![image-20220408213845594](https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408213845594.png)



### setenv函数

`man 3 setenv`

作用：设置或修改环境变量值

头文件：`stdlib.h`

函数原型：`int setenv(const char* name, const char* value, int overwrite);`

- 如果`name`不存在，则添加`name=value`到环境变量中
- 若`name`已经存在
  - `overwrite!=0`，修改原`name`的值为`value`
  - `overwrite=0`，不修改`name` 
- 返回值：成功0，失败-1



### unsetenv函数

`man 3 unsetenv`

头文件：`stdlib.h`

函数原型：`int unsetenv(const char* name);`

- 删除指定的环境变量字符串
- 返回值：成功0，失败-1
- 若`name`不存在，返回的也是0



### putenv函数

`man 3 putenv`

`putenv`函数将环境变量字符串放入环境变量表中；若该字符串已经存在，则覆盖

头文件：`stdlib.h`

函数原型：`int putenv(char *string);`

- `string`格式：`name=value`
- 添加宏定义：`_XOPEN_SOURCE`



### 示例代码1

`getenv`  `setenv`  `unsetenv` 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *val;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="string">&quot;ABD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    val = getenv(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1, %s = %s\n&quot;</span>, name, val);</span><br><span class="line"></span><br><span class="line">    setenv(name, <span class="string">&quot;haha-day-and-night&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    val = getenv(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2, %s = %s\n&quot;</span>, name, val);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">int</span> ret = unsetenv(<span class="string">&quot;ABD=&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">    val = getenv(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3, %s = %s\n&quot;</span>, name, val);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">int</span> ret = unsetenv(<span class="string">&quot;ABD&quot;</span>);  <span class="comment">//name=value:value</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">    val = getenv(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3, %s = %s\n&quot;</span>, name, val);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### fork函数

`man 2 fork`

头文件：`unistd.h`

函数原型：`pid_t fork(void);`

返回值：

- `fork`函数被正确调用后，将会在子进程中和父进程中分别返回！！
- 在子进程中返回值为0（不合法的PID，提示当前运行在子进程中）

- 在父进程中返回值为子进程ID（让父进程掌握所创建子进程的ID号）
- 出错返回`-1`

**fork用法**：

- 父进程希望复制自己（共享代码，复制数据空间），但父子进程**执行相同代码中的不同分支**
  - 网络服务程序中，父进程等待客户端的服务请求，当请求达到时，父进程调用fork创建子进程处理该请求，而父进程继续等待下一个服务请求到达
- 父子进程**执行不同的可执行文件**（父子进程具有完全不同的代码段和数据空间）
  - 子进程从`fork`返回后，立即调用`exec`类函数执行另外一个可执行文件

**示例：**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;the returned value is %d\n&quot;</span>, pid);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;in child process!!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;My PID is %d\n&quot;</span>, getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;the returned value is %d\n&quot;</span>, pid);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;in father process!!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;My PID is %d\n&quot;</span>, getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409110646792.png" alt="image-20220409110646792" style="zoom: 80%;" />

示例2：创建5个子进程

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxxxxxx\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(i); <span class="comment">//保证顺序输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27; am %d child, pid = %u\n&quot;</span>, i+<span class="number">1</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(i); <span class="comment">//保证父进程最后结束</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m parent\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### vfork函数

`man 2 vfork`

头文件：`unistd.h`

函数原型：`pid_t vfork(void);`

- 返回值：成功返回pid，失败返回-1

**vfork用法：**

- `vfork`用于创建新进程，而该新进程的目的是**执行一个可执行文件**
- 由于新程序将有自己的地址空间，因此`vfork`函数**并不将父进程的地址空间完全复制到子进程中**
- 子进程在调用`exec`或`exit`之前，在父进程的地址空间中运行
- `vfork`函数**保证子进程先执行**，在它调用`exec`或者`exit`之后，父进程才会继续被调度执行（父进程处于`TASK_UNINTERRUPTIBLE`状态），如果在
  调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁

![image-20220409111815455](https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409111815455.png)

**和fork相比：**

- `fork`之后，子进程拷贝父进程的数据段，代码段。（读时共享写时复制）
- `vfork`共享父进程的数据段。主要适用于执行可执行文件

**示例：**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    pid = vfork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error in fork!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cnt=%d\n&quot;</span>,cnt);  <span class="comment">// cnt=1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the child process,ID is %d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 注释此语句将发送段错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;		</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cnt=%d\n&quot;</span>,cnt);  <span class="comment">// cnt=2</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the parent process,ID is %d\n&quot;</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

![image-20220602192411062](https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220602192411062.png)



### getpid函数

`man 2 getpid`

作用：获取进程ID

头文件：

- `#include <sys/types.h>`
- `#include <unistd.h>`

函数：`pid_t getpid( void);`

- `pid_t`实际就是`int`类型
- 执行成功返回当前进程的ID，失败返回-1（错误原因存储在errno中）



### 示例代码2

`getuid` `getgid` `geteuid` `getegid`

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//suid.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;real uid: %d, real gid:%d\n&quot;</span>,getuid(), getgid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;effective uid: %d, effective gid: %d\n&quot;</span>, geteuid(), getegid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

![image-20220408165715572](https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220408165715572.png)



## exec函数族

进程调用**exec系列函数**在进程中加载执行另外一个可执行文件

exec系列函数替换了当前进程（执行该函数的进程）的**正文段、数据段、堆和栈**（来源于加载的可执行文件）

执行exec系列函数后从加载可执行文件的main函数开始重新执行

exec系列函数并不创建新进程，所以在调用exec系列函数后其**进程ID并未改变**，**已经打开的文件描述符不变**

<img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409121804687.png" alt="image-20220409121804687" style="zoom:80%;" />



`execl execle execlp execv execve execvp` 共6个函数

`man 3 execl` 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Feature Test Macro Requirements <span class="keyword">for</span> <span class="title">glibc</span> <span class="params">(see feature_test_macros(<span class="number">7</span>))</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	<span class="title">execvpe</span><span class="params">()</span>: _GNU_SOURCE</span></span><br></pre></td></tr></table></figure>

- `l`：`list`，每个命令行参数都说明为一个单独的参数
- `v`：`vector`，命令行参数放在数组中
- `e`：`environment`，表示由函数调用者提供环境变量表
- `p`：`path`，使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量

exec函数一旦调用成功即执行新的程序，不返回。**只有失败才返回，错误值-1**。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。

只有execve是真正的系统调用，其它五个函数最终都调用execve，所以execve在man手册第2节，其它函数在man手册第3节。

**exec函数的关系**

![image-20220602151137083](https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220602151137083.png)



### execl函数

函数原型：`int execl(const char *pathname, const char *arg0, ...,NULL`

- `pathname`：要执行程序的绝对路径名
- 可变参数：要执行程序的命令行参数，以空指针`NULL`结束
- 返回值：出错返回-1，成功该函数不返回！

**示例：**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;entering main process--\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>); </span><br><span class="line">        <span class="comment">//若execl执行成功，execl后面的代码不会执行，而是运行新的可执行文件的代码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exiting main process --\n&quot;</span>); <span class="comment">//这句代码不会执行</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### execv函数

函数原型：`int execv(const char *pathname, char *const argv[]);`

- `pathname`：要执行程序的绝对路径名
- `argv`：数组指针维护的程序命令行参数列表，该数组的最后一个成员必须为空指针

- 返回值：出错返回-1，成功该函数不返回！

**示例：**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;entering main process --\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = execv(<span class="string">&quot;/bin/ls&quot;</span>, argv);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;execv error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exiting main process --\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### execle函数

函数原型：`int execle(const char *pathname, const char *arg0,... NULL, char *const envp[]);`

- `pathname`：要执行程序的绝对路径名
- 可变参数：要执行程序的命令行参数，以空指针结束
- `envp`指向环境字符串指针数组的指针，该数组的最后一个成员必须为空指针
- 返回值：出错返回-1，成功该函数不返回

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *envp[] = &#123;<span class="string">&quot;PATH=/tmp&quot;</span>, <span class="string">&quot;USER=yang&quot;</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(execle(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>, envp) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;execle error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### execlp函数
`int execlp(const char *filename,const char *arg0, ...,NULL);`

- `filename`参数可以是相对路径（路径信息从环境变量PATH中获取）
- 例如默认环境变量中包含的`PATH=/bin:/usr/bin:/usr/local/bin/`

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### 示例

将`ps aux`的结果输出到`ps.out`文件中

1）法一：使用`dup2` ，`dup2(fd, STDOUT_FILENO);` 让标准输出指向`ps.out`

2）法二：使用输出重定向`ps aux > ps.out`  其中`>` 需要转义

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;ps.out&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//方法一：</span></span><br><span class="line">    <span class="comment">//dup2(fd, STDOUT_FILENO);</span></span><br><span class="line">    <span class="comment">//execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL);</span></span><br><span class="line">    <span class="comment">//方法二：</span></span><br><span class="line">    execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="string">&quot;\&gt;&quot;</span>, <span class="string">&quot;ps.out&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// &gt; 需要转义</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



## 子进程回收

### 孤儿进程

孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am child, my parent pid = %d\n&quot;</span>, getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent, my pid is = %d\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------parent going to die------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

![image-20220602152843510](https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220602152843510.png)



### 僵尸进程

父进程先于子进程结束，未回收子进程资源。子进程在退出之前会释放进程用户空间的所有资源，但PCB等内核空间资源不会被释放。

- 当父进程调用`wait`或`waitpid`函数后，内核将根据情况关闭该进程打开的所有文件，释放PCB（释放内核空间资源）
- 对于已经终止但父进程尚未对其调用`wait`或`waitpid`函数的进程（`TASK_ZOMBIE`状态），称为**僵尸进程**

如果父进程在子进程终止之前终止，则子进程的父进程将变为`init`进程，保证每个进程都有父进程，由`init`进程调用`wait`函数进行善后



### 回收资源

一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用`wait`或`waitpid`获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量`$?`查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。



**获知子进程状态信息改变**：

当一个进程发生特定的状态变化（进程终止、暂停以及恢复）时，内核向其父进程发送`SIGCHLD`信号

父进程可以选择忽略该信号，也可以对信号进行处理（默认处理方式为忽略该信号）

**`wait`或`waitpid`函数**可以用于等待子进程状态信息改变，并获取其状态信息





### wait函数

`man 2 wait` 

功能：获取任意子进程的状态改变信息

- 若是**终止状态**，则回收子进程残留资源
- **阻塞**等待子进程退出
- 获取子进程结束状态（**退出原因**）

头文件：`sys/wait.h`

函数原型：`pid_t wait(int *wstatus);`

- `wstatus`：用于获取子进程的状态改变
- `wstatus`可以为空指针，此时父进程不需要具体了解子进程的状态变化，只是为了防止子进程成为僵尸进程，或者因为同步原因需等待子进程终止
- 若`wstatus`不是空指针，则内核将子进程状态改变信息存放在它指向的存储空间中（正常终止→退出值；异常终止→终止信号）
- 返回值：若成功返回状态信息改变子进程ID，出错返回`-1`

**wait函数传出参数status**

子进程状态改变信息包含了多种类型的信息，可以通过系统提供的宏来快速解析子进程的状态。可使用来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：

| 宏                      | 功能说明                                                     |
| ----------------------- | ------------------------------------------------------------ |
| `WIFEXITED(wstatus)`    | 当子进程**正常终止**时该宏为真，对于这种情况可进一步执行`WEXITSTATUS(wstatus)`，获取子进程传递给`exit`、`_exit`函数参数的低8位或`return`值 |
| `WIFSIGNALED(wstatus)`  | 当子进程**异常终止（信号）**时该宏为真，对于这种情况可进一步执行`WTERMSTG(wstatus)`，获取使子进程终止的信号编号 |
| `WIFSTOPPED(wstatus)`   | 当子进程**暂停**时该宏为真，对于这种情况可进一步执行`WSTOPSIG(wstatus)`，获取使子进程暂停的信号编号 |
| `WIFCONTINUED(wstatus)` | 若子进程在**暂停后已经继续运行**则该宏为真                   |

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, wpid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child, my parent = %d, going to sleep 10s\n&quot;</span>, getppid());</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----------child die----------------\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">77</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// wpid = wait(NULL);</span></span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        wpid = wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span>(wpid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status)) <span class="comment">//判断是否正常终止</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果正常终止，打印终止的退出值</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child exit with %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFSIGNALED(status)) <span class="comment">//判断是否是异常终止，信号导致</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child exit with %d\n&quot;</span>, WTERMSTG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

调用`wait`函数之后，父进程可能出现的情况：

- 如果所有子进程都还在运行，则父进程被**阻塞**（`TASK_INTERRUPTIBLE`状态），直到有一个子进程终止或暂停，`wait`函数才返回
- 如果已经有子进程进入终止或暂停状态，则`wait`函数会立即返回
- 若进程没有任何子进程，则立即出错返回`-1`



### 等待特定子进程

如果一个进程有几个子进程，那么**只要有一个子进程状态改变，wait函数就返回**

如何才能使用wait函数等待某个特定子进程的状态改变？

- 调用`wait`，然后将其返回的进程ID和所期望的子进程ID进行比较。
  - 如果ID不一致，则保存该ID，并循环调用`wait`函数，直到等到所期望的子进程ID为止

- 使用`waitpid`



### waitpid函数

`man 2 waitpid` 

功能：等待某个特定子进程状态改变

头文件：`sys/wait.h`

函数原型：`pid_t waitpid(pid_t pid, int *statloc, int options);`

- `pid`
  - `pid = -1`：等待任意子进程执行终止（同wait）
  - `pid > 0`：等待指定ID为`pid`的子进程终止
  - `pid = 0`：等待其组ID等于调用进程组ID的任意子进程
  - `pid < -1`：等待其组ID等于pid绝对值的任意子进程

- `statloc`：存放子进程终止状态
- `options`：可以为0（阻塞），也可以是以下常量或常量的或
  - `WCONTINUED`：如果暂停的子进程由于被`SIGCONT`唤醒而产生的`SIGCHLD`，则函数将返回
  - `WUNTRACED`：如果有处于终止状态的进程，则函数返回
  - `WNOHANG`：**非阻塞**。如果没有任何已经终止的子进程则马上返回,，函数不等待，此时**返回值为0**

- 返回值：成功返回终止子进程ID，失败返回-1（无子进程）



**waitpid的特有功能**：

- `waitpid`可等待一个特定的进程的状态改变信息
- `waitpid`可以实现非阻塞（异步）的等待操作，有时希望取得子进程的状态改变信息，但不希望阻塞等待子进程状态改变
- `waitpid`支持作业控制（**进程组控制**）



**示例：**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid_child, pid_return;</span><br><span class="line">    pid_child = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid_child &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occuredon forking.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid_child == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        pid_return = waitpid(pid_child, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span> (pid_return == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No child exited\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pid_return == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid_return == pid_child)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;successfullyget child %d\n&quot;</span>, pid_return);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;some error occured\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

![image-20220412122856363](https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220412122856363.png)



## 进程通信

Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为**进程间通信**（IPC，Inter-Process Communication）。

![image-20220602193549547](https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220602193549547.png)

在进程间完成数据传递需要借助操作系统提供特殊的方法，如：**文件、管道、信号、共享内存、消息队列、套接字、命名管道**等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：

① 管道（使用最简单）

② 信号（开销最小）

③ 共享映射区（无血缘关系）

④ 本地套接字（最稳定）



### 管道

管道是一种最古老、最简单的UNIX进程间通信机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：

​    1. 其本质是一个伪文件(实为内核缓冲区) 

2. 由两个文件描述符引用，一个表示读端，一个表示写端。

​    3. 规定数据从管道的写端流入管道，从读端流出。

管道的原理：管道实为内核使用**环形队列机制**，借助内核缓冲区(4k)实现。

- `ulimit -a` 可以看到默认管道大小为$8\times 512b = 4k$ （8个扇区）

管道的局限性：

① 数据自己读不能自己写，自己写不能自己读。

② 数据一旦被读走，便不在管道中存在，不可反复读取。

③ 由于管道采用**半双工**通信方式。因此，数据只能**单向流动**。

④ 只能在有**公共祖先**的进程间使用管道。

常见的通信方式有，单工通信、半双工通信、全双工通信。



#### pipe函数

`man 2 pipe` 

头文件：`unistd.h`

函数原型：`int pipe(int pipefd[2]);`

- 程序通过文件描述符`pipefd[0]`和`pipefd[1]`来访问管道
- `pipefd[0]`管道**读操作**，`pipefd[1]`管道**写操作**
- 写入`pipefd[1]`的数据可以按照**先进先出**的顺序从`pipefd[0]`中读出
- 返回值：成功返回`0`，出错返回`-1`
- 文件描述符`pipefd[0]`和`pipefd[1]`无需`open`，但需手动`close`
- 向管道文件读写数据其实是在读写内核缓冲区

管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？通常可以采用如下步骤：

![image-20220604115742038](https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220604115742038.png)

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        ret = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(STDOUT_FILENO, buf, ret);</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> *str = <span class="string">&quot;hello pipe\n&quot;</span>;</span><br><span class="line">        write(fd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



#### 管道读写行为

使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置`O_NONBLOCK`标志）：

1. 如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。

2. 如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。

3. 如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对`SIGPIPE`信号实施捕捉，不终止进程。具体方法信号章节详细介绍。

4. 如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。

总结：

1）读管道：

- 管道中有数据，read返回实际读到的字节数
- 管道中无数据：
  - 管道写端被全部关闭，read返回0（类似读到文件结尾）
  - 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)

2）写管道

- 管道读端全部被关闭， 进程异常终止（也可使用捕捉SIGPIPE信号，使进程不终止）
- 管道读端没有全部关闭：
  - 管道已满，write阻塞。（管道会自动扩容）
  - 管道未满，write将数据写入，并返回实际写入的字节数。



#### 管道缓冲区大小

可以使用`ulimit –a` 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为：`pipe size       (512 bytes, -p) 8`

也可以使用`fpathconf`函数，借助参数选项来查看。使用该宏应引入

头文件`<unistd.h>`

函数原型：`long fpathconf(int fd, int name);`

- 成功：返回管道的大小    失败：-1，设置errno
- `name` 是一些宏，如`_PC_PIPE_BUF` 



#### 管道小结

优点：简单，相比信号，套接字实现进程间通信，简单很多。

缺点：1）只能**单向通信**，双向通信需建立两个管道。2）只能用于父子、兄弟进程（有共同祖先）间通信。该问题后来使用fifo有名管道解决。

允许：



#### 代码示例

练习：使用管道实现兄弟进程间通信，实现`ls | wc -l`。兄：`ls`  弟： `wc -l`  父：等待回收子进程。

要求，使用“循环创建N个子进程”模型创建兄弟进程，使用循环因子i标示。注意管道读写行为。

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="comment">// 兄进程 读</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="comment">// 弟进程 写</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        dup2(fd[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">        execlp(<span class="string">&quot;wc&quot;</span>, <span class="string">&quot;wc&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// 父进程 阻塞等待回收子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(wait(<span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### 命名管道

#### 概念

FIFO常被称为**命名管道**，以区分管道（pipe）。

FIFO是Linux基础文件类型中的一种。但，FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信。

- 管道只能在父子进程之间使用
- 通过FIFO，不相关的进程也能交换数据
- FIFO也被称为命名管道， FIFO是一种特殊的文件（创建FIFO类似于创建文件，FIFO的路径名存在于文件系统中）
- 创建FIFO之后可以通过文件I/O对其进行操作
- **非父子进程可以通过文件名来使用FIFO**

创建FIFO的命令：`mkfifo`，函数`mkfifo`



#### mkfifo函数

作用：创建命名管道

`man 3 mkfifo` 

头文件：

- `sys/types.h`
- `sys/stat.h`

函数原型：`int mkfifo(const char *pathname, mode_t mode) ;`

- `pathname`：文件名（绝对路径）
- `mode`：文件类型、权限等，如`664`

返回值：成功返回`0`，出错返回`-1`



#### 代码示例

`fifo_r.c` 读，`fifo_w.c`写，提前创建命名管道`fifo_t`

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fifo_r.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, len;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out fifoname\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) </span><br><span class="line">        sys_err(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">        sleep(<span class="number">2</span>);           <span class="comment">//多个读端时应增加睡眠秒数,放大效果.</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fifo_w.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, i;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter like this: ./a.out fifoname\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) </span><br><span class="line">        sys_err(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello itcast %d\n&quot;</span>, i++);</span><br><span class="line"></span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### 文件通信

使用文件也可以完成IPC，理论依据是，fork后，父子进程共享文件描述符。也就共享打开的文件。

无血缘关系的进程可以打开同一个文件进行通信。



#### 父子进程示例

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *父子进程共享打开的文件描述符------使用文件完成进程间通信.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1, fd2; <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;---------test for shared fd in parent child process-----\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        fd1 = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child wrote over...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fd2 = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (fd2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);                   <span class="comment">//保证子进程写入数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = read(fd2, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line"></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



#### 无关系进程示例

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 先执行,将数据写入文件test.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;--------------secesuss-------------\n&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR|O_TRUNC|O_CREAT, <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接打开文件写入数据</span></span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test1 write into test.txt finish\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(N);</span><br><span class="line"></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ret = write(STDOUT_FILENO, buf, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write second error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 后执行,尝试读取另外一个进程写入文件的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;----------test2 write secesuss--------\n&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);   <span class="comment">//睡眠2秒,保证test1将数据写入test.txt文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试读取test.txt文件中test1写入的数据</span></span><br><span class="line">    ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将读到的数据打印至屏幕</span></span><br><span class="line">    write(STDOUT_FILENO, buf, ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入数据到文件test.txth中, 未修改读写位置</span></span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test2 read/write finish\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### 存储映射I/O

存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I/O操作。

使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过**mmap函数**来实现。

![image-20220604160436054](https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220604160436054.png)

#### mmap函数

`man 2 mmap`

头文件：`#include <sys/mman.h>`

`void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);`

- `addr`：指定映射区的首地址。通常为NULL（Linux内核指定）
- `length`：共享内存映射区的大小。（<= 文件的实际大小）
- `prot`：共享内存映射区的读写属性。`PROT_WRITE`、`PROT_READ`
- `flags`：共享内存的共享属性。
  - `MAP_SHARED`：会将映射区所做的操作反映到物理设备（磁盘）上
  - `MAP_PRIVATE`：映射区所做的修改不会反映到物理设备。
- `fd`：用于创建共享内存映射区的文件描述符
- `offset`：偏移量，默认0。`4k`的整数倍
- 返回值：
  - 成功：映射区的首地址
  - 失败：返回宏`MAP_FAILED` 即`((void*)-1)` 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;mytest.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0664</span>); <span class="comment">// 创建文件</span></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = ftruncate(fd, <span class="number">4</span>); <span class="comment">// 设置文件大小为4</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftruncate&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p = mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_WRITE | PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    ret = munmap(p, <span class="number">4</span>); <span class="comment">// 释放映射的内存</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



#### munmap函数

`man 2 munmap`

同malloc函数申请内存空间类似的，mmap建立的映射区在使用结束后也应调用类似free的函数来释放。

头文件：`#include <sys/mman.h>`

函数：`int munmap(void *addr, size_t length);`

- `addr`：映射区起始地址
- `length`：映射区长度
- 返回值：成功：0； 失败：-1



#### mmap注意事项

思考：

1. 可以open的时候O_CREAT一个新文件来创建映射区吗?

2. 如果open时O_RDONLY, mmap时PROT参数指定PROT_READ|PROT_WRITE会怎样？

3. 文件描述符先关闭，对mmap映射有没有影响？

4. 如果文件偏移量为1000会怎样？

5. 对mem越界操作会怎样？

6. 如果mem++，munmap可否成功？

7. mmap什么情况下会调用失败？

8. 如果不检测mmap的返回值，会怎样？

**总结：使用mmap时务必注意以下事项**：

1. 创建映射区的过程中，隐含着一次对映射文件的**读操作**。

2. 当`MAP_SHARED`时，要求：**映射区的权限应 <=文件打开的权限（出于对映射区的保护）**。而`MAP_PRIVATE`则无所谓，因为mmap中的权限是对内存的限制。

3. 映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。

4. 特别注意，当映射文件大小为0时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。

5. munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++、--操作。

6. 如果文件偏移量必须为4K的整数倍

7. mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。



#### 父子进程通信

父子等有血缘关系的进程之间也可以通过mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags：

`MAP_PRIVATE`: (私有映射)  父子进程各自独占映射区；

`MAP_SHARED`:  (共享映射)  父子进程共享映射区；

结论：**父子进程共享：1. 打开的文件  2. mmap建立的映射区(但必须要使用MAP_SHARED)**

练习：父进程创建映射区，然后fork子进程，子进程修改映射区内容，而后，父进程读取映射区内容，查验是否共享。

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = open(<span class="string">&quot;temp&quot;</span>, O_RDWR|O_CREAT|O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    unlink(<span class="string">&quot;temp&quot;</span>);				<span class="comment">//删除临时文件目录项,使之具备被释放条件.</span></span><br><span class="line">    ftruncate(fd, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    p = (<span class="keyword">int</span> *)mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);</span></span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;		<span class="comment">//注意:不是p == NULL</span></span><br><span class="line">        perror(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);					<span class="comment">//映射区建立完毕,即可关闭文件</span></span><br><span class="line"></span><br><span class="line">    pid = fork();				<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        *p = <span class="number">2000</span>;</span><br><span class="line">        var = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child, *p = %d, var = %d\n&quot;</span>, *p, var);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent, *p = %d, var = %d\n&quot;</span>, *p, var);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = munmap(p, <span class="number">4</span>);				<span class="comment">//释放映射区</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



#### 匿名映射

通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。

1）使用`MAP_ANONYMOUS`（或`MAP_ANON`），不需要打开文件，如：

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

2）需注意的是，`MAP_ANONYMOUS`和`MAP_ANON`这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/dev/zero&quot;</span>, O_RDWR);</span><br><span class="line">p = mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



**法一映射示例**：

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">100</span>;</span><br><span class="line">    p = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;		<span class="comment">//注意:不是p == NULL</span></span><br><span class="line">        perror(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pid = fork();				<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(p, <span class="string">&quot;hello, this is /dev/zero&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int</span> ret = munmap(p, size);				<span class="comment">//释放映射区</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**法二映射示例：**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/zero&quot;</span>, O_RDWR);</span><br><span class="line">    p = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;		<span class="comment">//注意:不是p == NULL</span></span><br><span class="line">        perror(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd); <span class="comment">// 关闭文件</span></span><br><span class="line">    </span><br><span class="line">    pid = fork();				<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(p, <span class="string">&quot;hello, /dev/zero&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int</span> ret = munmap(p, <span class="number">4</span>);				<span class="comment">//释放映射区</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



#### 无关系进程通信

实质上mmap是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。由于内核空间多进程共享，因此无血缘关系的进程间也可以使用mmap来完成通信。只要设置相应的标志位参数flags即可。若想实现共享，当然应该使用`MAP_SHARED`了。

示例：借助文件`file_shared`，`mmap_r.c`读映射区，`mmap_w.c`写映射区

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mmap_r.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">student</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STU</span> *<span class="title">mm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out file_shared\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(student), PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mm == MAP_FAILED)</span><br><span class="line">        sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;id=%d\tname=%s\t%c\n&quot;</span>, mm-&gt;id, mm-&gt;name, mm-&gt;sex);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(mm, <span class="keyword">sizeof</span>(student));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mmap_w.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">student</span> =</span> &#123;<span class="number">10</span>, <span class="string">&quot;xiaoming&quot;</span>, <span class="string">&#x27;m&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *mm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out file_shared\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    ftruncate(fd, <span class="keyword">sizeof</span>(student));</span><br><span class="line"></span><br><span class="line">    mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(student), PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mm == MAP_FAILED)</span><br><span class="line">        sys_err(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(mm, &amp;student, <span class="keyword">sizeof</span>(student));</span><br><span class="line">        student.id++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(mm, <span class="keyword">sizeof</span>(student));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

启动`mmap_w`后，再运行`mmap_r` 

![image-20220605114841501](https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220605114841501.png)



## XSI IPC机制

**进程通信机制**

![image-20220409175106240](https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409175106240.png)

System V（“系统五”）系统上发明了三种IPC机制（消息队列、信号量和共享内存），通常称为`System V IPC`。又因为后来被收录到Unix的XSI标准之中故又称为`XSI IPC`。所以当你看到System V IPC 和 XSI IPC的时候实际上指的是同一种东西。

- **信号量集（semaphore set）**，用于实现进程之间的同步与互斥
- **共享内存（shared memory）**，用于在进程之间高效地共享数据，适用于数据量大，速度要求高的场景
- **消息队列（message queue）**，进程之间传递数据的一种简单方法



### IPC对象ipcs

`ipcs`命令可以查看IPC对象

`ipcmk`：创建IPC对象

`ipcrm` ：删除IPC对象

![image-20220611141909021](https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220611141909021.png)

**IPC对象的key值和ID**

Linux系统中的IPC对象都是**全局**的，为每个IPC对象分配**唯一的ID**

在IPC操作中通信各方需要通过ID来指示操作的IPC对象，需要有机制让通信各方获取获取IPC对象的ID

- 创建IPC对象的进程通过创建IPC对象函数的返回值可获取ID值
- <font color=#ff0000>未创建IPC对象的进程如何获取IPC对象的ID值并使用该对象呢？</font>

<p>IPC机制的ID值为<strong>动态分配</strong>，无法提前约定，不能跨进程传递</p>
<p>多个进程提前<strong>约定使用相同的key值</strong>做为参数来创建IPC对象或打开已经创建的IPC对象</p>
<p>如果通信各方（进程）在创建/打开IPC对象时使用相同的key值：</p>
<ul>
<li>首次使用该key值创建IPC对象的进程将<strong>真正创建</strong>该IPC对象，并获取其ID值</li>
<li>后续使用该key值创建IPC对象的进程都将<strong>在内核中找到该IPC对象</strong>并打开它，从而获取其ID值</li>
</ul>
<p>IPC对象与key值一一对应，因此<strong>key值不能重复</strong></p>
<h3 id="ftok函数"><a href="#ftok函数" class="headerlink" title="ftok函数"></a>ftok函数</h3><p>通过<code>ftok</code>函数来产生独特的key值，避免重复</p>
<p><code>man 3 ftok</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pathname</code>是指定的文件名，可以是特殊文件也可以是目录文件）</li>
<li><code>proj_id</code>是子序号</li>
<li>成功返回key值，失败-1</li>
</ul>
<p><strong>如果要确保<code>key_t</code>值不变，需要确保<code>ftok</code>所指定的文件名不被删除</strong> </p>
<p>原因：每个文件都一个<strong>索引节点inode号</strong>，可以使用<code>ls -i</code>命令查看，且<code>inode</code>号一定不同。<code>ftok</code>的一般实现方法是<code>proj_id+inode</code> </p>
<p>假设<code>a.txt</code>文件节点号为<code>65538</code>，换算成16进制<code>0x010002</code>。指定<code>proj_id=38</code>即<code>0x26</code>，则<code>key=0x2610002</code> </p>
<h3 id="函数对比"><a href="#函数对比" class="headerlink" title="函数对比"></a>函数对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th>信号量集</th>
<th>共享内存</th>
<th>消息队列</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>semget</code></td>
<td><code>shmget</code></td>
<td><code>msgget</code></td>
<td>创建或打开一个IPC对象，获得对IPC机制的访问权</td>
</tr>
<tr>
<td><code>semop</code></td>
<td><code>shmat</code> <code>shmdt</code></td>
<td><code>msgsnd</code> <code>msgrcv</code></td>
<td>IPC操作: 信号量操作；连接/释放共享内存；发送/接收消息；</td>
</tr>
<tr>
<td><code>semctl</code></td>
<td><code>shmctl</code></td>
<td><code>msgctl</code></td>
<td>IPC控制：获得/修改IPC对象状态，“删除”IPC对象等</td>
</tr>
</tbody>
</table>
</div>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul>
<li>进程之间传递数据的一种简单方法</li>
<li>把每个消息看作一个记录，具有特定的格式</li>
<li>消息队列就是消息的链表</li>
<li><strong>写权限</strong>：按照一定的规则添加新消息</li>
<li><strong>读权限</strong>：从消息队列中读走消息</li>
<li>消息队列能够克服管道或命名管道机制的一些缺点，例如实时性差等</li>
</ul>
<h4 id="消息队列结构"><a href="#消息队列结构" class="headerlink" title="消息队列结构"></a>消息队列结构</h4><p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409203702015.png" alt="image-20220409203702015" style="zoom: 67%;" /></p>
<h4 id="消息队列操作"><a href="#消息队列操作" class="headerlink" title="消息队列操作"></a>消息队列操作</h4><p>头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>打开或创建消息队列对象：<code>msgget</code></li>
<li>向消息队列发送消息：<code>msgsnd</code></li>
<li>从消息队列接收消息：<code>msgrcv</code></li>
<li>消息队列控制操作：<code>msgctl</code> </li>
</ol>
<h4 id="msgget函数"><a href="#msgget函数" class="headerlink" title="msgget函数"></a>msgget函数</h4><p><strong>创建消息队列</strong> <code>man 2 msgget</code> </p>
<p><code>int msgget(key_t key, int msgflg);</code></p>
<p>返回值：成功返回创建或打开的消息队列对象ID；出错返回<code>-1</code></p>
<ul>
<li><p><code>key</code>：创建或打开消息队列对象时指定的key值（提前约定或通过<code>ftok</code>函数创建）</p>
<ul>
<li>若key为<code>IPC_PRIVATE</code>，则只能用于父子进程间通信</li>
</ul>
</li>
<li><p><code>msgflg</code>：设置访问权限，取值可以为以下一个或多个值的或</p>
<ul>
<li><code>IPC_CREAT</code> ：如果消息队列对象不存在则创建，否则打开已经存在的消息队列对象，创建还需同文件一样设置权限，如<code>IPC_CREAT | 0664</code> </li>
<li><code>IPC_EXCL</code>：只有消息队列对象不存在的时候，才能创建新的消息队列对象，否则就产生错误<code>EEXIST</code></li>
</ul>
</li>
<li><p>成功返回消息队列ID，失败返回-1</p>
</li>
</ul>
<h4 id="msgsnd函数"><a href="#msgsnd函数" class="headerlink" title="msgsnd函数"></a>msgsnd函数</h4><p><strong>发送信息到消息队列</strong> <code>man 2 msgsnd</code> </p>
<p><code>int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</code></p>
<ul>
<li><p><code>msgid</code>：消息队列ID</p>
</li>
<li><p><code>msgp</code>：指向<code>mymsg</code>的结构体（<code>mymsg</code>自己定义，样式如下）指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mymsg</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> mtype;  <span class="comment">// 消息类型 &gt;0，小于0的消息类型有特殊的指示作用</span></span><br><span class="line">	<span class="keyword">char</span> mtext[]; <span class="comment">// 消息内容, 数组长度自定义 &gt;=0 也可以是结构体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>msgsz</code>：以字节为单位指定待发送消息的长度（<code>mymsg</code>结构体中消息类型<code>mtext</code>自定义数据的大小）</p>
</li>
<li><p><code>msgflag</code>：可以是<code>0</code>，也可以是<code>IPC_NOWAIT</code>（该标志可以使函数工作在非阻塞模式）</p>
</li>
<li><p>返回值：成功返回0；出错返回<code>-1</code></p>
</li>
</ul>
<p>出现以下情况时：</p>
<p>1）指定的消息队列容量已满</p>
<p>2）在系统范围存在太多的消息</p>
<ul>
<li>若设置了<code>IPC_NOWAIT</code>，则<code>msgsnd</code>立即返回（返回<code>EAGAIN</code>错误）</li>
<li>若未指定该标志，则<code>msgsnd</code>导致调用进程阻塞，直到可以发送成功为止</li>
</ul>
<h4 id="msgrcv函数"><a href="#msgrcv函数" class="headerlink" title="msgrcv函数"></a>msgrcv函数</h4><p><strong>从消息队列接收信息</strong> <code>man 2 msgrcv</code> </p>
<p><code>ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);</code> </p>
<p>返回值：成功返回实际读取数据的字节数；出错返回<code>-1</code></p>
<ul>
<li>前三个参数同<code>msgsnd</code>函数</li>
<li><code>msgtyp</code>：指定期望从消息队列中接收什么样的消息<ul>
<li><code>msgtyp = 0</code>：队列中第一个消息（消息队列是一个FIFO链表，所以返回的是队列中最早的消息）</li>
<li><code>msgtyp &gt; 0</code>：消息队列中类型值为msgtyp的第一个消息</li>
<li><code>msgtyp &lt; 0</code>：消息队列中类型值小于或等于msgtyp绝对值中类型值最小的第一个消息</li>
</ul>
</li>
<li><code>msgflg</code>：当消息队列中没有期望接收的消息时会如何操作<ul>
<li>若设置了<code>IPC_NOWAIT</code>标志，则函数立即返回<code>ENOMSG</code>错误</li>
<li>若未设置<code>IPC_NOWAIT</code>标志，否则<code>msgrcv</code>导致调用进程阻塞直到如下某个事件发生：<ul>
<li>有其他进程向消息队列中发送了所期望接收的消息</li>
<li>该消息队列被删除，此时返回<code>EIDRM</code>错误</li>
<li>进程被某个信号中断，此时返回<code>EINTR</code>错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="msgctl函数"><a href="#msgctl函数" class="headerlink" title="msgctl函数"></a>msgctl函数</h4><p><strong>获取、设置消息队列属性，删除消息队列</strong>  <code>man 2 msgctl</code></p>
<p><code>int msgctl(int msqid, int cmd, struct msqid_ds *buf);</code></p>
<ul>
<li><code>cmd</code>：宏，决定对消息队列的操作<ul>
<li><code>IPC_STAT</code>：复制内核中的<code>msqid_ds</code>至<code>buf</code>中</li>
<li><code>IPC_SET</code>：通过<code>buf</code>设置内核中的<code>msqid_ds</code>内容</li>
<li><code>IPC_RMID</code>：删除消息队列，<code>buf</code>设<code>NULL</code> </li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span><span class="comment">/* Ownership and permissions */</span></span><br><span class="line">    <span class="keyword">time_t</span> msg_stime;    <span class="comment">/* Time of last msgsnd(2) */</span></span><br><span class="line">    <span class="keyword">time_t</span> msg_rtime;    <span class="comment">/* Time of last msgrcv(2) */</span></span><br><span class="line">    <span class="keyword">time_t</span> msg_ctime;    <span class="comment">/* Time of last change */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> __msg_cbytes; <span class="comment">/* Current number of bytes in</span></span><br><span class="line"><span class="comment">                                   queue (nonstandard) */</span></span><br><span class="line">    <span class="keyword">msgqnum_t</span> msg_qnum;  <span class="comment">/* Current number of messages</span></span><br><span class="line"><span class="comment">                                                in queue */</span></span><br><span class="line">    <span class="keyword">msglen_t</span> msg_qbytes; <span class="comment">/* Maximum number of bytes</span></span><br><span class="line"><span class="comment">                                   allowed in queue */</span></span><br><span class="line">    <span class="keyword">pid_t</span> msg_lspid;    <span class="comment">/* PID of last msgsnd(2) */</span></span><br><span class="line">    <span class="keyword">pid_t</span> msg_lrpid;    <span class="comment">/* PID of last msgrcv(2) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还有一大堆看不懂的操作</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>一个发送方，一个接收方。发送方从键盘输入消息</p>
<p>消息发送者： <code>msgsnd.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> msg_type;</span><br><span class="line">    <span class="keyword">char</span> text[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> msgid = <span class="number">-1</span>;</span><br><span class="line">    msgid = msgget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(msgid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;megget failed with error:%d\n&quot;</span>, errno); </span><br><span class="line">        <span class="comment">// errno : int型 errno 是记录系统的最后一次错误代码 在头文件 errno.h中</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">// EXIT_FAILURE 1   stdlib.h中的宏定义</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter some text:&quot;</span>);</span><br><span class="line">        fgets(buffer, <span class="number">1024</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        data.msg_type = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(data.text, buffer);</span><br><span class="line">        <span class="keyword">if</span>(msgsnd(msgid, (<span class="keyword">void</span>*)&amp;data, <span class="number">1024</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;msgsnd failed\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buffer, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)  <span class="comment">// 字符串比较函数 在 string.h中</span></span><br><span class="line">        &#123;</span><br><span class="line">            running = <span class="number">0</span>;</span><br><span class="line">            sleep(<span class="number">1</span>); 	<span class="comment">// 在头文件 unistd.h 中定义</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// exit(EXIT_SUCCESS); // EXIT_SUCCESS 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg %d destroy success\n&quot;</span>, msgid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgctl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息接收者：<code>msgrcv.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msg_type;</span><br><span class="line">    <span class="keyword">char</span> text[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> msgid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msgtype = <span class="number">0</span>;</span><br><span class="line">    msgid = msgget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(msgid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;megget failed with error:%d\n&quot;</span>, errno);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(msgrcv(msgid, (<span class="keyword">void</span>*)&amp;data, <span class="number">1024</span>, msgtype, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;msgrcv failed with errno:%d\n&quot;</span>, errno);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You wrote:%s\n&quot;</span>, data.text);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(data.text, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            running = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// exit(EXIT_SUCCESS);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220611170415896.png" alt="image-20220611170415896"></p>
<h3 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h3><p><strong>任务资源共享情况</strong></p>
<p><strong>临界资源</strong>：在一段时间内只允许一个任务访问的资源。诸任务间应采取互斥方式，实现对资源的共享</p>
<p><strong>共享资源</strong>：允许多个任务同时访问同一种资源的多个实例</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220410122956953.png" alt="image-20220410122956953" style="zoom:50%;" /></p>
<h4 id="信号量类型"><a href="#信号量类型" class="headerlink" title="信号量类型"></a>信号量类型</h4><p>信号量一般分为<strong>三种类型</strong>：</p>
<ul>
<li><strong>互斥信号量</strong>：任务之间互斥访问<strong>临界资源</strong></li>
<li><strong>计数信号量</strong>：任务之间竞争访问<strong>共享资源</strong></li>
<li><strong>二值信号量</strong>：任务之间的<strong>同步机制</strong></li>
</ul>
<p>信号量是操作系统提供的管理资源共享的有效手段</p>
<p><strong>信号量作为操作系统核心代码执行，其地位高于任务（进程或线程），任务调度不能终止其运行</strong></p>
<h4 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h4><p>信号量<code>s</code>一般包含以下成员：</p>
<ul>
<li>整数值<code>s.count</code>（实现资源计数）</li>
<li>任务阻塞队列<code>s.queue</code></li>
</ul>
<p>信号量操作：初始化、P操作、V操作</p>
<ul>
<li>在进程初始化信号量将<code>s.count</code>指定为一个非负整数值，表示可用的共享资源实例总数</li>
<li><p>运行中<code>s.count</code>可为负值（其绝对值表示当前等待访问该共享资源的进程数）</p>
</li>
<li><p>P操作<code>wait(s)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--s.count;<span class="comment">//表示申请一个资源;</span></span><br><span class="line"><span class="keyword">if</span> (s.count &lt; <span class="number">0</span>)<span class="comment">//表示没有空闲资源;</span></span><br><span class="line">&#123;</span><br><span class="line">    调用进程进入阻塞队列s.<span class="built_in">queue</span>;</span><br><span class="line">    阻塞调用进程;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>V操作<code>signal(s)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">++s.count; <span class="comment">//表示释放一个资源</span></span><br><span class="line"><span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>) <span class="comment">//表示有进程处于阻塞状态</span></span><br><span class="line">&#123;</span><br><span class="line">    从等待队列s.<span class="built_in">queue</span>中取出一个进程p;</span><br><span class="line">    进程P进入就绪队列;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="信号量状态图"><a href="#信号量状态图" class="headerlink" title="信号量状态图"></a>信号量状态图</h4><p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220611173018245.png" alt="image-20220611173018245"></p>
<h4 id="信号量集结构"><a href="#信号量集结构" class="headerlink" title="信号量集结构"></a>信号量集结构</h4><p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220410124618074.png" alt="image-20220410124618074" style="zoom:50%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>      </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">sem_base</span>;</span>   <span class="comment">/* 指向信号量数组的指针 */</span>       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">sem_pending</span>;</span>                     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> **<span class="title">sem_pending_last</span>;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">sem_undo</span> *<span class="title">undo</span>;</span>    </span><br><span class="line">    <span class="keyword">time_t</span> sem_otime; <span class="comment">/* 最后一次操作的时间 */</span></span><br><span class="line">	<span class="keyword">time_t</span> sem_ctime; <span class="comment">/* 最后一次改变此结构的时间 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sem_nsems; <span class="comment">/* 集合中信号量个数*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">pid_t</span> sempid; <span class="comment">/* 最后操作该信号量的进程ID */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> semncnt ; <span class="comment">/* 等待对该信号量执行P操作的进程数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> semzcnt; <span class="comment">/* 等待semval为0的进程数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> semval; <span class="comment">/* 信号量当前值 */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号量集操作"><a href="#信号量集操作" class="headerlink" title="信号量集操作"></a>信号量集操作</h4><p>头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建或打开信号量集对象：<code>semget</code>函数</p>
</li>
<li><p>信号量集操作（信号量的PV操作）：<code>semop</code>函数，<code>semtimedop</code>函数</p>
</li>
<li><p>信号量集控制（信号量初始化和删除操作）：<code>semctl</code>函数</p>
</li>
</ol>
<h4 id="semget函数"><a href="#semget函数" class="headerlink" title="semget函数"></a>semget函数</h4><p><code>man 2 semget</code> 创建或打开信号量集对象</p>
<p><code>int semget(key_t key, int nsems, int semflg);</code></p>
<ul>
<li><code>key</code>：用于创建或打开信号量集对象时指定的<code>key</code>值（约定或通过<code>ftok</code>函数创建）或者0(<code>IPC_PRIVATE</code>)—— 创建一个只有创建进程可以访问的信号量。</li>
<li><code>nsems</code>：信号量集对象中包含的信号量数量（例如取值为1，则信号量集只包含1个信号量）</li>
<li><code>semflg</code>：设置访问权限，取值可以为以下某个值或多个值的或<ul>
<li><code>IPC_CREAT</code> ：如果消息队列对象不存在则创建，否则打开已经存在的消息队列对象，创建还需同文件一样设置权限，如<code>IPC_CREAT | 0664</code> </li>
<li><code>IPC_EXCL</code>：只有消息队列对象不存在的时候，才能创建新的消息队列对象，否则就产生错误<code>EEXIST</code></li>
</ul>
</li>
<li>返回值：信号量集对象ID；失败返回<code>-1</code>；</li>
</ul>
<h4 id="semop函数"><a href="#semop函数" class="headerlink" title="semop函数"></a>semop函数</h4><p><code>man 2 semop</code> 信号量PV操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">size_t</span> nsops)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semtimedop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">size_t</span> nsops,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">const</span> struct timespec *timeout)</span></span>; <span class="comment">// 限时</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>semid</code>：信号量集对象ID（<code>semget</code>的返回值）</p>
</li>
<li><p><code>sops</code>：指向<code>sembuf</code>结构体数组（<code>ssembuf</code>自己定义，样式如下）的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sem_num; <span class="comment">//信号量序号，指示本次是操作信号量集中的哪个信号量（序号从0开始）</span></span><br><span class="line">    <span class="keyword">short</span> sem_op;	<span class="comment">//信号量操作码</span></span><br><span class="line">    <span class="comment">/*该值为正，信号量V操作，增加信号量的值（为n，则加n）</span></span><br><span class="line"><span class="comment">    该值为负，信号量P操作，减小信号量的值（为-n，则减n）</span></span><br><span class="line"><span class="comment">    该值为0，对信号量的当前值是否为0的测试*/</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg; <span class="comment">// semop操作控制标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nsops</code>：第二个参数中<code>sembuf</code>结构数组的元素个数</p>
</li>
<li><p>成功返回0；失败返回-1</p>
</li>
</ul>
<p><code>sem_flg</code>对<code>semop</code>操作进行控制，主要有2个控制标志：</p>
<ul>
<li><code>IPC_NOWAIT</code><ul>
<li>当指定的PV操作不能完成时，进程不会被阻塞，<code>semop</code>函数立即返回。返回值为-1，<code>errno</code>置为<code>EAGAIN</code>。</li>
<li>例如：信号量值在P操作后小于0，如果操作控制标志没有设置<code>IPC_NOWAIT</code>，则将调用进程阻塞，<code>semop</code>函数将不会返回直到资源可用为止；若设置了<code>IPC_NOWAIT</code>，则<code>semop</code>函数直接返回，调用进程将不会阻塞</li>
</ul>
</li>
<li><code>SEM_UNDO</code><ul>
<li>进程异常退出时，执行信号量解除（undo）操作</li>
<li>例如：进程执行了P操作后异常退出，如果操作控制标志设置了<code>SEM_UNDO</code>，则内核会对该进程执行V操作，保证安全性</li>
</ul>
</li>
</ul>
<h4 id="semctl函数"><a href="#semctl函数" class="headerlink" title="semctl函数"></a>semctl函数</h4><p><code>man semctl</code>  信号量初始化和删除操作</p>
<p><code>int semctl(int semid, int semnum, int cmd, ...);</code> （变参，三个或四个）</p>
<ul>
<li><p><code>semid</code>：信号量集对象的ID（<code>semget</code>的返回值）</p>
</li>
<li><p><code>semnum</code>：信号量集中信号量的编号（如果控制是针对整个信号量集，则将该值设置为0）</p>
</li>
<li><p><code>cmd</code>：要执行的控制命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对 整个信号量集 的控制命令主要包括：</span></span><br><span class="line">IPC_RMID	<span class="comment">//删除</span></span><br><span class="line">IPC_SET		<span class="comment">//设置ipc_perm参数</span></span><br><span class="line">IPC_STAT	<span class="comment">//获取ipc_perm参数</span></span><br><span class="line">IPC_INFO 	<span class="comment">//获取系统信息</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 针对信号量集中 某个信号量 的控制命令主要包括：</span></span><br><span class="line">SETVAL	<span class="comment">//设置信号量的值（一般用于信号量初始化时设置初始值）</span></span><br><span class="line">GETVAL	<span class="comment">//获取信号量的值</span></span><br><span class="line">GETPID	<span class="comment">//获取信号量拥有者进程的PID值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>arg</code>：与控制命令配合的参数（可选）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;   <span class="comment">/* Value for SETVAL */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span> <span class="comment">/*Buffer for IPC_STAT,IPC_SET */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;<span class="comment">/* Array for GETALL, SETALL */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span>  <span class="comment">/* Buffer for IPC_INFO */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值：成功返回值大于或等于0；失败返回值-1</p>
</li>
</ul>
<p><code>semctl</code>函数的控制命令通常为以下两种情况：</p>
<ul>
<li><code>SETVAL</code>：用来把信号量集中的某个信号量初始化为一个给定值， 这个值通过arg参数（<code>union semun</code>中的<code>val</code>成员）来指定</li>
<li><code>IPC_RMID</code>：用于删除信号量集对象，此时<code>arg</code>参数无需赋值</li>
<li><code>GETVAL</code>：返回值就是<code>get</code>得到的信号量的值</li>
</ul>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><h5 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h5><p>父子进程共享内存映射区的内容，使用信号量实现互斥</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYKEY 0x1a0a  <span class="comment">// 创建信号量使用的key值</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span>    <span class="comment">// semun 要自己添加</span></span><br><span class="line">    <span class="keyword">int</span> val; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span> </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *arry;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*信号量初始化（赋值函数）*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> init_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">    sem_union.val = init_value;	<span class="comment">// init_value为初始值</span></span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, sem_union) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Initialize semaphore\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从系统中删除信号量的函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, sem_union) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Delete semaphore\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*P 操作函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;	<span class="comment">//信号量编号，单个信号量的编号为0</span></span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>;	<span class="comment">//信号量操作，-1 为 P操作</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;	<span class="comment">//在进程没释放信号量而退出时，系统自动释放该进程中未释放的信号量</span></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>) <span class="comment">//进行P操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;V operation\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*V 操作函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;	<span class="comment">//信号量编号，单个信号量的编号为0</span></span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;	<span class="comment">//信号量操作，1 为 v操作</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;	<span class="comment">//在进程没释放信号量而退出时，系统自动释放该进程中未释放的信号量</span></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>) <span class="comment">//进行V操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;V operation\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> result;</span><br><span class="line">    <span class="keyword">int</span> sem_id;</span><br><span class="line">    <span class="comment">/*创建一个信号量*/</span></span><br><span class="line">    <span class="comment">//sem_id = semget(ftok(&quot;.&quot;, &#x27;a&#x27;), 1, 0666 | IPC_CREAT);</span></span><br><span class="line">    sem_id = semget(MYKEY, <span class="number">1</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    init_sem(sem_id, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内存映射</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*调用fork()函数*/</span></span><br><span class="line">    result = fork();</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(result == <span class="number">0</span>) <span class="comment">/*返回值为0代表子进程*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        sem_p(sem_id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child progress will wait for some seconds...\n&quot;</span>);</span><br><span class="line">        *p = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child change mmap int = %d\n&quot;</span>, *p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The returned value is %d in the child progress(PID=%d)\n&quot;</span>, result, getpid());</span><br><span class="line">        sem_v(sem_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/*返回值大于0代表父进程*/</span></span><br><span class="line">    &#123;</span><br><span class="line">    	sem_p(sem_id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The returned value is %d in the father progress(PID=%d)\n&quot;</span>, result, getpid());</span><br><span class="line">        *p = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent change mmap int = %d\n&quot;</span>, *p);</span><br><span class="line">        sem_v(sem_id);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        del_sem(sem_id);</span><br><span class="line">        <span class="keyword">if</span>(munmap((<span class="keyword">void</span>*)p, <span class="keyword">sizeof</span>(<span class="literal">NULL</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220611224521264.png" alt="image-20220611224521264"></p>
<h5 id="无关系进程"><a href="#无关系进程" class="headerlink" title="无关系进程"></a>无关系进程</h5><p>不同进程间创建相同信号量需要判定是否已存在，若已存在不能重新初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;               <span class="comment">/* value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>  <span class="comment">/* buffer for IPC_STAT &amp; IPC_SET */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>; <span class="comment">/* array for GETALL &amp; SETALL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span> <span class="comment">/* buffer for IPC_INFO */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span></span>; <span class="comment">// P操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span></span>; <span class="comment">// V操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> semid, ret;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;/dev/null&quot;</span>, <span class="number">0x04</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok key error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.创建信号量 （创建了三个信号量，实际只用0号信号量）</span></span><br><span class="line">    semid = semget(key, <span class="number">3</span>, IPC_CREAT | <span class="number">0600</span> | IPC_EXCL);</span><br><span class="line">    <span class="keyword">if</span> (semid == <span class="number">-1</span> &amp;&amp; errno == EEXIST) &#123; <span class="comment">// 若信号已存在</span></span><br><span class="line">        semid = semget(key, <span class="number">3</span>, <span class="number">0600</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem exists\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 若信号量不存在</span></span><br><span class="line">        <span class="comment">// 对0号信号量设置初始值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init semid\n&quot;</span>);</span><br><span class="line">        arg.val = <span class="number">1</span>;</span><br><span class="line">        ret = semctl(semid, <span class="number">0</span>, SETVAL, arg);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;semctl error&quot;</span>);</span><br><span class="line">            semctl(semid, <span class="number">0</span>, IPC_RMID, arg);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.打印当前0号信号量的值</span></span><br><span class="line">    ret = semctl(semid, <span class="number">0</span>, GETVAL, arg);</span><br><span class="line">    <span class="comment">// 4.开始P操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;P operate begin\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem_p(semid, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;P operate error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;P operate end\n&quot;</span>);</span><br><span class="line">    ret = semctl(semid, <span class="number">0</span>, GETVAL, arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after P sem[0].val= %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="comment">// 5.延时10s		（这个时间段内去执行另一个进程sem2，会在它的P操作那阻塞等待sem执行完V操作）</span></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">time_t</span> tNow = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;delay 10S，now time is:%s\n&quot;</span>, ctime(&amp;tNow));</span><br><span class="line">    <span class="comment">// 6.开始V操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;V operate begin\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem_v(semid, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;V operate error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;V operate end\n&quot;</span>);</span><br><span class="line">    ret = semctl(semid, <span class="number">0</span>, GETVAL, arg);</span><br><span class="line">    <span class="comment">// 7.移除信号量</span></span><br><span class="line">    <span class="comment">// 轮询 是否信号量被使用</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ret = semctl(semid, <span class="number">0</span>, GETVAL);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">1</span> || ret == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;process is using semid %d, wait...\n&quot;</span>, semid);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = semctl(semid, <span class="number">0</span>, IPC_RMID, arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EIDRM) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;semid had been removed\n&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;remove semid success\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对信号量数组semnum编号的信号量做P操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span>;</span></span><br><span class="line">    op.sem_num = <span class="number">0</span>;</span><br><span class="line">    op.sem_op = <span class="number">-1</span>;</span><br><span class="line">    op.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">return</span> (semop(semid, &amp;op, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对信号量数组semnum编号的信号量做V操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span>;</span></span><br><span class="line">    op.sem_num = <span class="number">0</span>;</span><br><span class="line">    op.sem_op = +<span class="number">1</span>;</span><br><span class="line">    op.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">return</span> (semop(semid, &amp;op, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220612141517746.png" alt="image-20220612141517746"></p>
<p>分别用两个终端运行<code>./IPC_sem</code>，等待约二十秒查看结果，注意删除信号量之前睡眠15秒是为了等待另一进程完成PV操作，<strong>即删除信号量时需保证所有使用该信号量的进程完成PV操作，否则会出错</strong></p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul>
<li>共享内存是内核为进程间通信创建的<strong>特殊内存段</strong></li>
<li>不同进程可以将同一段共享内存连接到自己的地址空间</li>
<li>最快的进程间通信方式</li>
<li>本身不具有互斥访问机制</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220410144858118.png" alt="image-20220410144858118" style="zoom: 40%;" /></p>
<h4 id="共享内存操作"><a href="#共享内存操作" class="headerlink" title="共享内存操作"></a>共享内存操作</h4><p>头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>打开或创建共享内存对象：<code>shmget</code>函数</li>
<li><p>将共享内存连接到进程空间：<code>shmat</code>函数</p>
</li>
<li><p>断开进程空间和共享内存的连接：<code>shmdt</code>函数</p>
</li>
<li>共享内存控制操作：<code>shmctl</code>函数</li>
</ol>
<h4 id="shmget函数"><a href="#shmget函数" class="headerlink" title="shmget函数"></a>shmget函数</h4><p><code>int shmget(key_t key, size_t size, int shmflag)</code> </p>
<ul>
<li><p><code>key</code>：创建或打开共享内存对象时指定的key值（提前约定或通过ftok函数创建）或者0(<code>IPC_PRIVATE</code>)—— 创建一个只有创建进程可以访问的信号量。</p>
</li>
<li><p><code>size</code>：指定创建的共享内存大小（首次创建共享内存对象时通过该参数指定共享内存段的大小）</p>
</li>
<li><p><code>shmflag</code>：设置共享内存的访问权限 ，取值可以为以下一个或多个值的或</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_CREAT 01000	<span class="comment">//如果消息队列对象不存在则创建，否则打开已经存在的消息队列对象</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_EXCL 02000	<span class="comment">//只有消息队列对象不存在的时候，才能创建新的消息队列对象，否则就产生错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_NOWAIT 04000 <span class="comment">//如果操作需要等待，则直接返回错误</span></span></span><br><span class="line"><span class="comment">//还有9 bits的权限 如 0644</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>成功返回0，失败-1</p>
</li>
</ul>
<h4 id="shmat函数"><a href="#shmat函数" class="headerlink" title="shmat函数"></a>shmat函数</h4><p><code>void *shmat(int shmid, const void *shmaddr, int shmflg);</code></p>
<ul>
<li><code>shmid</code>：共享内存对象ID</li>
<li><code>shmaddr</code>：指明共享内存连接到的进程空间地址；通常指定为<code>NULL</code>，让Linux系统决定共享内存连接到进程空间中的哪个地址</li>
<li><code>shmflg</code>：可以设置以下两个标志位之一或者不设置（值为0）<ul>
<li><code>SHM_RND</code>（ addr参数指定的地址应被规整到内存页面大小的整数倍）</li>
<li><code>SHM_RDONLY</code>（共享内存连接到进程空间时被限制为只读）</li>
</ul>
</li>
<li>成功<strong>返回共享内存在进程空间中的连接地址</strong>；失败返回 -1</li>
</ul>
<h4 id="shmdt函数"><a href="#shmdt函数" class="headerlink" title="shmdt函数"></a>shmdt函数</h4><p><code>int shmdt(const void *shmaddr);</code></p>
<ul>
<li>从调用进程的地址空间中，取消由<code>shmaddr</code>参数所指向的，共享内存映射区域</li>
<li><code>shmaddr</code>：共享内存在进程空间中的连接地址，一般为<code>shmat</code>函数返回的地址。</li>
<li>内核将该共享内存的加载计数减1</li>
<li>成功返回0；失败返回-1</li>
</ul>
<h4 id="shmctl函数"><a href="#shmctl函数" class="headerlink" title="shmctl函数"></a>shmctl函数</h4><p><code>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</code></p>
<ul>
<li><code>shmid</code>：共享内存对象ID</li>
<li><code>cmd</code>：执行的控制命令<ul>
<li><code>IPC_RMID</code>，从系统中删除该共享内存对象</li>
<li><code>IPC_STAT</code>，获取共享内存对象的内核结构值</li>
<li><code>IPC_SET</code>，设置共享内存对象的内核结构值</li>
</ul>
</li>
<li><code>buf</code>：指向<code>shmid_ds</code>结构的指正，当控制命令为<code>IPC_STAT</code>或<code>IPC_SET</code>时，用于获取或设置共享内存对象的内核结构</li>
<li>成功返回0；失败返回-1</li>
</ul>
<h4 id="生产者消费者示例"><a href="#生产者消费者示例" class="headerlink" title="生产者消费者示例"></a>生产者消费者示例</h4><p>问题描述：进程之间通过共享缓冲池（包含一定数量的缓冲区）交换数据。其中，“生产者”进程不断写入，而“消费者”进程不断读出；任何时刻只能有一个任务可对共享缓冲池进行操作。</p>
<ul>
<li>进程之间的共享缓冲池可以通过共享内存机制实现</li>
</ul>
<p>消费者读取共享内存：<code>consumer.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> Buffer[<span class="number">5</span>][<span class="number">100</span>]; <span class="comment">// 5 个缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> Index[<span class="number">5</span>];	<span class="comment">//缓冲区状态</span></span><br><span class="line">    <span class="comment">// 0 表示 对应的缓冲区未被生产者使用，可生产但不可消费</span></span><br><span class="line">    <span class="comment">// 1 表示 对应的缓冲区已被生产者使用，不可生产但可消费</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> *shm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span> *<span class="title">shared</span>;</span></span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>)); <span class="comment">// 设置随机数种子</span></span><br><span class="line">    shmid = shmget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="keyword">sizeof</span>(struct BufferPool), <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    shm = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(shm == (<span class="keyword">void</span>*)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    shared = (struct BufferPool*)shm;</span><br><span class="line">    <span class="keyword">while</span>(running) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, index, shared-&gt;Index[index]);</span><br><span class="line">        <span class="keyword">if</span>(shared-&gt;Index[index] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;consume buffer: %s&quot;</span>, shared-&gt;Buffer[index]);</span><br><span class="line">            shared-&gt;Index[index] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(shared-&gt;Buffer[index], <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index = (index + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">            sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;buf is empty\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shmctl(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成者写入共享内存：<code>producer.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> Buffer[<span class="number">5</span>][<span class="number">100</span>]; <span class="comment">// 5 个缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> Index[<span class="number">5</span>];	<span class="comment">//缓冲区状态</span></span><br><span class="line">    <span class="comment">// 0 表示 对应的缓冲区未被生产者使用，可生产但不可消费</span></span><br><span class="line">    <span class="comment">// 1 表示 对应的缓冲区已被生产者使用，不可生产但可消费</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> *shm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span> *<span class="title">shared</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    shmid = shmget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="keyword">sizeof</span>(struct BufferPool), <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    shm = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(shm == (<span class="keyword">void</span>*)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Memory attached at %X\n&quot;</span>, (<span class="keyword">int</span>*)shm);</span><br><span class="line">    shared = (struct BufferPool*)shm;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;puts in end to over\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(running) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, index, shared-&gt;Index[index]);</span><br><span class="line">        <span class="keyword">if</span>(shared-&gt;Index[index] == <span class="number">1</span>)  &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;buf is full, wait 1s ...\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Enter some text:&quot;</span>);</span><br><span class="line">            fgets(buffer, <span class="number">100</span>, <span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">strncpy</span>(shared-&gt;Buffer[index], buffer, <span class="number">100</span>);</span><br><span class="line">            shared-&gt;Index[index] = <span class="number">1</span>;</span><br><span class="line">            index = (index + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buffer, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shmctl(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220612153541618.png" alt="image-20220612153541618"></p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。代表一个或多个进程的集合。每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了<strong>简化对多个进程的管理</strong>。</p>
<p><strong>进程组</strong>：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</p>
<p>当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID\==第一个进程ID（组长进程）。所以，组长进程标识：其进程组ID\==其进程ID </p>
<p>可以使用<code>kill -SIGKILL -进程组ID</code>来将整个进程组内的进程全部杀死。</p>
<p>组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</p>
<p>进程组生存期：进程组创建到最后一个进程离开(终止或转移到另一个进程组)。</p>
<p>一个进程可以为自己或子进程设置进程组ID</p>
<h3 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h3><p><code>man 2 setpgid</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>;   </span><br></pre></td></tr></table></figure>
<p><strong>getpgrp函数</strong></p>
<p>获取当前进程的进程组ID</p>
<p><strong>getpgid函数</strong></p>
<p>获取指定进程的进程组ID。如果pid = 0，那么该函数作用和getpgrp一样。</p>
<p><strong>setpgid函数</strong></p>
<p>改变进程默认所属的进程组。通常可用来加入一个现有的进程组或创建一个新进程组。</p>
<ol>
<li><p>如改变子进程为新的组，应fork后，exec前。 </p>
</li>
<li><p>权级问题。非root进程只能改变自己创建的子进程，或有权限操作的进程</p>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child PID == %d\n&quot;</span>, getpid());</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child Group ID == %d\n&quot;</span>, getpgid(<span class="number">0</span>)); <span class="comment">// 返回组id</span></span><br><span class="line">		<span class="comment">//printf(&quot;child Group ID == %d\n&quot;, getpgrp()); //返回组id</span></span><br><span class="line">		sleep(<span class="number">7</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;----Group ID of child is changed to %d\n&quot;</span>, getpgid(<span class="number">0</span>));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		setpgid(pid, pid);</span><br><span class="line"></span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;parent PID == %d\n&quot;</span>, getpid());</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;parent&#x27;s parent process PID == %d\n&quot;</span>, getppid());</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;parent Group ID == %d\n&quot;</span>, getpgid(<span class="number">0</span>));</span><br><span class="line">		</span><br><span class="line">		sleep(<span class="number">5</span>);</span><br><span class="line">		setpgid(getpid(), getppid());	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;parent Group ID == %d\n&quot;</span>, getpgid(<span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608150818204.png" alt="image-20220608150818204"></p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><h3 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h3><p>创建一个会话需要注意以下6点注意事项：</p>
<ol>
<li><p>调用进程<strong>不能是进程组组长</strong>，该进程变成新会话首进程（session header）</p>
</li>
<li><p>该进程成为一个新进程组的组长进程。</p>
</li>
<li><p>需有root权限（ubuntu不需要）</p>
</li>
<li><p>新会话丢弃原有的控制终端，该会话没有控制终端</p>
</li>
<li><p>该调用进程是组长进程，则出错返回</p>
</li>
<li><p>建立新会话时，先调用fork，父进程终止，子进程调用<code>setsid</code></p>
</li>
</ol>
<h3 id="getsid函数"><a href="#getsid函数" class="headerlink" title="getsid函数"></a>getsid函数</h3><p><code>man 2 getsid</code></p>
<p>获取进程所属的会话ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>pid为0表示察看当前进程<code>session ID</code></p>
<p>成功：返回调用进程的会话ID；失败：-1</p>
<p><code>ps ajx</code>命令查看系统中的进程。参数a表示不仅列当前用户的进程，也列出所有其他用户的进程，参数x表示不仅列有控制终端的进程，也列出所有无控制终端的进程，参数j表示列出与作业控制相关的信息。</p>
<p>组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程。</p>
<h3 id="setsid函数"><a href="#setsid函数" class="headerlink" title="setsid函数"></a>setsid函数</h3><p><code>man 2 setsid</code> </p>
<p>创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>成功：返回调用进程的会话ID；失败：-1</p>
<p>调用了setsid函数的进程，既是新的会长，也是新的组长。    </p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child process PID is %d\n&quot;</span>, getpid());</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Group ID of child is %d\n&quot;</span>, getpgid(<span class="number">0</span>));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Session ID of child is %d\n&quot;</span>, getsid(<span class="number">0</span>));</span><br><span class="line">		</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">		setsid();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Changed:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child process PID is %d\n&quot;</span>, getpid());</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Group ID of child is %d\n&quot;</span>, getpgid(<span class="number">0</span>));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Session ID of child is %d\n&quot;</span>, getsid(<span class="number">0</span>));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608153322335.png" alt="image-20220608153322335"></p>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以<code>d</code>结尾的名字（如<code>vsftpd</code>，<code>httpd</code>，<code>sshd</code>等）。</p>
<p>Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。</p>
<p>创建守护进程，最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader。 </p>
<h3 id="创建守护进程模型"><a href="#创建守护进程模型" class="headerlink" title="创建守护进程模型"></a>创建守护进程模型</h3><ol>
<li>创建子进程，父进程退出  <code>fork()</code></li>
</ol>
<p>​           所有工作在子进程中进行形式上脱离了控制终端</p>
<ol>
<li>在子进程中创建新会话   <code>setsid()</code></li>
</ol>
<p>　　    使子进程完全独立出来，脱离控制终端</p>
<ol>
<li>改变当前目录为根目录  <code>chdir()</code></li>
</ol>
<p>　　    防止占用可卸载的文件系统，也可以换成其它路径</p>
<ol>
<li>重设文件权限掩码  <code>umask()</code></li>
</ol>
<p>　　    防止继承的文件创建屏蔽字拒绝某些权限，增加守护进程灵活性</p>
<ol>
<li>重定向文件描述符0/1/2 —&gt; <code>/dev/null</code>  <code>dup2()</code> </li>
</ol>
<p>　　    继承的打开文件不会用到，浪费系统资源，无法卸载</p>
<ol>
<li><p>开始执行守护进程核心工作</p>
</li>
<li><p>守护进程退出处理程序模型        </p>
</li>
</ol>
<h3 id="创建示例"><a href="#创建示例" class="headerlink" title="创建示例"></a>创建示例</h3><p><code>daemon.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork(); <span class="comment">// 1.创建子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> sid = setsid(); <span class="comment">// 2.创建新会话，返回会话ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = chdir(<span class="string">&quot;/home/yang&quot;</span>); <span class="comment">// 3.改变工作路径</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    umask(<span class="number">0002</span>); <span class="comment">// 4.设置文件掩码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.重定向文件描述符0/1/2 --&gt; /dev/null</span></span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line">    open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    dup2(<span class="number">0</span>, STDOUT_FILENO);</span><br><span class="line">    dup2(<span class="number">0</span>, STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 6.核心工作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      
      
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">程序和进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">1.2.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">1.3.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.4.</span> <span class="nav-text">单道程序设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.5.</span> <span class="nav-text">多道程序设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU%E5%92%8CMMU"><span class="nav-number">1.6.</span> <span class="nav-text">CPU和MMU</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%88PCB%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">进程控制块（PCB）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">2.2.</span> <span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">文件管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">2.4.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F"><span class="nav-number">2.5.</span> <span class="nav-text">进程组织形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">2.6.</span> <span class="nav-text">进程属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84"><span class="nav-number">2.6.1.</span> <span class="nav-text">用户和用户组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.7.</span> <span class="nav-text">进程生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="nav-number">2.8.</span> <span class="nav-text">进程的终止</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#exit-exit%E5%87%BD%E6%95%B0"><span class="nav-number">2.8.1.</span> <span class="nav-text">exit&#x2F;_exit函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exit%E4%B8%8Ereturn"><span class="nav-number">2.8.2.</span> <span class="nav-text">exit与return</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">2.8.3.</span> <span class="nav-text">终止处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#atexit%E5%87%BD%E6%95%B0"><span class="nav-number">2.8.3.1.</span> <span class="nav-text">atexit函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#on-exit%E5%87%BD%E6%95%B0"><span class="nav-number">2.8.3.2.</span> <span class="nav-text">on_exit函数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="nav-number">3.</span> <span class="nav-text">进程环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="nav-number">3.2.</span> <span class="nav-text">用户空间布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">命令行参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ftok%E5%87%BD%E6%95%B0"><span class="nav-number">3.4.</span> <span class="nav-text">ftok函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94"><span class="nav-number">3.5.</span> <span class="nav-text">函数对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">3.6.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84"><span class="nav-number">3.6.1.</span> <span class="nav-text">消息队列结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C"><span class="nav-number">3.6.2.</span> <span class="nav-text">消息队列操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#msgget%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.3.</span> <span class="nav-text">msgget函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#msgsnd%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.4.</span> <span class="nav-text">msgsnd函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#msgrcv%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.5.</span> <span class="nav-text">msgrcv函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#msgctl%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.6.</span> <span class="nav-text">msgctl函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.6.7.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86"><span class="nav-number">3.7.</span> <span class="nav-text">信号量集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.7.1.</span> <span class="nav-text">信号量类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.7.2.</span> <span class="nav-text">信号量的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%8A%B6%E6%80%81%E5%9B%BE"><span class="nav-number">3.7.3.</span> <span class="nav-text">信号量状态图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86%E7%BB%93%E6%9E%84"><span class="nav-number">3.7.4.</span> <span class="nav-text">信号量集结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86%E6%93%8D%E4%BD%9C"><span class="nav-number">3.7.5.</span> <span class="nav-text">信号量集操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#semget%E5%87%BD%E6%95%B0"><span class="nav-number">3.7.6.</span> <span class="nav-text">semget函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#semop%E5%87%BD%E6%95%B0"><span class="nav-number">3.7.7.</span> <span class="nav-text">semop函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#semctl%E5%87%BD%E6%95%B0"><span class="nav-number">3.7.8.</span> <span class="nav-text">semctl函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">3.7.9.</span> <span class="nav-text">代码示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.7.9.1.</span> <span class="nav-text">父子进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E5%85%B3%E7%B3%BB%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.7.9.2.</span> <span class="nav-text">无关系进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">3.8.</span> <span class="nav-text">共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C"><span class="nav-number">3.8.1.</span> <span class="nav-text">共享内存操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shmget%E5%87%BD%E6%95%B0"><span class="nav-number">3.8.2.</span> <span class="nav-text">shmget函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shmat%E5%87%BD%E6%95%B0"><span class="nav-number">3.8.3.</span> <span class="nav-text">shmat函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shmdt%E5%87%BD%E6%95%B0"><span class="nav-number">3.8.4.</span> <span class="nav-text">shmdt函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shmctl%E5%87%BD%E6%95%B0"><span class="nav-number">3.8.5.</span> <span class="nav-text">shmctl函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.8.6.</span> <span class="nav-text">生产者消费者示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-number">4.</span> <span class="nav-text">进程组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">操作函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.3.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D"><span class="nav-number">5.</span> <span class="nav-text">会话</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BC%9A%E8%AF%9D"><span class="nav-number">5.1.</span> <span class="nav-text">创建会话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getsid%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">getsid函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setsid%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">setsid函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">5.4.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.1.</span> <span class="nav-text">创建守护进程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B"><span class="nav-number">6.2.</span> <span class="nav-text">创建示例</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yanglinqi"
      src="/images/headpic.jpg">
  <p class="site-author-name" itemprop="name">yanglinqi</p>
  <div class="site-description" itemprop="description">用于做笔记，对学过的知识总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yanglinqi107" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanglinqi107" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yanglinqi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


  <script async src="/js/cursor/fireworks.js"></script>


</body>
</html>

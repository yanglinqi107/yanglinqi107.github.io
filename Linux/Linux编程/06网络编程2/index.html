<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yanglinqi107.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="黑马程序员，man 7 ip ，高并发服务器、UDP">
<meta property="og:type" content="article">
<meta property="og:title" content="Socket编程2">
<meta property="og:url" content="http://yanglinqi107.github.io/Linux/Linux%E7%BC%96%E7%A8%8B/06%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/index.html">
<meta property="og:site_name" content="杨记">
<meta property="og:description" content="黑马程序员，man 7 ip ，高并发服务器、UDP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220617124915060.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220615221830468.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220616150558550.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220616152303401.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220616152702823.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220616161411020.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220616162101547.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220616164717253.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220618141648371.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220619133706699.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220619134050224.png">
<meta property="article:published_time" content="2022-06-18T05:22:58.938Z">
<meta property="article:modified_time" content="2022-08-02T02:12:00.536Z">
<meta property="article:author" content="yanglinqi">
<meta property="article:tag" content="Linux编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220617124915060.png">

<link rel="canonical" href="http://yanglinqi107.github.io/Linux/Linux%E7%BC%96%E7%A8%8B/06%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Socket编程2 | 杨记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杨记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">碎片化学习令人焦虑，系统化学习使人进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">100</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yanglinqi107.github.io/Linux/Linux%E7%BC%96%E7%A8%8B/06%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headpic.jpg">
      <meta itemprop="name" content="yanglinqi">
      <meta itemprop="description" content="用于做笔记，对学过的知识总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Socket编程2
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-18 13:22:58" itemprop="dateCreated datePublished" datetime="2022-06-18T13:22:58+08:00">2022-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 10:12:00" itemprop="dateModified" datetime="2022-08-02T10:12:00+08:00">2022-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Linux%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Linux编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>黑马程序员，<code>man 7 ip</code> ，高并发服务器、UDP</p>
<span id="more"></span>
<h2 id="高并发服务器"><a href="#高并发服务器" class="headerlink" title="高并发服务器"></a>高并发服务器</h2><p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220617124915060.png" alt="image-20220617124915060"></p>
<h3 id="多进程并发服务器"><a href="#多进程并发服务器" class="headerlink" title="多进程并发服务器"></a>多进程并发服务器</h3><p>使用多进程并发服务器时要考虑以下几点：</p>
<ol>
<li><p>父进程最大文件描述个数（父进程中需要close关闭accept返回的新文件描述符）</p>
</li>
<li><p>系统内创建进程个数（与内存大小相关）</p>
</li>
<li><p>进程创建过多是否降低整体服务性能（进程调度）</p>
</li>
</ol>
<p><code>server.c</code> ，和每个客户端的数据交互放在子进程中。子进程结束后，捕捉<code>SIGCHLD</code>信号回收进程资源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">&quot;106.13.232.203&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, cfd, i, pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ], clie_IP[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>;</span></span><br><span class="line"></span><br><span class="line">    newact.sa_handler = wait_child;</span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    sigaction(SIGCHLD, &amp;newact, <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">    sfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr);</span></span><br><span class="line">    Bind(sfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    Listen(sfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">        cfd = Accept(sfd, (struct sockaddr*)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line"></span><br><span class="line">        bzero(&amp;clie_IP, <span class="keyword">sizeof</span>(clie_IP));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client: IP:%s\tport:%d\n&quot;</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perr_exit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            close(sfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            close(cfd); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            n = Read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;  <span class="comment">// client close</span></span><br><span class="line">                close(cfd);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">-1</span>) &#123;</span><br><span class="line">                perr_exit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">                    buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                write(cfd, buf, n);</span><br><span class="line">                write(STDOUT_FILENO, buf, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多线程并发服务器"><a href="#多线程并发服务器" class="headerlink" title="多线程并发服务器"></a>多线程并发服务器</h3><p>在使用线程模型开发服务器时需考虑以下问题：</p>
<ol>
<li><p>调整进程内最大文件描述符上限</p>
</li>
<li><p>线程如有共享数据，考虑线程同步</p>
</li>
<li><p>服务于客户端线程退出时，退出处理。（退出值，分离态）</p>
</li>
<li><p>系统负载，随着链接客户端增加，导致其它线程不能及时得到CPU</p>
</li>
</ol>
<p><code>server.c</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> &#123;</span>         <span class="comment">//定义一个结构体, 将地址结构跟cfd捆绑</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> connfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_work</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> *<span class="title">ts</span> =</span> (struct s_info*)arg;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN]; <span class="comment">// #define INET_ADDRSTRLEN 16  &quot;[+d&quot;可查看</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        n = Read(ts-&gt;connfd, buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 读客户端</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;the client %d closed ...\n&quot;</span>, ts-&gt;connfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>, inet_ntop(AF_INET, &amp;(*ts).clie_addr.sin_addr.s_addr, str, <span class="keyword">sizeof</span>(str)), ntohs((*ts).clie_addr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]); <span class="comment">// 小写--&gt;大写</span></span><br><span class="line"></span><br><span class="line">        Write(STDOUT_FILENO, buf, n); <span class="comment">//写出至屏幕</span></span><br><span class="line">        Write(ts-&gt;connfd, buf, n); <span class="comment">//回写至客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">    Close(ts-&gt;connfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> <span class="title">ts</span>[256];</span> <span class="comment">//根据最大线程数创建结构体数组</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">//创建一个socket, 得到文件描述符</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)); <span class="comment">// 地址结构清零</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT); <span class="comment">//指定端口号 8000</span></span><br><span class="line">    </span><br><span class="line">    Bind(listenfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, <span class="number">128</span>); <span class="comment">//设置同一时刻链接服务器上限数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accepting client connect ...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">        connfd = Accept(listenfd, (struct sockaddr*)&amp;clie_addr, &amp;clie_addr_len); <span class="comment">//阻塞监听客户端链接请求</span></span><br><span class="line">        ts[i].clie_addr = clie_addr;</span><br><span class="line">        ts[i].connfd = connfd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//达到线程最大数是，pthread_create出错处理，增加服务器稳定性</span></span><br><span class="line">        pthread_create(&amp;tid, <span class="literal">NULL</span>, do_work, (<span class="keyword">void</span>*)&amp;ts[i]);</span><br><span class="line">        pthread_detach(tid);  <span class="comment">// 子线程分离，防止僵尸线程产生</span></span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多路I-O转接服务器"><a href="#多路I-O转接服务器" class="headerlink" title="多路I/O转接服务器"></a>多路I/O转接服务器</h3><p>多路IO转接服务器也叫做多任务IO服务器。该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之由<strong>内核</strong>替应用程序监视文件。</p>
<p>主要使用的方法有三种</p>
<ul>
<li><code>select</code>函数实现</li>
<li><code>poll</code>函数实现</li>
<li><code>epoll</code>函数实现</li>
</ul>
<font color=#ff0000>既然是文件，则使用文件描述符进行操作。所有除了对套接字（也是文件）适用外，之前的管道等也同样适用。</font>



<h4 id="select实现"><a href="#select实现" class="headerlink" title="select实现"></a>select实现</h4><p>select能监听的文件描述符个数受限于<code>FD_SETSIZE</code>，一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数</p>
<p>解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力</p>
<h5 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">nfds:       监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前多少个文件描述符的状态</span></span><br><span class="line"><span class="comment">readfds：   监控有读数据到达文件描述符集合，传入传出参数</span></span><br><span class="line"><span class="comment">writefds：  监控写数据到达文件描述符集合，传入传出参数</span></span><br><span class="line"><span class="comment">exceptfds： 监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数</span></span><br><span class="line"><span class="comment">timeout：   定时阻塞监控时间，3种情况</span></span><br><span class="line"><span class="comment">			1.NULL，永远等下去</span></span><br><span class="line"><span class="comment">			2.设置timeval，等待固定时间</span></span><br><span class="line"><span class="comment">			3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span></span><br><span class="line"><span class="comment">返回值：    三个文件描述符集合所有 有相应事件发生的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把文件描述符集合里所有位清0 初始化set(位图)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">//把文件描述符集合里fd清0 即从set中删除fd</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;  </span><br><span class="line"><span class="comment">//测试文件描述符集合里fd是否置1 即判断fd是否在set中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; </span><br><span class="line"><span class="comment">//把文件描述符集合里fd位置1  即将fd添加到set中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;  </span><br></pre></td></tr></table></figure>
<p>存在的问题：</p>
<ol>
<li>文件描述符有上限 1024</li>
<li>不知道具体对应哪个文件描述符有反馈，需要for(1 —&gt; 1023)或自定义数据结构（数组）</li>
<li>监听集合作为传入传出参数，会发生改变。需要保存原集合</li>
</ol>
<h5 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h5><ol>
<li><code>select()</code>监听 服务器端的监听套接字<code>listenfd</code>的 读（有读数据说明有客户端进行连接）</li>
<li>使用<code>accept()</code>建立连接返回交互套接字<code>connfd</code>，后<code>select()</code>监听<code>connfd</code>的读写</li>
<li><code>select()</code>返回 需要处理的文件描述符的个数，使用<code>FD_ISSET()</code>进行判断是哪些文件描述符</li>
</ol>
<p><code>server.c</code> 还是小写转大写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, n, maxi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nready, client[FD_SETSIZE];  <span class="comment">// 自定义数组client 防止遍历1024个文件描述符 FD_SETSIZE 1024</span></span><br><span class="line">    <span class="keyword">int</span> maxfd, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ], str[INET_ADDRSTRLEN]; <span class="comment">// #define INET_ADDRSTRLEN 16</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>, <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    fd_set rset, allset;    <span class="comment">// rset读事件文件描述符集合 allset用来暂存</span></span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>; </span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));  <span class="comment">// 端口复用</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    Listen(listenfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wait for connect ...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    maxfd = listenfd;   <span class="comment">// 起初 listenfd 即为最大文件描述符</span></span><br><span class="line">    maxi = <span class="number">-1</span>;      <span class="comment">// 之后用作client[]的下标 初始值指向0个元素之前下标位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; FD_SETSIZE; ++i)</span><br><span class="line">        client[i] = <span class="number">-1</span>;     <span class="comment">// 用-1初始化client[]</span></span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;allset);   </span><br><span class="line">    FD_SET(listenfd, &amp;allset);  <span class="comment">//构造select监控文件描述符集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        rset = allset;  <span class="comment">//每次循环时都从新设置select监控信号集</span></span><br><span class="line">        nready = select(maxfd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(nready &lt; <span class="number">0</span>) </span><br><span class="line">            perr_exit(<span class="string">&quot;select&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有新的客户端链接请求</span></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(listenfd, &amp;rset)) &#123; </span><br><span class="line">            clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">            connfd = Accept(listenfd, (struct sockaddr*)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">                    inet_ntop(AF_INET, (<span class="keyword">void</span>*)&amp;clie_addr.sin_addr.s_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                    ntohs(clie_addr.sin_port));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; FD_SETSIZE; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(client[i] &lt; <span class="number">0</span>) &#123;   <span class="comment">// 找client[]中没有使用的位置</span></span><br><span class="line">                    client[i] = connfd;  <span class="comment">// 保存accept返回的文件描述符到client[]里</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i == FD_SETSIZE) &#123;  <span class="comment">//达到select能监控的文件个数上限</span></span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot;too many clients\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            FD_SET(connfd, &amp;allset);    <span class="comment">// 向监控文件描述符集合allset添加新的文件描述符connfd</span></span><br><span class="line">            <span class="keyword">if</span>(connfd &gt; maxfd)</span><br><span class="line">                maxfd = connfd; <span class="comment">// select 第一个参数需要</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i &gt; maxi)</span><br><span class="line">                maxi = i;   <span class="comment">// 保证maxi存的总是client[]最后一个元素下标</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(--nready == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有数据需要读取</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= maxi; ++i) &#123; <span class="comment">// 检测哪个clients有数据就绪</span></span><br><span class="line">            <span class="keyword">if</span>((sockfd = client[i]) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line">                <span class="keyword">if</span>((n = Read(sockfd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>) &#123;  <span class="comment">// 当client关闭链接时 服务器端也关闭对应连接</span></span><br><span class="line">                    Close(sockfd);</span><br><span class="line">                    FD_CLR(sockfd, &amp;allset);  <span class="comment">// 解除select对此文件描述符的监控</span></span><br><span class="line">                    client[i] = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;      <span class="comment">// 处理数据 转成大写</span></span><br><span class="line">                    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                        buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                    Write(sockfd, buf, n);</span><br><span class="line">                    Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(--nready == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// 跳出for循环 还在while中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="pselect函数"><a href="#pselect函数" class="headerlink" title="pselect函数"></a>pselect函数</h5><p>pselect原型如下，此模型应用较少。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">                   fd_set *exceptfds, <span class="keyword">const</span> struct timespec *timeout,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br><span class="line"><span class="comment">// 用sigmask替代当前进程的阻塞信号集，调用返回后还原原有阻塞信号集</span></span><br></pre></td></tr></table></figure>
<h4 id="poll实现"><a href="#poll实现" class="headerlink" title="poll实现"></a>poll实现</h4><p>优点：</p>
<ol>
<li>能监听的文件描述符可以突破1024（方法参见epoll）</li>
<li>监听、返回集合 分离开</li>
<li>搜索范围小</li>
</ol>
<h5 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">// 监控的事件</span></span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">// 监控事件中满足条件返回的事件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fds 	结构体数组首地址</span></span><br><span class="line"><span class="comment">nfds	监控数组中有多少文件描述符需要被监控（不一定是数组长度）</span></span><br><span class="line"><span class="comment">timeout 		毫秒级等待</span></span><br><span class="line"><span class="comment">		-1：阻塞等待    #define INFTIM -1 (Linux中没有定义此宏)</span></span><br><span class="line"><span class="comment">		 0：立即返回，不阻塞进程</span></span><br><span class="line"><span class="comment">		&gt;0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">事件：</span></span><br><span class="line"><span class="comment">POLLIN		    普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND  (*)</span></span><br><span class="line"><span class="comment">POLLRDNORM		数据可读</span></span><br><span class="line"><span class="comment">POLLRDBAND		优先级带数据可读</span></span><br><span class="line"><span class="comment">POLLPRI 		高优先级可读数据</span></span><br><span class="line"><span class="comment">POLLOUT		    普通或带外数据可写							   (*)</span></span><br><span class="line"><span class="comment">POLLWRNORM		数据可写</span></span><br><span class="line"><span class="comment">POLLWRBAND		优先级带数据可写</span></span><br><span class="line"><span class="comment">POLLERR 		发生错误									   (*)</span></span><br><span class="line"><span class="comment">POLLHUP 		发生挂起</span></span><br><span class="line"><span class="comment">POLLNVAL 		描述字不是一个打开的文件</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>如果不再监控某个文件描述符时，可以把<code>pollfd</code>中，fd设置为-1，<code>poll</code>不再监控此pollfd，下次返回时，把<code>revents</code>设置为0</p>
<h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><p><code>server.c</code> 小写转大写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, maxi, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="keyword">int</span> nready;    <span class="comment">// 接收poll返回值 记录满足监听事件的fd个数</span></span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">socklen_t</span> clie_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>, <span class="title">serv_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    client[<span class="number">0</span>].fd = listenfd;    <span class="comment">//要监听的第一个文件描述符 存入client[0]</span></span><br><span class="line">    client[<span class="number">0</span>].events = POLLIN;  <span class="comment">//listenfd监听普通读事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; OPEN_MAX; ++i)</span><br><span class="line">        client[i].fd = <span class="number">-1</span>;     <span class="comment">// 用-1初始化client[]中剩余元素 0也是文件描述符,不可用</span></span><br><span class="line"></span><br><span class="line">    maxi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        nready = poll(client, maxi+<span class="number">1</span>, <span class="number">-1</span>);      <span class="comment">// 阻塞监听是否有客户端连接请求</span></span><br><span class="line">        <span class="keyword">if</span>(client[<span class="number">0</span>].revents &amp; POLLIN) &#123;    <span class="comment">//listenfd有读事件就绪</span></span><br><span class="line">            clie_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">            connfd = Accept(listenfd, (struct sockaddr*)&amp;clie_addr, &amp;clie_len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>, </span><br><span class="line">                    inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                    ntohs(clie_addr.sin_port));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; OPEN_MAX; ++i)</span><br><span class="line">                <span class="keyword">if</span>(client[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    client[i].fd = connfd; <span class="comment">//找到client[]中空闲的位置 存放accept返回的connfd</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == OPEN_MAX)       <span class="comment">// 达到最大客户端数</span></span><br><span class="line">                perr_exit(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i &gt; maxi)</span><br><span class="line">                maxi = i;       <span class="comment">// 更新client[]中最大元素下标</span></span><br><span class="line">            <span class="keyword">if</span>(--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= maxi; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(client[i].fd &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(client[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="keyword">if</span>((n = Read(sockfd, buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(errno == ECONNRESET) &#123; <span class="comment">// 收到RST标志</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client[%d] aborted connection\n&quot;</span>, i);</span><br><span class="line">                        Close(sockfd);</span><br><span class="line">                        client[i].fd = <span class="number">-1</span>;  <span class="comment">//poll中不监控该文件描述符 置为-1 不用像select那样移除</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> </span><br><span class="line">                        perr_exit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>) &#123; <span class="comment">// 说明客户端关闭连接</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client[%d], closed connection\n&quot;</span>, i);</span><br><span class="line">                    Close(sockfd);</span><br><span class="line">                    client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; ++j) </span><br><span class="line">                        buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                    Writen(sockfd, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ppoll函数"><a href="#ppoll函数" class="headerlink" title="ppoll函数"></a>ppoll函数</h5><p>GNU定义了ppoll（非POSIX标准），可以支持设置信号屏蔽字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ppoll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">const</span> struct timespec *timeout_ts, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="epoll实现"><a href="#epoll实现" class="headerlink" title="epoll实现"></a>epoll实现</h4><p>epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p>
<p>目前epell是linux大规模并发网络程序中的热门首选模型。</p>
<p>epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。</p>
<p>可以使用cat命令查看一个进程可以打开的socket描述符上限：<code>cat /proc/sys/fs/file-max</code></p>
<p>如有需要，可以通过修改配置文件的方式修改该上限值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/security/limits.conf</span><br><span class="line">在文件尾部写入以下配置,soft软限制，hard硬限制。如下图所示。</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 100000</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220615221830468.png" alt="image-20220615221830468"></p>
<h5 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h5><ol>
<li><code>epoll_create</code>函数</li>
<li><code>epoll_ctl</code>函数</li>
<li><code>epoll_wait</code>函数</li>
</ol>
<p>1）创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;  <span class="comment">// size 监听数目</span></span><br><span class="line"><span class="comment">// 内核和根据要监听的文件个数创建一个红黑树结构，并分配内存</span></span><br><span class="line"><span class="comment">// 返回文件描述符（句柄），用来操作内核中的开辟出的红黑树</span></span><br></pre></td></tr></table></figure>
<p>2）控制某个epoll监控的文件描述符上的事件：注册、修改、删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fd:		 要进行操作的文件描述符</span></span><br><span class="line"><span class="comment">epfd：	为epoll_creat的句柄</span></span><br><span class="line"><span class="comment">op：		表示动作，用3个宏来表示：</span></span><br><span class="line"><span class="comment">		 EPOLL_CTL_ADD (注册新的fd到epfd)，</span></span><br><span class="line"><span class="comment">		 EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，</span></span><br><span class="line"><span class="comment">		 EPOLL_CTL_DEL (从epfd删除一个fd)；</span></span><br><span class="line"><span class="comment">event：	告诉内核需要监听的事件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">EPOLLIN：	表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</span></span><br><span class="line"><span class="comment">EPOLLOUT：	表示对应的文件描述符可以写</span></span><br><span class="line"><span class="comment">EPOLLPRI：	表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</span></span><br><span class="line"><span class="comment">EPOLLERR：	表示对应的文件描述符发生错误</span></span><br><span class="line"><span class="comment">EPOLLHUP：	表示对应的文件描述符被挂断；</span></span><br><span class="line"><span class="comment">EPOLLET： 	将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</span></span><br><span class="line"><span class="comment">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>3）等待所监控文件描述符上有事件的产生，类似于<code>select()</code>调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">events：		结构体数组，传出参数。用来存内核得到事件的集合</span></span><br><span class="line"><span class="comment">maxevents：	告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size</span></span><br><span class="line"><span class="comment">timeout：	是超时时间</span></span><br><span class="line"><span class="comment">			 -1： 阻塞</span></span><br><span class="line"><span class="comment">			 0：	 立即返回，非阻塞</span></span><br><span class="line"><span class="comment">			 &gt;0： 指定毫秒</span></span><br><span class="line"><span class="comment">返回值：	成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h5 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h5><p><code>server.c</code> 小写转大写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 5000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="keyword">int</span> n, num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> nready, efd, res;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">socklen_t</span> clie_len;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>, <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">tep</span>, <span class="title">ep</span>[<span class="title">OPEN_MAX</span>];</span>   <span class="comment">//tep: epoll_ctl参数 ep[]:epoll_wait参数</span></span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt)); <span class="comment">//端口复用</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    efd = epoll_create(OPEN_MAX);   <span class="comment">//创建epoll模型,efd指向红黑树根节点</span></span><br><span class="line">    <span class="keyword">if</span>(efd == <span class="number">-1</span>)</span><br><span class="line">        perr_exit(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line"></span><br><span class="line">    tep.events = EPOLLIN;   <span class="comment">// 指定listenfd监听事件为读</span></span><br><span class="line">    tep.data.fd = listenfd;</span><br><span class="line">    res = epoll_ctl(efd, EPOLL_CTL_ADD,listenfd, &amp;tep);  <span class="comment">// 将listenfd及对应结构体设置到efd操纵的树上</span></span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">-1</span>)</span><br><span class="line">        perr_exit(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="comment">// epoll为server阻塞监听事件 ep为struct epoll_event类型数组 OPEN_MAX为数组容量 -1永久阻塞</span></span><br><span class="line">        nready = epoll_wait(efd, ep, OPEN_MAX, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nready == <span class="number">-1</span>)</span><br><span class="line">            perr_exit(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nready; ++i) &#123; </span><br><span class="line">            <span class="keyword">if</span>(!ep[i].events &amp; EPOLLIN)  <span class="comment">// 如果不是 读事件 ， 继续循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ep[i].data.fd == listenfd) &#123; <span class="comment">// 判断满足事件的fd是不是listenfd</span></span><br><span class="line">                clie_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                connfd = Accept(listenfd, (struct sockaddr*)&amp;clie_addr, &amp;clie_len);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">                        inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                        ntohs(clie_addr.sin_port));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;cfd %d---client %d\n&quot;</span>, connfd, ++num);</span><br><span class="line"></span><br><span class="line">                tep.events = EPOLLIN;</span><br><span class="line">                tep.data.fd = connfd;</span><br><span class="line">                res = epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;tep);</span><br><span class="line">                <span class="keyword">if</span>(res == <span class="number">-1</span>)</span><br><span class="line">                    perr_exit(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                        <span class="comment">// 不是listenfd</span></span><br><span class="line">                sockfd = ep[i].data.fd;</span><br><span class="line">                n = Read(sockfd, buf, MAXLINE);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;    <span class="comment">//读到0，说明客户端关闭连接</span></span><br><span class="line">                    res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>); <span class="comment">//将该文件描述符从红黑树中删除</span></span><br><span class="line">                    <span class="keyword">if</span>(res == <span class="number">-1</span>)</span><br><span class="line">                        perr_exit(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">                    Close(sockfd);  <span class="comment">//关闭与该客户端的连接</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client[%d] closed connection\n&quot;</span>, sockfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;     <span class="comment">//出错</span></span><br><span class="line">                    perror(<span class="string">&quot;read n &lt; 0&quot;</span>);</span><br><span class="line">                    res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);</span><br><span class="line">                    Close(sockfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;        <span class="comment">//实际读到了字节数</span></span><br><span class="line">                    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);   <span class="comment">//转大写</span></span><br><span class="line">                    Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                    Writen(sockfd, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Close(listenfd);</span><br><span class="line">    Close(efd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="epoll进阶"><a href="#epoll进阶" class="headerlink" title="epoll进阶"></a>epoll进阶</h3><h4 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h4><p><code>EPOLL</code>事件有两种模型：</p>
<ul>
<li><code>Edge Triggered (ET)</code>边缘触发只有数据到来才触发，不管缓存区中是否还有数据。</li>
<li><code>Level Triggered (LT)</code>水平触发只要有数据都会触发。</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220616150558550.png" alt="image-20220616150558550"></p>
<p>思考如下步骤：</p>
<ol>
<li><p>假定我们已经把一个用来从管道中读取数据的文件描述符(RFD)添加到epoll描述符。</p>
</li>
<li><p>管道的另一端写入了2KB的数据</p>
</li>
<li><p>调用epoll_wait，并且它会返回RFD，说明它已经准备好读取操作</p>
</li>
<li><p>读取1KB的数据</p>
</li>
<li><p>调用epoll_wait……</p>
</li>
</ol>
<p>在这个过程中，有两种工作模式：ET模式 和 LT模式</p>
<h5 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a>ET模式</h5><p>ET模式即<code>Edge Triggered</code>工作模式。</p>
<p>如果我们在第1步将RFD添加到epoll描述符的时候使用了<code>EPOLLET</code>标志，那么在第5步调用epoll_wait之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。epoll工作在ET模式的时候，必须使用<strong>非阻塞套接口</strong>，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用ET模式的epoll接口，在后面会介绍避免可能的缺陷。</p>
<p>1) 基于非阻塞文件句柄</p>
<p>2) 只有当read或者write返回<code>EAGAIN</code>(非阻塞读，暂时无数据)时才需要挂起、等待。但这并不是说每次read时都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当read返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。</p>
<h5 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a>LT模式</h5><p>LT模式即<code>Level Triggered</code>工作模式。</p>
<p>与ET模式不同的是，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的poll，无论后面的数据是否被使用。</p>
<p>LT（level triggered）：LT是缺省的工作方式，并且同时支持<code>block</code>和<code>no-block socket</code>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的<code>select/poll</code>都是这种模型的代表。</p>
<p>ET（edge-triggered）：ET是高速工作方式，只支持<code>no-block socket</code>。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）</p>
<h4 id="管道示例"><a href="#管道示例" class="headerlink" title="管道示例"></a>管道示例</h4><ol>
<li>创建一个管道，子进程写数据，父进程读数据</li>
<li>子进程每次写10B大小的数据，再睡眠10s</li>
<li>父进程使用epoll监听管道的读端，每次读5B大小的数据</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> epfd, i;</span><br><span class="line">    <span class="keyword">int</span> pfd[<span class="number">2</span>];  <span class="comment">// epoll和管道</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    pipe(pfd);</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;      <span class="comment">// 写</span></span><br><span class="line">        close(pfd[<span class="number">0</span>]);   <span class="comment">//关闭读端</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// aaaa\n</span></span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXLINE/<span class="number">2</span>; ++i)</span><br><span class="line">                buf[i] = ch;</span><br><span class="line">            buf[i - <span class="number">1</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            ch++;</span><br><span class="line">            <span class="comment">// bbbb\n</span></span><br><span class="line">            <span class="keyword">for</span>(; i &lt; MAXLINE; ++i)</span><br><span class="line">                buf[i] = ch;</span><br><span class="line">            buf[i - <span class="number">1</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            ch++;</span><br><span class="line">            <span class="comment">// aaaa\nbbbb\n</span></span><br><span class="line">            write(pfd[<span class="number">1</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child write to pipe-------------\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;--------------------------------\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pfd[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;    <span class="comment">//父 读</span></span><br><span class="line">        struct epoll_event event, resevent;</span><br><span class="line">        <span class="keyword">int</span> res, len;</span><br><span class="line"></span><br><span class="line">        close(pfd[<span class="number">1</span>]);  <span class="comment">//关闭写端</span></span><br><span class="line"></span><br><span class="line">        epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">        event.events = EPOLLIN | EPOLLET;   <span class="comment">// ET 边沿触发</span></span><br><span class="line">        <span class="comment">//event.events = EPOLLIN;             // LT 水平触发（默认）</span></span><br><span class="line">        event.data.fd = pfd[<span class="number">0</span>];</span><br><span class="line">        epoll_ctl(epfd, EPOLL_CTL_ADD, pfd[<span class="number">0</span>], &amp;event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            res = epoll_wait(epfd, &amp;resevent, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;father read from pipe\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;res %d\n&quot;</span>, res);</span><br><span class="line">            <span class="keyword">if</span>(resevent.data.fd == pfd[<span class="number">0</span>]) &#123;</span><br><span class="line">                len = read(pfd[<span class="number">0</span>], buf, MAXLINE/<span class="number">2</span>);</span><br><span class="line">                write(STDOUT_FILENO, buf, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(pfd[<span class="number">0</span>]);</span><br><span class="line">        close(epfd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ET边沿触发模式</strong>：子进程写一次<code>aaaa\nbbbb\n</code>， 父进程读一次<code>aaaa\n</code>；……</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220616152303401.png" alt="image-20220616152303401" style="zoom:80%;" /></p>
<p><strong>LT水平触发模式：</strong> 子进程写一次<code>aaaa\nbbbb\n</code>， 父进程读一次<code>aaaa\n</code>，父进程再读一次<code>bbbb\n</code>；……</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220616152702823.png" alt="image-20220616152702823" style="zoom: 80%;" /></p>
<h4 id="C-S示例"><a href="#C-S示例" class="headerlink" title="C/S示例"></a>C/S示例</h4><p>和管道示例类似，子进程换成了客户端，父进程换成了服务器</p>
<p><code>server.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> epfd;</span><br><span class="line"></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    bind(listenfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    listen(listenfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">resevent</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res, len;</span><br><span class="line"></span><br><span class="line">    epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;   <span class="comment">// ET 边沿触发</span></span><br><span class="line">    <span class="comment">//event.events = EPOLLIN;             // LT 水平触发 默认</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accept connections ...\n&quot;</span>);</span><br><span class="line">    clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">    connfd = accept(listenfd, (struct sockaddr*)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">            inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">            ntohs(clie_addr.sin_port));</span><br><span class="line"></span><br><span class="line">    event.data.fd = connfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        res = epoll_wait(epfd, &amp;resevent, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server read from socket buf\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;res %d\n&quot;</span>, res);</span><br><span class="line">        <span class="keyword">if</span>(resevent.data.fd == connfd) &#123;</span><br><span class="line">            len = read(connfd, buf, MAXLINE/<span class="number">2</span>);</span><br><span class="line">            write(STDOUT_FILENO, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(connfd);</span><br><span class="line">    close(listenfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>client.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connfd, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    inet_pton(AF_INET, SERV_IP, (<span class="keyword">void</span>*)&amp;serv_addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    connfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    connect(connfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// aaaa\n</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXLINE/<span class="number">2</span>; ++i)</span><br><span class="line">            buf[i] = ch;</span><br><span class="line">        buf[i - <span class="number">1</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        ch++;</span><br><span class="line">        <span class="comment">// bbbb\n</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; MAXLINE; ++i)</span><br><span class="line">            buf[i] = ch;</span><br><span class="line">        buf[i - <span class="number">1</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        ch++;</span><br><span class="line">        <span class="comment">// aaaa\nbbbb\n</span></span><br><span class="line">        write(connfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client write to socket buf-------------\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ET边沿触发模式</strong>：</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220616161411020.png" alt="image-20220616161411020" style="zoom:80%;" /></p>
<p><strong>LT水平触发模式：</strong> </p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220616162101547.png" alt="image-20220616162101547" style="zoom:80%;" /></p>
<h4 id="非阻塞读示例"><a href="#非阻塞读示例" class="headerlink" title="非阻塞读示例"></a>非阻塞读示例</h4><p>基于网络C/S非阻塞模型的epoll ET触发模式。服务器对套接字非阻塞读，但要加上while循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>, <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> epfd, flag;</span><br><span class="line"></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    bind(listenfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    listen(listenfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">resevent</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res, len;</span><br><span class="line"></span><br><span class="line">    epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN | EPOLLET;   <span class="comment">// ET 边沿触发</span></span><br><span class="line">    <span class="comment">//event.events = EPOLLIN</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accepting connections ...\n&quot;</span>);</span><br><span class="line">    clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">    connfd = accept(listenfd, (struct sockaddr*)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">            inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">            ntohs(clie_addr.sin_port));</span><br><span class="line">    </span><br><span class="line">    flag = fcntl(connfd, F_GETFL);  <span class="comment">// 修改connfd为非阻塞读</span></span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    fcntl(connfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">    event.data.fd = connfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;event); <span class="comment">//将connfd放入监听红黑树</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait begin\n&quot;</span>);</span><br><span class="line">        res = epoll_wait(epfd, &amp;resevent, <span class="number">1</span>, <span class="number">-1</span>);    <span class="comment">//只监听1个</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait end res %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(resevent.data.fd == connfd) &#123;</span><br><span class="line">            <span class="keyword">while</span>((len = read(connfd, buf, MAXLINE/<span class="number">2</span>)) &gt; <span class="number">0</span>) <span class="comment">//非阻塞读 轮询</span></span><br><span class="line">                write(STDOUT_FILENO, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220616164717253.png" alt="image-20220616164717253"></p>
<h4 id="反应堆模型"><a href="#反应堆模型" class="headerlink" title="反应堆模型"></a>反应堆模型</h4><p><code>libevent</code> 核心思想实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * epoll基于非阻塞I/O事件驱动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 1024         <span class="comment">//监听上限数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;                                             <span class="comment">//要监听的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> events;                                         <span class="comment">//对应的监听事件</span></span><br><span class="line">    <span class="keyword">void</span> *arg;                                          <span class="comment">//泛型参数</span></span><br><span class="line">    <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg);   <span class="comment">//回调函数</span></span><br><span class="line">    <span class="keyword">int</span> status;                                         <span class="comment">//是否在监听: 1-&gt;在红黑树上 0-&gt;不在</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFLEN];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">long</span> last_active;                                   <span class="comment">//记录每次加入红黑树 g_efd 的时间值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_efd;                                  <span class="comment">//全局变量 保存epoll_create的返回值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> <span class="title">g_events</span>[<span class="title">MAX_EVENTS</span>+1];</span>    <span class="comment">//自定义结构体类型数组 +1 --&gt; listen fd</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventset</span><span class="params">(struct myevent_s *ev, <span class="keyword">int</span> fd, <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span>*), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventadd</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">int</span> events, struct myevent_s *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventdel</span><span class="params">(<span class="keyword">int</span> efd, struct myevent_s *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptconn</span><span class="params">(<span class="keyword">int</span> lfd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">senddata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initlistensocket</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">short</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> port = SERV_PORT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">2</span>)</span><br><span class="line">        port = atoi(argv[<span class="number">1</span>]);       <span class="comment">//使用用户指定端口 未指定则用默认端口</span></span><br><span class="line"></span><br><span class="line">    g_efd = epoll_create(MAX_EVENTS+<span class="number">1</span>); <span class="comment">//创建红黑树 返回给全局g_efd</span></span><br><span class="line">    <span class="keyword">if</span>(g_efd &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create efd in %s err %s\n&quot;</span>, __func__, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initlistensocket(g_efd, port);      <span class="comment">//初始化监听socket</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>+1];</span>    <span class="comment">//保存已经满足就绪事件的文件描述符数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server running:port[%d]\n&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> checkpos = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 超时验证，每次测试100个链接，不测试listenfd  当客户端60秒内没有和服务器通信，则关闭与该客户端链接 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> now = time(<span class="literal">NULL</span>);   <span class="comment">//当前时间</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i, checkpos++) &#123; <span class="comment">//一次循环检测100个 checkpos控制检测对象</span></span><br><span class="line">            <span class="keyword">if</span>(checkpos == MAX_EVENTS)</span><br><span class="line">                checkpos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(g_events[checkpos].status != <span class="number">1</span>)  <span class="comment">//不在红黑树 g_efd 上</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> duration = now - g_events[checkpos].last_active;   <span class="comment">//客户端不活跃的时间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(duration &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">                close(g_events[checkpos].fd);   <span class="comment">//关闭与该客户端链接</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[fd=%d\n] timeout\n&quot;</span>, g_events[checkpos].fd);</span><br><span class="line">                eventdel(g_efd, &amp;g_events[checkpos]);   <span class="comment">//将该客户端 从红黑树g_efd移除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 监听红黑树g_efd,将满足的事件的文件描述符加至events数组中，1秒没有实践满足，返回0 */</span></span><br><span class="line">        <span class="keyword">int</span> nfd = epoll_wait(g_efd, events, MAX_EVENTS+<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span>(nfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nfd; ++i) &#123;</span><br><span class="line">            <span class="comment">/* 使用自定义结构体myevent_s类型指针，接收 联合体data的void *ptr成员 */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (struct myevent_s *)events[i].data.ptr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN)) &#123;</span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT)) &#123;</span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 退出前释放所有资源 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建 socket, 初始化lfd */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initlistensocket</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> flag = fcntl(lfd, F_GETFL);</span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    fcntl(lfd, F_SETFL, flag);        <span class="comment">// 将socket设为非阻塞</span></span><br><span class="line"></span><br><span class="line">    eventset(&amp;g_events[MAX_EVENTS], lfd, acceptconn, &amp;g_events[MAX_EVENTS]); <span class="comment">//g_events数组的最后一个元素对应lfd</span></span><br><span class="line"></span><br><span class="line">    eventadd(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    bzero(&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    bind(lfd, (struct sockaddr*)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"></span><br><span class="line">    listen(lfd, <span class="number">128</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将结构体 myevent_s 成员变量 初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventset</span><span class="params">(struct myevent_s *ev, <span class="keyword">int</span> fd, <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span>*), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ev-&gt;fd = fd;</span><br><span class="line">    ev-&gt;call_back = call_back;</span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;arg = arg;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//memset(ev-&gt;buf, 0, sizeof(ev-&gt;buf));</span></span><br><span class="line">    <span class="comment">//ev-&gt;len = 0;</span></span><br><span class="line">    ev-&gt;last_active = time(<span class="literal">NULL</span>);   <span class="comment">//调用eventset函数的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向epoll监听的红黑树 添加一个 文件描述符 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventadd</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">int</span> events, struct myevent_s *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> =</span> &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    epv.events = ev-&gt;events = events;   <span class="comment">// EPOLLIN 或 EPOLLOUT</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status == <span class="number">1</span>) &#123;       <span class="comment">// 已经在红黑树 g_efd 里</span></span><br><span class="line">        op = EPOLL_CTL_MOD;     <span class="comment">// 修改其属性 </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 已经在红黑树中</span></span><br><span class="line">        op = EPOLL_CTL_ADD;     <span class="comment">// 将其加入红黑树 g_efd, 并将status置1 </span></span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(epoll_ctl(efd, op, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)    <span class="comment">//实际添加/修改</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;event add failed [fd=%d], events[%d]\n&quot;</span>, ev-&gt;fd, events);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;event add OK [fd=%d], op=%d, events[%0X]\n&quot;</span>, ev-&gt;fd, op, events);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从epoll监听的 红黑树中删除一个 文件描述符 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventdel</span><span class="params">(<span class="keyword">int</span> efd, struct myevent_s *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> =</span> &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status != <span class="number">1</span>)  <span class="comment">//不在红黑树上</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;                 <span class="comment">//修改状态</span></span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv); <span class="comment">//从红黑树 efd 上将ev-&gt;fd 摘除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当有文件描述符就绪, epoll返回，调用该函数 与客户端建立连接 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptconn</span><span class="params">(<span class="keyword">int</span> lfd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cin</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="built_in">cin</span>);</span><br><span class="line">    <span class="keyword">int</span> cfd, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((cfd = accept(lfd, (struct sockaddr*)&amp;<span class="built_in">cin</span>, &amp;len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EAGAIN &amp;&amp; errno != EINTR) &#123;</span><br><span class="line">            <span class="comment">/* 暂时不做处理 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: accept, %s\n&quot;</span>, __func__, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_EVENTS; ++i) <span class="comment">//从全局数组g_events中找一个空闲元素</span></span><br><span class="line">            <span class="keyword">if</span>(g_events[i].status == <span class="number">0</span>) <span class="comment">//类似于select中找值为-1的元素</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i == MAX_EVENTS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: max connect limit[%d]\n&quot;</span>, __func__, MAX_EVENTS);</span><br><span class="line">            <span class="keyword">break</span>;      <span class="comment">//跳出do while(0) 不执行后续代码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>) &#123;  <span class="comment">//将cfd也设置为阻塞</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: fcntl nonblocking failed, %s\n&quot;</span>, __func__, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 给cfd设置一个 myevent_s结构体 回调函数 设置为 recvdata */</span></span><br><span class="line"></span><br><span class="line">        eventset(&amp;g_events[i], cfd, recvdata, &amp;g_events[i]);</span><br><span class="line">        eventadd(g_efd, EPOLLIN, &amp;g_events[i]);     <span class="comment">//将cfd添加红黑树g_efd中 监听读事件</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new connect [%s:%d][time:%ld], pos[%d]\n&quot;</span>,</span><br><span class="line">            inet_ntoa(<span class="built_in">cin</span>.sin_addr), ntohs(<span class="built_in">cin</span>.sin_port), g_events[i].last_active, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (struct myevent_s*)arg;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = recv(fd, ev-&gt;buf, <span class="keyword">sizeof</span>(ev-&gt;buf), <span class="number">0</span>);    <span class="comment">//读文件描述符，数据存入myevent_s成员buf中</span></span><br><span class="line"></span><br><span class="line">    eventdel(g_efd, ev);    <span class="comment">//将该节点从红黑树上摘除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ev-&gt;len = len;</span><br><span class="line">        ev-&gt;buf[len] = <span class="string">&#x27;\0&#x27;</span>;    <span class="comment">//手动添加字符串结束标记</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C[%d]:%s\n&quot;</span>, fd, ev-&gt;buf);</span><br><span class="line"></span><br><span class="line">        eventset(ev, fd, senddata, ev); <span class="comment">//设置该fd对应的回调函数为senddata</span></span><br><span class="line">        eventadd(g_efd, EPOLLOUT, ev);  <span class="comment">//将fd加入红黑树g_efd中，监听其写事件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">        close(ev-&gt;fd);</span><br><span class="line">        <span class="comment">/* ev-g_events 地址相减得到偏移元素位置 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[fd=%d] pos[%ld], closed\n&quot;</span>, fd, ev-g_events);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(ev-&gt;fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv[fd=%d] error[%d]:%s\n&quot;</span>, fd, errno, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">senddata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (struct myevent_s*)arg;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = send(fd, ev-&gt;buf, ev-&gt;len, <span class="number">0</span>);    <span class="comment">//直接将数据回写给客户端</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * printf(&quot;fd=%d\tev-&gt;buf=%s\tev-&gt;len=%d\n&quot;, fd, ev-&gt;buf, ev-&gt;len);</span></span><br><span class="line"><span class="comment">     * printf(&quot;send len = %d\n&quot;, len);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send[fd=%d], [%d]%s\n&quot;</span>, fd, len, ev-&gt;buf);</span><br><span class="line">        eventdel(g_efd, ev);            <span class="comment">//从红黑树g_efd中移除</span></span><br><span class="line">        eventset(ev, fd, recvdata, ev); <span class="comment">//将该fd的回调函数改为recvdata</span></span><br><span class="line">        eventadd(g_efd, EPOLLIN, ev);   <span class="comment">//重新添加到红黑树上，设为监听读事件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(ev-&gt;fd);      <span class="comment">//关闭连接</span></span><br><span class="line">        eventdel(g_efd, ev);    <span class="comment">//从红黑树g_efd中移除</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send[fd=%d] error %s\n&quot;</span>, fd, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ol>
<li><p>预先创建阻塞于accept多线程，使用互斥锁上锁保护accept</p>
</li>
<li><p>预先创建多线程，由主线程调用accept</p>
</li>
</ol>
<p><code>threadpool.h</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __THREADPOOL_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __THREADPOOL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">threadpool_t</span> <span class="title">threadpool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">threadpool_t</span> *<span class="title">threadpool_create</span><span class="params">(<span class="keyword">int</span> min_thr_num, <span class="keyword">int</span> max_thr_num, <span class="keyword">int</span> queue_max_size)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_add</span><span class="params">(<span class="keyword">threadpool_t</span> *pool, <span class="keyword">void</span>*(*function)(<span class="keyword">void</span> *arg), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_destroy</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_all_threadnum</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_busy_threadnum</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>threadpool.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_TIME 10         <span class="comment">/* 10s检测一次 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_WAIT_TASK_NUM 10    <span class="comment">/* 如果queue_size &gt; MIN_WAIT_TASK_NUM 添加新的线程到线程池 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_THREAD_VARY 10  <span class="comment">/* 每次创建或销毁线程的个数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *(*function)(<span class="keyword">void</span> *); <span class="comment">/* 函数指针 回调函数 */</span></span><br><span class="line">    <span class="keyword">void</span> *arg;                  <span class="comment">/* 上面函数的参数 */</span></span><br><span class="line">&#125; <span class="keyword">threadpool_task_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 描述线程池相关信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadpool_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;           <span class="comment">/* 用于锁住本结构体 */</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> thread_counter; <span class="comment">/* 记录忙状态线程个数的锁 -- busy_thr_num */</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> queue_not_full;  <span class="comment">/* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> queue_not_empty; <span class="comment">/* 任务队列里不为空时，通知等待任务的线程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> *threads;             <span class="comment">/* 存放线程池中每个线程的tid 数组 */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> adjust_tid;           <span class="comment">/* 存管理线程tid */</span></span><br><span class="line">    <span class="keyword">threadpool_task_t</span> *task_queue;  <span class="comment">/* 任务队列 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min_thr_num;                <span class="comment">/* 线程池最小线程数 */</span></span><br><span class="line">    <span class="keyword">int</span> max_thr_num;                <span class="comment">/* 线程池最大线程数 */</span></span><br><span class="line">    <span class="keyword">int</span> live_thr_num;               <span class="comment">/* 当前存活线程个数 */</span></span><br><span class="line">    <span class="keyword">int</span> busy_thr_num;               <span class="comment">/* 忙状态线程个数 */</span></span><br><span class="line">    <span class="keyword">int</span> wait_exit_thr_num;          <span class="comment">/* 要销毁的线程个数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> queue_front;                <span class="comment">/* task_queue队头下标 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_rear;                 <span class="comment">/* task_queue队尾下标 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_size;                 <span class="comment">/* taks_queue队中实际任务数 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_max_size;             <span class="comment">/* task_queue队列可容纳任务数上限 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shutdown;                   <span class="comment">/* 标志位，线程池使用状态，true或false */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadpool_thread</span><span class="params">(<span class="keyword">void</span> *threadpool)</span></span>;  <span class="comment">//销毁线程池</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_free</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span>;    <span class="comment">//释放pool资源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">adjust_thread</span><span class="params">(<span class="keyword">void</span> *threadpool)</span></span>;  <span class="comment">//管理者线程的启动函数，管理线程池的线程数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_thread_alive</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>; <span class="comment">//判断某个线程是否存活</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">threadpool_t</span> *<span class="title">threadpool_create</span><span class="params">(<span class="keyword">int</span> min_thr_num, <span class="keyword">int</span> max_thr_num, <span class="keyword">int</span> queue_max_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">threadpool_t</span> *pool = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((pool = (<span class="keyword">threadpool_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">threadpool_t</span>))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadpool fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 跳出do while</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool-&gt;min_thr_num = min_thr_num;</span><br><span class="line">        pool-&gt;max_thr_num = max_thr_num;</span><br><span class="line">        pool-&gt;busy_thr_num = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;live_thr_num = min_thr_num;   <span class="comment">// 存活的线程数 初值=最小线程数</span></span><br><span class="line">        pool-&gt;queue_size = <span class="number">0</span>;           <span class="comment">// 有0个产品</span></span><br><span class="line">        pool-&gt;queue_max_size = queue_max_size;</span><br><span class="line">        pool-&gt;queue_front = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queue_rear = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;shutdown = <span class="literal">false</span>;         <span class="comment">// 不关闭线程池</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 根据最大线程上限数，给工作线程数组开辟空间，并清零 */</span></span><br><span class="line">        pool-&gt;threads = (<span class="keyword">pthread_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>) * max_thr_num);</span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;threads == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threads fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;threads, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>) * max_thr_num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 任务队列开辟空间 */</span></span><br><span class="line">        pool-&gt;task_queue = (<span class="keyword">threadpool_task_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">threadpool_task_t</span>) * queue_max_size);</span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;task_queue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc task_queue fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化互斥锁、条件变量 */</span></span><br><span class="line">        <span class="keyword">if</span>(pthread_mutex_init(&amp;(pool-&gt;lock), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_mutex_init(&amp;(pool-&gt;thread_counter), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_cond_init(&amp;(pool-&gt;queue_not_empty), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_cond_init(&amp;(pool-&gt;queue_not_full), <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;init the lock or cond fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 启动 min_thr_num 个 work thread */</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; min_thr_num; ++i) &#123;</span><br><span class="line">            pthread_create(&amp;(pool-&gt;threads[i]), <span class="literal">NULL</span>, threadpool_thread, (<span class="keyword">void</span> *)pool); <span class="comment">// pool指向当前线程池</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;start thread 0x%x ...\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pool-&gt;threads[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_create(&amp;(pool-&gt;adjust_tid), <span class="literal">NULL</span>, adjust_thread, (<span class="keyword">void</span>*)pool); <span class="comment">// 启动管理者线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    threadpool_free(pool);  <span class="comment">// 前面代码调用失败时，释放pool存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 向线程池中 添加一个任务 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_add</span><span class="params">(<span class="keyword">threadpool_t</span> *pool, <span class="keyword">void</span>*(*function)(<span class="keyword">void</span> *arg), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队列已经满，调用wait阻塞 */</span></span><br><span class="line">    <span class="keyword">while</span>((pool-&gt;queue_size == pool-&gt;queue_max_size) &amp;&amp; (!pool-&gt;shutdown)) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;(pool-&gt;queue_not_full), &amp;(pool-&gt;lock));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;shutdown) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加的任务插入尾部 先释放尾部arg */</span></span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;task_queue[pool-&gt;queue_rear].arg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;task_queue[pool-&gt;queue_rear].arg);</span><br><span class="line">        pool-&gt;task_queue[pool-&gt;queue_rear].arg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 添加任务到任务队列中 */</span></span><br><span class="line">    pool-&gt;task_queue[pool-&gt;queue_rear].function = function;</span><br><span class="line">    pool-&gt;task_queue[pool-&gt;queue_rear].arg = arg;</span><br><span class="line">    pool-&gt;queue_rear = (pool-&gt;queue_rear + <span class="number">1</span>) % pool-&gt;queue_max_size;   <span class="comment">// 队尾指针移动，模拟环形</span></span><br><span class="line">    pool-&gt;queue_size++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加完任务后，队列不为空，唤醒线程池中 等待处理任务的线程 */</span></span><br><span class="line">    pthread_cond_signal(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_thread_alive</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kill_rc = pthread_kill(tid, <span class="number">0</span>); <span class="comment">// 发0号信号，测试线程是否存活</span></span><br><span class="line">    <span class="keyword">if</span>(kill_rc == ESRCH) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_destroy</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pool-&gt;shutdown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 先销毁管理线程 */</span></span><br><span class="line">    pthread_join(pool-&gt;adjust_tid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; pool-&gt;live_thr_num; ++i) &#123;</span><br><span class="line">        <span class="comment">/* 通知所有的空闲线程 */</span></span><br><span class="line">        pthread_cond_broadcast(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; pool-&gt;live_thr_num; ++i) &#123;</span><br><span class="line">        pthread_join(pool-&gt;threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    threadpool_free(pool);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_all_threadnum</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all_threadnum = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">    all_threadnum = pool-&gt;live_thr_num;</span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">    <span class="keyword">return</span> all_threadnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_busy_threadnum</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> busy_threadnum = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    busy_threadnum = pool-&gt;busy_thr_num;</span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    <span class="keyword">return</span> busy_threadnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 管理线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">adjust_thread</span><span class="params">(<span class="keyword">void</span> *threadpool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">threadpool_t</span> *pool = (<span class="keyword">threadpool_t</span> *)threadpool;</span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown) &#123;</span><br><span class="line">        sleep(DEFAULT_TIME);    <span class="comment">// 定时 对线程池管理</span></span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">        <span class="keyword">int</span> queue_size = pool-&gt;queue_size;  <span class="comment">// 关注 任务数</span></span><br><span class="line">        <span class="keyword">int</span> live_thr_num = pool-&gt;live_thr_num;  <span class="comment">// 存活线程数</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        <span class="keyword">int</span> busy_thr_num = pool-&gt;busy_thr_num;      <span class="comment">// 忙着的线程数</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建新线程 任务数大于最小线程池个数，且存活的线程数少于最大线程个数时</span></span><br><span class="line">        <span class="keyword">if</span>(queue_size &gt;= MIN_WAIT_TASK_NUM &amp;&amp; live_thr_num &lt; pool-&gt;max_thr_num) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">            <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一次增加 DFAULT_THREAD 个线程</span></span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; pool-&gt;max_thr_num &amp;&amp; add &lt;DEFAULT_THREAD_VARY</span><br><span class="line">                    &amp;&amp; pool-&gt;live_thr_num &lt; pool-&gt;max_thr_num; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;threads[i] = <span class="number">0</span> || !is_thread_alive(pool-&gt;threads[i])) &#123;</span><br><span class="line">                    pthread_create(&amp;(pool-&gt;threads[i]), <span class="literal">NULL</span>, threadpool_thread, (<span class="keyword">void</span>*)pool);</span><br><span class="line">                    add++;</span><br><span class="line">                    pool-&gt;live_thr_num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁多余的空闲线程 忙线程x2 小于 存活的线程数 且 存活的线程数 大于 最小线程数时</span></span><br><span class="line">        <span class="keyword">if</span>((busy_thr_num * <span class="number">2</span>) &lt; live_thr_num &amp;&amp; live_thr_num &gt; pool-&gt;min_thr_num) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">            <span class="comment">// 一次销毁DEFAULT_THREAD个线程 随机10个</span></span><br><span class="line">            pool-&gt;wait_exit_thr_num = DEFAULT_THREAD_VARY;  <span class="comment">// 要销毁的线程数 设置为10</span></span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; DEFAULT_THREAD_VARY; ++i) &#123;</span><br><span class="line">                <span class="comment">// 通知处于空闲状态的线程，他们会自行终止</span></span><br><span class="line">                pthread_cond_signal(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadpool_thread</span><span class="params">(<span class="keyword">void</span> *threadpool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">threadpool_t</span> *pool = (<span class="keyword">threadpool_t</span> *)threadpool;</span><br><span class="line">    <span class="keyword">threadpool_task_t</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">/* 刚创建出线程，等待任务队列里有任务，否则阻塞等待任务队列里有任务后再唤醒接收任务 */</span></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* queue_size == 0 说明没有任务，调wait阻塞在条件变量上，若有任务，跳过该while */</span></span><br><span class="line">        <span class="keyword">while</span>((pool-&gt;queue_size == <span class="number">0</span>) &amp;&amp; (!pool-&gt;shutdown)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x is waiting\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">            pthread_cond_wait(&amp;(pool-&gt;queue_not_empty), &amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 清除指定数目的空闲线程，如果要结束的线程个数大于0，结束线程 */</span></span><br><span class="line">            <span class="keyword">if</span>(pool-&gt;wait_exit_thr_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pool-&gt;wait_exit_thr_num--;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 如果线程池里线程个数大于最小值时可以结束当前线程 */</span></span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;live_thr_num &gt; pool-&gt;min_thr_num) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x is exiting\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">                    pool-&gt;live_thr_num--;</span><br><span class="line">                    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">                    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果指定了true,要关闭线程池里的每个线程，自行退出处理 */</span></span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;shutdown) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x is exiting\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>); <span class="comment">//线程自行结束</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从任务队列里获取任务，是一个出队操作 */</span></span><br><span class="line">        task.function = pool-&gt;task_queue[pool-&gt;queue_front].function;</span><br><span class="line">        task.arg = pool-&gt;task_queue[pool-&gt;queue_front].arg;</span><br><span class="line"></span><br><span class="line">        pool-&gt;queue_front = (pool-&gt;queue_front + <span class="number">1</span>) % pool-&gt;queue_max_size; <span class="comment">//出队 模拟环形队列</span></span><br><span class="line">        pool-&gt;queue_size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通知可以有新任务添加进来 */</span></span><br><span class="line">        pthread_cond_broadcast(&amp;(pool-&gt;queue_not_full));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 任务取出后，立即将线程池锁 释放 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 执行任务 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x start working\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter)); <span class="comment">// 忙状态线程数变量锁</span></span><br><span class="line">        pool-&gt;busy_thr_num++;                        <span class="comment">// 忙状态线程数+1</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));  </span><br><span class="line">        (*(task.function))(task.arg);               <span class="comment">// 执行回调函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 任务结束处理 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x end working\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pool-&gt;busy_thr_num--;                       <span class="comment">// 处理掉一个任务，忙状态线程数-1 </span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadpool_free</span><span class="params">(<span class="keyword">threadpool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;task_queue) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;task_queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;threads) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;threads);</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">        pthread_mutex_destroy(&amp;(pool-&gt;lock));</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pthread_mutex_destroy(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pthread_cond_destroy(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">        pthread_cond_destroy(&amp;(pool-&gt;queue_not_full));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1  <span class="comment">// 测试代码</span></span></span><br><span class="line"><span class="comment">/* 线程池中的线程，模拟处理业务 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">process</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x working on task %d\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self(), *(<span class="keyword">int</span> *)arg);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;task %d is end\n&quot;</span>, *(<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">threadpool_t</span> *thp = threadpool_create(<span class="number">3</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">// 创建线程池，池里最小3个线程，最大100，队列最大100</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pool inited&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">20</span>], i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        num[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add task %d\n&quot;</span>, i);</span><br><span class="line">        threadpool_add(thp, process, (<span class="keyword">void</span>*)&amp;num[i]);   <span class="comment">/* 向线程池中添加任务 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">10</span>);      <span class="comment">/* 等子线程完成任务 */</span></span><br><span class="line">    threadpool_destroy(thp);        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="UDP服务器"><a href="#UDP服务器" class="headerlink" title="UDP服务器"></a>UDP服务器</h2><p>传输层主要应用的协议模型有两种，一种是TCP协议，另外一种则是UDP协议。TCP协议在网络通信中占主导地位，绝大多数的网络通信借助TCP协议完成数据传输。但UDP也是网络通信中不可或缺的重要通信手段。</p>
<p>相较于TCP而言，UDP通信的形式更像是发短信。不需要在数据传输之前建立、维护连接。只专心获取数据就好。省去了三次握手的过程，通信速度可以大大提高，但与之伴随的通信的稳定性和正确率便得不到保证。因此，我们称UDP为“无连接的不可靠报文传递”。</p>
<p>那么与我们熟知的TCP相比，UDP有哪些优点和不足呢？由于无需创建连接，所以UDP开销较小，数据传输速度快，实时性较强。多用于对实时性要求较高的通信场合，如视频会议、电话会议等。但随之也伴随着数据传输不可靠，传输数据的正确率、传输顺序和流量都得不到控制和保证。所以，通常情况下，使用UDP协议进行数据传输，为保证数据的正确性，我们需要在应用层添加辅助校验协议来弥补UDP的不足，以达到数据可靠传输的目的。</p>
<p>与TCP类似的，UDP也有可能出现缓冲区被填满后，再接收数据时丢包的现象。由于它没有TCP滑动窗口的机制，通常采用如下两种方法解决：</p>
<p>1) 服务器应用层设计流量控制，控制发送数据速度。</p>
<p>2) 借助setsockopt函数改变接收缓冲区大小。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">220</span>x1024;</span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;n, <span class="keyword">sizeof</span>(n));</span><br></pre></td></tr></table></figure>
<h3 id="C-S模型"><a href="#C-S模型" class="headerlink" title="C/S模型"></a>C/S模型</h3><p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220618141648371.png" alt="image-20220618141648371"></p>
<p>由于UDP不需要维护连接，程序逻辑简单了很多，但是UDP协议是不可靠的，保证通讯可靠性的机制需要在应用层实现。</p>
<p>编译运行server，在两个终端里各开一个client与server交互，看看server是否具有并发服务的能力。用Ctrl+C关闭server，然后再运行server，看此时client还能否和server联系上。和前面TCP程序的运行结果相比较，体会无连接的含义。</p>
<h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> i, n, ret;</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    ret = bind(sockfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accepting connectings ... \n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ, <span class="number">0</span>, (struct sockaddr*)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;recvfrom error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">                inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                ntohs(clie_addr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line"></span><br><span class="line">        n = sendto(sockfd, buf, n, <span class="number">0</span>, (struct sockaddr*)&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;sendto error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">&quot;106.13.232.203&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sockfd, n;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">&quot;sockfd error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr);</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;sendto error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        n = recvfrom(sockfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">//NULL: 不保存对端信息</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;recvfrom error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        write(STDOUT_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>要设置广播权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;flag, <span class="keyword">sizeof</span>(flag)); <span class="comment">//设置广播权限</span></span><br></pre></td></tr></table></figure>
<p>使用<code>ifconfig</code>可以查看广播地址</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220619133706699.png" alt="image-20220619133706699"></p>
<h4 id="server-1"><a href="#server-1" class="headerlink" title="server"></a>server</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BROADCAST_IP <span class="meta-string">&quot;192.168.15.255&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造用于UDP通信的套接字</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;     <span class="comment">// ipv4</span></span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">//本地任意IP</span></span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;flag, <span class="keyword">sizeof</span>(flag)); <span class="comment">//设置广播权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 client 地址 IP+端口</span></span><br><span class="line">    bzero(&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">    clie_addr.sin_family = AF_INET;</span><br><span class="line">    clie_addr.sin_port = htons(CLIENT_PORT);</span><br><span class="line">    inet_pton(AF_INET, BROADCAST_IP, &amp;clie_addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Drink %d glasses of water\n&quot;</span>, ++i);</span><br><span class="line">        <span class="comment">//fgets(buf, sizeof(buf), stdin);</span></span><br><span class="line">        sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr*)&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="client-1"><a href="#client-1" class="headerlink" title="client"></a>client</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">local_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> connfd;</span><br><span class="line">    <span class="keyword">ssize_t</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建socket</span></span><br><span class="line">    connfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化本地端地址</span></span><br><span class="line">    bzero(&amp;local_addr, <span class="keyword">sizeof</span>(local_addr));</span><br><span class="line">    local_addr.sin_family = AF_INET;</span><br><span class="line">    local_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    local_addr.sin_port = htons(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(connfd, (struct sockaddr*)&amp;local_addr, <span class="keyword">sizeof</span>(local_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;...bind ok ...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        len = recvfrom(connfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多播-组播"><a href="#多播-组播" class="headerlink" title="多播/组播"></a>多播/组播</h3><p>组播组可以是永久的也可以是临时的。组播组地址中，有一部分由官方分配的，称为永久组播组。永久组播组保持不变的是它的ip地址，组中的成员构成可以发生变化。永久组播组中成员的数量都可以是任意的，甚至可以为零。那些没有保留下来供永久组播组使用的ip组播地址，可以被临时组播组利用。</p>
<p><code>224.0.0.0～224.0.0.255</code>        为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；</p>
<p><code>224.0.1.0～224.0.1.255</code>        是公用组播地址，可以用于Internet；欲使用需申请。</p>
<p><code>224.0.2.0～238.255.255.255</code>    为用户可用的组播地址（临时组地址），全网范围内有效；</p>
<p><code>239.0.0.0～239.255.255.255</code>    为本地管理组播地址，仅在特定的本地范围内有效。</p>
<p>可使用<code>ip address</code>或<code>ip ad</code>命令查看网卡编号，如：</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220619134050224.png" alt="image-20220619134050224"></p>
<p><code>if_nametoindex</code>函数可以根据网卡名，获取网卡序号。</p>
<p>获取组播权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">&quot;239.0.0.2&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span></span><br><span class="line">inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);        <span class="comment">/* 设置组地址 */</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;group.imr_address);      <span class="comment">/* 本地任意IP */</span></span><br><span class="line">group.imr_ifindex = if_nametoindex(<span class="string">&quot;eth0&quot;</span>);             <span class="comment">/* 给出网卡名,转换为对应编号: eth0 --&gt; 编号  命令:ip ad */</span></span><br><span class="line">setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_IF, &amp;group, <span class="keyword">sizeof</span>(group));  <span class="comment">/* 组播权限 */</span></span><br></pre></td></tr></table></figure>
<p>加入多播组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(connfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, <span class="keyword">sizeof</span>(group)); <span class="comment">//加入多播组</span></span><br></pre></td></tr></table></figure>
<h4 id="server-2"><a href="#server-2" class="headerlink" title="server"></a>server</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">&quot;239.0.0.2&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ] = <span class="string">&quot;itcast\n&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span></span><br><span class="line">    </span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);    <span class="comment">//构造用于UDP通信的套接字</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);    <span class="comment">// 设置组地址</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;group.imr_address);  <span class="comment">// 本地任意IP</span></span><br><span class="line">    group.imr_ifindex = if_nametoindex(<span class="string">&quot;eth0&quot;</span>);         <span class="comment">// 给出网卡名，获取为对应编号</span></span><br><span class="line"></span><br><span class="line">    setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_IF, &amp;group, <span class="keyword">sizeof</span>(group)); <span class="comment">//设置组播权限</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">    clie_addr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, GROUP, &amp;clie_addr.sin_addr);</span><br><span class="line">    clie_addr.sin_port = htons(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;itcast %d\n&quot;</span>, ++i);</span><br><span class="line">        <span class="comment">//fgets(buf, sizeof(buf), stdin);</span></span><br><span class="line">        sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr*)&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="client-2"><a href="#client-2" class="headerlink" title="client"></a>client</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">&quot;239.0.0.2&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">local_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> connfd;</span><br><span class="line">    <span class="keyword">ssize_t</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span></span><br><span class="line"></span><br><span class="line">    connfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;local_addr, <span class="keyword">sizeof</span>(local_addr));</span><br><span class="line">    local_addr.sin_family = AF_INET;</span><br><span class="line">    local_addr.sin_port = htons(CLIENT_PORT);</span><br><span class="line">    local_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    bind(connfd, (struct sockaddr*)&amp;local_addr, <span class="keyword">sizeof</span>(local_addr));</span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;group.imr_address);</span><br><span class="line">    group.imr_ifindex = if_nametoindex(<span class="string">&quot;eth0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    setsockopt(connfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, <span class="keyword">sizeof</span>(group)); <span class="comment">//加入多播组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        len = recvfrom(connfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h2><p>socket API原本是为网络通讯设计的，但后来在socket的框架上发展出一种IPC机制，就是UNIX Domain Socket。虽然网络socket也可用于同一台主机的进程间通讯（通过loopback地址127.0.0.1），但是UNIX Domain Socket用于IPC更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。UNIX Domain Socket也提供<strong>面向流</strong>和<strong>面向数据包</strong>两种API接口，类似于TCP和UDP，但是面向消息的UNIX Domain Socket也是可靠的，消息既不会丢失也不会顺序错乱。</p>
<p>UNIX Domain Socket是全双工的，API接口语义丰富，相比其它IPC机制有明显的优越性，目前已成为使用最广泛的IPC机制，比如X Window服务器和GUI程序之间就是通过UNIX Domain Socket通讯的。</p>
<p>使用UNIX Domain Socket的过程和网络socket十分相似，也要先调用socket()创建一个socket文件描述符，address family指定为AF_UNIX，type可以选择SOCK_DGRAM或SOCK_STREAM，protocol参数仍然指定为0即可。</p>
<p>UNIX Domain Socket与网络socket编程最明显的不同在于地址格式不同，用结构体<code>sockaddr_un</code>表示，网络编程的socket地址是IP地址加端口号，而UNIX Domain Socket的地址是一个socket类型的文件在文件系统中的路径，这个socket文件由bind()调用创建，如果调用bind()时该文件已存在，则bind()错误返回。</p>
<p>对比网络套接字地址结构和本地套接字地址结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">__kernel_sa_family_t</span> sin_family; <span class="comment">/*Address family*/</span></span><br><span class="line">    __be16 sin_port;		<span class="comment">/* Port number */</span>		</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/*Internet address */</span>	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span>  <span class="comment">// 头文件 &lt;sys/un.h&gt;</span></span><br><span class="line">	<span class="keyword">__kernel_sa_family_t</span> sun_family; <span class="comment">/*AF_UNIX*/</span></span><br><span class="line">	<span class="keyword">char</span> sun_path[UNIX_PATH_MAX]; <span class="comment">/* pathname */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以下程序将UNIX Domain socket绑定到一个地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(un.sun_path);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(type, member) ((int)&amp;((type *)0)-&gt;MEMBER)  <span class="comment">// offsetof获取 member在结构体type中的偏移量</span></span></span><br></pre></td></tr></table></figure>
<h3 id="server-3"><a href="#server-3" class="headerlink" title="server"></a>server</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_ADDR  <span class="meta-string">&quot;serv.socket&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd, cfd, len, size, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    lfd = Socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path,SERV_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);     <span class="comment">/* servaddr total len */</span></span><br><span class="line"></span><br><span class="line">    unlink(SERV_ADDR);                              <span class="comment">/* 确保bind之前serv.sock文件不存在,bind会创建该文件 */</span></span><br><span class="line">    Bind(lfd, (struct sockaddr *)&amp;servaddr, len);           <span class="comment">/* 参3不能是sizeof(servaddr) */</span></span><br><span class="line"></span><br><span class="line">    Listen(lfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accept ...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        cfd = Accept(lfd, (struct sockaddr *)&amp;cliaddr, (<span class="keyword">socklen_t</span> *)&amp;len);</span><br><span class="line"></span><br><span class="line">        len -= offsetof(struct sockaddr_un, sun_path);      <span class="comment">/* 得到文件名的长度 */</span></span><br><span class="line">        cliaddr.sun_path[len] = <span class="string">&#x27;\0&#x27;</span>;                       <span class="comment">/* 确保打印时,没有乱码出现 */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client bind filename %s\n&quot;</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((size = read(cfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">            write(cfd, buf, size);</span><br><span class="line">        &#125;</span><br><span class="line">        close(cfd);</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="client-3"><a href="#client-3" class="headerlink" title="client"></a>client</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_ADDR <span class="meta-string">&quot;serv.socket&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIE_ADDR <span class="meta-string">&quot;clie.socket&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  cfd, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    cfd = Socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    cliaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(cliaddr.sun_path,CLIE_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(cliaddr.sun_path);     <span class="comment">/* 计算客户端地址结构有效长度 */</span></span><br><span class="line"></span><br><span class="line">    unlink(CLIE_ADDR);</span><br><span class="line">    Bind(cfd, (struct sockaddr *)&amp;cliaddr, len);                                 <span class="comment">/* 客户端也需要bind, 不能依赖自动绑定*/</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));                                          <span class="comment">/* 构造server 地址 */</span></span><br><span class="line">    servaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path,SERV_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);   <span class="comment">/* 计算服务器端地址结构有效长度 */</span></span><br><span class="line"></span><br><span class="line">    Connect(cfd, (struct sockaddr *)&amp;servaddr, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        write(cfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      
      
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">高并发服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">多进程并发服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.2.</span> <span class="nav-text">多线程并发服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.3.</span> <span class="nav-text">多路I&#x2F;O转接服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#select%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">select实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#select%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">select函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">使用流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pselect%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">pselect函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poll%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.2.</span> <span class="nav-text">poll实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#poll%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">poll函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">使用示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ppoll%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">ppoll函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.3.</span> <span class="nav-text">epoll实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80API"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">基础API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">使用示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll%E8%BF%9B%E9%98%B6"><span class="nav-number">1.4.</span> <span class="nav-text">epoll进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.4.1.</span> <span class="nav-text">事件模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ET%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">ET模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LT%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">LT模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.4.2.</span> <span class="nav-text">管道示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-S%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.4.3.</span> <span class="nav-text">C&#x2F;S示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%AF%BB%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.4.4.</span> <span class="nav-text">非阻塞读示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.4.5.</span> <span class="nav-text">反应堆模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.5.</span> <span class="nav-text">线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">UDP服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-S%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">C&#x2F;S模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#server"><span class="nav-number">2.1.1.</span> <span class="nav-text">server</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#client"><span class="nav-number">2.1.2.</span> <span class="nav-text">client</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD"><span class="nav-number">2.2.</span> <span class="nav-text">广播</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#server-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">server</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#client-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">client</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%92%AD-%E7%BB%84%E6%92%AD"><span class="nav-number">2.3.</span> <span class="nav-text">多播&#x2F;组播</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#server-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">server</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#client-2"><span class="nav-number">2.3.2.</span> <span class="nav-text">client</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">3.</span> <span class="nav-text">本地套接字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#server-3"><span class="nav-number">3.1.</span> <span class="nav-text">server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#client-3"><span class="nav-number">3.2.</span> <span class="nav-text">client</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yanglinqi"
      src="/images/headpic.jpg">
  <p class="site-author-name" itemprop="name">yanglinqi</p>
  <div class="site-description" itemprop="description">用于做笔记，对学过的知识总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">100</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yanglinqi107" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanglinqi107" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yanglinqi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


  <script async src="/js/cursor/fireworks.js"></script>


</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="referer" content="never">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yanglinqi107.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="linux中pthread_join()与pthread_detach()详解_魏波-的博客-CSDN博客_pthread_detach   pthread_join()和pthread_detach()二者的区别_modi000的博客-CSDN博客">
<meta property="og:type" content="article">
<meta property="og:title" content="线程">
<meta property="og:url" content="http://yanglinqi107.github.io/Linux/Linux%E7%BC%96%E7%A8%8B/04%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="杨记">
<meta property="og:description" content="linux中pthread_join()与pthread_detach()详解_魏波-的博客-CSDN博客_pthread_detach   pthread_join()和pthread_detach()二者的区别_modi000的博客-CSDN博客">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/wps1.jpg">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608181620634.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608181050880.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409142558448.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220412170357636.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608225635395.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608230509650.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608231551583.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609101307247.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609142823616.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609153152276.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609164540216.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609165000944.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609155347698.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609191236028.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609192440859.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409153932168.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409154622468.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409160816138.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609230838624.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220610112336201.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220610143129783.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409165937723.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220610170438272.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220610205703709.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220610212537547.png">
<meta property="article:published_time" content="2022-06-05T07:33:13.065Z">
<meta property="article:modified_time" content="2022-07-27T15:44:10.007Z">
<meta property="article:author" content="yanglinqi">
<meta property="article:tag" content="Linux编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/wps1.jpg">

<link rel="canonical" href="http://yanglinqi107.github.io/Linux/Linux%E7%BC%96%E7%A8%8B/04%E7%BA%BF%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>线程 | 杨记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杨记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">碎片化学习令人焦虑，系统化学习使人进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">98</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yanglinqi107.github.io/Linux/Linux%E7%BC%96%E7%A8%8B/04%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headpic.jpg">
      <meta itemprop="name" content="yanglinqi">
      <meta itemprop="description" content="用于做笔记，对学过的知识总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          线程
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-05 15:33:13" itemprop="dateCreated datePublished" datetime="2022-06-05T15:33:13+08:00">2022-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-27 23:44:10" itemprop="dateModified" datetime="2022-07-27T23:44:10+08:00">2022-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Linux%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Linux编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weibo1230123/article/details/81410241">linux中pthread_join()与pthread_detach()详解_魏波-的博客-CSDN博客_pthread_detach</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/modi000/article/details/108345917">pthread_join()和pthread_detach()二者的区别_modi000的博客-CSDN博客</a></p>
<span id="more"></span>
<h2 id="NPTL"><a href="#NPTL" class="headerlink" title="NPTL"></a>NPTL</h2><ol>
<li><p>察看当前pthread库版本<code>getconf GNU_LIBPTHREAD_VERSION</code></p>
</li>
<li><p>NPTL实现机制(POSIX)，Native POSIX Thread Library</p>
</li>
<li><p>使用线程库时gcc指定 <code>–lpthread</code></p>
</li>
<li>查看线程函数列表<code>man -k pthread</code>，不存在则安装线程man page：<code>sudo apt-get install manpages-posix-dev</code> </li>
</ol>
<h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p><strong>进程</strong>的概念体现出两个特点：<strong>资源</strong>（代码和数据空间、打开的文件等）以及<strong>调度/执行</strong>。</p>
<p><strong>线程</strong>是进程内的独立执行代码的实体和<strong>调度</strong>单元</p>
<p>一个<strong>进程内的所有线程共享进程的很多资源</strong>（这种共享又带来了同步问题）</p>
<h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p><code>LWP</code>：<code>light weight process</code>轻量级的进程，本质仍是进程（在Linux环境下）</p>
<p>进程：独立地址空间，拥有PCB</p>
<p>线程：也有PCB，但没有独立的地址空间(共享)</p>
<p>区别：在于是否共享地址空间。    独居(进程)；合租(线程)。</p>
<p>Linux下：    </p>
<ul>
<li>线程：最小的执行单位</li>
<li>进程：最小分配资源单位，可看成是只有一个线程的进程。</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/wps1.jpg" alt="img"></p>
<p>​    </p>
<h3 id="Linux线程实现原理"><a href="#Linux线程实现原理" class="headerlink" title="Linux线程实现原理"></a>Linux线程实现原理</h3><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</p>
<ol>
<li><p>轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</p>
</li>
<li><p>从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</p>
</li>
<li><p>进程可以蜕变成线程</p>
</li>
<li><p>线程可看做寄存器和栈的集合</p>
</li>
<li><p>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</p>
</li>
</ol>
<p>察看<code>LWP</code>号：<code>ps –Lf pid</code> 查看指定进程里面的所有<code>lwp</code>号（和线程ID不同）</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608181620634.png" alt="image-20220608181620634"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608181050880.png" alt="image-20220608181050880"></p>
<p>三级映射：进程PCB —&gt; 页目录(可看成数组，首地址位于PCB中) —&gt; 页表 —&gt; 物理页面 —&gt; 内存单元</p>
<p>对于进程来说，相同的地址（同一个虚拟地址）在不同的进程中，反复使用而不冲突。原因是他们虽虚拟址一样，但，页目录、页表、物理页面各不相同。相同的虚拟址，映射到不同的物理页面内存单元，最终访问不同的物理页面。</p>
<p>但！线程不同！两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。</p>
<p>实际上，无论是创建进程的<code>fork</code>，还是创建线程的<code>pthread_create</code>，底层实现都是调用同一个内核函数<code>clone</code>。</p>
<p>如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。</p>
<p>因此：Linux内核是不区分进程和线程的。只在用户层面上进行区分。所以，线程所有操作函数 <code>pthread_*</code> 是库函数，而非系统调用。</p>
<h3 id="线程间共享"><a href="#线程间共享" class="headerlink" title="线程间共享"></a>线程间共享</h3><p><strong>线程间共享</strong></p>
<ul>
<li>进程指令 </li>
<li>内存地址空间（.text/.data/.bss/heap/共享库）</li>
<li>文件描述符表</li>
<li>信号处理程序 </li>
<li>当前工作目录 </li>
<li>用户ID和组ID</li>
</ul>
<p><strong>线程私有</strong></p>
<ul>
<li>线程ID</li>
<li>寄存器集合（包括PC和栈指针）</li>
<li>栈（用于存放局部变量）</li>
<li><code>errno</code>变量</li>
<li>信号掩码</li>
<li>调度优先级</li>
</ul>
<h3 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h3><p>优点：    1. 提高程序并发性    2. 开销小    3. 数据通信、共享数据方便</p>
<p>缺点：    1. 库函数，不稳定    2. 调试、编写困难、gdb不支持    3. 对信号支持不好</p>
<p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p>
<h3 id="线程与进程对比"><a href="#线程与进程对比" class="headerlink" title="线程与进程对比"></a>线程与进程对比</h3><p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409142558448.png" alt="image-20220409142558448"></p>
<ul>
<li>线程只拥有少量在运行中必不可少的资源<ul>
<li>PC指针：标识当前线程执行的位置</li>
<li>寄存器：当前线程执行的上下文环境</li>
<li>栈：用于实现函数调用、局部变量（局部变量是私有的）</li>
</ul>
</li>
<li>进程占用资源多，线程占用资源少，使用灵活</li>
<li>线程不能脱离进程而存在，线程的层次关系，执行顺序并不明显，会增加程序的复杂度</li>
<li>没有通过代码显示创建线程的进程，可以看成是只有一个线程的进程</li>
</ul>
<p><strong>控制原语对比</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>控制操作</th>
<th>进程操作API</th>
<th>线程操作API</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建</td>
<td><code>fork</code>,<code>vfork</code></td>
<td><code>pthread_create</code></td>
</tr>
<tr>
<td>终止</td>
<td><code>exit</code></td>
<td><code>pthread_exit</code></td>
</tr>
<tr>
<td>等待</td>
<td><code>wait</code>、<code>waitpid</code></td>
<td><code>pthread_join</code></td>
</tr>
<tr>
<td>读取ID</td>
<td><code>getpid</code></td>
<td><code>pthread_self</code></td>
</tr>
<tr>
<td>杀死</td>
<td><code>kill</code></td>
<td><code>pthread_cancel</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="线程ID"><a href="#线程ID" class="headerlink" title="线程ID"></a>线程ID</h3><p>同进程一样，每个线程也有一个线程ID</p>
<p>进程ID在整个系统中是唯一的，<strong>线程ID只在它所属的进程环境中唯一</strong></p>
<p>线程ID的类型是<code>pthread_t</code>，在Linux中的定义：<code>/usr/include/bits/pthreadtypes.h</code>（实际位置可能有变化）</p>
<ul>
<li><code>typedef unsigned long int pthread_t</code></li>
</ul>
<p>线程ID是用来区分线程的，线程号是用来分配资源。</p>
<h3 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h3><p>线程创建后等待系统调度，被调度后从线程启动例程函数</p>
<p>一次性创建多个线程，调度顺序与创建顺序无关</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220412170357636.png" alt="image-20220412170357636"></p>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p>线程的三种终止方式</p>
<ul>
<li>线程从启动例程函数中返回，函数返回值作为线程的退出码</li>
<li>线程被同一进程中的其他线程取消</li>
<li>线程在任意函数中调用<code>pthread_exit</code>函数终止执行</li>
</ul>
<h2 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h2><p>获取线程ID：<code>pthread_self()</code></p>
<p>创建线程：<code>pthread_create()</code></p>
<p>线程退出：<code>pthread_exit()</code></p>
<p>等待线程并回收：<code>pthread_join()</code></p>
<p>终止线程：<code>pthread_cancel()</code></p>
<p>分离线程：<code>pthread_detach()</code></p>
<p>判断两个线程ID是否相等：<code>int pthread_equal(pthread_t t1, pthread_t t2);</code> （目前没啥用，可以直接<code>t1 == t2</code>）</p>
<h3 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h3><p><code>man 3 pthread_self</code> </p>
<p><code>pthread_self</code>函数可以让调用线程获取自己的线程ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值：调用线程的线程ID</p>
<p>线程ID：<code>`pthread_t</code>类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现</p>
<p>线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同)</p>
<p>注意：不应使用全局变量 <code>pthread_t tid</code>，在子线程中通过<code>pthread_create</code>传出参数来获取线程ID，而应使用<code>pthread_self</code>。</p>
<h3 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h3><p><code>man 3 pthread_create</code> </p>
<p><code>pthread_create</code>函数用于创建一个线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">void</span> *(*start_rtn)(<span class="keyword">void</span> *), </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用<code>pthread_create</code>函数的线程是所创建线程的父线程</p>
<p>参数：</p>
<ul>
<li><code>thread</code>：指向线程ID的指针，当函数成功返回时将存储所创建的子线程ID</li>
<li><code>attr</code>：用于指定线程属性（一般直接传入空指针NULL，采用默认线程属性）</li>
<li><code>start_rtn</code>：线程的<strong>启动例程函数</strong>（类似进程的main函数入口）指针，创建的线程首先执行该函数代码（可以调用其他函数）</li>
<li><code>arg</code>：向线程的启动例程函数传递信息的参数</li>
</ul>
<p>返回值：成功返回0，出错时返回各种错误码（Linux环境下，所有线程特点，失败均直接返回错误号。）</p>
<p>在一个线程中调用<code>pthread_create()</code>创建新的线程后，当前线程从<code>pthread_create()</code>返回继续往下执行，而新的线程所执行的代码由我们传给<code>pthread_create</code>的函数指针<code>start_routine</code>决定。<code>start_routine</code>函数接收一个参数，是通过<code>pthread_create</code>的<code>arg</code>参数传递给它的，该参数的类型为<code>void *</code>，这个指针按什么类型解释由调用者自己定义。<code>start_routine</code>的返回值类型也是<code>void *</code>，这个指针的含义同样由调用者自己定义。<code>start_routine</code>返回时，这个线程就退出了，其它线程可以调用<code>pthread_join</code>得到<code>start_routine</code>的返回值，类似于父进程调用<code>wait(2)</code>得到子进程的退出状态。</p>
<p><code>pthread_create</code>成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用<code>getpid(2)</code>可以获得当前进程的id，是一个正整数值。线程id的类型是<code>thread_t</code>，它只在当前进程中保证是唯一的，在不同的系统中<code>thread_t</code>这个类型有不同的实现，它<strong>可能是一个整数值，也可能是一个结构体，也可能是一个地址</strong>，所以不能简单地当成整数用printf打印，调用<code>pthread_self(3)</code>可以获得当前线程的id。</p>
<p><code>attr</code>参数表示线程属性，一般传NULL给attr参数，表示线程属性取缺省值。深入了解参考APUE。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="创建一个子线程"><a href="#创建一个子线程" class="headerlink" title="创建一个子线程"></a>创建一个子线程</h4><p>用法和进程创建子进程类似。</p>
<p>不同：进程结束（main函数return或exit），子线程不会继续执行，所以要等子线程执行完。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In thread: thread id = %u, pid = %u\n&quot;</span>, pthread_self(), getpid());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In main: thread id = %u, pid = %u\n&quot;</span>, pthread_self(), getpid());</span><br><span class="line">	ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sleep(<span class="number">1</span>); <span class="comment">// 去掉之后子线程可能没有输出</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In main: thread id = %u, pid = %u\n&quot;</span>, pthread_self(), getpid());</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建N个子线程"><a href="#创建N个子线程" class="headerlink" title="创建N个子线程"></a>创建N个子线程</h4><p>创建5个线程，每个线程打印自己的序号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int i = *((int*)arg); // 传地址</span></span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;	<span class="comment">// 传值</span></span><br><span class="line">    sleep(i); <span class="comment">// 使子线程按顺序打印输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%dth thread: thread id = %u, pid = %u\n&quot;</span>, i+<span class="number">1</span>, pthread_self(), getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In main: thread id = %u, pid = %u\n&quot;</span>, pthread_self(), getpid());</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//ret = pthread_create(&amp;tid[i], NULL, thrd_func, (void*)&amp;i); // 传地址</span></span><br><span class="line">        ret = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thrd_func, (<span class="keyword">void</span>*)i); <span class="comment">// 传值</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">5</span>); <span class="comment">// 休眠5秒，等待子线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In main: thread id = %u, pid = %u\n&quot;</span>, pthread_self(), getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意代码中两种给子线程传参的方式：</p>
<p>1）<strong>传值</strong>：子线程按顺序输出</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608225635395.png" alt="image-20220608225635395"></p>
<p>会有警告<code>warning: cast from pointer to integer of different size [-Wpointer-to-int-cast]</code>。</p>
<p>因为将<code>int</code>强制转换为<code>void*</code>，再将<code>void*</code>强制转换为<code>int</code></p>
<p>32位系统下指针大小为4字节，64位是8字节。<code>int</code>大小为4字节。<code>int</code>强制转换为<code>void*</code>，高位补0。<code>void*</code>再转回<code>int</code>，取低位。</p>
<p>2）<strong>传地址</strong>：出问题</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608230509650.png" alt="image-20220608230509650"></p>
<p>现象：第一次5个子线程都没有输出。第二次注释子进程中的睡眠，5个子线程输出<code>6th</code>，不合预期</p>
<p>原因：主线程循环5次创建5个子线程，i变为5，执行<code>sleep</code>，让出cpu。传地址后，子线程访问的<code>i</code>就不是预期的<code>0、1、2、3、4</code>，而是<code>5</code>，各自加1输出了<code>6th</code>。子线程不去掉<code>sleep</code>时，睡眠时间比主线程长，主线程结束后，整个进程结束，子线程没来得及输出。</p>
<h4 id="线程共享全局变量"><a href="#线程共享全局变量" class="headerlink" title="线程共享全局变量"></a>线程共享全局变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	var = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;At first var = %d\n&quot;</span>, var);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;after pthread_create, var = %d\n&quot;</span>, var);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220608231551583.png" alt="image-20220608231551583"></p>
<h3 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h3><p><code>man 3 pthread_exit</code> </p>
<p>作用：退出当前线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>retval</code> 该指针将参数传递给<code>pthread_join</code>函数（与<code>exit</code>函数参数用法类似）</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">func1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In thread child: thread id = %u, pid = %u\n&quot;</span>, pthread_self(), getpid());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In thread: thread id = %u, pid = %u\n&quot;</span>, pthread_self(), getpid());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	</span><br><span class="line">	ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, func1, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In main: thread id = %u, pid = %u\n&quot;</span>, pthread_self(), getpid());</span><br><span class="line">	ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In main: thread id = %u, pid = %u\n&quot;</span>, pthread_self(), getpid());</span><br><span class="line">	</span><br><span class="line">	pthread_exit((<span class="keyword">void</span>*)<span class="number">1</span>);  <span class="comment">//退出主控线程</span></span><br><span class="line">    <span class="comment">// return 0; // 退出进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609101307247.png" alt="image-20220609101307247"></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>多线程环境中，应尽量少用，或者不使用<code>exit</code>函数，取而代之使用<code>pthread_exit</code>函数，将单个线程退出。任何线程里<code>exit</code>导致进程退出，其他线程未工作结束，主控线程退出时不能<code>return</code>或<code>exit</code>。</p>
<p>另注意，<code>pthread_exit</code>或者<code>return</code>返回的指针所指向的内存单元必须是全局的或者是用<code>malloc</code>分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。</p>
<ul>
<li><code>return</code>：返回到调用者那里去</li>
<li><code>pthread_exit()</code>：将调用该函数的线程退出</li>
<li><code>exit</code>: 将进程退出</li>
</ul>
<h3 id="phread-join函数"><a href="#phread-join函数" class="headerlink" title="phread_join函数"></a>phread_join函数</h3><p><code>man 3 pthread_join</code> </p>
<p>阻塞等待线程退出，获取线程退出状态。（对应进程中 waitpid() 函数）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用该函数的父线程将一直被阻塞，直到指定的子线程终止</p>
<p>返回值：成功返回0，否则返回错误编号</p>
<p>参数：</p>
<ul>
<li><code>thread</code>：需要等待的子线程ID</li>
<li><code>retval</code>：线程返回值<ul>
<li>若线程从启动例程返回<code>return</code>，<code>retval</code>将包含返回码</li>
<li>若线程被取消<code>pthread_cancel</code>，<code>retval</code>指向的内存单元值置为<code>PTHREAD_CANCELED</code></li>
<li>若线程通过调用<code>pthread_exit</code>函数终止，<code>retval</code>就是调用<code>pthread_exit</code>时传入的参数</li>
<li>若不关心线程返回值，可直接将该参数设置为空指针<code>NULL</code></li>
</ul>
</li>
</ul>
<h4 id="结构体示例"><a href="#结构体示例" class="headerlink" title="结构体示例"></a>结构体示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch; </span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">64</span>];</span><br><span class="line">&#125; <span class="keyword">exit_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">exit_t</span> *retvar = (<span class="keyword">exit_t</span>*)arg;</span><br><span class="line"></span><br><span class="line">    retvar-&gt;ch = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">    retvar-&gt;var = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(retvar-&gt;str, <span class="string">&quot;my thread\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)retvar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">exit_t</span> *retval = (<span class="keyword">exit_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">exit_t</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In main : thread id=%lu, pid=%u\n&quot;</span>, pthread_self(), getpid());</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, (<span class="keyword">void</span>*)retval);</span><br><span class="line">    pthread_join(tid, (<span class="keyword">void</span>**)&amp;retval);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c, var = %d, str = %s\n&quot;</span>, retval-&gt;ch, retval-&gt;var, retval-&gt;str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(retval);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609142823616.png" alt="image-20220609142823616"></p>
<h4 id="回收N个线程"><a href="#回收N个线程" class="headerlink" title="回收N个线程"></a>回收N个线程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i = (<span class="keyword">int</span>)arg;</span><br><span class="line"></span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">        var = <span class="number">333</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;var = %d\n&quot;</span>, var);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)var;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        var = <span class="number">777</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m %dth pthread, pthread_id = %lu\n var = %d\n&quot;</span>, i+<span class="number">1</span>, pthread_self(), var);</span><br><span class="line">        pthread_exit((<span class="keyword">void</span>*)var);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m %dth pthread, pthread_id = %lu\n var = %d\n&quot;</span>, i+<span class="number">1</span>, pthread_self(), var);</span><br><span class="line">        pthread_exit((<span class="keyword">void</span>*)var);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *ret[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, tfn, (<span class="keyword">void</span>*)i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], (<span class="keyword">void</span>**)&amp;ret[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----------%d is ret = %d\n&quot;</span>, i, (<span class="keyword">int</span>)ret[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m main pthread tid = %lu\t var = %d\n&quot;</span>, pthread_self(), var);</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609153152276.png" alt="image-20220609153152276"></p>
<h3 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h3><p><code>man 3 pthread_cancel</code> </p>
<p>线程调用该函数可以取消同一进程中的其他线程（即让该线程终止）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数：<code>tid</code> 需要取消的线程ID</p>
<p>返回值：成功返回0，出错返回错误编号</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>在默认情况下，<code>pthread_cancel</code>函数与被取消线程（ID等于tid的线程）自身调用<code>pthread_exit</code>函数（参数为<code>PTHREAD_CANCELED</code>）效果等同</li>
<li>线程可以选择忽略取消方式或者控制取消方式</li>
<li><code>pthread_cancel</code>并不等待线程终止，它仅仅是提出请求</li>
</ul>
<p>【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点（检查点）。</p>
<p><strong>取消点</strong>：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用<code>creat,open,pause,close,read,write</code>等，执行命令<code>man 7 pthreads</code>可以查看具备这些取消点的系统调用列表。也可参阅 APUE.12.7 取消选项小节。</p>
<p>如线程中没有取消点，可以通过调用<code>pthread_testcancel</code>函数自行设置一个取消点。</p>
<p>被取消的线程，退出值定义在Linux的<code>pthread</code>库中。常数<code>PTHREAD_CANCELED</code>的值是<code>-1</code>。可在头文件<code>pthread.h</code>中找到它的定义：<code>#define PTHREAD_CANCELED ((void *) -1)</code>。因此当我们对一个已经被取消的线程使用<code>pthread_join</code>回收时，得到的返回值为-1。</p>
<h4 id="取消点示例"><a href="#取消点示例" class="headerlink" title="取消点示例"></a>取消点示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 1 returning\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 2 : I&#x27;m going to die in 3 seconds ... \n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pthread_testcancel(); // 添加取消点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">666</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">void</span> *tret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid, &amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 1 exit code = %d\n\n&quot;</span>, (<span class="keyword">int</span>)tret);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn2, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid, &amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 2 exit code = %d\n&quot;</span>, (<span class="keyword">int</span>)tret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609164540216.png" alt="image-20220609164540216"></p>
<p>将<code>tfn2</code>中的<code>while</code>中的语句注释掉，即第2个子线程一直运行但不涉及系统调用。第2 个子线程不会终止，主线程会一直阻塞等待</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609165000944.png" alt="image-20220609165000944"></p>
<h3 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h3><p><code>man 3 pthread_detach</code> </p>
<p>作用：实现线程分离</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值：成功：0；失败：错误号</p>
<p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</p>
<p>进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。</p>
<p>也可使用 <code>pthread_create</code>函数参2(线程属性)来设置线程分离。</p>
<p>特点：</p>
<ul>
<li>使用<code>pthread_detach</code>函数后，使线程处于分离态；</li>
<li>使用<code>pthread_detach</code>函数后，线程在退出后，会自己<strong>清理资源</strong></li>
<li>相较<code>pthread_join</code>,使用<code>pthread_detach</code>函数<strong>不会阻塞主线程</strong>，但是无法获取线程的返回值。</li>
<li><strong>pthread_detach使用时，依然需要配合sleep函数或者while(1);，否则无法保证子线程先于主线程执行完，且不能再pthread_join回收该线程</strong></li>
</ul>
<p><strong>示例</strong>：线程分离后，不能使用<code>pthread_join</code>回收</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread count %d\n&quot;</span>, n);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">void</span> *tret;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_attr_t</span> attr;			<span class="comment">/*通过线程属性来设置游离态*/</span></span><br><span class="line">	pthread_attr_init(&amp;attr);</span><br><span class="line">	pthread_attr_setdetachstate(&amp;attr,	PTHREAD_CREATE_DETACHED);</span><br><span class="line">	pthread_create(&amp;tid, &amp;attr, tfn, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_detach(tid);         <span class="comment">//让线程分离  ----自动退出,无系统残留资源</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		err = pthread_join(tid, &amp;tret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------err= %d\n&quot;</span>, err);</span><br><span class="line">		<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;thread_join error: %s\n&quot;</span>, strerror(err));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;thread exit code %d\n&quot;</span>, (<span class="keyword">int</span>)tret);</span><br><span class="line"></span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609155347698.png" alt="image-20220609155347698"></p>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>linux下线程的属性是可以根据实际项目需要，进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。</p>
<p><strong>pthead_attr_t结构体</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> etachstate; 	<span class="comment">//线程的分离状态</span></span><br><span class="line">    <span class="keyword">int</span> schedpolicy; 	<span class="comment">//线程调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">schedparam</span>;</span> 	<span class="comment">//线程的调度参数</span></span><br><span class="line">    <span class="keyword">int</span> inheritsched; 	<span class="comment">//线程的继承性</span></span><br><span class="line">    <span class="keyword">int</span> scope; 			<span class="comment">//线程的作用域</span></span><br><span class="line">    <span class="keyword">size_t</span> guardsize; 	<span class="comment">//线程栈末尾的警戒缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span>	stackaddr_set; 	<span class="comment">//线程的栈设置</span></span><br><span class="line">    <span class="keyword">void</span>* stackaddr; 	<span class="comment">//线程栈的位置</span></span><br><span class="line">    <span class="keyword">size_t</span> stacksize; 	<span class="comment">//线程栈的大小</span></span><br><span class="line">&#125; <span class="keyword">pthread_attr_t</span>; </span><br></pre></td></tr></table></figure>
<p>主要结构体成员：</p>
<ol>
<li><p>线程分离状态</p>
</li>
<li><p>线程栈大小（默认平均分配）</p>
</li>
<li><p>线程栈警戒缓冲区大小（位于栈末尾）  参 APUE.12.3 线程属性</p>
</li>
</ol>
<p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为<code>pthread_attr_init</code>，这个函数必须在<code>pthread_create</code>函数之前调用。之后须用<code>pthread_attr_destroy</code>函数来释放资源。</p>
<p>线程属性主要包括如下属性：</p>
<ul>
<li>作用域（scope）</li>
<li>栈尺寸（stack size）</li>
<li>栈地址（stack address）</li>
<li>优先级（priority）</li>
<li>分离的状态（detached state）</li>
<li>调度策略和参数（scheduling policy and parameters）</li>
</ul>
<p>默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</p>
<h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程属性初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的分离状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的栈地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstack</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *stackaddr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstack</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> **stackaddr, <span class="keyword">size_t</span> *stacksize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的栈大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> *stacksize)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="线程属性初始化"><a href="#线程属性初始化" class="headerlink" title="线程属性初始化"></a>线程属性初始化</h3><p>注意：应先初始化线程属性，再<code>pthread_create</code>创建线程</p>
<p>初始化线程属性：</p>
<p><code>int pthread_attr_init(pthread_attr_t *attr);</code> 成功：0；失败：错误号</p>
<p>销毁线程属性所占用的资源：</p>
<p><code>int pthread_attr_destroy(pthread_attr_t *attr);</code>  成功：0；失败：错误号</p>
<h3 id="线程的分离状态"><a href="#线程的分离状态" class="headerlink" title="线程的分离状态"></a>线程的分离状态</h3><p>线程的分离状态决定一个线程以什么样的方式来终止自己。</p>
<p><strong>非分离状态</strong>：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</p>
<p><strong>分离状态</strong>：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</p>
<p>线程分离状态的函数：</p>
<p>设置线程属性，分离or非分离：</p>
<p><code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code></p>
<p>获取程属性，分离or非分离：</p>
<p><code>int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate);</code> </p>
<p>成功：0；失败：错误号</p>
<p>参数：</p>
<ul>
<li><code>attr</code>：已初始化的线程属性</li>
<li><code>detachstate</code><ul>
<li><code>PTHREAD_CREATE_DETACHED</code>（分离线程）</li>
<li><code>PTHREAD_CREATE_JOINABLE</code>（非分离线程）</li>
</ul>
</li>
</ul>
<p>注意：如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在<code>pthread_create</code>函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用<code>pthread_create</code>的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程的启动历程函数里调用<code>pthread_cond_timedwait</code>函数，让这个线程等待一会儿，留出足够的时间让函数<code>pthread_create</code>返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如<code>wait()</code>之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</p>
<h3 id="线程的栈地址"><a href="#线程的栈地址" class="headerlink" title="线程的栈地址"></a>线程的栈地址</h3><p>POSIX.1定义了两个常量 <code>_POSIX_THREAD_ATTR_STACKADDR</code> 和<code>_POSIX_THREAD_ATTR_STACKSIZE</code>检测系统是否支持栈属性。也可以给<code>sysconf</code>函数传递<code>_SC_THREAD_ATTR_STACKADDR</code>或 <code>_SC_THREAD_ATTR_STACKSIZE</code>来进行检测。</p>
<p>当进程栈地址空间不够用时，指定新建线程使用由malloc分配的空间作为自己的栈空间。通过<code>pthread_attr_setstack</code>和<code>pthread_attr_getstack</code>两个函数分别设置和获取线程的栈地址。</p>
<p><code>int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);</code>  成功：0；失败：错误号</p>
<p><code>int pthread_attr_getstack(pthread_attr_t *attr, void **stackaddr, size_t *stacksize);</code>  成功：0；失败：错误号</p>
<p>参数：    </p>
<ul>
<li><code>attr</code>：指向一个线程属性的指针</li>
<li><code>stackaddr</code>：返回获取的栈地址</li>
<li><code>stacksize</code>：返回获取的栈大小</li>
</ul>
<h3 id="线程的栈大小"><a href="#线程的栈大小" class="headerlink" title="线程的栈大小"></a>线程的栈大小</h3><p>当系统中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用，当线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小。</p>
<p>函数<code>pthread_attr_getstacksize</code>和 <code>pthread_attr_setstacksize</code>提供设置。</p>
<p><code>int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);</code>  成功：0；失败：错误号</p>
<p><code>int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);</code>   成功：0；失败：错误号</p>
<p>参数：</p>
<ul>
<li><code>attr</code>：指向一个线程属性的指针</li>
<li><code>stacksize</code>：返回线程的堆栈大小</li>
</ul>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="分离线程示例"><a href="#分离线程示例" class="headerlink" title="分离线程示例"></a>分离线程示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread count %d\n&quot;</span>, n);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr; <span class="comment">// 通过线程属性来设置游离态</span></span><br><span class="line">    pthread_attr_init(&amp;attr); </span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    pthread_create(&amp;tid, &amp;attr, tfn, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_join(tid, &amp;tret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-----err = %d\n&quot;</span>, err);</span><br><span class="line">        <span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;thread_join error: %s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;thread exit code %d\n&quot;</span>, (<span class="keyword">int</span>)tret);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609191236028.png" alt="image-20220609191236028"></p>
<h4 id="线程数量示例"><a href="#线程数量示例" class="headerlink" title="线程数量示例"></a>线程数量示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// max_pthread.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">int</span> ret, count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(ret));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;---------%d\n&quot;</span>, ++count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609192440859.png" alt="image-20220609192440859"></p>
<h4 id="线程栈示例"><a href="#线程栈示例" class="headerlink" title="线程栈示例"></a>线程栈示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 0x10000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">th_fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">int</span> err, detachstate, i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">	<span class="keyword">size_t</span> stacksize;   <span class="comment">//typedef  size_t  unsigned int </span></span><br><span class="line">	<span class="keyword">void</span> *stackaddr;</span><br><span class="line"></span><br><span class="line">	pthread_attr_init(&amp;attr);		</span><br><span class="line">	pthread_attr_getstack(&amp;attr, &amp;stackaddr, &amp;stacksize);</span><br><span class="line">	pthread_attr_getdetachstate(&amp;attr, &amp;detachstate);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (detachstate == PTHREAD_CREATE_DETACHED)   <span class="comment">//默认是分离态</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread detached\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (detachstate == PTHREAD_CREATE_JOINABLE) <span class="comment">//默认时非分离</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread join\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread un known\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置线程分离属性 */</span></span><br><span class="line">	pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">/* 在堆上申请内存,指定线程栈的起始地址和大小 */</span></span><br><span class="line">		stackaddr = <span class="built_in">malloc</span>(SIZE);</span><br><span class="line">		<span class="keyword">if</span> (stackaddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		stacksize = SIZE;</span><br><span class="line">	 	pthread_attr_setstack(&amp;attr, stackaddr, stacksize);   <span class="comment">//借助线程的属性,修改线程栈空间大小</span></span><br><span class="line"></span><br><span class="line">		err = pthread_create(&amp;tid, &amp;attr, th_fun, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(err));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h2><ol>
<li><p>主线程退出其他线程不退出，主线程应调用pthread_exit</p>
</li>
<li><p>避免僵尸线程</p>
<ol>
<li><code>pthread_join</code> — 回收子线程</li>
<li><code>pthread_detach</code> — 分离线程</li>
<li><code>pthread_create</code>  — 创建时设置分离属性</li>
</ol>
</li>
</ol>
<blockquote>
<p>被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值;</p>
</blockquote>
<ol>
<li><p><code>malloc</code>和<code>mmap</code>申请的内存可以被其他线程释放 </p>
</li>
<li><p>应避免在多线程模型中调用fork，除非马上exec，子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit</p>
</li>
<li><p>信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制</p>
</li>
</ol>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>所谓同步，即同时起步，协调一致。不同的对象，对“同步”的理解方式略有不同。如，设备同步，是指在两个设备之间规定一个共同的时间参考；数据库同步，是指让两个或多个数据库内容保持一致，或者按需要部分保持一致；文件同步，是指让两个或多个文件夹里的文件保持一致。等等</p>
<p>而，编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。“同”字应是指协同、协助、互相配合。主旨在<strong>协同步调，按预定的先后次序运行</strong>。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>同步即协同步调，按预定的先后次序运行。</p>
<p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p>
<p>举例1：银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000</p>
<p>举例2：内存中100字节，线程T1欲填入全1， 线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续    从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。</p>
<p>产生的现象叫做<strong>与时间有关的错误（time related）</strong>。为了避免这种数据混乱，线程需要同步。</p>
<p>“同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。</p>
<p>因此，<strong>所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。</strong></p>
<h3 id="数据混乱原因"><a href="#数据混乱原因" class="headerlink" title="数据混乱原因"></a>数据混乱原因</h3><ol>
<li><p>资源共享（独享资源则不会）    </p>
</li>
<li><p>调度随机（意味着数据访问会出现竞争）    </p>
</li>
<li><p>线程间缺乏必要的同步机制。</p>
</li>
</ol>
<p>以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。</p>
<p>所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p>
<h3 id="任务关系"><a href="#任务关系" class="headerlink" title="任务关系"></a>任务关系</h3><p>Linux系统中多任务（进程/线程）之间的关系</p>
<ul>
<li><strong>独立</strong>：仅竞争CPU资源</li>
<li><strong>互斥</strong>：竞争除CPU外的其他资源</li>
<li><strong>同步</strong>：协调彼此运行的步调，保证协同运行的各个任务具有正确的执行次序</li>
<li><strong>通信</strong>：数据共享，彼此间传递数据或信息，以协同完成某项工作</li>
</ul>
<h3 id="线程数据共享"><a href="#线程数据共享" class="headerlink" title="线程数据共享"></a>线程数据共享</h3><p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409153932168.png" alt="image-20220409153932168" style="zoom:67%;" /></p>
<h3 id="任务互斥问题"><a href="#任务互斥问题" class="headerlink" title="任务互斥问题"></a>任务互斥问题</h3><p><strong>任务互斥—资源共享关系（间接相互制约关系）</strong></p>
<ul>
<li>任务本身之间不存在直接联系。一个任务正在使用某个系统资源，另外一个想用该资源的任务就必须等待，而不能同时使用</li>
</ul>
<p>全局变量存储在进程数据段中，被线程所共享。线程对全局变量的访问，要经历三个步骤</p>
<ol>
<li><p>将内存单元中的数据读入寄存器</p>
</li>
<li><p>对寄存器中的值进行运算</p>
</li>
<li>将寄存器中的值写回内存单元</li>
</ol>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409154622468.png" alt="image-20220409154622468" style="zoom:67%;" /></p>
<p>解决方法：互斥量</p>
<h3 id="任务同步问题"><a href="#任务同步问题" class="headerlink" title="任务同步问题"></a>任务同步问题</h3><p><strong>任务同步—相互合作关系（直接相互制约关系）</strong></p>
<ul>
<li>两个或多个任务为了合作完成同一个工作，在执行速度或某个确定的时序点上必须相互协调，即一个任务的执行必须依赖另一个任务的执行情况</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409160816138.png" alt="image-20220409160816138" style="zoom:50%;" /></p>
<p>程序设计中存在这样的情况：多个线程都要访问临界资源又要相互合作（线程间<strong>同时存在互斥关系和同步关系</strong>）</p>
<p>线程A先执行某操作（例如对全局变量x的修改）后，线程B才能（根据变量x的值判断）执行另一操作<br>（可能是对全局变量x的修改），该如何实现？</p>
<ul>
<li>Linux提供了<strong>条件变量</strong>机制：<strong>条件变量与互斥量一起使用</strong>时，允许线程以互斥的方式阻塞等待特定条件的发生（同步）</li>
</ul>
<p><strong>临界资源</strong>：在一段时间内只允许一个任务（线程或进程）访问的资源。诸任务间应采取互斥方式，实现对资源的共享</p>
<ul>
<li>共享变量，打印机等属于临界资源</li>
<li>访问临界资源的那段代码被称为<strong>临界区</strong></li>
</ul>
<h2 id="线程同步-1"><a href="#线程同步-1" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h3><p><strong>互斥量</strong>确保同一时间里只有一个线程访问临界资源或进入临界区</p>
<p><strong>互斥量（mutex）</strong>本质上是一把锁</p>
<ul>
<li>在访问临界资源前，对互斥量进行加锁</li>
<li>在访问完成后对互斥量解锁</li>
<li>对互斥量加锁后，任何其他试图对互斥量加锁的线程将会被阻塞，直到互斥量被解锁为止</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220609230838624.png" alt="image-20220609230838624"></p>
<p>当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。</p>
<p>所以，互斥锁实质上是操作系统提供的一把<strong>建议锁（又称协同锁）</strong>，建议程序中有多线程访问共享资源的时候使用该机制。但，<strong>并没有强制限定</strong>。</p>
<p>因此，即使有了mutex，<strong>如果有线程不按规则来访问数据，依然会造成数据混乱</strong>。</p>
<h4 id="互斥量的操作"><a href="#互斥量的操作" class="headerlink" title="互斥量的操作"></a>互斥量的操作</h4><p><strong>头文件</strong>：<code>#include &lt;pthread.h&gt;</code> </p>
<ol>
<li>定义互斥量变量： <code>pthread_mutex_t mutex;</code> </li>
<li>初始化互斥量变量：<code>pthread_mutex_init</code>函数</li>
<li>对互斥量加锁：<ul>
<li><code>pthread_mutex_lock</code>函数（阻塞）</li>
<li><code>pthread_mutex_trylock</code>函数（非阻塞）</li>
<li><code>pthread_mutex_timedlock</code>函数（限时加锁）</li>
</ul>
</li>
<li>对互斥量解锁：<code>pthread_mutex_unlock</code>函数</li>
<li>销毁互斥量变量：<code>pthread_mutex_destroy</code>函数</li>
</ol>
<p>以上5个函数的返回值都是：<strong>成功返回0，出错返回错误码</strong>。</p>
<p><code>pthread_mutex_t</code>类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。只有两种取值1、0。</p>
<h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><p>1）<code>pthread_mutex_init</code></p>
<p>作用：<strong>初始化互斥量变量</strong></p>
<p>静态初始化</p>
<ul>
<li><code>pthread_mutex_t mlock = PTHREAD_MUTEX_INITIALIZER;</code></li>
<li>如果互斥锁 mutex 是静态分配的（定义在全局，或加了<code>static</code>关键字修饰），可以直接使用宏进行初始化</li>
</ul>
<p>动态初始化</p>
<ul>
<li><code>int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *attr);</code><ul>
<li><code>mutex</code>：指向互斥量的指针</li>
<li><code>attr</code>：设置互斥量的属性，通常可采用默认属性（线程共享），传入空指针（<code>NULL</code>）。</li>
</ul>
</li>
</ul>
<p><code>restrict</code>关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改</p>
<p>2）<code>pthread_mutex_destroy</code></p>
<p>作用：销毁互斥量</p>
<p>互斥量在使用完毕后，必须要对互斥量进行销毁，以释放资源</p>
<p><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p>
<ul>
<li><code>mutex</code>：即互斥量</li>
</ul>
<p>3）<code>pthread_mutex_lock</code></p>
<p>在对临界资源访问之前，需要对互斥量进行<strong>加锁操作</strong></p>
<p><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code> </p>
<p>当调用<code>pthread_mutex_lock</code>时，若互斥量已被加锁，则调用线程将被<strong>阻塞</strong>直到可以完成加锁操作为止。</p>
<p>4）<code>pthread_mutex_trylock</code></p>
<p><strong>尝试加锁，非阻塞</strong></p>
<p><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></p>
<ul>
<li>调用该函数时，若互斥量未加锁，则对该互斥量加锁，返回0；</li>
<li>若互斥量已加锁，则函数直接返回错误码<code>EBUSY</code>（不会阻塞调用线程）</li>
</ul>
<p>5）<code>pthread_mutex_unlock</code></p>
<p><strong>互斥量的解锁</strong></p>
<p><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></p>
<p>unlock主动解锁函数，<strong>同时将阻塞在该锁上的所有线程全部唤醒</strong>，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</p>
<p>6）<code>pthread_mutex_timedlock</code></p>
<p><strong>限时加锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span> <span class="comment">//头文件 time.h</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec;		<span class="comment">/* seconds */</span> 秒</span><br><span class="line">	<span class="keyword">long</span>   tv_nsec;	<span class="comment">/* nanosecondes*/</span> 纳秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>man sem_timedwait</code>可以查看<code>struct timespec</code>结构体</p>
<p>形参<code>abstime</code>：绝对时间。                                        </p>
<p>如：<code>time(NULL)</code>返回的就是绝对时间。而<code>alarm(1)</code>是相对时间，相对当前时间定时1秒钟。    </p>
<p>错误用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span> =</span> &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 只能定时到 1970年1月1日 00:00:01秒(早已经过去)</span></span><br><span class="line">pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); </span><br></pre></td></tr></table></figure>
<p> 正确用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">NULL</span>);  <span class="comment">// 获取当前时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span>		  <span class="comment">// 定义timespec 结构体变量t</span></span><br><span class="line">t.tv_sec = cur+<span class="number">1</span>; 		  <span class="comment">// 定时1秒</span></span><br><span class="line">pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t);</span><br></pre></td></tr></table></figure>
<h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><p>两个线程共享<code>stdout</code>资源，分别打印<code>hello world</code>和<code>HELLO WORLD</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>); <span class="comment">// 模拟长时间操作共享资源，导致CPU易主产生与时间有关函数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;world\n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex); <span class="comment">// 共享stdout资源 使用完立即解锁 不要睡眠后再解锁</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>); </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag--) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HELLO &quot;</span>);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WORLD\n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>); </span><br><span class="line">    &#125;   </span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_mutex_destroy(&amp;mutex); <span class="comment">//销毁锁</span></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_mutex_destroy: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220610112336201.png" alt="image-20220610112336201"></p>
<p><strong>小结</strong>：<strong>在访问共享资源前加锁，访问结束后</strong>立即解锁。锁的“粒度”应越小越好。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁场景</p>
<pre><code>1. 线程试图对同一个互斥量A加锁两次。
1. 线程1拥有A锁，请求获得B锁；线程2拥有B锁，请求获得A锁
1. 震荡（哲学家进餐问题，同时拿起筷子，同时释放筷子，同时再拿起筷子...）
</code></pre><p>避免方法：</p>
<ul>
<li>保证资源的获取顺序，要求每个线程获取资源的顺序一致</li>
<li>当得不到所有所需资源时，放弃已经获得的资源（不同时），等待</li>
</ul>
<h3 id="读写锁rwlock"><a href="#读写锁rwlock" class="headerlink" title="读写锁rwlock"></a>读写锁rwlock</h3><p>与互斥量类似，但读写锁允许更高的并行性。其特性为：写独占，读共享。</p>
<p><strong>读写锁引入</strong> </p>
<p>问题描述：</p>
<ul>
<li>在对临界资源的访问中，更多的是读操作，而写操作较少，只有互斥量机制可能会影响访问效率</li>
<li>期望对临界资源的访问控制粒度更精细，任一时刻允许<strong>多个线程对临界资源进行读操作</strong>，但只允许<strong>一个线程对临界资源进行写操作</strong></li>
</ul>
<p><strong>互斥关系：</strong></p>
<ul>
<li>读操作-写操作互斥</li>
<li>写操作-写操作互斥</li>
<li>读操作-读操作不互斥</li>
</ul>
<p><strong>同步关系</strong>：</p>
<ul>
<li>缓冲区不满，才允许写操作</li>
<li>缓冲区不空，才允许读操作 </li>
</ul>
<p><strong>读写锁通信机制</strong></p>
<p>在保证互斥的基础上，Linux提供了<strong>对临界资源访问控制粒度更细</strong>的读写锁机制</p>
<ol>
<li><p>读写锁是<strong>写模式加锁（写锁）</strong>时， 解锁前，所有对该锁加锁的线程都会被阻塞。</p>
</li>
<li><p>读写锁是<strong>读模式加锁（读锁）</strong>时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</p>
</li>
<li><p>读写锁是<strong>读模式加锁</strong>时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。<strong>读锁、写锁并行阻塞，写锁优先级高</strong></p>
</li>
</ol>
<p>读写锁也叫<strong>共享-独占锁</strong>。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。<font color=#ff0000>写独占、读共享</font>。</p>
<p>读写锁非常适合于对数据结构读的次数远大于写的情况。</p>
<h4 id="读写锁的操作"><a href="#读写锁的操作" class="headerlink" title="读写锁的操作"></a>读写锁的操作</h4><p>读写锁的操作与互斥量的操作非常类似</p>
<p>头文件：<code>#include &lt;pthread.h&gt;</code> </p>
<ol>
<li>定义读写锁变量：<code>pthread_rwlock_t rwlock;</code> </li>
<li>初始化读写锁变量：<code>pthread_rwlock_init</code>函数</li>
<li>访问临界资源（读操作或写操作）前对读写锁加锁<ul>
<li>阻塞申请读锁：<code>pthread_rwlock_rdlock</code>函数</li>
<li>阻塞申请写锁：<code>pthread_rwlock_wrlock</code>函数</li>
<li>非阻塞申请读锁：<code>pthread_rwlock_tryrdlock</code>函数</li>
<li>非阻塞申请写锁：<code>pthread_rwlock_trywrlock</code>函数</li>
<li>限时申请读锁：<code>pthread_rwlock_timerdlock</code>函数</li>
<li>限时申请写锁：<code>pthread_rwlock_timewrlock</code>函数</li>
</ul>
</li>
<li>解锁（包括读锁和写锁）：<code>pthread_rwlock_unlock</code>函数</li>
<li>销毁读写锁变量：<code>pthread_rwlock_destroy</code>函数</li>
</ol>
<p>以上函数<strong>成功返回0，失败返回错误码</strong></p>
<h4 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h4><p>1）<strong>读写锁初始化</strong> </p>
<p>静态初始化：<code>pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER</code></p>
<p>动态初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>attr</code>表读写锁属性，通常使用默认属性，传<code>NULL</code>即可。</li>
</ul>
<p>2）<strong>销毁读写锁变量</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>
<p>3）<strong>请求读锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; <span class="comment">// 阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; <span class="comment">// 非阻塞</span></span><br></pre></td></tr></table></figure>
<p>4）<strong>请求写锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; <span class="comment">// 阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; <span class="comment">// 非阻塞</span></span><br></pre></td></tr></table></figure>
<p>5）<strong>限时加锁</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>; <span class="comment">// 限时加读锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>; <span class="comment">// 限时加写锁</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>abstime</code>的使用参考前面互斥量的<code>pthread_mutex_timedlock</code>函数</li>
</ul>
<p>6）<strong>读写锁解锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>就近原则。加锁（读锁/写锁）与解锁配对出现，为代码中距离最近的加锁操作解锁</li>
</ul>
<h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 3个线程不定时 &quot;写&quot; 全局资源，5个线程不定时 &quot;读&quot; 同一全局资源 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter; <span class="comment">// 全局资源</span></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">th_write</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        t = counter;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=========== write %d : %lu : counter=%d ++counter=%d\n&quot;</span>, i, pthread_self(), t, ++counter);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">th_read</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------read %d : %lu : %d\n&quot;</span>, i, pthread_self(), counter);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">900</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">8</span>];</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, th_write, (<span class="keyword">void</span>*)i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        pthread_create(&amp;tid[i+<span class="number">3</span>], <span class="literal">NULL</span>, th_read, (<span class="keyword">void</span>*)i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock); <span class="comment">// 释放读写锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220610143129783.png" alt="image-20220610143129783"></p>
<h3 id="条件变量cond"><a href="#条件变量cond" class="headerlink" title="条件变量cond"></a>条件变量cond</h3><p>条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。</p>
<h4 id="条件变量的操作"><a href="#条件变量的操作" class="headerlink" title="条件变量的操作"></a>条件变量的操作</h4><p>头文件：<code>#include &lt;pthread.h&gt;</code> </p>
<ol>
<li>定义互斥量变量，定义条件变量<code>pthread_cond_t cond;</code></li>
<li>初始化互斥量，初始化条件变量<code>pthread_cond_init</code>函数</li>
<li>等待条件线程x（假设先执行）<ol>
<li>互斥量加锁 —&gt; XX操作 —&gt;</li>
<li>等待条件变量：<code>pthread_cond_wait</code>函数、<code>pthread_cond_timedwait</code>函数</li>
<li>—&gt; XX操作 —&gt; 互斥量解锁</li>
</ol>
</li>
<li>触发条件线程y（假设后执行）<ol>
<li>触发条件变量：<code>pthread_cond_signal</code>函数、<code>pthread_cond_broadcast</code>函数</li>
</ol>
</li>
<li>销毁互斥量变量，销毁条件变量<code>pthread_cond_destroy</code></li>
</ol>
<p>函数的返回值都是：成功返回0， 失败返回错误码。</p>
<p><strong>为什么条件变量需要和互斥量配合使用</strong></p>
<ul>
<li>条件变量的使用场景伴随共享资源的使用，例如全局变量</li>
<li>在调用<code>pthread_cond_wait</code>前，需要使互斥量处于加锁状态，这样可以通过原子操作的方式，将调用线程放到该条件变量等待线程队列（临界资源）中</li>
</ul>
<p><strong>调用<code>pthread_cond_wait</code>函数后内核自动执行的操作：</strong></p>
<ul>
<li>在线程阻塞等待条件变量之前，调用<code>pthread_mutex_unlock</code></li>
<li>若条件变量被其他线程触发，在该线程被唤醒后，调用<code>pthread_mutex_lock</code></li>
</ul>
<h4 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h4><p>1）<strong>条件变量初始化</strong></p>
<p>静态初始化：<code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</code></p>
<p>动态初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cond</code>：条件变量</li>
<li><code>attr</code>：条件变量属性，若为<code>NULL</code>，则使用默认属性</li>
</ul>
<p>2）<strong>条件变量销毁</strong></p>
<p><code>int pthread_cond_destroy(pthread_cond_t * cond);</code></p>
<p>3）<strong>等待条件变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将使调用线程进入阻塞状态，直到条件被触发</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pthread_cond_wait</code>函数作用：（ <strong>1.2.两步为一个原子操作</strong>）</p>
<ol>
<li><p>阻塞等待条件变量cond（参1）满足    </p>
</li>
<li><p>释放已掌握的互斥锁（解锁互斥量）相当于<code>pthread_mutex_unlock(&amp;mutex);</code></p>
</li>
<li><p>当被唤醒，<code>pthread_cond_wait</code>函数返回时，解除阻塞并重新申请获取互斥锁<code>pthread_mutex_lock(&amp;mutex);</code></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限时等待一个条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>abstime</code>的使用参考前面互斥量的<code>pthread_mutex_timedlock</code>函数</li>
</ul>
<p>4）<strong>触发条件变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pthread_cond_signal</code>唤醒该条件变量等待线程队列中的<strong>某一个线程</strong></p>
<p><code>pthread_cond_broadcast</code>唤醒该条件变量等待线程队列中的<strong>所有线程</strong>，这些线程会进行竞争</p>
<h4 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> count_lock;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> count_ready;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">decrement_count</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">increment_count</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;count_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;count_ready, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, decrement_count, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, increment_count, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decrement quit\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">decrement_count</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;count_lock); <span class="comment">// 上锁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decrement:waitting\n&quot;</span>);</span><br><span class="line">    pthread_cond_wait(&amp;count_ready, &amp;count_lock);</span><br><span class="line">    <span class="comment">/*等待条件变量，期间互斥量仍然可用*/</span></span><br><span class="line">    count -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decrement:count = %d\n&quot;</span>, count);</span><br><span class="line">    pthread_mutex_unlock(&amp;count_lock); <span class="comment">// 解锁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decrement quit\n&quot;</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">increment_count</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;count_lock); <span class="comment">// 上锁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;increment:running\n&quot;</span>);</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;count_ready);</span><br><span class="line">    <span class="comment">/*触发条件变量*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;increment:count = %d\n&quot;</span>, count); <span class="comment">// 解锁</span></span><br><span class="line">    pthread_mutex_unlock(&amp;count_lock);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220409165937723.png" alt="image-20220409165937723"></p>
<h4 id="条件变量优点"><a href="#条件变量优点" class="headerlink" title="条件变量优点"></a>条件变量优点</h4><p>相较于mutex而言，条件变量可以减少竞争。</p>
<p>如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</p>
<h3 id="生成者消费者模型"><a href="#生成者消费者模型" class="headerlink" title="生成者消费者模型"></a>生成者消费者模型</h3><p>一个生成者线程，一个消费者线程</p>
<p>生成者生成自定义的<code>struct msg</code></p>
<p>生产的产品以链表的结构组合，头部插入，所以后生产的先消费</p>
<p>代码中生成者和消费者执行完各自动作后的睡眠不能去掉。不然某个线程解锁完立马加锁，一直占据CPU</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER; <span class="comment">// 互斥量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> product = PTHREAD_COND_INITIALIZER; <span class="comment">// 条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        mp = (struct msg*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct msg));</span><br><span class="line">        mp-&gt;num = rand() % <span class="number">400</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----producer : %d\n&quot;</span>, mp-&gt;num);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex); <span class="comment">// 加锁</span></span><br><span class="line">        mp-&gt;next = head;</span><br><span class="line">        head = mp;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex); <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line">        pthread_cond_signal(&amp;product);</span><br><span class="line">        sleep(rand() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex); <span class="comment">// 上锁</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;product, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex); <span class="comment">// 解锁</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;====consumer : %d\n&quot;</span>, tmp-&gt;num);</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        tmp = <span class="literal">NULL</span>;</span><br><span class="line">        sleep(rand() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> ptid, ctid;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>)); <span class="comment">// 随机数种子</span></span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;ptid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;ctid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(ptid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(ctid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;product);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220610170438272.png" alt="image-20220610170438272"></p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="信号量sem"><a href="#信号量sem" class="headerlink" title="信号量sem"></a>信号量sem</h3><p>进化版的互斥锁（1 —&gt; N）</p>
<p>由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。</p>
<p>信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</p>
<h4 id="信号量的操作"><a href="#信号量的操作" class="headerlink" title="信号量的操作"></a>信号量的操作</h4><p><strong>头文件</strong>：<code>#include &lt;semaphore.h&gt;</code> </p>
<ol>
<li>定义信号量变量：<code>sem_t sem</code> </li>
<li>初始化信号量变量：<code>sem_init</code>函数</li>
<li>对信号量加锁（P操作）：<ul>
<li><code>sem_wait</code>函数（阻塞）</li>
<li><code>sem_trywait</code>函数（非阻塞）</li>
<li><code>sem_timedlock</code>函数（限时加锁）</li>
</ul>
</li>
<li>对信号量解锁（V操作）：<code>sem_post</code>函数</li>
<li>销毁信号量变量：<code>sem_destroy</code>函数</li>
</ol>
<p>以上5个函数的返回值都是：<strong>成功返回0；失败返回-1，并设置errno</strong>。</p>
<p><code>sem_t</code>类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节（类似于使用文件描述符）。 初始化信号量sem不能 &lt; 0。</p>
<p><strong>信号量的初值，决定了可占用信号量的线程的个数。</strong></p>
<h4 id="函数说明-1"><a href="#函数说明-1" class="headerlink" title="函数说明"></a>函数说明</h4><p>1）<strong>初始化信号量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sem</code>信号量</li>
<li><code>pshared</code>取 <strong>0用于线程间；取非0（一般为1）用于进程间</strong></li>
<li><code>value</code>指定信号量初值 <code>&gt;=0</code> </li>
</ul>
<p>2）<strong>销毁信号量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
<p>3）<strong>给信号量加锁</strong>  （P操作<code>--</code>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">const</span> struct timespec *abs_timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>abs_timeout</code>绝对时间，参考前面<code>pthread_mutex_timedlock</code>函数介绍</li>
</ul>
<p>4）<strong>对信号量解锁</strong> （V操作<code>++</code>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><p>线程实现。一个生产者，一个消费者。所以只考虑了同步。如果是多个生产者，多个消费者，需要考虑上互斥。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">queue</span>[NUM]; <span class="comment">// 缓冲区 环形队列</span></span><br><span class="line"><span class="keyword">sem_t</span> blank_number; <span class="comment">// 空闲</span></span><br><span class="line"><span class="keyword">sem_t</span> product_number; <span class="comment">// 已生产</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;blank_number);</span><br><span class="line">        <span class="built_in">queue</span>[i] = rand() % <span class="number">1000</span> + <span class="number">1</span>; <span class="comment">// 生产一个产品</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----produce : %d\n&quot;</span>, <span class="built_in">queue</span>[i]);</span><br><span class="line">        sem_post(&amp;product_number);</span><br><span class="line">        i = (i + <span class="number">1</span>) % NUM;</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;product_number);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;====consume : %d\n&quot;</span>, <span class="built_in">queue</span>[i]);</span><br><span class="line">        <span class="built_in">queue</span>[i] = <span class="number">0</span>; <span class="comment">// 消费一个产品</span></span><br><span class="line">        sem_post(&amp;blank_number);</span><br><span class="line">        i = (i + <span class="number">1</span>) % NUM;</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">pthread_t</span> pid, cid;</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;blank_number, <span class="number">0</span>, NUM); <span class="comment">//初始化空闲缓冲区为5</span></span><br><span class="line">    sem_init(&amp;product_number, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 初始化已占用缓冲区为0</span></span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    sem_destroy(&amp;blank_number);</span><br><span class="line">    sem_destroy(&amp;product_number);</span><br><span class="line">    </span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220610205703709.png" alt="image-20220610205703709"></p>
<h3 id="互斥量mutex-1"><a href="#互斥量mutex-1" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h3><p>进程间也可以使用互斥锁，来达到同步的目的。但应在<code>pthread_mutex_init</code>初始化之前，修改其属性为进程间共享。<code>mutex</code>的属性修改函数主要有以下几个。</p>
<h4 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h4><p>头文件：<code>#include &lt;pthread.h&gt;</code></p>
<ol>
<li><p>用于定义mutex锁的<strong>属性</strong>：<code>pthread_mutexattr_t mattr;</code> </p>
</li>
<li><p>初始化一个mutex属性对象：<code>pthread_mutexattr_init</code>函数</p>
</li>
<li>设置属性修改<code>mutex</code>：<code>pthread_mutexattr_setpshared</code>函数</li>
<li>销毁<code>mutex</code>属性对象（而非销毁锁）：<code>pthread_mutexattr_destroy</code>函数</li>
</ol>
<p>返回值：成功返回0，失败返回错误码</p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> *pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pshared</code>取值：</p>
<ul>
<li>线程锁：<code>PTHREAD_PROCESS_PRIVATE</code>（mutex的默认属性即为线程锁，进程间私有）</li>
<li>进程锁：<code>PTHREAD_PROCESS_SHARED</code></li>
</ul>
<h4 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mt</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> mutexattr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mt</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* int fd = open(&quot;mt_test&quot;, O_CREAT | O_RDWR, 0777);</span></span><br><span class="line"><span class="comment">    ftruncate(fd, sizeof(*mm));</span></span><br><span class="line"><span class="comment">    mm = mmap(NULL, sizeof(*mm), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span></span><br><span class="line"><span class="comment">    close(fd);</span></span><br><span class="line"><span class="comment">    unlink(&quot;mt_test&quot;); */</span></span><br><span class="line">    mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(*mm), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>); <span class="comment">// 匿名映射</span></span><br><span class="line">    <span class="built_in">memset</span>(mm, <span class="number">0</span>, <span class="keyword">sizeof</span>(*mm));</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_init(&amp;mm-&gt;mutexattr);                                  <span class="comment">//初始化mutex属性对象</span></span><br><span class="line">    pthread_mutexattr_setpshared(&amp;mm-&gt;mutexattr, PTHREAD_PROCESS_SHARED);    <span class="comment">//修改属性为进程间共享</span></span><br><span class="line">    pthread_mutex_init(&amp;mm-&gt;mutex, &amp;mm-&gt;mutexattr);                          <span class="comment">//初始化一把mutex琐</span></span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line">            (mm-&gt;num)++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-child----num++   %d\n&quot;</span>, mm-&gt;num);</span><br><span class="line">            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line">            mm-&gt;num += <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-parent---num+=2  %d\n&quot;</span>, mm-&gt;num);</span><br><span class="line">            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_destroy(&amp;mm-&gt;mutexattr);          <span class="comment">//销毁mutex属性对象</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mm-&gt;mutex);                <span class="comment">//销毁mutex</span></span><br><span class="line">    munmap(mm,<span class="keyword">sizeof</span>(*mm));                          <span class="comment">//释放映射区</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/Linux-img/image-20220610212537547.png" alt="image-20220610212537547"></p>
<h3 id="条件变量cond-1"><a href="#条件变量cond-1" class="headerlink" title="条件变量cond"></a>条件变量cond</h3><p>条件变量一般和互斥量配套使用。既然互斥量可以用于进程间，条件变量自然也可以。</p>
<p>头文件：<code>#include &lt;pthread.h&gt;</code></p>
<ol>
<li><p>用于定义条件变量cond的<strong>属性</strong>：<code>pthread_condattr_t mattr;</code> </p>
</li>
<li><p>初始化一个cond属性对象：<code>pthread_condattr_init</code>函数</p>
</li>
<li>设置属性修改cond：<code>pthread_condattr_setpshared</code>函数</li>
<li>销毁cond属性对象（而非销毁条件变量）：<code>pthread_condattr_destroy</code>函数</li>
</ol>
<p>返回值：成功返回0，失败返回错误码</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">int</span> *pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setpshared</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pshared</code>取值：</p>
<ul>
<li>线程：<code>PTHREAD_PROCESS_PRIVATE</code>（默认属性）</li>
<li>进程：<code>PTHREAD_PROCESS_SHARED</code></li>
</ul>
<h3 id="读写锁rwlock-1"><a href="#读写锁rwlock-1" class="headerlink" title="读写锁rwlock"></a>读写锁rwlock</h3><p>读写锁同样可以用于进程间互斥，需要设置属性</p>
<p>头文件：<code>#include &lt;pthread.h&gt;</code></p>
<ol>
<li><p>用于定义读写锁rwlock的<strong>属性</strong>：<code>pthread_rwlockattr_t mattr;</code> </p>
</li>
<li><p>初始化一个rwlock属性对象：<code>pthread_rwlockattr_init</code>函数</p>
</li>
<li>设置属性修改rwlock：<code>pthread_rwlockattr_setpshared</code>函数</li>
<li>销毁rwlock属性对象（而非销毁读写锁）：<code>pthread_rwlockattr_destroy</code>函数</li>
</ol>
<p>返回值：成功返回0，失败返回错误码</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_init</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_destroy</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *attr, <span class="keyword">int</span> *pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_setpshared</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pshared</code>取值：</p>
<ul>
<li>线程：<code>PTHREAD_PROCESS_PRIVATE</code>（默认属性）</li>
<li>进程：<code>PTHREAD_PROCESS_SHARED</code></li>
</ul>
<h3 id="文件锁fcntl"><a href="#文件锁fcntl" class="headerlink" title="文件锁fcntl"></a>文件锁fcntl</h3><p>借助 <code>fcntl</code> 函数来实现锁机制。操作文件的进程没有获得锁时，可以打开，但无法执行<code>read</code>、<code>write</code>操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, struct flock*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">short</span> l_type;    <span class="comment">//	锁的类型：F_RDLCK 、F_WRLCK 、F_UNLCK</span></span><br><span class="line">    <span class="keyword">short</span> l_whence;  <span class="comment">//	偏移位置：SEEK_SET、SEEK_CUR、SEEK_END </span></span><br><span class="line">    <span class="keyword">off_t</span> l_start;   <span class="comment">//	起始偏移，开始上锁位置</span></span><br><span class="line">    <span class="keyword">off_t</span> l_len;     <span class="comment">//	长度，对多长的数据上锁：0表示整个文件加锁</span></span><br><span class="line">    <span class="keyword">pid_t</span> l_pid;     <span class="comment">//	持有该锁的进程ID：(F_GETLK only)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cmd</code><ul>
<li><code>F_SETLK</code>  设置文件锁（trylock）</li>
<li><code>F_SETLKW</code> 设置文件锁（lock），解锁（unlock）</li>
<li><code>F_GETLK</code>  获取文件锁</li>
</ul>
</li>
</ul>
<p>注意：</p>
<p>1）依然遵循<strong>读共享、写独占</strong>特性。但！如若进程不加锁直接操作文件，依然可访问成功，但数据势必会出现混乱。</p>
<p>2）多线程间共享文件描述符，而给文件加锁，是通过修改文件描述符所指向的文件结构体中的成员变量来实现的。因此，多线程中无法使用文件锁。</p>
<p><strong>使用示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">f_lock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out filename\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    f_lock.l_type = F_WRLCK;  <span class="comment">// 选用写锁</span></span><br><span class="line">    <span class="comment">//f_lock.l_type = F_RDLCK;   //选用读锁</span></span><br><span class="line"></span><br><span class="line">    f_lock.l_whence = SEEK_SET; </span><br><span class="line">    f_lock.l_start = <span class="number">0</span>;         </span><br><span class="line">    f_lock.l_len = <span class="number">0</span>;           <span class="comment">// 0 表示整个文件加锁</span></span><br><span class="line"></span><br><span class="line">    fcntl(fd, F_SETLKW, &amp;f_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get flock\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    f_lock.l_type = F_UNLCK;</span><br><span class="line">    fcntl(fd, F_SETLKW, &amp;f_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;un flock\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>进程和线程共有：</p>
<blockquote>
<p>互斥量mutex、读写锁rwlock、条件变量cond、信号量sem、</p>
</blockquote>
<p>进程独有：<strong>文件锁</strong></p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      
      
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#NPTL"><span class="nav-number">1.</span> <span class="nav-text">NPTL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-number">2.</span> <span class="nav-text">线程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">什么是线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">Linux线程实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB"><span class="nav-number">2.3.</span> <span class="nav-text">线程间共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.4.</span> <span class="nav-text">线程优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="nav-number">2.5.</span> <span class="nav-text">线程与进程对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8BID"><span class="nav-number">2.6.</span> <span class="nav-text">线程ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8"><span class="nav-number">2.7.</span> <span class="nav-text">线程启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">2.8.</span> <span class="nav-text">线程终止</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD"><span class="nav-number">3.</span> <span class="nav-text">线程控制原语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-self%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">pthread_self函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-create%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">pthread_create函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.3.</span> <span class="nav-text">代码示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.3.1.</span> <span class="nav-text">创建一个子线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAN%E4%B8%AA%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.3.2.</span> <span class="nav-text">创建N个子线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.3.</span> <span class="nav-text">线程共享全局变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-exit%E5%87%BD%E6%95%B0"><span class="nav-number">3.4.</span> <span class="nav-text">pthread_exit函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.4.1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">3.4.2.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phread-join%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.</span> <span class="nav-text">phread_join函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.5.1.</span> <span class="nav-text">结构体示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6N%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.5.2.</span> <span class="nav-text">回收N个线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cancel%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.</span> <span class="nav-text">pthread_cancel函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.6.1.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%96%E6%B6%88%E7%82%B9%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.6.2.</span> <span class="nav-text">取消点示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-detach%E5%87%BD%E6%95%B0"><span class="nav-number">3.7.</span> <span class="nav-text">pthread_detach函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">线程属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="nav-number">4.1.</span> <span class="nav-text">相关操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.2.</span> <span class="nav-text">线程属性初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BB%E7%8A%B6%E6%80%81"><span class="nav-number">4.3.</span> <span class="nav-text">线程的分离状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A0%88%E5%9C%B0%E5%9D%80"><span class="nav-number">4.4.</span> <span class="nav-text">线程的栈地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A0%88%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.5.</span> <span class="nav-text">线程的栈大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">4.6.</span> <span class="nav-text">代码示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E7%BA%BF%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.6.1.</span> <span class="nav-text">分离线程示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.6.2.</span> <span class="nav-text">线程数量示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%88%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.6.3.</span> <span class="nav-text">线程栈示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.</span> <span class="nav-text">线程使用注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">6.</span> <span class="nav-text">同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">6.1.</span> <span class="nav-text">线程同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B7%B7%E4%B9%B1%E5%8E%9F%E5%9B%A0"><span class="nav-number">6.2.</span> <span class="nav-text">数据混乱原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%85%B3%E7%B3%BB"><span class="nav-number">6.3.</span> <span class="nav-text">任务关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="nav-number">6.4.</span> <span class="nav-text">线程数据共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98"><span class="nav-number">6.5.</span> <span class="nav-text">任务互斥问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-number">6.6.</span> <span class="nav-text">任务同步问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-1"><span class="nav-number">7.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8Fmutex"><span class="nav-number">7.1.</span> <span class="nav-text">互斥量mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">7.1.1.</span> <span class="nav-text">互斥量的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-number">7.1.2.</span> <span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">7.1.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">7.2.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81rwlock"><span class="nav-number">7.3.</span> <span class="nav-text">读写锁rwlock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">7.3.1.</span> <span class="nav-text">读写锁的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-1"><span class="nav-number">7.3.2.</span> <span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">7.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcond"><span class="nav-number">7.4.</span> <span class="nav-text">条件变量cond</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">7.4.1.</span> <span class="nav-text">条件变量的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="nav-number">7.4.2.</span> <span class="nav-text">函数说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-4"><span class="nav-number">7.4.3.</span> <span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%BC%98%E7%82%B9"><span class="nav-number">7.4.4.</span> <span class="nav-text">条件变量优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.5.</span> <span class="nav-text">生成者消费者模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">8.</span> <span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8Fsem"><span class="nav-number">8.1.</span> <span class="nav-text">信号量sem</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">8.1.1.</span> <span class="nav-text">信号量的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E-1"><span class="nav-number">8.1.2.</span> <span class="nav-text">函数说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.1.3.</span> <span class="nav-text">生产者消费者模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8Fmutex-1"><span class="nav-number">8.2.</span> <span class="nav-text">互斥量mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C"><span class="nav-number">8.2.1.</span> <span class="nav-text">主要操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-5"><span class="nav-number">8.2.2.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcond-1"><span class="nav-number">8.3.</span> <span class="nav-text">条件变量cond</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81rwlock-1"><span class="nav-number">8.4.</span> <span class="nav-text">读写锁rwlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E9%94%81fcntl"><span class="nav-number">8.5.</span> <span class="nav-text">文件锁fcntl</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">9.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yanglinqi"
      src="/images/headpic.jpg">
  <p class="site-author-name" itemprop="name">yanglinqi</p>
  <div class="site-description" itemprop="description">用于做笔记，对学过的知识总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yanglinqi107" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanglinqi107" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yanglinqi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


  <script async src="/js/cursor/fireworks.js"></script>


</body>
</html>

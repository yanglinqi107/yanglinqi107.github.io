<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yanglinqi107.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="学自电子科技大学 文档中的函数都可以用 man funcName 查看介绍">
<meta property="og:type" content="article">
<meta property="og:title" content="文件和目录操作">
<meta property="og:url" content="http://yanglinqi107.github.io/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/index.html">
<meta property="og:site_name" content="杨记">
<meta property="og:description" content="学自电子科技大学 文档中的函数都可以用 man funcName 查看介绍">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405150528083.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405152119180.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405152619972.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405160247813.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405160358404.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405160535000.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406120310070.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405170349612.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405171331260.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405225155321.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406135159849.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406135301992.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406135352137.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406135433630.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406135923462.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406140531667.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406140929967.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406141107311.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406143746728.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406143935113.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406143948216.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406150131249.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406150315979.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406150416375.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406152559930.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406152730069.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406152820289.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406152854242.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406152959593.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406165728902.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406165833211.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407103144896.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407103203149.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407103229973.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407113940167.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407114308228.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407155354291.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407174200065.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407174829214.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407180857330.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407181940228.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408113535578.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408113556252.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408113707390.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408120554130.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408122030806.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408123707548.png">
<meta property="article:published_time" content="2022-05-17T14:55:40.628Z">
<meta property="article:modified_time" content="2022-05-19T05:39:14.289Z">
<meta property="article:author" content="yanglinqi">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405150528083.png">

<link rel="canonical" href="http://yanglinqi107.github.io/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>文件和目录操作 | 杨记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杨记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">碎片化学习令人焦虑，系统化学习使人进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">20</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">89</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yanglinqi107.github.io/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headpic.jpg">
      <meta itemprop="name" content="yanglinqi">
      <meta itemprop="description" content="用于做笔记，对学过的知识总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          文件和目录操作
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-17 22:55:40" itemprop="dateCreated datePublished" datetime="2022-05-17T22:55:40+08:00">2022-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-19 13:39:14" itemprop="dateModified" datetime="2022-05-19T13:39:14+08:00">2022-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Linux系统编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>学自电子科技大学</p>
<p>文档中的函数都可以用 <code>man funcName</code> 查看介绍</p>
<span id="more"></span>
<h2 id="Linux初识1"><a href="#Linux初识1" class="headerlink" title="Linux初识1"></a>Linux初识1</h2><h3 id="UNIX和Linux"><a href="#UNIX和Linux" class="headerlink" title="UNIX和Linux"></a>UNIX和Linux</h3><p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405150528083.png" alt="image-20220405150528083" style="zoom:67%;" /></p>
<p>C语言是UNIX的副产品！</p>
<hr>
<p>80年代UNIX版本的剧增以及各种UNIX版本之间的差别不断扩大导致了以美国政府为代表许多用户要求对其标准化，以增强各种应用程序在这些UNIX操作系统之间的可移植性</p>
<p>重要的UNIX标准包括：ANSI C、IEEE POSIX等</p>
<p>UNIX标准只是<strong>对应用程序接口进行统一</strong>（内部实现机制则留给操作系统开发者自行实现）</p>
<p>ANSI C</p>
<ul>
<li>ANSI C是美国国家标准协会（ANSI）于1983年发布的C语言标准</li>
<li>1989年，此标准被采纳为国际标准ISO/IEC 9899:1990</li>
<li>ISO C标准现旨在提供<strong>应用程序的可移植性</strong>，使其能适应于不同的操作系统，而不仅仅是UNIX操作系统</li>
</ul>
<p>POSIX</p>
<ul>
<li>1986年，IEEE制定了IEEE P1003标准，这套标准被称为POSIX（Potable Operating System Interface）</li>
<li>POSIX定义了一整套的应用程序接口，包括系统调用、库函数、公共命令</li>
<li>POSIX标准希望在<strong>源代码级别保证应用程序可移植性</strong></li>
</ul>
<hr>
<p>Stallman在 1983 年发起了<strong>GNU</strong>计划，GNU是“GNU‘s Not Unix”的递归缩写，其目标是创建一个完全自由的<strong>类Unix操作系统</strong>，GNU计划也开发了大批其他的自由软件，例如 Emacs 、Glibc、GCC、BASH等</p>
<p>1985年Stallman又创立了自由软件基金会（Free Software Foundation）来为GNU计划提供技术、法律以及财政支持</p>
<p>自由软件并不是指“免费”的，而是指具有“自由度”的软件。什么是自由度呢？也就是使用者运行、复制、发布、研究、修改和改进该软件的自由</p>
<p>GNU通用公共许可协议（GNU GPL）是一个广泛被使用的自由软件许可协议条款，最初Stallman为GNU计划而撰写，GPL授予程序接受人以下权利，或称“自由”：</p>
<ul>
<li>以任何目的运行此程序的自由；</li>
<li>再发行复制件的自由；</li>
<li>改进此程序，并公开发布改进的自由</li>
</ul>
<p>1984年”，安德鲁·斯图尔特·塔能鲍姆（ Andrew Stuart Tanenbaum ）自己编写了兼容于UNIX的<strong>Minix系统</strong>，用于教学</p>
<p>1991年，芬兰郝尔辛基大学研究生林纳斯·托瓦兹（Linus Torvalds）受Minix系统影响，开发了针对386机器的<strong>Linux内核</strong></p>
<p>1991年Linux的第一个版本公开发行时，GNU计划已经完成除了操作系统内核之外的大部分软件（其中包括了<strong>shell程序，C语言程序库以及C语言编译器</strong>）。 Linus Torvalds及其他早期Linux开发人员加入了这些工具，而完成了Linux操作系统</p>
<p><strong>Linux是在GNU通用公共许可证下发行，它却不是GNU计划的一部分</strong></p>
<hr>
<p>UNIX是可以应用从大型计算机到普通PC机等多种不同的平台上，是应用面最广、影响力最大的操作系统。</p>
<p>Linux是一种外观和性能与UNIX相同或更好的操作系统，但Linux不源于任何版本的UNIX的源代码，是一个类似于UNIX的产品</p>
<p>Linux遵循POSIX规范，成功的模仿了UNIX系统和功能，更具体地讲，Linux兼容于System V以及BSD UNIX：</p>
<ul>
<li>对于System V，应用程序源代码在Linux下重新编译之后就可以运行</li>
<li>对于BSD UNIX，应用程序可执行文件可以直接在Linux环境下运行</li>
</ul>
<h3 id="Linux体系结构"><a href="#Linux体系结构" class="headerlink" title="Linux体系结构"></a>Linux体系结构</h3><p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405152119180.png" alt="image-20220405152119180" style="zoom:67%;" /></p>
<p><strong>内核的功能</strong></p>
<ul>
<li><strong>内存管理</strong><ul>
<li>内存分配调用： 包括静态分配方式、动态分配方式；</li>
<li>内存保护：确保每个程序在自己的内存空间运行、互不干扰。方法是使用界限寄存器或存储保护键；</li>
<li>地址映射：实现程序的逻辑地址与存储器的物理地址之间的映射功能；</li>
<li>内存扩充：从逻辑上扩充物理内存，以允许比物理内存更大的程序在机器内运行，为此操作系统必须具有：请求调入功能与置换功能</li>
</ul>
</li>
<li><strong>进程管理</strong><ul>
<li>进程控制：包括进程创建、进程撤销、进程阻塞、进程唤醒</li>
<li>进程协调：由于进程运行的异步性，因此进程同步的任务是对诸进程的运行协调，包括两种方式：进程互斥方式与进程同步方式；</li>
<li>进程通信：主要完成同一台机器上不同进程间通信和不同机器上进程间的通信，以共同完成一相同的任务；</li>
<li>进程调度：操作系统按照一定的规则对等待运行的多道程序进行调度，以保证每个程序都能有机会得到运行，并最终完成</li>
</ul>
</li>
<li><strong>文件管理</strong><ul>
<li>文件存储空间的管理：为每一文件分配必要的外存空间。为提高外部存储空间的利用率，系统应设置相应的数据结构，用于记录文件存储空间的使用情况；</li>
<li>目录管理：为了方便对用户的文件进行管理，对文件系统建立一定结构的目录结构，同时要求快速的目录查询手段；</li>
<li>文件的读、写管理和存取控制：利用一定的系统调用对文件进行读写操作。同时，为防止系统中的文件被非法访问和窃取，文件系统中必须提供有效存取控制功能；</li>
</ul>
</li>
<li><strong>设备管理</strong><ul>
<li>缓冲管理：管理各种类型的缓冲区，如字符缓冲区和块缓冲区，以缓和CPU和I/O速度不匹配的矛盾，最终达到提高CPU和I／O设备的利用率，进而提高系统吞吐量的目的；</li>
<li>设备分配：根据用户的I/O请求，为之分配其所需要的设备；</li>
<li>设备处理：又称为设备驱动程序，任务是实现CPU和设备控制器之间的通信；</li>
<li>设备独立性和虚拟设备：一方面保证用户程序独立于物理设备，另一方面保证多个进程能并发地共享同一个设备；</li>
</ul>
</li>
</ul>
<hr>
<p><strong>UNIX/Linux操作系统结构</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405152619972.png" alt="image-20220405152619972"></p>
<h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><hr>
<p>操作系统用户接口：</p>
<ul>
<li><strong>命令接口</strong>：以命令形式呈现在用户面前，方便用户直接或间接控制自己的作业</li>
<li><p><strong>程序接口</strong>：为应用程序使用系统功能而设置，是应用程序取得操作系统服务的唯一途径。由一系列系统调用组成，每一个系统调用都是一个能完成特定功能的子程序。</p>
</li>
<li><p><strong>图形接口</strong>：采用了图形化的操作界面，将各种应用程序和文件，直观、逼真地表示出来。</p>
</li>
</ul>
<p><strong>系统调用是内核提供的程序接口，是应用程序和硬件设备之间的中间层</strong>：</p>
<blockquote>
<p>为应用程序提供了系统服务和硬件抽象能力，例如，当需要读文件时，应用程序可以不管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型；</p>
<p>系统调用保证了系统的稳定和安全</p>
<p>每个进程都运行在虚拟系统中</p>
</blockquote>
<p>Research UNIX系统的第7个版本提供了大给50个系统调用，4.4BSD提供了大约110个，SVR4有大约120个。<strong>Linux根据不同的版本有240到260个系统调用的接口</strong></p>
<ul>
<li><code>man 2 syscalls</code> 查看所有的系统调用接口</li>
</ul>
<p>系统调用的类型：</p>
<ul>
<li>文件操作类系统调用： 如打开、创建、读取、删除、修改文件；</li>
<li>进程控制类系统调用：如创建进程、设置或获取进程属性等；</li>
<li>通信类系统调用：创建进程间的通信连接，发送、接收消息，或其他的通信方式；</li>
<li>设备管理类系统调用：打开、关闭和操作设备；</li>
<li>信息维护类系统调用：在用户程序和OS之间传递信息。例如，系统向用户程序传送当前时间、日期、操作系统版本号等。</li>
</ul>
<p>系统调用与C库函数：</p>
<p>系统调用和C库函数之间并不是一一对应的关系，可能几个不同的函数会调用到同一个系统调用：</p>
<ul>
<li><p>malloc函数和free函数都是通过sbrk系统调用来扩大或缩小进程的堆栈空间；</p>
</li>
<li><p>execl、execlp、execle、execv、execvp和execve函数都是通过execve系统调用来执行一个可执行文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405160247813.png" alt="image-20220405160247813" style="zoom:50%;" /></p>
</li>
</ul>
<p>并非所有的库函数都会调用系统调用，例如，printf函数会调用write系统调用以输出一个字符串，但strcpy和atoi函数则不使用任何系统调用</p>
<p>UNIX/Linux软件层次架构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405160358404.png" alt="image-20220405160358404" style="zoom:50%;" /></p>
<p>一般而言，应用程序使用API而不是直接使用系统调用来编程</p>
<p>进程UNIX/Linux的C库遵循POSIX规范，以库函数的形式实现了POSIX API（在API中使用系统调用完成相应功能）。</p>
<p>参考：<code>/usr/include/asm/unistd.h</code> （没有的话，用 <code>find / -name &quot;unistd.h&quot;</code>找一下，出来一大堆，感觉应该是<code>/usr/include/unistd.h</code>）<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405160535000.png" alt="image-20220405160535000"></p>
<h3 id="文件目录命令"><a href="#文件目录命令" class="headerlink" title="文件目录命令"></a>文件目录命令</h3><p>浏览目录命令：<code>ls</code> 、<code>pwd</code></p>
<p>目录操作命令：<code>cd</code>、 <code>mkdir</code>、 <code>rmdir</code></p>
<p>浏览文件命令：<code>cat</code>、<code>more</code>、<code>less</code>、<code>head</code>、<code>tail</code></p>
<p>文件操作命令：<code>cp</code>、<code>rm</code>、 <code>mv</code>、<code>find</code>、 <code>grep</code>、<code>tar</code></p>
<hr>
<p>命令名称：<code>ls</code></p>
<ul>
<li>命令英文原意：<code>list</code></li>
<li>功能描述：显示目录文件</li>
<li>语法：ls 选项[-ald] [文件或目录]<ul>
<li><code>-a</code> 显示所有文件，包括隐藏文件</li>
<li><code>-l</code> 详细信息显示</li>
<li><code>-d</code> 查看目录属性</li>
</ul>
</li>
</ul>
<p>命令名称：<code>pwd</code></p>
<ul>
<li>命令英文原意：<code>print working directory</code></li>
<li>语法：pwd</li>
<li>功能描述：显示当前所在的工作目录</li>
</ul>
<p>命令名称：<code>cd</code></p>
<ul>
<li>命令英文原意：<code>change directory</code></li>
<li>语法：<code>cd [目录]</code></li>
<li>功能描述：切换目录</li>
<li>范例：<ul>
<li><code>$ cd / 切换到根目录</code></li>
<li><code>$ cd .. 回到上一级目录</code> </li>
</ul>
</li>
</ul>
<p>命令名称：<code>mkdir</code></p>
<ul>
<li>命令英文原意：<code>make directory</code></li>
<li>语法：<code>mkdir [目录名]</code></li>
<li>功能描述：创建新目录</li>
<li>范例： <code>$ mkdir newdir</code></li>
</ul>
<p>命令名称：<code>rmdir</code></p>
<ul>
<li>命令英文原意：<code>remove directory</code></li>
<li>语法：<code>rmdir [目录名]</code></li>
<li>功能描述：删除空目录</li>
<li>范例： <code>$ rmdir newdir</code></li>
</ul>
<p>命令名称：<code>cat</code></p>
<ul>
<li>命令英文原意：<code>concatenate and display files</code></li>
<li>功能描述：连接文件并打印到标准输出设备上</li>
<li>选项：<ul>
<li><code>-E</code> 在每一行的末尾显示<code>$</code></li>
<li><code>-n</code> 为显示行添加行号</li>
</ul>
</li>
<li>参数：指定要连接的文件列表。</li>
<li>范例：<ul>
<li><code>cat m1</code> （在屏幕上显示文件ml的内容）</li>
<li><code>cat m1 m2</code> （同时显示文件ml和m2的内容）</li>
</ul>
</li>
</ul>
<p>命令名称：<code>more</code></p>
<ul>
<li>语法：<code>more [文件名]</code><ul>
<li><code>(空格)或f</code> 显示下一页</li>
<li><code>(Enter)</code> 显示下一行</li>
<li><code>q或Q</code>   退出</li>
</ul>
</li>
<li>功能描述：分页显示文件内容</li>
<li>范例：<code>$ more /etc/services</code></li>
</ul>
<p><code>less</code>命令的用法与more命令类似，也可以用来浏览超过一页的文件。所不同的是less命令除了可以按空格键向下显示文件外，还可以利用上下键来卷动文件。</p>
<p><code>head</code>命令：用于显示文件前几行的内容</p>
<ul>
<li>格式：<code>head [参数] &lt;文件名&gt;</code><ul>
<li><code>-n</code>：显示前n行，不指定此参数显示前10行</li>
<li><code>[root@linux root]# head /etc/passwd</code></li>
</ul>
</li>
</ul>
<p><code>tail</code>命令：用于显示文件后几行的内容</p>
<ul>
<li>格式：<code>tail [参数] &lt;文件名&gt;</code><ul>
<li><code>-n</code>：显示后n行，不指定此参数显示后10行</li>
<li><code>+n</code>：从第n行显示到文件尾</li>
<li><code>-F</code>：用于跟踪显示不断增长的文件结尾内容（通常用于显示日志文件）。</li>
<li><code>[root@linux root]# tail /etc/passwd</code></li>
</ul>
</li>
</ul>
<p><code>cp</code>（copy）命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。</p>
<ul>
<li>格式：<code>cp [参数] &lt;源文件路径&gt; &lt;目标文件路径&gt;</code><ul>
<li><code>-p</code> ：连同文件的属性一起复制，而非使用默认方式，常用于备份</li>
<li><code>-i</code> ：若目标文件已经存在时，在覆盖时会先询问操作的进行</li>
<li><code>-r</code> ：递归持续复制，用于目录的复制行为</li>
<li><code>-u</code> ：目标文件与源文件有差异时才会复制</li>
</ul>
</li>
<li>范例：<ul>
<li>将test1.txt复制成test2.txt：<code>[test@linux test]$ cp test1.txt test2.txt</code> </li>
<li>将test3.txt复制到/tmp目录中：<code>[test@linux test]$ cp test3.txt /tmp</code> </li>
<li>目录test1拷贝：<code>[test@linux test]$ cp –r test1 test2</code></li>
</ul>
</li>
</ul>
<p><code>rm</code>（remove）命令：删除文件或目录</p>
<ul>
<li>格式：<code>rm [参数] &lt;目标文件路径&gt;</code><ul>
<li><code>-f</code> ：就是force的意思，忽略不存在的文件，不会出现警告消息</li>
<li><code>-i</code> ：互动模式，在删除前会询问用户是否操作</li>
<li><code>-r</code> ：递归删除，最常用于目录删除，它是一个非常危险的参数</li>
</ul>
</li>
<li>范例：<ul>
<li>删除myfiles文件：<code>[test@linux test]$ rm myfiles</code></li>
<li>删除当前目录下的所有文件：<code>[test@linux test]$ rm *</code></li>
<li>递归删除某个目录所有内容：<code>`[test@linux test]$ rm -r myfolder</code></li>
<li>强迫删除所有后缀名为txt文件：<code>[test@linux test]$ rm –f *.txt</code></li>
<li>删除当前目录下的所有文件：<code>[test@linux test]$ rm –i *</code>（删除文件时会询问,可按Y或N键表示允许或拒绝删除文件）</li>
</ul>
</li>
</ul>
<p><code>find</code>命令：用来寻找文件或目录</p>
<ul>
<li>格式：<code>find 路径 [参数]</code><ul>
<li><code>-name filename</code>：找出文件名为filename的文件</li>
<li><code>-size [+-]SIZE</code> ：找出比<code>SIZE</code>还要大（+）或小（-）的文件</li>
<li><code>-tpye TYPE</code>：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f）、设备文件（b、c）、目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；</li>
<li><code>-perm mode</code>：查找文件权限刚好等于mode的文件，mode用数字表示，如0755</li>
</ul>
</li>
</ul>
<p><code>grep</code>命令（Globally search a Regular Expression and Print）</p>
<ul>
<li>功能：在文件中搜索匹配的字符并进行输出</li>
<li>格式：<code>grep[参数] &lt;要找的字串&gt; &lt;要寻找字串的源文件&gt;</code><ul>
<li><code>-a</code>：将<code>binary</code>文件以<code>text</code>文件的方式查找数据</li>
<li><code>-c</code>：计算找到“查找字符串”的次数</li>
<li><code>-i</code>：忽略大小写的区别，即把大小写视为相同</li>
<li><code>-v</code>：反向选择，即显示出不包含‘查找字符串’内容的那一行</li>
</ul>
</li>
</ul>
<p><code>tar</code>（tape archive）命令能够将用户所指定的文件或目录打包成一个文件，也可以通过指定参数开启压缩/解压缩功能</p>
<ul>
<li>格式：<code>tar [参数] &lt;文件&gt;</code><ul>
<li><code>-c</code>：新建打包文件</li>
<li><code>-t</code>：查看打包文件的内容含有哪些文件名</li>
<li><code>-x</code>：解打包或解压缩的功能，可以搭配<code>-C</code>（大写）指定解压的目录，注意<code>-c,-t,-x</code>不能同时出现在同一条命令中</li>
<li><code>-j</code>：通过<code>bzip2</code>的支持进行压缩/解压缩</li>
<li><code>-z</code>：通过<code>gzip</code>的支持进行压缩/解压缩</li>
<li><code>-v</code>：在压缩/解压缩过程中，将正在处理的文件名显示出来</li>
<li><code>-f filename</code>：filename为要处理的文件</li>
<li><code>-C dir</code>：指定压缩/解压缩的目录<code>dir</code>，<code>dir</code>必须已存在</li>
</ul>
</li>
<li><p>范例：</p>
<ul>
<li><p>将当前目录的所有文件打包成test.tar：<code>[root@linux test]# tar -cvf test.tar *</code></p>
</li>
<li><p>将当前目录的所有文件打包成test.tar,再用gzip命令压缩：<code>[root@linux test]# tar -czvf test.tar.gz *</code> </p>
</li>
<li><p>查看test.tar文件中包括了哪些文件：<code>[root@linux ljr]# tar -tf test.tar</code></p>
</li>
<li><p>将test.tar解打包：<code>[root@linux test]# tar -xvf test.tar</code></p>
</li>
<li><p>将foo.tar.gz解压缩并解打包：<code>[root@linux test]# tar -xzvf foo.tar.gz</code> </p>
</li>
<li><p><code>-C</code>的示例，打包Cprogram内的文件，不把<code>Cprogram</code>文件夹名也打包</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406120310070.png" alt="image-20220406120310070"></p>
</li>
</ul>
</li>
</ul>
<h3 id="进程控制类命令"><a href="#进程控制类命令" class="headerlink" title="进程控制类命令"></a>进程控制类命令</h3><p>查看系统中的进程命令：<code>ps</code> 、<code>top</code></p>
<p>控制系统中的进程命令：<code>kill</code> 、<code>killall</code>、 <code>nice</code>、 <code>renice</code></p>
<p>进程后台运行命令 <code>&amp;</code></p>
<p>进程的挂起和恢复</p>
<hr>
<p><strong>程序和进程的区别</strong></p>
<p>程序是一个包含可执行代码的文件，它放在磁盘等介质上。</p>
<p>当程序被操作系统装载到内存并分配给它一定资源后，此时可称为<strong>进程</strong>。</p>
<p>程序是<strong>静态概念</strong>，进程是<strong>动态概念</strong>。</p>
<hr>
<p><strong>进程状态</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405170349612.png" alt="image-20220405170349612"></p>
<p><code>ps</code>命令是用来显示系统瞬间的进程信息，它可以显示出在用户输入ps命令时系统的进程及进程的相关信息。</p>
<ul>
<li>格式：<code>ps [参数]</code><ul>
<li><code>-l</code> 长格式输出</li>
<li><code>-u</code> 按用户名和启动时间的顺序来显示进程</li>
<li><code>-j</code> 用任务格式来显示进程</li>
<li><code>-f</code> 用树形格式来显示进程</li>
<li><code>-a</code> 显示所有用户的所有进程（包括其它用户）</li>
<li><code>-x</code> 显示无控制终端的进程</li>
<li><code>-r</code> 显示运行中的进程</li>
</ul>
</li>
</ul>
<p><code>top</code>命令</p>
<ul>
<li><p>功能：动态监视系统任务的工具，输出结果是连续的</p>
</li>
<li><p>格式：<code>top [参数]</code></p>
<ul>
<li><code>-b</code> 以批量模式运行，但不能接受命令行输入</li>
<li><code>-c</code> 显示命令行，而不仅仅是命令名</li>
<li><code>-d N</code> 显示两次刷新时间的间隔，比如<code>-d 5</code>，表示两次刷新间隔为5秒</li>
<li><code>-i</code> 禁止显示空闲进程或僵尸进程</li>
<li><code>-n NUM</code> 显示更新次数，然后退出。比如<code>-n 5</code>，表示top更新5次数据就退出</li>
<li><code>-p PID</code> 仅监视指定进程的ID；<code>PID</code>是一个数值</li>
<li><code>-q</code> 不经任何延时就刷新</li>
<li><code>-s</code> 安全模式运行，禁用一些效互指令</li>
<li><code>-S</code> 累积模式，输出每个进程的总的CPU时间</li>
</ul>
</li>
<li><p>范例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405171331260.png" alt="image-20220405171331260" style="zoom:67%;" /></p>
</li>
</ul>
<p><code>kill</code>命令，该命令用于向某个进程（通过PID标识）传送一个信号，它通常与<code>ps</code>和<code>jobs</code>命令一起使用</p>
<ul>
<li>格式：<code>kill –signal PID</code>，常用的<code>signal</code>参数如下：<ul>
<li><code>1:SIGHUP</code>，启动被终止的进程</li>
<li><code>2:SIGINT</code>，相当于输入<code>ctrl+c</code>，中断一个程序的进行</li>
<li><code>9:SIGKILL</code>，强制中断一个进程的进行</li>
<li><code>15:SIGTERM</code>，以正常的结束进程方式来终止进程</li>
<li><code>17:SIGSTOP</code>，相当于输入<code>ctrl+z</code>，暂停一个进程的进行</li>
</ul>
</li>
<li>范例：<ul>
<li>以正常的结束进程方式来终止第一个后台工作进程  <code>kill -SIGTERM %1</code></li>
<li>重新启动进程ID为PID的进程  <code>kill -SIGHUP PID</code></li>
</ul>
</li>
</ul>
<p><code>killall</code>命令使用进程的名称来杀死进程，使用此指令可以杀死一组同名进程</p>
<p>使用kill命令可以杀死指定进程PID的进程，如果要根据进程名称找到需要杀死的进程，还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一</p>
<ul>
<li>用法：<code>killall [参数] &lt;正在运行的进程名&gt;</code><ul>
<li><code>-e</code>：对长名称进行精确匹配</li>
<li><code>-I</code>：忽略大小写的不同</li>
<li><code>-p</code>：杀死进程所属的进程组</li>
<li><code>-i</code>：交互式杀死进程，杀死进程前需要进行确认</li>
<li><code>-l</code>：打印所有已知信号列表</li>
<li><code>-q</code>：如果没有进程被杀死，则不输出任何信息</li>
<li><code>-r</code>：使用正规表达式匹配要杀死的进程名称</li>
<li><code>-s</code>：用指定的进程号代替默认信号“SIGTERM”</li>
<li><code>-u</code>：杀死指定用户的进程</li>
</ul>
</li>
<li>使用范例：<code>[root@localhost test]# killall game</code></li>
</ul>
<p><code>nice</code>命令：允许在默认优先级的基础上进行增大或减小的方式来运行命令</p>
<ul>
<li>格式：<code>nice [参数] &lt;command [arguments...]&gt;</code><ul>
<li>command 是系统中任意可执行文件的名称</li>
<li><code>-n</code>, <code>--adjustment</code> 指定程序运行优先级的调整值</li>
<li>优先级的调整值范围为<code>-20 ～ 19</code> ，其中数值越小优先级越高，数值越大优先级越低</li>
<li>若 nice命令未指定优先级的调整值，则以缺省值10来调整程序运行优先级，既在命令通常运行优先级基础之上增加10</li>
</ul>
</li>
<li>使用范例：<code>[root@host root]# nice -n -5 myprogram&amp;</code>在后台以通常运行优先级<code>-5</code>的优先级运行<code>myprogram</code></li>
</ul>
<p><code>renice</code>命令：改变一个正在运行的进程的<code>nice</code>值</p>
<ul>
<li>格式：<code>renice [参数] &lt;pid&gt;</code><ul>
<li><code>-n</code> 指定程序运行优先级的调整值</li>
</ul>
</li>
<li>使用范例：<code>[root@host root]# renice -5 777</code> 将正在运行的PID为777的进程nice值改为-5</li>
</ul>
<p>后台运行程序的<code>＆</code>命令</p>
<ul>
<li><code>[root@host root]# cp –r /usr/* test &amp;</code>将/usr 目录下的所有子目录及文件复制到/root/test目录下的工作放到后台运行</li>
</ul>
<p>进程的中止（挂起）和终止</p>
<ul>
<li>挂起（Ctrl+Z）</li>
<li>终止（Ctrl+C）</li>
</ul>
<p>进程的恢复</p>
<ul>
<li>恢复到前台继续运行 <code>fg</code> ： <code>fg [n]</code></li>
<li>恢复到后台继续运行 <code>bg</code> ：<code>bg [n]</code></li>
<li>查看被挂起的进程 <code>jobs</code></li>
</ul>
<h3 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h3><p>用户管理类命令：<code>useradd</code> 、<code>usermod</code>、 <code>passwd</code> 、<code>userdel</code>、 <code>su</code> 、<code>id</code>、 <code>whoami</code> 、<code>w</code>、 <code>finger</code> </p>
<p>用户组管理类命令：<code>groupadd</code>、 <code>groupmod</code> 、<code>groupdel</code></p>
<p>文件权限管理类命令：<code>chmod</code>、 <code>chown</code> 、<code>chgrp</code></p>
<p>Linux用户分为三类：</p>
<ul>
<li>超级用户：拥有最高权限</li>
<li>系统用户：与系统服务相关，但不能用于登录</li>
<li>普通用户：由超级用户创建并赋予权限，只能操作其拥有权限的文件和目录，只能管理自己启动的进程</li>
</ul>
<p><strong>用户信息：</strong></p>
<ul>
<li>用户名：唯一，由字母、数字和符号组成。</li>
<li>口令</li>
<li>用户<code>ID(uid)</code>：每个用户拥有的唯一的识别号码。超级用户为0，系统用户1-499，普通用户从500开始</li>
<li>用户组<code>id(gid)</code></li>
<li>用户主目录</li>
<li>全称：用户帐户的附加信息，可以为空</li>
<li>登录Shell：默认使用Bash</li>
</ul>
<p><strong>与用户相关的文件：</strong></p>
<ul>
<li>用户帐号信息文件<code>/etc/passwd</code><ul>
<li>文件中每一行为一个用户的信息</li>
<li>文件中各字段从左到右依次为：<strong>用户名、口令、用户ID、用户组、全称、用户主目录和登录Shell</strong>。</li>
<li>口令字段用<code>x</code>来填充，加密后的口令保存在<code>/etc/shadow</code>文件中。</li>
</ul>
</li>
<li>用户口令信息文件<code>/etc/shadow</code><ul>
<li><code>shadow</code> 文件只有超级用户才能查看并修改其内容，且加密(AES-256)存储。</li>
</ul>
</li>
</ul>
<p><strong>用户组</strong>：</p>
<ul>
<li>Linux将相同特性的用户划归为同一用户组，可以大大简化用户的管理，方便用户之间文件的共享，任何用户都至少属于一个用户组。</li>
<li>一个用户只能属于一个用户组，但可以同时属于多个附加组。用户不仅拥有其用户组的权限，还同时拥有其附加组的权限。</li>
<li>用户组包括系统用户组与私人用户组</li>
</ul>
<p><strong>与用户组相关的文件：</strong></p>
<ul>
<li>用户组账号信息文件<code>/etc/group</code><ul>
<li>每一行为一个用户组信息</li>
<li>文件中各字段从左到右依次为：<code>用户组名、口令、用户组ID和附加用户列表</code>。</li>
</ul>
</li>
<li>用户组口令信息文件<code>/etc/gshadow</code><ul>
<li>同<code>/etc/shadow</code></li>
</ul>
</li>
</ul>
<hr>
<p><code>useradd</code>命令：新建用户帐号（超级用户可用）</p>
<ul>
<li>格式：<code>useradd [参数] &lt;用户名&gt;</code><ul>
<li><code>-d</code> 指定用户登入时的主目录</li>
<li><code>-e</code> 账号终止日期</li>
<li><code>-g</code> 指定账户所属的用户组</li>
<li><code>-G</code> 指定账户所属的附加组</li>
<li><code>-s</code> 指定账户登录后所使用的shell</li>
<li><code>-u</code> 指定用户ID号</li>
</ul>
</li>
<li>举例：新建一个用户zhangsan，用户组为net04：<code>useradd –g net04 zhangsan</code></li>
</ul>
<p><code>passwd</code>命令：设置或修改用户的口令以及口令的属性</p>
<ul>
<li>格式：<code>passwd [参数] &lt;用户&gt;</code><ul>
<li><code>-d</code> 删除用户的口令</li>
<li><code>-l</code> 暂时锁定指定的用户帐号</li>
<li><code>-u</code> 解除指定用户帐号的锁定</li>
<li><code>-s</code> 显示指定用户帐号的状态</li>
</ul>
</li>
<li>范例：<ul>
<li>设置与修改属性 <code>passwd zhangsan</code></li>
<li>删除口令 <code>passwd –d zhangsan</code></li>
<li>锁定用户帐号 <code>passwd –l zhangsan</code></li>
<li>解锁用户帐号 <code>passwd –u zhangsan</code></li>
<li>显示用户帐号状态 <code>passwd –s zhangsan</code></li>
</ul>
</li>
</ul>
<p><code>usermod</code>命令：修改用户的属性（超级用户可用）</p>
<ul>
<li>格式：<code>usermod [参数] &lt;用户名&gt;</code><ul>
<li><code>-d</code> 指定用户登入时的主目录</li>
<li><code>-e</code> 账号终止日期</li>
<li><code>-g</code> 指定账户所属的用户组</li>
<li><code>-G</code> 指定账户所属的附加组</li>
<li><code>-s</code> 指定账户登录后所使用的shell</li>
<li><code>-u</code> 指定用户ID号</li>
<li><code>-l</code> 新用户名（用于修改用户名）</li>
</ul>
</li>
<li>举例：将zhangsan改为zhangs ：<code>usermod –l zhangs zhangsan</code></li>
</ul>
<p><code>userdel</code>命令：删除指定的用户帐号（超级用户可用）</p>
<ul>
<li>格式：userdel [参数] &lt;用户名&gt;<ul>
<li><code>-r</code>：不仅删除此用户帐号，而且删除用户主目录及本地邮件存储的目录或文件</li>
<li><code>-f</code>：删除用户登入目录以及目录中所有文件</li>
</ul>
</li>
<li>如果删除用户属于私人组群，而该组群没有其他用户，组群也一并删除。</li>
<li>正在使用系统的用户不能删除。</li>
</ul>
<p><code>su</code>命令：切换用户身份</p>
<ul>
<li>格式：<code>su &lt;用户名&gt;</code><ul>
<li>超级用户可以切换为任何普通用户，而不需要输入口令；普通用户转换为其他用户时需要输入被转换用户的口令</li>
</ul>
</li>
<li>使用<code>exit</code>可以返回到本来的用户身份</li>
</ul>
<p><code>id</code>命令：查看用户的UID、GID和用户所属用户组的信息，如果不指定用户，则显示当前用户的相关信息。</p>
<ul>
<li>格式：<code>id &lt;用户名&gt;</code></li>
</ul>
<p><code>whoami</code>命令：查看当前用户名</p>
<p><code>w</code>命令：查看当前登录系统用户和详细信息</p>
<p><code>groupadd</code>命令：新建组群（超级用户可用）</p>
<ul>
<li>格式：<code>groupadd [参数] &lt;用户组名&gt;</code><ul>
<li><code>-g</code>：指定用户组ID</li>
<li><code>-o</code>：允许组ID号不唯一</li>
</ul>
</li>
</ul>
<p><code>groupmod</code>命令：修改指定用户组的属性（超级用户可用）</p>
<ul>
<li>格式：groupmod [参数] &lt;用户组名&gt;<ul>
<li><code>-g</code>：指定新的用户组ID</li>
<li><code>-n</code>：指定新的用户组名字</li>
<li><code>-o</code>： 允许组ID号不唯一</li>
</ul>
</li>
</ul>
<p><code>groupdel</code>命令：删除指定的用户组（超级用户可用）</p>
<ul>
<li>格式：<code>groupdel &lt;用户组名&gt;</code></li>
<li>注意：在删除指定用户组之前必须保证该用户组不是任何用户的主要组群，否则要先删除以此用户组为主要组群的用户才可以删除该用户组</li>
</ul>
<hr>
<p><strong>文件权限</strong></p>
<ul>
<li>读取权限：浏览文件/目录中内容的权限</li>
<li>写入权限：<ul>
<li>对文件而言是修改文件内容的权限</li>
<li>对目录而言是删除、添加和重命名目录内文件的权限</li>
</ul>
</li>
<li>执行权限：<ul>
<li>对可执行文件而言是允许执行的权限</li>
<li>对目录而言是进入目录的权限。</li>
</ul>
</li>
</ul>
<p><strong>文件用户分类</strong>：</p>
<ul>
<li>文件所有者：建立文件和目录的用户</li>
<li>文件所有者所在组用户：文件所有者所属用户组中的其他用户</li>
<li>其他用户：既不是文件所有者，又不是文件所有组所在组的其他所有用户</li>
<li>超级用户：负责整个系统的管理和维护，拥有系统中所有文件的全部访问权限。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220405225155321.png" alt="image-20220405225155321" style="zoom: 80%;" /></p>
<hr>
<p><code>chmod</code>命令：修改文件的访问权限</p>
<ul>
<li>格式：<code>chmod &lt;模式&gt; &lt;文件&gt;</code><ul>
<li>模式：<ul>
<li>对象：<code>u</code> 文件所有者 、<code>g</code> 同组用户、<code>o</code>其他用户</li>
<li>操作符：<code>+</code>增加、<code>-</code>删除、<code>=</code>赋予</li>
<li>权限：<code>r</code> 读、<code>w</code> 写、<code>x</code> 执行、<code>s</code>设置用户ID</li>
</ul>
</li>
</ul>
</li>
<li>举例：<ul>
<li>取消同组用户对file文件的写入权限 <code>chmod g-w file</code></li>
<li>将pict目录的访问权限设置为775 <code>chmod 775 pict</code></li>
<li>设置file文件的设置用户ID位 <code>chmod u+s file</code></li>
</ul>
</li>
</ul>
<p><code>chown</code>命令：将指定文件的拥有者改为指定的用户或用户组</p>
<ul>
<li>格式：<code>chown [选项] &lt;所有者/组&gt; &lt;文件&gt;...</code><ul>
<li><code>-c</code> ：显示更改的部分的信息</li>
<li><code>-f</code> ：忽略错误信息</li>
<li><code>-h</code> ：修复符号链接</li>
<li><code>-R</code> ：处理指定目录以及其子目录下的所有文件</li>
<li><code>-v</code> ：显示详细的处理信息</li>
<li><code>-deference</code> ：作用于符号链接的指向，而不是链接文件本身</li>
<li>用户是用户名或者用户ID，用户组可以是组名或者组ID</li>
<li>文件是以空格分开的要改变权限的文件列表，支持通配符</li>
</ul>
</li>
<li>举例：将<code>ex1</code>的所有者由root改为hellen：<code>chown hellen ex1</code></li>
</ul>
<p><code>chgrp</code>命令：改变文件的所属用户组</p>
<ul>
<li>格式：<code>chgrp [选项] &lt;组&gt; &lt;文件&gt;</code><ul>
<li><code>-c</code> ：显示更改的部分的信息</li>
<li><code>-f</code> ：忽略错误信息</li>
<li><code>-h</code> ：修复符号链接</li>
<li><code>-R</code> ：处理指定目录以及其子目录下的所有文件</li>
<li><code>-v</code> ：显示详细的处理信息</li>
<li><code>-deference</code> ：作用于符号链接的指向，而不是链接文件本身</li>
<li>用户组可以是组名或者组ID</li>
</ul>
</li>
<li>举例：将ex1文件所属的用户组由root改为staff：<code>chgrp staff ex1</code></li>
</ul>
<h3 id="编译调试方法"><a href="#编译调试方法" class="headerlink" title="编译调试方法"></a>编译调试方法</h3><h4 id="gcc概述"><a href="#gcc概述" class="headerlink" title="gcc概述"></a><strong>gcc概述</strong></h4><p>gcc是GNU计划的一个项目。是一个自由编译器，如今的gcc已经是一个包含众多语言的编译器了（ C，C++，Ada，Object C，Java及Go等）。所以，GCC也由原来的GNU C Compiler变为<br>GNU Compiler Collection</p>
<p>GCC主要包括:</p>
<ul>
<li><code>cpp</code>(预处理器)</li>
<li><code>gcc</code>(c编译器)、<code>g++</code>(c++编译器)等编译器</li>
<li><code>binutils</code>等二进制工具.<ul>
<li><code>as</code>(汇编器)</li>
<li><code>ld</code>(链接器)</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>源文件-》预处理-》编译-》汇编-》链接-》可执行</strong></p>
<ul>
<li><code>cpp -o hello.i hello.c</code></li>
<li><code>ccl -o hello.s hello.i</code></li>
<li><code>as -o hello.o hello.s</code></li>
<li><code>ld -o hello hello.o</code></li>
</ul>
<hr>
<p><strong>gcc基础使用方法：</strong></p>
<ul>
<li>gcc命令格式：<code>gcc [选项] &lt;文件名&gt;</code><ul>
<li><code>-o filename</code> ：指定输出文件为filename.该选项不在乎gcc产生什么输出，无论是可执行文件，目标文件，汇编文件还是预处理后的C代码</li>
<li>如果没有使用<code>-o</code>选项,默认的输出结果是:可执行文件为<code>a.out</code>，编译后产生的目标文件是<code>sourcename.o</code>，汇编文件是 <code>sourcename.s</code>，而预处理后的C源代码送往标准输出 </li>
</ul>
</li>
<li>对于源代码<code>main.c</code>，可以通过如下命令编译成最终可执行文件（默认包含了预处理、编译、汇编及链接四个阶段）：<code>gcc main.c –o main</code></li>
</ul>
<p><strong>gcc常用编译选项</strong>：</p>
<ul>
<li><code>-D</code>: 宏定义选项，等同于代码中的<code>#define MACRO</code> ，但<code>-D</code>定义的宏作用于所有的源文件。<ul>
<li><code>#define PI 3.14159</code>(如果程序用到PI则用3.14159代替)</li>
<li><code>gcc -DPI=3.14159 main.c</code>（但如果没有定义宏的话，就可以直接在编译的时候赋值再运行）</li>
</ul>
</li>
<li><p><code>-I</code> 头文件的搜索路径:如果用户的头文件不在gcc的搜索路径中，可以用此选项指定额外搜索路径。</p>
<ul>
<li><code>gcc helloworld.c –I /usr/include –o helloworld</code>（将<code>/usr/inlcude</code>加入到文件头文件的搜索路径中）</li>
</ul>
</li>
<li><p>警告选项</p>
<ul>
<li>警告是针对程序结构的诊断信息,程序不一定有错误,而是存在风险,或者可能存在错误。</li>
<li>所有以<code>-W</code>开头的选项基本上均可使用<code>-Wno-option</code>来关闭该警告信息</li>
<li>如<code>-Wunused</code>在某个局部变量除了声明就没再使用,或者声明了静态函数但是没有定义,或者某条语句的运算结果显然没有使用时, 编译器就发出警告。使用<code>`-Wno-unused</code>可禁止该警告信息。</li>
<li><code>-w</code> ：禁止所有警告信息. </li>
<li><code>-Wall</code>：打开所有警告选项，输出警告信息</li>
<li>通常建议打开<code>-Wall</code>，这样至少可以看出你的代码里有哪些地方可能存在问题</li>
</ul>
</li>
</ul>
<p><strong>静态库编译和使用</strong>：</p>
<ul>
<li>把 <code>.c</code>编译成 <code>.o</code>：  <code>gcc –c increase.c –o increase.o</code></li>
<li>把 <code>.o</code>归档成 静态库<code>.a</code> ：<code>ar –r libincrease.a increase.o</code></li>
<li>静态库和其它源文件链接成可执行文件：<code>gcc main.c –L –static –o main</code></li>
</ul>
<p><strong>动态库编译</strong>：</p>
<ul>
<li>生成动态链接库：<code>gcc -shared -fPIC -o libinc.so increase.c</code><ul>
<li>动态链接库的名字必须以<code>lib</code>开头 <code>.so</code>结束，这是linux系统上的强制约束，否则无法使用该共享库</li>
<li><code>-shared</code> 生成共享文件</li>
<li><code>-fPIC</code> 生成位置独立的代码，此类代码可以在不同进程间共享。</li>
</ul>
</li>
</ul>
<p><strong>动态库的使用</strong>：</p>
<ul>
<li><code>-l library</code> 名字为library的动态链接库。事实上此动态链接库在文件系统中的名字为liblibrary .so。连接器会自动加上lib*.so。</li>
<li><code>-L dir</code> 共享库搜索目录。gcc除了会在自定义的目录中搜索共享库外，用户也自定义目录让gcc搜索。<code>gcc main.c -o main -linc -L./</code></li>
</ul>
<h4 id="gdb概述"><a href="#gdb概述" class="headerlink" title="gdb概述"></a><strong>gdb概述</strong></h4><p>gdb是GNU计划开发的程序调试工具</p>
<p>gdb可以完成以下四个方面的功能：</p>
<ul>
<li>启动程序，可以按照自定义的要求随心所欲的运行程序</li>
<li>可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式）</li>
<li>当程序被停住时，可以检查此时程序中所发生的情况</li>
<li>动态的改变程序的执行环境</li>
</ul>
<p><strong>gdb的启动</strong>：</p>
<ul>
<li>直接在shell中运行<code>gdb</code>命令，进入gdb界面后用<code>file program</code>装载程序。</li>
<li>在shell中启动gdb并加载可执行文件<code>gdb &lt;program&gt;</code></li>
<li>用gdb同时调试一个运行程序和core文件（core是程序非法执行后core dump后产生的文件）<code>gdb program core</code></li>
<li>调试正在运行的进程<code>gdb program &lt;processid&gt;</code><ul>
<li>进入gdb后用 <code>attach &lt;processid&gt;</code> 调试正在运行的进程。</li>
</ul>
</li>
</ul>
<p><strong>gdb常用命令</strong>：</p>
<p><code>break</code>命令：</p>
<ul>
<li>功能：断点设置命令<code>break</code>(缩写 <code>b</code>)，当gdb执行到该断点时会让程序暂停运行。此时程序员可以查看运行中程序的情况。</li>
<li>格式：<code>break [LOCATION] [thread THREADNUM] [if CONDITION]</code><ul>
<li><code>[LOCATION]</code>：<ul>
<li><code>linenum</code>（行号），如<code>b 123</code></li>
<li><code>function</code>(函数名) ，如<code>b main</code></li>
<li><code>filename:linenum</code>，如<code>b increase:123</code></li>
<li><code>filename:function</code>，如<code>b increase:main</code></li>
<li>class:function（c++）</li>
</ul>
</li>
<li><code>[thread THREADNUM]</code> 调试多线程程序时，切换到哪个线程或者在那个线程中设置断点。<code>break frik.c:13 thread 28</code> </li>
<li><code>[if CONDITION]</code>： 当条件满足时，断点才生效。一般称为条件断点。CONDITION跟C语言一样。<ul>
<li><code>b 123 if index==2</code>当index为2时，程序在123行停下</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>watchpoint</code>命令：</p>
<ul>
<li><code>watchpoint</code>称为观察点，当观察对象的值有变化时，程序立即停止执行。</li>
<li><code>watch &lt;expr&gt;</code> ：为表达式（变量）expr设置一个观察点。一旦表达式值有变化时，马上停住程序。</li>
<li><code>rwatch &lt;expr&gt;</code> ：当表达式（变量）expr被读时，停住程序。</li>
<li><code>awatch &lt;expr&gt;</code> ：当表达式（变量）的值被读或被写时，停住程序。</li>
<li><code>info watchpoints</code> ：列出当前所设置了的所有观察点</li>
</ul>
<p>清除禁止断点或观察点：</p>
<ul>
<li><code>clear [linenum] [function name]</code> 清除所有断点，不会清除watchpoints</li>
<li><code>delete &lt;num&gt;</code> 清除编号为num的断点或者watchpoint</li>
<li><code>disable &lt;num&gt;</code> 禁止某个断点</li>
<li><code>enable &lt;num&gt;</code> 开启某个断点</li>
</ul>
<p>gdb调试命令：</p>
<ul>
<li><code>step</code> 单步调试命令，一次执行一行程序。</li>
<li><code>next</code> 单步调试命令，但跳过函数调用。</li>
<li><code>finish</code> 单步调试时直接从一个函数中返回</li>
<li><code>disassemble</code> 显示汇编代码。</li>
<li><code>backtrace</code>或者<code>bt</code> 查看目前程序的堆栈情况。</li>
<li><code>where</code>查看当前位置。</li>
<li><code>up/down</code> 向上或者向下移动一个堆栈。</li>
<li><code>frame&lt;num&gt;</code>或者<code>f</code> 移动到第num个堆栈。</li>
<li>当移动到某个堆栈时，便可以用gdb命令查看在那个堆栈中的局部变量。</li>
</ul>
<h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><h3 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h3><p>文件系统是以合理有效的层次结构组织的文件和目录的集合</p>
<p>“<strong>一切皆是文件</strong>”是 Unix/Linux 的基本哲学之一</p>
<p>普通文件、目录、字符设备、块设备、 套接字等在 Unix/Linux 中都是文件</p>
<p>类型不同的文件都是通过<strong>相同的API</strong>对其进行操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406135159849.png" alt="image-20220406135159849" style="zoom:80%;" /></p>
<p>Unix/Linux 中允许不同的文件系统共存，如 ext2, ext3, ext4, xfs, btrfs 等</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406135301992.png" alt="image-20220406135301992" style="zoom:67%;" /></p>
<p>通过统一的文件 I/O 系统调用API即可对系统中的任意文件进行操作而无需考虑其所在的具体文件系统格式</p>
<p>文件操作可以跨文件系统执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406135352137.png" alt="image-20220406135352137" style="zoom:67%;" /></p>
<p><strong>与windows文件系统的区别</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406135433630.png" alt="image-20220406135433630" style="zoom:67%;" /></p>
<h3 id="文件系统架构"><a href="#文件系统架构" class="headerlink" title="文件系统架构"></a>文件系统架构</h3><p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406135923462.png" alt="image-20220406135923462"></p>
<h3 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h3><p><strong>虚拟文件系统VFS</strong></p>
<ul>
<li>虚拟文件系统是Linux 内核中的一个软件层，对内实现文件系统的抽象，允许不同的文件系统共存，对外向应用程序提供统一的文件系统接口</li>
<li>为了能够支持不同文件系统，VFS 定义了所有文件系统都支持的基本的、抽象的接口和<strong>数据结构</strong></li>
<li>实际文件系统实现VFS 定义的抽象接口和数据结构，将自身的诸如文件、目录等概念在形式上与VFS的定义保持一致，在统一的接口和数据结构下隐藏了具体的实现细节</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406140531667.png" alt="image-20220406140531667" style="zoom:67%;" /></p>
<p><strong>VFS中的数据结构：</strong></p>
<ul>
<li><strong>超级块（super block）</strong>：用于存储文件系统的控制信息的数据结构。描述文件系统的状态、文件系统类型、大小、区块数、索引节点数等，存放于磁盘的特定扇区中。</li>
<li><strong>索引节点（inode）</strong>：用于存储文件的元数据（文件的基本信息）的一个数据结构，包含诸如文件的大小、拥有者、创建时间、磁盘位置等信息。</li>
<li><strong>目录项（dentry）</strong>：目录被用来容纳文件，目录可以包含子目录，层层嵌套以形成文件路径。</li>
<li><strong>文件对象（file）</strong>：一组在逻辑上具有完整意义的信息项的系列</li>
</ul>
<p><strong>VFS-超级块（super block</strong>）：</p>
<ul>
<li>超级块用来描述整个文件系统的信息。每个具体的文件系统都有各自的超级块</li>
<li>VFS超级块是各种具体文件系统在安装时建立的，并在卸载时被自动删除，其数据结构是<code>super_block</code></li>
<li>所有超级块对象以双向环形链表的形式链接在一起</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406140929967.png" alt="image-20220406140929967" style="zoom:80%;" /></p>
<p><strong>VFS-索引节点（inode）</strong>：</p>
<ul>
<li>文件系统处理文件所需要的所有信息都放在称为索引节点的数据结构inode中</li>
<li>具体文件系统的索引节点是存放在磁盘上的，是一种<strong>静态结构</strong>，要使用它，必须调入内存，填写VFS的索引节点，因此，也称VFS索引节点是<strong>动态节点</strong></li>
<li>文件名可以随时更改，但是索引节点对文件是唯一的，并且随文件的存在而存在</li>
<li>每个inode节点的大小，一般是128字节或256字节</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406141107311.png" alt="image-20220406141107311" style="zoom:80%;" /></p>
<p><strong>VFS-目录项对象（dentry）</strong>：</p>
<ul>
<li>每个文件除了有一个索引节点inode数据结构外，还有一个目录项dentry数据结构。</li>
<li>dentry结构代表的是逻辑意义上的文件，描述的是文件逻辑上的属性，目录项对象在磁盘上并没有对应的映像</li>
<li>inode结构代表的是物理意义上的文件，记录的是物理上的属性，对于一个具体的文件系统，其inode结构在磁盘上就有对应的映像</li>
<li>一个索引节点对象可能对应多个目录项对象</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406143746728.png" alt="image-20220406143746728"></p>
<p><strong>VFS-文件对象（file）</strong>：</p>
<ul>
<li>进程是通过文件描述符来访问文件的</li>
<li>Linux中专门用了一个<code>file</code>文件对象来保存打开文件的文件位置，这个对象称为打开的文件描述（open file description）</li>
<li>文件描述符是用来描述打开的文件的。每个进程用一个<code>files_struct</code>结构来记录文件描述符的使用情况，这个files_struct结构称为用户打开文件表，它是进程的私有数据</li>
<li>file结构中主要保存了文件位置，此外，还把指向该文件索引节点的指针也放在其中。file结构形成一个双链表，称为系统打开文件表。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406143935113.png" alt="image-20220406143935113"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406143948216.png" alt="image-20220406143948216"></p>
<p><strong>VFS数据结构之间的关系</strong></p>
<ul>
<li>超级块是对一个文件系统的描述</li>
<li>索引节点是对一个文件物理属性的描述</li>
<li>目录项是对一个文件逻辑属性的描述</li>
<li>一个进程所处的位置是由<code>fs_struct</code>来描述的，而一个进程（或用户）打开的文件是由<code>files_struct</code>来描述的，而整个系统所打开的文件是由<code>file</code>结构来描述</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406150131249.png" alt="image-20220406150131249"></p>
<h3 id="文件系统的注册和注销"><a href="#文件系统的注册和注销" class="headerlink" title="文件系统的注册和注销"></a>文件系统的注册和注销</h3><ul>
<li>当内核被编译时，就已经确定了可以支持哪些文件系统，这些文件系统在系统引导时，在 VFS 中进行注册。</li>
<li>VFS的初始化函数用来向VFS注册，即填写文件注册表<code>file_system_type</code>数据结构</li>
<li>注册调用<code>register_filesystem()</code>函数</li>
<li>注销即删除一个<code>file_system_type</code> 结构，需调用 <code>unregister_filesystem()</code>函数</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406150315979.png" alt="image-20220406150315979" style="zoom:67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406150416375.png" alt="image-20220406150416375" style="zoom:67%;" /></p>
<h3 id="文件系统的安装"><a href="#文件系统的安装" class="headerlink" title="文件系统的安装"></a>文件系统的安装</h3><ul>
<li>安装一个文件系统实际上是安装一个物理设备</li>
<li>自己（一般是超级用户）安装文件系统时，需要指定三种信息：文件系统的名称、包含文件系统的物理块设备、文件系统在已有文件系统中的安装点。</li>
<li><code>$ mount -t iso9660 /dev/hdc /mnt/cdrom</code> 其中，<code>iso9660</code>是光驱文件系统的名称，<code>/dev/hdc</code>是包含文件系统的物理块设备，<code>/mnt/cdrom</code>就是将要安装到的目录，即安装点。</li>
<li>在用户程序中要安装一个文件系统则可以调用<code>mount()</code>系统调用。安装过程主要工作是创建安装点对象，将其挂接到根文件系统的指定安装点下，然后初始化超级块对象，从而获得文件系统基本信息和相关的操作。</li>
</ul>
<h3 id="文件系统的卸载"><a href="#文件系统的卸载" class="headerlink" title="文件系统的卸载"></a>文件系统的卸载</h3><ul>
<li>如果文件系统中的文件当前正在使用，该文件系统是不能被卸载的</li>
<li>查看对应的 VFS 超级块，如果该文件系统的 VFS 超级块标志为“脏”，则必须将超级块信息写回磁盘</li>
<li>之后，对应的 VFS 超级块被释放，vfsmount 数据结构将从vfsmntlist 链表中断开并被释放</li>
<li>具体的实现代码为<code>fs/super.c</code>中的<code>sys_umount()</code>函数</li>
</ul>
<h2 id="文件IO操作"><a href="#文件IO操作" class="headerlink" title="文件IO操作"></a>文件IO操作</h2><p>系统调用：操作系统提供给用户程序调用的一组“特殊”接口，用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406152559930.png" alt="image-20220406152559930" style="zoom: 50%;" /></p>
<p>Q：为什么用户程序不能直接访问系统内核提供的服务？</p>
<p>A：为了更好地保护内核空间，将程序的运行空间分为内核空间和用户空间（也就是常称的内核态和用户态），它们分别运行在不同的级别上，在逻辑上是相互隔离的。因此，用户进程在通常情况下不允许访问内核数据，也无法使用内核函数，它们只能在用户空间操作用户数据，调用用户空间的函数。</p>
<p>进行系统调用时，程序运行空间从用户空间进入内核空间，处理完后再返回到用户空间</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406152730069.png" alt="image-20220406152730069" style="zoom:67%;" /></p>
<p>系统调用并不是直接与程序员进行交互的，它仅仅是一个通过<strong>软中断机制</strong>向内核提交请求，以获取内核服务的接口。</p>
<p>在实际使用中程序员调用的通常是用户编程接口——API</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406152820289.png" alt="image-20220406152820289" style="zoom:50%;" /></p>
<p>Linux中的系统调用包含在Linux的libc库中，通过标准的C函数调用方法可以调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406152854242.png" alt="image-20220406152854242" style="zoom: 67%;" /></p>
<p><strong>系统命令</strong>相对API更高了一层，它实际上是一个可执行程序，它的内部调用了用户编程接口（API）来实现相应的功能</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406152959593.png" alt="image-20220406152959593" style="zoom:67%;" /></p>
<p><strong>文件描述符</strong>：</p>
<p>Q：内核如何区分和引用特定的文件？</p>
<p>A：通过<strong>文件描述符</strong>。文件描述符是一个非负的整数，它是一个索引值，并指向在内核中每个进程打开文件的记录表。当打开一个现存文件或创建一个新文件时，内核就向进程返回一个文件描述符；当需要读写文件时，也需要把文件描述符作为参数传递给相应的函数。</p>
<p>一个进程启动时，通常会打开3个文件：</p>
<ul>
<li>标准输入 描述符为0</li>
<li>标准输出 描述符为1</li>
<li>标准出错处理 描述符为2</li>
</ul>
<p><strong>文件IO函数</strong></p>
<ul>
<li><code>open()</code> 用于打开或创建文件，可以指定文件的属性及用户的权限等各种参数</li>
<li><code>creat()</code> 打开一个文件，如果文件不存在，则创建它</li>
<li><code>close()</code> 用于关闭一个被打开的文件。当一个进程终止时，所有被它打开的文件都由内核自动关闭，很多程序都使用这一功能而不显示地关闭一个文件</li>
<li><code>read()</code> 用于将从指定的文件描述符中读出的数据放到缓存区中，并返回实际读入的字节数。若返回0，则表示没有数据可读，即已达到文件尾。读操作从文件的当前指针位置开始</li>
<li><code>write()</code>  用于向打开的文件写数据，写操作从文件的当前指针位置开始。对磁盘文件进行写操作，若磁盘已满或超出该文件的长度，则write()函数返回失败</li>
</ul>
<hr>
<h3 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h3><p>头文件</p>
<ul>
<li><code>#include &lt;sys/types.h&gt;</code></li>
<li><code>#include &lt;sys/stat.h&gt;</code></li>
<li><code>#include &lt;fcntl.h&gt;</code></li>
</ul>
<p>函数原型</p>
<ul>
<li><code>int open(const char* pathname, int flags);</code></li>
<li><code>int open(const char* pathname, int flags, mode_t mode);</code></li>
</ul>
<p>函数说明</p>
<ul>
<li>参数<code>pathname</code> 指向欲打开的文件路径字符串。</li>
<li>下列是参数<code>flags</code> 常用的标识:<ul>
<li><code>O_RDONLY</code> 以<strong>只读</strong>方式打开文件</li>
<li><code>O_WRONLY</code> 以<strong>只写</strong>方式打开文件</li>
<li><code>O_RDWR</code> 以<strong>可读写</strong>方式打开文件。上述三种标识是互斥的，也就是不可同时使用，但可与下列的标识利用OR(|)运算符组合。</li>
<li><code>O_CREAT</code> 若欲打开的文件<strong>不存在则自动建立</strong>该文件。</li>
<li><code>O_TRUNC</code> 若文件存在并且以可写的方式打开时，此标识会<strong>令文件长度清为0</strong>，而原来存于该文件的资料也会消失。</li>
<li><code>O_APPEND</code> 当读写文件时会从文件尾开始移动，也就是所写入的数据会以<strong>附加</strong>的方式加入到文件后面。</li>
<li><code>O_NONBLOCK</code> 以不可阻断的方式打开文件，也就是无论有无数据读取或等待，都会立即返回进程之中。</li>
<li><code>O_EXCL</code>: 如果同时指定 O_CREAT，而该文件又是存在的，报错；也可以测试一个文件是否存在，不存在则创建。</li>
</ul>
</li>
<li>返回值：文件打开成功返回文件的描述符，失败返回-1</li>
</ul>
<h3 id="creat函数"><a href="#creat函数" class="headerlink" title="creat函数"></a>creat函数</h3><p>头文件</p>
<ul>
<li><code>#include&lt;sys/types.h&gt;</code></li>
<li><code>#include&lt;sys/stat.h&gt;</code></li>
<li><code>#include&lt;fcntl.h&gt;</code></li>
</ul>
<p>函数原型</p>
<ul>
<li><code>int creat(const char * pathname, mode_t mode)</code></li>
</ul>
<p>参数说明</p>
<ul>
<li>参数<code>pathname</code>指向欲建立的文件路径字符串。</li>
<li><code>creat()</code>相当于使用下列的调用方式调用<code>open(const char * pathname ,(O_CREAT|O_WRONLY|O_TRUNC))</code></li>
</ul>
<p>返回值</p>
<ul>
<li><code>creat()</code>会返回新的文件描述词，若有错误发生则会返回-1，并把错误代码设给errno</li>
</ul>
<p>附加说明</p>
<ul>
<li><code>creat</code>函数的一个不足之处是它以<strong>只写</strong>方式打开所创建的文件</li>
</ul>
<h3 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h3><p>头文件</p>
<ul>
<li><code>#include&lt;unistd.h&gt;</code></li>
</ul>
<p>函数原型</p>
<ul>
<li><code>int close(int fd);</code></li>
</ul>
<p>函数说明</p>
<ul>
<li>当使用完文件后若已不再需要则可使用close()关闭该文件，close()会让数据写回磁盘，并释放该文件所占用的资源。</li>
<li>参数<code>fd</code>为先前由open()或creat()所返回的文件描述符;</li>
<li>返回值：若文件顺利关闭则返回0，发生错误时返回-1。</li>
<li>附加说明：虽然在进程结束时，系统会自动关闭已打开的文件，但仍建议自行关闭文件，并检查返回值。</li>
</ul>
<h3 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h3><p>头文件</p>
<ul>
<li><code>#include&lt;unistd.h&gt;</code></li>
</ul>
<p>定义函数</p>
<ul>
<li><code>ssize_t read(int fd, void * buf, size_t count);</code></li>
</ul>
<p>函数说明</p>
<ul>
<li><code>read()</code>会把参数<code>fd</code> 所指的文件传送<code>count</code>个字节到<code>buf</code>指针所指的内存中。</li>
<li>若参数<code>count</code>为0，则<code>read()</code>不会有作用并返回0。</li>
<li>返回值为实际读取到的字节数，如果返回0，表示已到达文件尾或是无可读取的数据，此外文件读写位置会随读取到的字节移动;</li>
<li>返回值：成功返回读取的字节数，出错返回-1</li>
</ul>
<p><code>read</code>函数实际读到的字节数少于要求读的字节数时：</p>
<ul>
<li>读普通文件，在读到要求字节数之前就到达文件尾</li>
<li>当从终端设备读，通常一次最多读一行；</li>
<li>当从网络读时，网络中的缓冲机构可能造成返回值小于所要求读的字节数；</li>
<li>某些面向记录的设备，如磁带，一次最多返回一个记录；</li>
</ul>
<p>读操作完成后，文件的当前位置将从读之前的位置加上实际读的字节数</p>
<p>当有错误发生时则返回-1，错误代码存入errno中，而文件读写位置则无法预期</p>
<h3 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h3><p>头文件</p>
<ul>
<li><code>#include&lt;unistd.h&gt;</code></li>
</ul>
<p>函数原型</p>
<ul>
<li><code>ssize_t write (int fd, const void * buf, size_t count);</code> </li>
</ul>
<p>函数说明</p>
<ul>
<li><code>write()</code>会把参数<code>buf</code>所指的内存写入<code>count</code>个字节到参数<code>fd</code>所指的文件内。当然，文件读写位置也会随之移动;</li>
<li>返回值：如果顺利<code>write()</code>会返回实际写入的字节数。当有错误发生时则返回<code>-1</code>，错误代码存入<code>errno</code>中。</li>
<li><code>write</code>出错的原因可能是磁盘满、没有访问权限、或写超过文件长度限制等等</li>
<li>附加说明：将数据写入已打开的文件内。对于普通文件，写操作从文件当前位置开始写（除非打开文件时指定了<code>O_APPEND</code>选项）。写操作完成后，文件的当前位置将从写之前的位置加上实际写的字节数。</li>
</ul>
<p><font color=#ff0000>注意：</font>数据无法一次性读完时：</p>
<ul>
<li>第二次读<code>buf</code>中数据时，读位置指针并不会自动移动</li>
<li>按如下格式实现读位置移动：<code>write(fp, p1+len, (strlen(p1)-len)</code>，直至指针恢复</li>
</ul>
<p>Write一次可以写的最大数据范围是<code>8192</code></p>
<ul>
<li>写入数据大小最好小于buff中的值</li>
<li>Count参数值大于<code>SSIZE_MAX</code>，则<code>write</code>调用的结果未定义</li>
<li>Count参数值为0时，write调用会立即返回0这个值</li>
<li>Write调用返回时，内核已经将缓冲区所提供的数据复制到内核的缓冲区，但是无法保证数据已经写出到预定的目的地</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_PATH <span class="meta-string">&quot;./test.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>((fd = open(FILE_PATH, O_RDWR | O_CREAT | O_EXCL, <span class="number">0666</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>); <span class="comment">//test.txt文件存在的话会报错</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open success\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入内容到test.txt文件中\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>]; </span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">if</span> ((num = read(STDIN_FILENO, buf, <span class="number">200</span>)) == <span class="number">-1</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;read error&quot;</span>); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>); </span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// 将键盘输入又输出到屏幕上</span></span><br><span class="line">		write(STDOUT_FILENO, buf, num);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将键盘输入 分两次 输出到test.txt文件</span></span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((front = write(fd, buf, <span class="number">10</span>)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write %d Bytes\n&quot;</span>, front);</span><br><span class="line">        <span class="keyword">if</span>((front = write(fd, buf+<span class="number">10</span>, num<span class="number">-10</span>)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write %d bytes\n&quot;</span>, front);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题：怎么会读不到test.txt文件中的内容呢？</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">if</span>((fd = open(<span class="string">&quot;./test.txt&quot;</span>, O_RDONLY) == <span class="number">-1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open success\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd = %d\n&quot;</span>, fd);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = read(fd, buf, <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read %d bytes\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">        num = read(fd, buf, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read %d bytes\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ioctl函数"><a href="#ioctl函数" class="headerlink" title="ioctl函数"></a>ioctl函数</h3><p>设备驱动程序中对设备的I/O通道进行管理</p>
<p>头文件</p>
<ul>
<li><code>#include&lt;sys/ioctl.h&gt;</code></li>
</ul>
<p>定义函数</p>
<ul>
<li><code>int ioctl(int fd, int cmd, ...);</code></li>
</ul>
<p>函数说明</p>
<ul>
<li><code>ioctl()</code>能对一些特殊的文件(主要是设备)进行一些底层参数的操作。许多字符设备都使用ioctl请求来完成对设备的控制;</li>
<li>返回值：成动返回0。当有错误发生时则返回-1，错误代码存入errno中</li>
<li>附加说明：ioctl是设备驱动程序中对设备的I/O通道进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406165728902.png" alt="image-20220406165728902"></p>
<p>在驱动程序中实现的ioctl函数体内，实际上是有一个<code>switch&#123;case&#125;</code>结构，每一个case对应一个<strong>命令码</strong>，做出一些相应的操作</p>
<p>ioctl中命令码是唯一联系用户程序命令和驱动程序支持的途径</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220406165833211.png" alt="image-20220406165833211" style="zoom:67%;" /></p>
<p>“幻数”是一个字母，数据长度也是8，用一个特定的字母来标明设备类型</p>
<h2 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h2><p>为什么要设计标准I/O库？</p>
<ul>
<li>直接使用API进行文件访问时，需要考虑许多细节问题，例如：read、write时，缓冲区的大小该如何确定，才能使效率最优</li>
<li>read和write等底层系统调用函数进行输入输出时，在用户态和内核态之间来回切换，每次读出或写入的数据量较少，导致频繁的I/O操作，增加了系统开销</li>
</ul>
<p>标准I/O库是ANSI C规范的一部分，函数原型在文件<code>stdio.h</code>中定义，对底层I/O系统调用进行了封装，为程序员提供了带有格式转换功能的输入输出操作，并在用户空间增加了缓冲区管理</p>
<p><strong>标准I/O库</strong>：</p>
<ul>
<li>分离了应用程序空间和实际的物理设备</li>
<li>减少了直接读盘次数，提高性能<ul>
<li>读取前查看是否已存在页缓存中，如果已经存放在了页缓存中，数据立即返回给应用程序</li>
<li>写数据前先写到页缓存中，如果用户采用的是同步写机制（synchronous writes），那么数据会立即被写回到磁盘上，应用程序会一直等到数据被写完为止；如果用户采用的是延迟写机制（ deferred writes ），那么应用程序就完全不需要等到数据全部被写回到磁盘，数据只要被写到页缓存中去就可以了</li>
</ul>
</li>
</ul>
<h3 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h3><p>fopen函数功能：打开一个指定文件</p>
<p>函数原型</p>
<ul>
<li><code>FILE *fopen(const char *restrict pathname, const char *restrict type);</code></li>
</ul>
<p>参数</p>
<ul>
<li><code>pathname</code>：要打开的文件名 </li>
<li><code>type</code>：指定文件的读、写方式</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">type</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r或rb</td>
<td style="text-align:center">为读而打开</td>
</tr>
<tr>
<td style="text-align:center">w或wb</td>
<td style="text-align:center">使文件长度为0，或为写而创建</td>
</tr>
<tr>
<td style="text-align:center">a或ab</td>
<td style="text-align:center">追加文件内容，或为写而创建</td>
</tr>
<tr>
<td style="text-align:center">r+或r+b或rb+</td>
<td style="text-align:center">为读写而打开</td>
</tr>
<tr>
<td style="text-align:center">w+或w+b或wb+</td>
<td style="text-align:center">使文件长度为0，或为读写而打开或创建</td>
</tr>
<tr>
<td style="text-align:center">a+或a+b或ab+</td>
<td style="text-align:center">在文件尾读写而打开或创建</td>
</tr>
</tbody>
</table>
</div>
<h3 id="setbuf函数"><a href="#setbuf函数" class="headerlink" title="setbuf函数"></a>setbuf函数</h3><p>  定义流 stream 应如何缓冲</p>
<p>函数原型</p>
<ul>
<li><code>void setbuf(FILE *steam, char *buf);</code></li>
</ul>
<p>参数</p>
<ul>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。</li>
<li><strong>buffer</strong> — 这是分配给用户的缓冲，它的长度至少为 <code>BUFSIZ</code> 字节，<code>BUFSIZ</code> 是一个宏常量，表示数组的长度。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">   setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;This is runoob&quot;</span>);</span><br><span class="line"></span><br><span class="line">   fflush(<span class="built_in">stdout</span>);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-setbuf.html">C 库函数 – setbuf() | 菜鸟教程 (runoob.com)</a></p>
<h3 id="setvbuf函数"><a href="#setvbuf函数" class="headerlink" title="setvbuf函数"></a>setvbuf函数</h3><p>函数原型</p>
<ul>
<li><code>void setvbuf(FILE *steam, char *buf, int mode, size_t size);</code></li>
</ul>
<p>参数</p>
<ul>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。</li>
<li><strong>buffer</strong> — 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。</li>
<li><strong>mode</strong> — 这指定了文件缓冲的模式：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">_IOFBF</td>
<td style="text-align:left"><strong>全缓冲</strong>：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。</td>
</tr>
<tr>
<td style="text-align:left">_IOLBF</td>
<td style="text-align:left"><strong>行缓冲</strong>：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。</td>
</tr>
<tr>
<td style="text-align:left">_IONBF</td>
<td style="text-align:left"><strong>无缓冲</strong>：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>size</strong> —这是缓冲的大小，以字节为单位。</li>
</ul>
<p>返回值：如果成功，则该函数返回 0，否则返回非零值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">memset</span>( buff, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>( buff ));</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;启用全缓冲\n&quot;</span>);</span><br><span class="line">   setvbuf(<span class="built_in">stdout</span>, buff, _IOFBF, <span class="number">1024</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;这里是 runoob.com\n&quot;</span>);</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;该输出将保存到 buff\n&quot;</span>);</span><br><span class="line">   fflush( <span class="built_in">stdout</span> );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;这将在编程时出现\n&quot;</span>);</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;最后休眠五秒钟\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   sleep(<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-setvbuf.html">C 库函数 – setvbuf() | 菜鸟教程 (runoob.com)</a></p>
<h3 id="fdopen函数"><a href="#fdopen函数" class="headerlink" title="fdopen函数"></a>fdopen函数</h3><p>函数功能</p>
<ul>
<li>取一个现存的文件描述符，并使一个标准I/O流与该描述符相结合</li>
</ul>
<p>头文件</p>
<ul>
<li><code>#include&lt;stdio.h&gt;</code></li>
</ul>
<p>函数原型</p>
<ul>
<li><code>FILE *fdopen(int fd, const char *type);</code></li>
</ul>
<p>fdopen常用于由创建管道及网络通信通道函数返回的描述符。</p>
<ul>
<li>这些特殊类型的文件，不能用fopen打开</li>
<li>因此必须先调用设备专用函数以获得一个文件描述符，然后再用fdopen使一个标准I/O流与该描述符相关联</li>
</ul>
<p>对于fdopen函数，<code>type</code>参数的意义稍有区别</p>
<ul>
<li>因为该描述符已被打开，所以fdopen为写而打开并不截短该文件</li>
<li>不能用于创建该文件（因为如若一个描述符引用一个文件，则该文件一定已经存在）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Type值</th>
<th>操作文件类型</th>
<th>是否新建文件</th>
<th>是否清空原文件</th>
<th>可读</th>
<th>可写</th>
<th>读写开始位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>文本文件</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
<td>文件开头</td>
</tr>
<tr>
<td>r+</td>
<td>文本文件</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td>文件开头</td>
</tr>
<tr>
<td>w</td>
<td>文本文件</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>文件开头</td>
</tr>
<tr>
<td>w+</td>
<td>文本文件</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>文件开头</td>
</tr>
<tr>
<td>a</td>
<td>文本文件</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>文件结尾</td>
</tr>
<tr>
<td>a+</td>
<td>文本文件</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>文件结尾</td>
</tr>
<tr>
<td>rb</td>
<td>二进制文件</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
<td>文件开头</td>
</tr>
<tr>
<td>r+b或rb+</td>
<td>二进制文件</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td>文件开头</td>
</tr>
<tr>
<td>wb</td>
<td>二进制文件</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>文件开头</td>
</tr>
<tr>
<td>w+b或wb+</td>
<td>二进制文件</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>文件开头</td>
</tr>
<tr>
<td>ab</td>
<td>二进制文件</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>文件结尾</td>
</tr>
<tr>
<td>a+b或ab+</td>
<td>二进制文件</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>文件结尾</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>)) == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fopen file error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;hello word\n&quot;</span>); <span class="comment">//写入文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR)) == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file fail\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fp = fdopen(fd, <span class="string">&quot;a+&quot;</span>)) == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fdopen open\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;linux c program\n&quot;</span>); <span class="comment">//写入文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><h3 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h3><p>lseek函数用于改变文件的当前偏移量。</p>
<p>头文件</p>
<ul>
<li><code>#include&lt;unistd.h&gt;</code></li>
</ul>
<p>定义函数</p>
<ul>
<li><code>off_t lseek(int filedes, off_t offset, int origin);</code></li>
</ul>
<p>函数说明</p>
<ul>
<li><code>filedes</code> 文件描述符</li>
<li><code>offset</code> 必须与origin一同解析</li>
<li><code>origin</code>为 SEEK_SET, 则offset从文件的开头算起。</li>
<li><code>origin</code>为 SEEK_CUR, 则offset从当前位置算起，既新偏移量为当前偏移量加上offset</li>
<li><code>origin</code>为 SEEK_END, 则offset从文件末尾算起。</li>
</ul>
<p>返回值</p>
<ul>
<li>如果失败，返回值为-1</li>
<li>成功返回移动后的文件偏移量。可用<code>lseek</code>确定文件当前偏移量: <code>currpos = lseek(fd, 0, SEEK_CUR)</code></li>
</ul>
<p>lseek常用于找到文件的开头、找到文件的末端，判定文件描述符的当前位置</p>
<p>lseek仅将当前的文件偏移量记录在内核中，它并不引起任何I/O操作，然后该偏移量用于下一次读、写操作。</p>
<p>文件偏移量可以大于文件的当前长度，但并不改变相应的i节点信息。在这种情况下的下一次写将延长该文件，并在文件中构成一个<strong>空洞</strong>，但文件大小并不是文件的最大偏移量。对空洞位置的读操作将返回0。</p>
<p><strong>lseek实现空洞</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	fd=open(<span class="string">&quot;hole.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	write(fd,<span class="string">&quot;hello&quot;</span>,<span class="number">5</span>);</span><br><span class="line">	ret = lseek(fd, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>, SEEK_CUR);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;lseek error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	write(fd,<span class="string">&quot;world&quot;</span>,<span class="number">5</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yang@Ubuntu18~$ gcc lseek_test.c -o lseek_test</span><br><span class="line">yang@Ubuntu18~$ ./lseek_test</span><br><span class="line">yang@Ubuntu18~$ ls -lh hole.txt</span><br><span class="line">-rw-r--r-- 1 yang yang 1.1G Apr  6 20:49 hole.txt</span><br><span class="line">yang@Ubuntu18~$ od -c hole.txt</span><br><span class="line">0000000   h   e   l   l   o  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0</span><br><span class="line">0000020  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0</span><br><span class="line">*</span><br><span class="line">10000000000  \0  \0  \0  \0  \0   w   o   r   l   d</span><br><span class="line">10000000012</span><br><span class="line">yang@Ubuntu18~$ cat hole.txt</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<h3 id="pread函数"><a href="#pread函数" class="headerlink" title="pread函数"></a>pread函数</h3><p>在给定的偏移量读取一个文件描述</p>
<p>头文件</p>
<ul>
<li><code>#include &lt;unistd.h&gt;</code></li>
</ul>
<p>函数原型</p>
<ul>
<li><code>ssize_t pread (int fd, void *buf, size_t count, off_t pos)</code></li>
</ul>
<p>返回值</p>
<ul>
<li>返回读到的字节数；出错：返回-1；到文件结尾：返回0</li>
</ul>
<p>解决问题</p>
<ul>
<li>由于lseek和read调用之间，内核可能会临时挂起进程，所以对同步问题造成了问题，调用<strong>pread相当于顺序调用了lseek 和read</strong>，这两个操作相当于一个<strong>捆绑的原子操作</strong></li>
</ul>
<p>其他</p>
<ul>
<li>调用pread时，无法中断其定位和读操作，另外不更新文件指针</li>
</ul>
<h3 id="pwrite函数"><a href="#pwrite函数" class="headerlink" title="pwrite函数"></a>pwrite函数</h3><p>在给定的偏移量写入一个文件描述符</p>
<p>头文件</p>
<ul>
<li><code>#include&lt;unistd.h&gt;</code></li>
</ul>
<p>函数原型</p>
<ul>
<li><code>ssize_t pwrite (int fd, const void *buf, size_t count, off_t pos )</code></li>
</ul>
<p>返回值</p>
<ul>
<li>返回已写的字节数；出错：返回-1</li>
</ul>
<p>解决问题</p>
<ul>
<li>由于lseek和write 调用之间，内核可能会临时挂起进程，所以对同步问题造成了问题，调用<strong>pwrite相当于顺序调用了lseek 和 write</strong>，这两个操作相当于一个捆绑的原子操作</li>
</ul>
<p>其他</p>
<ul>
<li>调用pwrite时，无法中断其定位和读操作，另外不更新文件指针</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><code>pread/pwrite</code>与<code>read/write</code>的区别</p>
<ul>
<li>调用更容易使用，特别是在进行需要技巧的操作时</li>
<li>完成工作后不会改变文件指针</li>
<li>避免使用lseek时可能造成的竞争条件<ul>
<li>如果有多个线程共享文件描述符，当地一个线程调用lseek之后，在它进行读取或写入操作之前，同一个程序中的另一个线程可能会改变文件的位置</li>
</ul>
</li>
</ul>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>UNIX/Linux支持不同进程间共享文件。内核使用的三种表（<strong>文件描述符表、文件表、索引结点表</strong>）之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响</p>
<ul>
<li>每个进程在进程表中有一个文件描述符表，每个描述符表项指向一个文件表</li>
<li><p>内核为每一个被打开的文件维护一张文件表，文件表项包含</p>
<ul>
<li>文件的状态标志（读、写、同步、非阻塞）</li>
<li>文件当前位置</li>
<li>指向该文件索引节点表的指针</li>
</ul>
</li>
<li><p>每个文件（或设备）都有一个索引节点，它包含了文件类型属性及文件数据</p>
</li>
</ul>
<p>如果两个进程分别打开同一个的文件（物理文件），则它们有不同的文件表，因此每个进程有自己的文件当前位置，因此其读写操作互不影响。</p>
<p>也存在不同进程共享同一个文件表（父子进程），或同一进程共享同一个文件表（dup操作）。此时，两个进程对该文件的读写操作将基于同一个文件当前位置。</p>
<h3 id="进程共享文件"><a href="#进程共享文件" class="headerlink" title="进程共享文件"></a>进程共享文件</h3><p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407103144896.png" alt="image-20220407103144896" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407103203149.png" alt="image-20220407103144896" style="zoom: 67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407103229973.png" alt="image-20220407103144896" style="zoom: 67%;" /></p>
<h3 id="dup和dup2"><a href="#dup和dup2" class="headerlink" title="dup和dup2"></a>dup和dup2</h3><p>头文件：<code>unistd.h</code></p>
<p>函数原型</p>
<ul>
<li><code>int dup( int oldfd );</code></li>
<li><code>int dup2( int oldfd, int targetfd );</code></li>
</ul>
<p>函数说明：复制一个文件的描述符，dup2函数跟dup函数相似，但dup2函数允许调用者规定一个有效描述符和目标描述符的</p>
<p>返回值：dup2函数成功返回时，目标描述符（dup2函数的第二个参数）将变成源描述符（dup2函数的第一个参数）的复制品</p>
<h3 id="线程共享文件"><a href="#线程共享文件" class="headerlink" title="线程共享文件"></a>线程共享文件</h3><p>线程的定义：有时称<strong>轻量级进程</strong>，是进程中的一个执行线路或线索，是一个相对独立的、可独立调度和指派的执行单元</p>
<p>线程的创建：应用程序可以通过一个统一的<code>clone()</code>系统调用接口，用不同的参数指定创建轻量进程还是普通进程</p>
<p><code>clone()</code>调用<code>do_fork()</code>创建线程， <code>do_fork()</code>参数为：<code>(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND)</code></p>
<ul>
<li><code>CLONE_VM</code>：<code>do_fork()</code>需要调用<code>copy_mm()</code>来设置<code>task_struct</code>中的<code>mm</code>和active_mm项，这两个<code>mm_struct</code>数据与进程所关联的<strong>内存空间</strong>相对应。如果<code>do_fork()</code>时指定了<code>CLONE_VM</code>开关，<code>copy_mm()</code>将把新的<code>task_struct</code>中的<code>mm</code>和<code>active_mm</code>设置成与<code>current</code>的相同，同时提高该<code>mm_struct</code>的使用者数目<code>(mm_struct::mm_users)</code>。也就是说，<strong>轻量级进程与父进程共享内存地址空间</strong></li>
<li><code>CLONE_FS</code>：<code>task_struct</code>中利用<code>fs(struct fs_struct *)</code>记录了<strong>进程所在文件系统的根目录和当前目录信息</strong>，<code>do_fork()</code>时调用<code>copy_fs()</code>复制了这个结构;而对于轻量级进程则仅增加<code>fs-&gt;count</code>计数，与父进程共享相同的<code>fs_struct</code>。也就是说，<strong>轻量级进程没有独立的文件系统相关的信息，进程中任何一个线程改变当前目录、根目录等信息都将直接影响到其他线程</strong></li>
<li><code>CLONE_FILES</code>：一个进程可能打开了一些文件，在进程结构<code>task_struct</code>中利用<code>files(struct files_struct *)</code>来保存进程<strong>打开的文件结构<code>(struct file)</code>信息</strong>，<code>do_fork()</code>中调用了<code>copy_files()</code>来处理这个进程属性；轻量级进程与父进程是共享该结构的，<code>copy_files()</code>时仅增加<code>files-&gt;count</code>计数。这一共享使得<strong>任何线程都能访问进程所维护的打开文件，对它们的操作会直接反映到进程中的其他线程</strong></li>
<li><code>CLONE_SIGHAND</code>：每一个Linux进程都可以自行定义对信号的处理方式，在<code>task_struct</code>中的<code>sig(struct signal_struct)</code>中使用一个<code>struct k_sigaction</code>结构的数组来保存这个配置信息，<code>do_fork()</code>中的<code>copy_sighand()</code>负责复制该信息；<strong>轻量级进程不进行复制</strong>，而仅仅增加<code>signal_struct::count</code>计数，与父进程共享该结构。也就是说，<strong>子进程与父进程的信号处理方式完全相同，而且可以相互更改</strong></li>
</ul>
<p><strong>总结</strong>：线程间所有文件结构都为共享资源，不但“文件表项”（file对象）是共享的，就连“文件描述符表”（files_struct结构）也是共享的。线程的创建仅仅增加的是<code>files</code>和<code>fs</code>的引用计数，“文件打开计数”（file对象的引用计数）并没有增加，所以任何一个线程对打开的文件执行<code>close</code>操作，文件都将关闭（文件打开计数为1的情况）。但是如果线程不进行打开文件的关闭，则文件直到进程结束时才会关闭，这就是使用多线程实现tcp服务器时，服务线程必须要显示调用close的原因，否则永远不会发送FIN终止链接（因为主线程一直处于监听不会结束）。</p>
<p><strong>进程间文件描述符的传递</strong>：</p>
<ul>
<li>传递描述符的函数的参数是fd，fd是打开文件指针在数组中的下标</li>
<li>将一个文件描述符传递给另一个进程后，文件的“访问计数”会增加</li>
<li>进程间传递文件描述符可以看做跨进程的dup调用，也就是同一个file对象在不同进程间的映射</li>
<li>对于网络接口返回的描述符 ，只能采取传递文件描述符的方法。</li>
<li>UNIX系统中两个方法：BSD <code>sendmsg</code>，<code>recvmsg</code>方法；SYSV <code>ioctl</code>方法</li>
<li>进程间传递文件描述符时，发送进程和接收进程共享同一文件表项</li>
<li>进程间文件描述符的传递，只是通过内核将接收文件的一个新file指针指向和发送进程的同一个file对象，并使这个file对象的引用计数增加</li>
</ul>
<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><h3 id="ls-l"><a href="#ls-l" class="headerlink" title="ls -l"></a>ls -l</h3><p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407113940167.png" alt="image-20220407113940167" style="zoom:67%;" /></p>
<p><strong>文件类型</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标识</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>普通文件</td>
</tr>
<tr>
<td>d</td>
<td>目录文件</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件</td>
</tr>
<tr>
<td>b</td>
<td>块设备文件</td>
</tr>
<tr>
<td>p</td>
<td>管道或FIFO</td>
</tr>
<tr>
<td>l</td>
<td>符号链接</td>
</tr>
<tr>
<td>s</td>
<td>套接字</td>
</tr>
</tbody>
</table>
</div>
<p><strong>文件访问权限：</strong></p>
<ul>
<li><code>r</code> 读权限</li>
<li><code>w</code> 写权限</li>
<li><code>x</code> 执行权限</li>
</ul>
<p><strong>ls –l 程序设计</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407114308228.png" alt="image-20220407114308228" style="zoom:67%;" /></p>
<h3 id="获取当前目录"><a href="#获取当前目录" class="headerlink" title="获取当前目录"></a>获取当前目录</h3><p><strong>getcwd</strong>函数</p>
<p>头文件： <code>unistd.h</code></p>
<p>函数声明：<code>char *getcwd(char *buf, size_t size);</code></p>
<p>函数说明：将当前的工作目录绝对路径字符串复制到参数<code>buf</code>所指的缓冲区，参数<code>size</code>为<code>buf</code>缓冲区大小。</p>
<p>返回值：成功调用返回指向<code>buf</code>的指针，失败返回<code>NULL</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 255</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> path[MAX_SIZE];</span><br><span class="line">        getcwd(path, <span class="keyword">sizeof</span>(path));</span><br><span class="line">        <span class="built_in">puts</span>(path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yang@Ubuntu18:~/Documents/Cprogram/$ gcc getcwd_test.c -o getcwd_test</span><br><span class="line">yang@Ubuntu18:~/Documents/Cprogram/$ ./getcwd_test</span><br><span class="line">/home/yang/Documents/Cprogram</span><br></pre></td></tr></table></figure>
<p><strong>get_current_dir_name</strong></p>
<p>文件首加宏定义：<code>#define _GNU_SOURCE</code></p>
<p>头文件： <code>unistd.h</code></p>
<p>函数声明：<code>char * get_current_dir_name(void);</code></p>
<p>函数说明：调用后会返回一个字符串指针，指向当前工作目录绝对路径字符串</p>
<p>返回值：成功则返回<code>字符串指针</code>，失败则返回<code>NULL</code>，错误代码存放于errno中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *path;</span><br><span class="line">        path = get_current_dir_name();</span><br><span class="line">        <span class="built_in">puts</span>(path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yang@Ubuntu18:~/Documents/Cprogram$ gcc get_current_dir_name_test.c -o get_current_dir_name_test</span><br><span class="line">yang@Ubuntu18:~/Documents/Cprogram$ ./get_current_dir_name_test</span><br><span class="line">/home/yang/Documents/Cprogram</span><br></pre></td></tr></table></figure>
<h3 id="DIR结构体"><a href="#DIR结构体" class="headerlink" title="DIR结构体"></a>DIR结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">dirstream</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *__fd;</span><br><span class="line">    <span class="keyword">char</span> *__data;</span><br><span class="line">    <span class="keyword">int</span> __entry_data;</span><br><span class="line">    <span class="keyword">char</span> *__ptr;</span><br><span class="line">    <span class="keyword">int</span> __entry_ptr;</span><br><span class="line">    <span class="keyword">size_t</span> __allocation;</span><br><span class="line">    <span class="keyword">size_t</span> __size;</span><br><span class="line">    __libc_lock_define (, __lock)</span><br><span class="line">&#125;; <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">dirstream</span> <span class="title">DIR</span>；</span></span><br></pre></td></tr></table></figure>
<h3 id="打开目录"><a href="#打开目录" class="headerlink" title="打开目录"></a>打开目录</h3><p><strong>opendir函数</strong></p>
<p>头文件：</p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>dirent.h</code></li>
</ul>
<p>函数声明：<code>DIR *opendir(const char *path);</code></p>
<p>函数说明：打开参数<code>path</code>指定的目录</p>
<p>返回值：成功则返回<strong>DIR形态的目录流</strong>，失败则返回<code>NULL</code>，错误代码存放于errno中</p>
<p>错误代码：</p>
<ul>
<li><code>EACCESS</code> 代表权限不足，也就是对这个目录没有执行权限。</li>
<li><code>EMFILE</code> 表示目前同时打开这个文件的进程数目已经到达了系统上限。</li>
<li><code>ENFILE</code> 代表已经达到系统可以同时打开的文件数上限。</li>
<li><code>ENOTDIR</code> 代表参数<code>path</code>指向的不是一个真正的目录。</li>
<li><code>EOENT</code> 表示参数<code>path</code>指向的目录不存在，或者参数<code>path</code>是一个空的字符串。</li>
<li><code>ENOMEM</code> 表示核心内存不足</li>
</ul>
<h3 id="关闭目录"><a href="#关闭目录" class="headerlink" title="关闭目录"></a>关闭目录</h3><p><strong>closedir函数</strong></p>
<p>头文件：</p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>dirent.h</code></li>
</ul>
<p>函数声明：<code>int closedir(DIR *dir);</code></p>
<p>函数说明：关闭参数<code>dir</code>指定的目录</p>
<p>返回值：关闭成功就返回0，失败的话就返回-1，错误原因存于errno中</p>
<p>错误代码：<code>EBADF</code>代表参数<code>dir</code>是一个无效的目录流</p>
<h3 id="dirent结构体"><a href="#dirent结构体" class="headerlink" title="dirent结构体"></a>dirent结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">ino_t</span> d_ino; <span class="comment">// i节点号</span></span><br><span class="line">    <span class="keyword">off_t</span> d_off; <span class="comment">// 在目录文件中的偏移，相对目录开头而言</span></span><br><span class="line">    usigned <span class="keyword">short</span> d_reclen; <span class="comment">// 文件名长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type;   <span class="comment">// 文件类型</span></span><br><span class="line">    <span class="keyword">char</span> d_name[<span class="number">256</span>];       <span class="comment">// 文件名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="读取目录文件"><a href="#读取目录文件" class="headerlink" title="读取目录文件"></a>读取目录文件</h3><p><strong>readdir函数</strong></p>
<p>头文件： </p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>dirent.h</code></li>
</ul>
<p>函数声明：<code>struct dirent *readdir(DIR *dirp);</code></p>
<p>函数说明：读取目标流<code>dir</code>标识的目录</p>
<p>返回值：每执行一次<code>readdir</code>，这个函数返回指向当前读取目录项结构的指针，有错误发生或读取到目录文件尾的时候就返回<code>NULL</code></p>
<p>错误代码：<code>EBADF</code>代表参数<code>dir</code>是一个无效的目录流</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 255</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> path <span class="meta-string">&quot;/home/yang/Documents/Cprogram&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        DIR *dir = opendir(path);</span><br><span class="line">        <span class="keyword">char</span> dir1[MAX_SIZE];</span><br><span class="line">        getcwd(dir1, <span class="keyword">sizeof</span>(dir1));</span><br><span class="line">        <span class="built_in">puts</span>(dir1);</span><br><span class="line">        <span class="keyword">char</span> *dir2 = get_current_dir_name();</span><br><span class="line">        <span class="built_in">puts</span>(dir2);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>((dent = readdir(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407155354291.png" alt="image-20220407155354291"></p>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p><strong>mkdir函数</strong></p>
<p>头文件：<code>sys/stat.h</code></p>
<p>函数声明：<code>int mkdir(const char *pathname, mode_t mode);</code></p>
<p>函数说明：以<code>mode</code>方式创建一个以参数<code>pathname</code>命名的目录，<code>mode</code>定义新创建目录的权限</p>
<p>返回值：若目录创建成功，则返回0；否则返回-1，并将错误记录到全局变量errno中</p>
<p>注意事项：</p>
<ul>
<li>创建<code>777</code>权限的目录，需要先执行<code>umask(0)</code>，然后再调用<code>mkdir</code>函数</li>
<li>目录已存在会返回-1</li>
<li>不能创建多个目录</li>
</ul>
<h3 id="文件权限mode"><a href="#文件权限mode" class="headerlink" title="文件权限mode"></a>文件权限mode</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>权限</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_IRWXU</code></td>
<td>00700</td>
<td>文件所有者拥有读写执行的权限</td>
</tr>
<tr>
<td><code>S_IRUSR(S_IREAD)</code></td>
<td>00400</td>
<td>文件所有者拥有可读权限</td>
</tr>
<tr>
<td><code>S_IWUSR(S_IWRITE)</code></td>
<td>00200</td>
<td>文件所有者拥有可写权限</td>
</tr>
<tr>
<td><code>S_IXUSR(S_IEXEC)</code></td>
<td>00100</td>
<td>文件所有者拥有执行权限</td>
</tr>
<tr>
<td><code>S_IRWXG</code></td>
<td>00070</td>
<td>文件用户组拥有读写执行的权限</td>
</tr>
<tr>
<td><code>S_IRGRP</code></td>
<td>00040</td>
<td>文件用户组拥有可读权限</td>
</tr>
<tr>
<td><code>S_IWGRP</code></td>
<td>00020</td>
<td>文件用户组拥有可写权限</td>
</tr>
<tr>
<td><code>S_IXGRP</code></td>
<td>00010</td>
<td>文件用户组拥有执行权限</td>
</tr>
<tr>
<td><code>S_IRWXO</code></td>
<td>00007</td>
<td>其他用户拥有读写执行权限</td>
</tr>
<tr>
<td><code>S_IROTH</code></td>
<td>00004</td>
<td>其他用户拥有可读权限</td>
</tr>
<tr>
<td><code>S_IWOTH</code></td>
<td>00002</td>
<td>其他用户拥有可写权限</td>
</tr>
<tr>
<td><code>S_IXOTH</code></td>
<td>00001</td>
<td>其他用户拥有执行权限</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH <span class="meta-string">&quot;home/yang/Documents/Cprogram/Linux系统编程学习/mulu&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    umask(<span class="number">0</span>); <span class="comment">//不调用umask，最高权限775</span></span><br><span class="line">    <span class="keyword">if</span>(mkdir(<span class="string">&quot;目录&quot;</span>, S_IRWXU | S_IRWXG | S_IRWXO) == <span class="number">-1</span>) <span class="comment">//权限777</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mkdir error\n&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">//在当前下创建</span></span><br><span class="line">    	</span><br><span class="line">    <span class="keyword">if</span>(mkdir(<span class="string">&quot;../mulu&quot;</span>, S_IRWXU | S_IRGRP | S_IROTH) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mkdir error\n&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">//在上级目录下创建</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(mkdir(<span class="string">&quot;../Linux系统编程学习/mulu&quot;</span>, S_IRWXU | S_IRGRP) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mkdir error\n&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">//这是ok的，在当前目录上一级目录下的 Linux系统编程学习 文件夹下创建 mulu</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(mkdir(PATH, S_IRWXU ) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mkdir error\n&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">//使用绝对路径创建</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><p><strong>rmdir函数</strong></p>
<p>头文件：<code>unistd.h</code></p>
<p>函数声明：<code>int rmdir(const char *pathname);</code></p>
<p>函数说明：删除一个目录，该目录必须是空的</p>
<p>返回值：若目录删除成功，则返回0；否则返回-1，并将错误记录到全局变量errno中</p>
<p>注意事项：<code>pathname</code>不能超过255，目录名不能以<code>.</code>开头（<code>.</code>开头的是隐藏文件）。目录没有被其他进程占用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rmdir(<span class="string">&quot;./mulu&quot;</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;rmdir error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="改变当前工作目录"><a href="#改变当前工作目录" class="headerlink" title="改变当前工作目录"></a>改变当前工作目录</h3><p><strong>chdir函数</strong></p>
<p>头文件：<code>unistd.h</code></p>
<p>函数声明：<code>int chdir(const char *path);</code></p>
<p>函数说明：<code>chdir</code>函数用于<strong>改变当前工作目录</strong>。调用参数是指向目录的指针，调用进程需要有搜索整个目录的权限</p>
<p>返回值：成功，则返回0；否则返回-1，并将错误记录到全局变量errno中</p>
<p>错误信息：</p>
<ul>
<li><code>EFAULT</code>: path指向了非法地址</li>
<li><code>ENAMETOOLNG</code>:  路径过长</li>
<li><code>ENOENT</code>: 文件不存在</li>
<li><code>ENOMEM</code>: 内核内存不足</li>
<li><code>ENOTDIR</code>: 给出路径不是目录</li>
<li><code>EACCES</code>: 无访问路径中某个目录的权限</li>
<li><code>ELOOP</code>：解析路径中太多的符号链接</li>
<li><code>EIO</code>: 发生I/O错误</li>
</ul>
<p>函数说明：</p>
<ul>
<li>每个进程都具有一个当前工作目录。在解析相对目录引用时，该目录是搜索路径的开始之处</li>
<li>如果调用进程更改了目录，则它只对该进程有效，而不能影响调用它的那个进程</li>
<li>在退出程序时，shell还会返回开始时的那个工作目录</li>
<li>内核解析参数中的路径名，并确保这个路径名有效。内核定位该目录的索引节点，并检查它的文件类型和权限位，确保目标文件是目录以及进程的所有者可以访问该目录</li>
<li>内核用新目标目录的路径名和索引节点替换u区中当前目录路径名和索引节点号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH <span class="meta-string">&quot;/home/yang&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(chdir(<span class="string">&quot;..&quot;</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">//相对路径</span></span><br><span class="line">    <span class="keyword">char</span> *nowdir = get_current_dir_name();</span><br><span class="line">    <span class="built_in">puts</span>(nowdir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(chdir(PATH) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">//绝对路径</span></span><br><span class="line">    nowdir = get_current_dir_name();</span><br><span class="line">    <span class="built_in">puts</span>(nowdir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407174200065.png" alt="image-20220407174200065"></p>
<h3 id="设置目录读取位置"><a href="#设置目录读取位置" class="headerlink" title="设置目录读取位置"></a>设置目录读取位置</h3><p><strong>rewinddir函数</strong></p>
<p>头文件：</p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>dirent.h</code></li>
</ul>
<p>函数声明：<code>void rewinddir(DIR *dir);</code></p>
<p>函数说明：设置参数<code>dir</code>指向的目录流目前的读取位置为原来<strong>开头</strong>的读取位置</p>
<p>返回值：无返回值，函数执行失败后会将错误记录到全局变量errno中</p>
<p>错误信息：<code>EBADF</code>：表示<code>dir</code>指向的目录流无效</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dir = opendir(<span class="string">&quot;./&quot;</span>); <span class="comment">//读取当前目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//先读3个文件</span></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    <span class="comment">//设置会开头</span></span><br><span class="line">    rewinddir(dir);</span><br><span class="line">    <span class="comment">//在读3个文件</span></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407174829214.png" alt="image-20220407174829214"></p>
<p><strong>seekdir函数</strong></p>
<p>头文件： <code>dirent.h</code></p>
<p>函数声明：<code>void seekdir(DIR * dir, off_t offset)</code></p>
<p>函数说明：设置参数dir指向的目录流目前的读取位置为<code>offset</code>，在调用<code>readdir()</code>时便从此新位置开始读取。参数<code>offset</code>代表<strong>距离目录文件开头的偏移量</strong>。</p>
<p>返回值：无返回值，函数执行失败后会将错误记录到全局变量errno中</p>
<p>错误信息：<code>EBADF</code>：表示dir指向的目录流无效</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dir = opendir(<span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先读3个文件</span></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;该文件的offset = %ld\n\n&quot;</span>, dent-&gt;d_off);</span><br><span class="line"></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;该文件offset = %ld\n\n&quot;</span>, dent-&gt;d_off);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">off_t</span> offset = dent-&gt;d_off;  <span class="comment">//文件的偏移量是相对目录开头而言的，不要叠加</span></span><br><span class="line"></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;该文件offset = %ld\n\n&quot;</span>, dent-&gt;d_off);</span><br><span class="line"></span><br><span class="line">    seekdir(dir, offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;移动到离目录开头偏移%ld\n\n&quot;</span>, offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在读3个文件</span></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407180857330.png" alt="image-20220407180857330"></p>
<h3 id="获取目录读取位置"><a href="#获取目录读取位置" class="headerlink" title="获取目录读取位置"></a>获取目录读取位置</h3><p><strong>telldir函数</strong></p>
<p>头文件： <code>dirent.h</code></p>
<p>函数声明：<code>off_t telldir(DIR * dir);</code></p>
<p>函数说明：取得目录流<code>dir</code>的读取位置。</p>
<p>返回值：返回参数<code>dir</code>目录流目前的读取位置. 此返回值代表<strong>距离目录文件开头的偏移量</strong>，有错误发生时返回-1.</p>
<p>错误信息：<code>EBADF</code>：表示dir指向的目录流无效</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dir = opendir(<span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dent = readdir(dir);</span><br><span class="line">        <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dirent-&gt;d_off = %ld\n&quot;</span>, dent-&gt;d_off);</span><br><span class="line">        <span class="keyword">off_t</span> offset = telldir(dir);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;telldir = %ld\n\n&quot;</span>, offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220407181940228.png" alt="image-20220407181940228"></p>
<h3 id="读取特定目录数据"><a href="#读取特定目录数据" class="headerlink" title="读取特定目录数据"></a>读取特定目录数据</h3><p><strong>scandir函数</strong></p>
<p>头文件： <code>dirent.h</code></p>
<p>函数声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scandir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dir, </span></span></span><br><span class="line"><span class="params"><span class="function">            struct dirent ***namelist, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> (*filter) (<span class="keyword">const</span> struct dirent*), </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span>(*compar)(<span class="keyword">const</span> struct dirent **, <span class="keyword">const</span> struct dirent**)</span></span></span><br><span class="line"><span class="params"><span class="function">           )</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数说明：<code>scandir()</code>会扫描参数<code>dir</code>指定的目录文件，经由参数<code>filter</code>指定的函数来挑选目录结构至参数<code>namelist</code>数组中，最后再调用参数<code>compar</code>指定的函数来排序<code>namelist</code>数组中的目录数据。每次从目录文件中读取一个目录结构后便将此结构传给参数<code>filter</code>所指的函数，<code>filter</code>函数若不想要将此目录结构复制到<code>namelist</code>数组就返回0，若<code>filter</code>为空指针则代表选择所有的目录结构。<code>scandir()</code>会调用<code>qsort()</code>来排序数据，参数<code>compar</code>则为<code>qsort()</code>的参数，若是要排列目录名称字母则可使用<code>alphasort()</code>。</p>
<p>返回值：成功则返回复制到<code>namelist</code>数组中的数据结构数目，有错误发生则返回-1.</p>
<p>错误信息：<code>ENOMEM</code> 核心内存不足</p>
<p>补充：</p>
<ul>
<li><code>int alphasort(const void **a, const void **b);</code></li>
<li><code>int versionsort(const void **a, const void **b);</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">namelist</span>;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    n = scandir(<span class="string">&quot;.&quot;</span>, &amp;namelist, <span class="number">0</span>, alphasort);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;not found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, namelist[n]-&gt;d_name);</span><br><span class="line">            <span class="built_in">free</span>(namelist[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(namelist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件属性管理"><a href="#文件属性管理" class="headerlink" title="文件属性管理"></a>文件属性管理</h2><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>Linux系统中常见的文件类型：</p>
<ul>
<li>普通文件 <code>-</code> ：包含了某种形式的数据</li>
<li>目录文件 <code>d</code> ：包含了其他文件的名字以及指向与这些文件有关信息的指针</li>
<li>字符特殊文件 <code>c</code> ：提供对设备不带缓冲的访问</li>
<li>FIFO文件 <code>p</code> ：用于进程间的通信，命名管道</li>
<li>套接字文件 <code>s</code> ：用于网络通信</li>
<li>符号链接 <code>l</code> ：使文件指向另一个文件</li>
</ul>
<h3 id="读取文件属性"><a href="#读取文件属性" class="headerlink" title="读取文件属性"></a>读取文件属性</h3><p>头文件：<code>sys/stat.h</code></p>
<ul>
<li><code>int stat(const char *path, struct stat *buf);</code></li>
<li><code>int lstat(const char *path, struct stat *buf);</code></li>
<li><code>int fstat(int fd, struct stat *buf);</code></li>
<li><code>int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag);</code></li>
</ul>
<p>函数说明：</p>
<ul>
<li><code>stat</code>和<code>lstat</code>参数相同，功能类似。读取<code>path</code>参数所指定文件的文件属性并将其填充到<code>buf</code>参数所指向的结构体中；对于符号链接文件，<code>lstat</code>返回符号链接的文件属性，<code>stat</code>返回符号链接引用文件的文件属性。</li>
<li><code>fstat</code>与前两个函数功能类似，指定文件的方式改为通过文件描述符</li>
<li><code>statat</code>函数为一个相对于当前打开目录(由fd参数指向)的路径名返回文件统计信息。 <code>flag</code>参数控制着是否跟随着一个符号链接，返回符号链接本身的信息或者符号链接所指向的实际文件信息。<ul>
<li>如果fd参数的值是<code>AT_FDCWD</code>，并且<code>pathname</code>参数是一个相对路径名，<code>fstatat</code>会计算相对于当前目录的<code>pathname</code>参数，如果<code>pathname</code>是一个绝对路径，<code>fd</code>参数就会被忽略。这两种情况下，根据<code>flag</code>的取值<code>fstatat</code>的作用就跟<code>stat</code>或<code>lstat</code>一样</li>
</ul>
</li>
<li>参数<code>buf</code>，是一个指向<code>stat</code>结构的指针，这几个函数都是为了填充<code>buf</code>指向的结构<code>stat</code></li>
<li>成功返回0，失败返回-1</li>
</ul>
<h3 id="stat结构"><a href="#stat结构" class="headerlink" title="stat结构"></a>stat结构</h3><p><code>stat</code>是linux系统用来描述文件属性的重要数据结构信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span> </span><br><span class="line">    <span class="keyword">mode_t</span> st_mode; 	<span class="comment">// 文件类型与访问权限</span></span><br><span class="line">    <span class="keyword">ino_t</span> st_ino; 		<span class="comment">// i节点号</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_dev; 		<span class="comment">// 文件的主、次设备号信息</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_rdev; 		<span class="comment">// 设备文件的设备号</span></span><br><span class="line">    <span class="keyword">nlink_t</span> st_nlink; 	<span class="comment">// 文件的硬链接数</span></span><br><span class="line">    <span class="keyword">uid_t</span> st_uid; 		<span class="comment">// 文件所有者用户ID</span></span><br><span class="line">    <span class="keyword">gid_t</span> st_gid; 		<span class="comment">// 文件所有者组ID</span></span><br><span class="line">    <span class="keyword">off_t</span> st_size; 		<span class="comment">// 文件大小（以字节为单位）</span></span><br><span class="line">    <span class="keyword">time_t</span> st_atime; 	<span class="comment">// 最后一次访问该文件的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> st_mtime; 	<span class="comment">// 最后一次修改该文件的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> st_ctime; 	<span class="comment">// 最后一次改变该文件状态的时间</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize; 	<span class="comment">// 包含该文件的磁盘块的大小</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span> st_blocks; 	<span class="comment">// 该文件所占的磁盘块数</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h3 id="st-mode"><a href="#st-mode" class="headerlink" title="st_mode"></a><code>st_mode</code></h3><div class="table-container">
<table>
<thead>
<tr>
<th>宏</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_ISREG()</code></td>
<td>普通文件<code>-</code></td>
</tr>
<tr>
<td><code>S_ISDIR()</code></td>
<td>目录文件<code>d</code></td>
</tr>
<tr>
<td><code>S_ISCHR()</code></td>
<td>字符特殊文件<code>c</code></td>
</tr>
<tr>
<td><code>S_ISBLK()</code></td>
<td>块特殊文件<code>b</code></td>
</tr>
<tr>
<td><code>S_ISFIFO()</code></td>
<td>管道或FIFO<code>p</code></td>
</tr>
<tr>
<td><code>S_ISLNK()</code></td>
<td>符号链接<code>l</code></td>
</tr>
<tr>
<td><code>S_ISSOCK()</code></td>
<td>套接字<code>s</code></td>
</tr>
</tbody>
</table>
</div>
<p><code>mode_t st_mode</code> 无符号整数，其低16位定义如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408113535578.png" alt="image-20220408113535578"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408113556252.png" alt="image-20220408113556252" style="zoom:67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408113707390.png" alt="image-20220408113707390" style="zoom:67%;" /></p>
<p><strong>设置用户ID位和设置组ID位</strong>：</p>
<p>定义：</p>
<ul>
<li>包含在可执行文件的权限标记中，有一个“设置用户ID位”若该位被设置，表示：执行该文件时，进程的有效用户ID变为文件的所有者对于设置组ID位类似</li>
<li>通过命令行设置用户ID位：<ul>
<li><code>chmod u+s filename</code>； <code>chmod u-s filename</code>；</li>
<li><code>chmod g+s filename</code>； <code>chmod g-s filename</code>；</li>
</ul>
</li>
<li>若文件所有者是超级用户，且设置了设置用户ID位，则执行此文件的进程拥有超级用户权限</li>
<li>Passwd(1) 允许任一用户改变其口令，该程序是一个设置用户ID程序</li>
<li>分别用常量<code>S_ISUID</code>和<code>S_ISGID</code>测试</li>
</ul>
<h3 id="粘着位"><a href="#粘着位" class="headerlink" title="粘着位"></a>粘着位</h3><p>在UNIX早期版本中，有一位被称为粘住位，如果一可执行程序文件的这一位被设置了，那么在该程序第一次执行并结束时，该程序正文被保存在交换区中，这使得下次执行该程序时能较快地将其装入内存。</p>
<p>现今较新的UNIX系统大多数都具有<strong>虚存系统以及快速文件系统</strong>，所以<strong>不再需要使用这种技术</strong></p>
<p>如果对一个目录设置了粘住位，则只有对该目录具有<strong>写许可权</strong>的用户并且满足下列条件之一，才能删除或更名该目录下文件：</p>
<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户</li>
</ul>
<p>目录/<code>tmp</code>和<code>/var/spool/uucppublic</code>(<strong>怎么没有？</strong>)是设置粘住位的候选者。这两个目录是任何用户都可在其中创建文件的目录，对任一用户(用户、组和其他)的许可权通常都是读、写和执行。但是<strong>用户不应能删除或更名属于其他人的文件</strong>，为此在这两个目录的文件方式中都设置了粘住位。</p>
<h3 id="st-size"><a href="#st-size" class="headerlink" title="st_size"></a><code>st_size</code></h3><p><code>stat</code>结构的成员<code>st_size</code>包含了<strong>以字节为单位的该文件的长度</strong>。此字段只对普通文件、目录文件和符号连接有意义</p>
<ul>
<li>对于普通文件，其文件长度可以是0，在读这种文件时，将得到文件结束指示</li>
<li>对于目录，文件长度通常是一个数，例如16或512的整倍数</li>
<li>对于符号连接，文件长度是在文件名中的实际字节数。例如：<ul>
<li><code>lrwxrwxrwx 1 root 7 Sep 25 07:14 lib -&gt; usr/lib</code></li>
<li>其中，文件长度7就是路径名<code>usr/lib</code>的长度</li>
</ul>
</li>
</ul>
<h3 id="文件截断"><a href="#文件截断" class="headerlink" title="文件截断"></a>文件截断</h3><p>函数原型：</p>
<ul>
<li><code>int truncate(const char* pathname, off_t length);</code></li>
<li><code>int ftruncate(int fd, off_t length);</code></li>
</ul>
<p>函数说明：</p>
<ul>
<li>用于改变文件的长度</li>
<li><code>pathname</code>：欲改变长度的文件的文件名</li>
<li><code>fd</code>：欲改变长度的文件的文件描述符；</li>
<li><code>length</code>：要设置的文件的新长度</li>
</ul>
<p>返回值：成功返回0，出错返回-1</p>
<p>注意事项：</p>
<ul>
<li>当文件以前的长度<code>&gt;length</code>时，则超过length以外的数据将不复存在</li>
<li>当文件以前的长度<code>&lt;length</code>时，在文件以前长度到length之间，将形成空洞，读该区域，将返回0</li>
</ul>
<p>常见问题：</p>
<p><code>truncate</code>和<code>ftruncate</code>函数并未实质性的向磁盘写入数据，只是分配了一定的空间供当前文件使用。当<code>fd&lt;length</code>时，此时如果使用十六进制编辑工具打开该文件，会发现文件末尾多了很多00，这就是执行这个函数后的效果。如果发生系统复位或者装置掉电以后，该函数所产生的作用将被文件系统忽略，也就是说它所分配的空间将不能被识别，文件的大小将会是最后一次写入操作的<br>区域大小，而非<code>ftruncate</code>分配的空间大小，也就是说，文件大小有可能会被改变</p>
<p>解决方案：</p>
<p>可以在执行完<code>ftruncate</code>之后，在新空间的末尾写入一个或以上字节的数据（不为0x00），这样新空间则不为空，文件系统会把这部分空间当成这个文件的私有空间处理，而不会出现文件大小改变的错误。</p>
<h3 id="passwd结构体"><a href="#passwd结构体" class="headerlink" title="passwd结构体"></a>passwd结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> * pw_name; <span class="comment">/* 用户名*/</span></span><br><span class="line">    <span class="keyword">char</span> * pw_passwd; <span class="comment">/* 密码.*/</span></span><br><span class="line">    <span class="keyword">__uid_t</span> pw_uid; <span class="comment">/* 用户ID.*/</span></span><br><span class="line">    <span class="keyword">__gid_t</span> pw_gid; <span class="comment">/*组ID.*/</span></span><br><span class="line">    <span class="keyword">char</span> * pw_gecos; <span class="comment">/*真实名*/</span></span><br><span class="line">    <span class="keyword">char</span> * pw_dir; <span class="comment">/* 主目录.*/</span></span><br><span class="line">    <span class="keyword">char</span> * pw_shell; <span class="comment">/*使用的shell*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="获取用户属性"><a href="#获取用户属性" class="headerlink" title="获取用户属性"></a>获取用户属性</h3><p>常用函数：<code>getpwuid</code></p>
<p>头文件： </p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>pwd.h</code></li>
</ul>
<p>函数原型：<code>struct passwd *getpwuid(uid_t uid);</code></p>
<p>函数说明：输入用户ID，返回用户属性信息（passwd结构）</p>
<h3 id="group结构体"><a href="#group结构体" class="headerlink" title="group结构体"></a>group结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *gr_name; <span class="comment">/*组名称*/</span></span><br><span class="line">	<span class="keyword">char</span> *gr_passwd; <span class="comment">/* 组密码*/</span></span><br><span class="line">	<span class="keyword">gid_t</span> gr_gid; <span class="comment">/*组ID*/</span></span><br><span class="line">	<span class="keyword">char</span> **gr_mem; <span class="comment">/*组成员账号*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取组属性"><a href="#获取组属性" class="headerlink" title="获取组属性"></a>获取组属性</h3><p>常用函数：<code>getgrgid</code></p>
<p>头文件： </p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>grp.h</code></li>
</ul>
<p>函数原型：<code>struct group *getgrgid(gid_t gid);</code></p>
<p>函数说明：输入用户组ID，返回用户组属性信息（group结构）</p>
<h3 id="设备特殊文件"><a href="#设备特殊文件" class="headerlink" title="设备特殊文件"></a>设备特殊文件</h3><p>每一个文件系统所在的存储设备都由其主、次设备号表示。设备号所用的数据类型是基本系统数据类型<code>dev_t</code></p>
<p>主设备号标识设备驱动程序，次设备号标识特定的子设备</p>
<p>通常可以使用两个宏<code>major</code>和<code>minor</code>来访问主、次设备号</p>
<ul>
<li>早期系统用16位整型存放设备号：8位用于主设备号，8位用于次设备号</li>
<li>FreeBSD 8.0和Mac OS X 10.6.8使用32位整型，其中8位表示主设备号，24位表示次设备号。</li>
<li>32位系统中，Solaris 10用32位整型表示dev_t，其中14位用于主设备号，18位用于次设备</li>
<li>64位系统中，Solaris 10用64位整型表示dev_t，主设备号和次设备号各为32位</li>
<li>在Linux 3.2.0上，dev_t是64位整型，12位用于主设备号，20位用于次设备号</li>
</ul>
<p>系统中与每个文件名关联的<code>st-dev</code>值是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的索引结点</p>
<p>只有<strong>字符特殊文件和块特殊文件才有<code>st-rdev</code>值</strong>，此值包含实际设备的设备号</p>
<h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><p>Linux系统通过进程的<strong>有效用户ID和有效用户组ID</strong>来决定进程对系统资源的访问权限</p>
<p>与一个进程相关联的用户ID和用户组ID有如下几种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408120554130.png" alt="image-20220408120554130" style="zoom:67%;" /></p>
<p>通常情况下，有效用户ID等于实际用户ID，有效组ID等于实际组ID；</p>
<p>可执行文件的权限中有一个特殊标志，定义为“当执行此文件时，将进程的有效用户ID设置为文件的所有者”，与此类似，组ID也有类似的情况。</p>
<p>这两个标志位称为：“设置用户ID” 和 “ 设 置 组 ID”， 这 两 位 都 包 含 在 <code>stat</code>信 息 中 的 <code>st_mode</code> 中 ， 可 用<code>S_ISUID</code>，<code>S_ISGID</code>测试。</p>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul>
<li>对于一个文件的<strong>读权限</strong>决定了我们是否能够打开该文件进行读操作</li>
<li>对一个文件的<strong>写权限</strong>决定了我们是否能够打开该文件进行写操作</li>
<li>为了在<code>open</code>函数中对一个文件指定<code>O_TRUNC</code>标志，必须对该文件具有写权限</li>
<li>执行某个可执行文件，都必须对该文件具有<strong>执行权限</strong></li>
</ul>
<h3 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h3><ul>
<li>目录文件的<strong>执行权限</strong>也表示可以进入该目录</li>
<li>通过文件名打开一个任意类型的文件时，对该文件路径名中包含的每一个目录都应具有执行权限</li>
<li>为了在一个目录中创建一个新文件，必须对该目录具有<strong>写权限</strong>和<strong>执行权限</strong></li>
<li>为了删除一个文件，必须对包含该文件的目录具有<strong>写权限</strong>和<strong>执行权限</strong>，对该文件本身则不需要有读、写权限</li>
</ul>
<h3 id="检查文件权限"><a href="#检查文件权限" class="headerlink" title="检查文件权限"></a>检查文件权限</h3><p>进程访问文件时，内核就进行文件权限检查。这种检查涉及到文件的所有者、文件的所有者所在组、进程有效用户、进程的有效组及进程的附加组。两个所有者是文件的性质，而有效用户与有效组是进程的性质</p>
<p>当进程对某个文件进行操作时，内核按顺序执行下列4步来检查文件权限</p>
<ul>
<li>若进程的有效用户为root（ID等于0），则允许任何操作；</li>
<li>若进程的有效用户等于文件的所有者（ID相同）（即该进程拥有文件），按照文件所有者具有的权限判定操作是否合法</li>
<li>若进程的有效组或进程的附加组之一等于文件所有者所在组,按照文件所有者所在组具有的权限判定操作是否合法</li>
<li>按照其他用户具有权限判定操作是否合法</li>
</ul>
<p>一般情况下：</p>
<ul>
<li>若进程有效用户拥有此文件，则按用户权限批准或拒绝该进程对文件的操作</li>
<li>若进程有效用户并不拥有该文件，但进程有效用户属于某个适当的组，则按组权限批准或拒绝该进程对文件的操作</li>
<li>若进程有效用户并不拥有该文件，也不属于某个适当的组，则按照其他其他用户权限批准或拒绝该进程对文件的操作</li>
</ul>
<p><strong>新文件和新目录的所有权：</strong></p>
<p>新文件的所有者设置为进程的有效用户</p>
<p>新文件所有者所在的组，POSIX允许选择下列之一：</p>
<ul>
<li>新文件所有者所在的组可以是进程的有效组</li>
<li>新文件所有者所在的组可以是它所在目录的组</li>
</ul>
<p>新文件所有者所在的组取决于它所在目录的设置组ID位是否设置，若设置，则为目录组，否则则为进程有效组</p>
<p>BSD总是用目录组作为新文件所有者所在组</p>
<p><strong><code>access</code>函数</strong></p>
<p>函数功能：按照前述文件权限检查的4个步骤测试存取文件是否具有相应权限</p>
<p>函数原型：<code>int access(const char *pathname, int mode);</code></p>
<p>成功返回0，失败返回-1</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Mode</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>R_OK</code></td>
<td>测试读许可</td>
</tr>
<tr>
<td><code>W_OK</code></td>
<td>测试写许可</td>
</tr>
<tr>
<td><code>X_OK</code></td>
<td>测试执行许可</td>
</tr>
<tr>
<td><code>F_OK</code></td>
<td>文件是否存在</td>
</tr>
</tbody>
</table>
</div>
<h3 id="改变文件权限"><a href="#改变文件权限" class="headerlink" title="改变文件权限"></a>改变文件权限</h3><p>函数原型</p>
<ul>
<li><code>int chmod(const char * pathname, mode_t mode);</code></li>
<li><code>int fchmod( int fd, mode_t mode);</code></li>
</ul>
<p>函数用途：改变指定文件的权限位。</p>
<p>函数说明：</p>
<ul>
<li><code>chmod</code>要求给出的是文件或目录所在的位置，而<code>fchmod</code>主要针对的是文件，要求调用是相应的文件描述符。</li>
<li>修改时，进程的有效用户ID必须等于文件的所有者ID，或是root运行的此进程</li>
</ul>
<p><strong><code>mode</code>：</strong> </p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408122030806.png" alt="image-20220408122030806"></p>
<p><strong><code>chmod</code>出错信息</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EACCES</code></td>
<td>给出的文件所处路径没有访问权限</td>
</tr>
<tr>
<td><code>EFAULT</code></td>
<td>路径指向的文件地址错误</td>
</tr>
<tr>
<td><code>EIO</code></td>
<td>发生I/O错误</td>
</tr>
<tr>
<td><code>ELOOP</code></td>
<td>给出的文件所在路径中符号连接过多</td>
</tr>
<tr>
<td><code>ENAMETOOLONG</code></td>
<td>路径过长</td>
</tr>
<tr>
<td><code>ENOENT</code></td>
<td>文件不存在</td>
</tr>
<tr>
<td><code>ENOMEM</code></td>
<td>内核内存空间不足</td>
</tr>
<tr>
<td><code>ENOTDIR</code></td>
<td>给出的文件所处路径中包含不是目录的部分</td>
</tr>
<tr>
<td><code>EPERM</code></td>
<td>有效用户ID与文件拥有者不同，进程无权访问修改文件权限</td>
</tr>
<tr>
<td><code>EROFS</code></td>
<td>文件位于只读文件系统</td>
</tr>
</tbody>
</table>
</div>
<p><strong><code>fchmod</code>函数出错信息</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EBADF</code></td>
<td>非法的文件描述符</td>
</tr>
<tr>
<td><code>EIO</code></td>
<td>发生I/O错误</td>
</tr>
<tr>
<td><code>EPERM</code></td>
<td>有效用户ID与文件拥有者不同，进程无权访问修改文件权限</td>
</tr>
<tr>
<td><code>EROFS</code></td>
<td>文件位于只读系统</td>
</tr>
</tbody>
</table>
</div>
<h3 id="更改文件所有者"><a href="#更改文件所有者" class="headerlink" title="更改文件所有者"></a>更改文件所有者</h3><p>函数原型</p>
<ul>
<li><code>int chown( const char *pathname, uid_t owner, gid_t group);</code></li>
<li><code>int fchown( int filedes, uid_t owner, gid_t group);</code></li>
<li><code>int lchown( const char *pathname, uid_t owner, gid_t group);</code></li>
</ul>
<p>函数用途：更改文件的用户ID和组ID。成功返回0，若出错则返回-1</p>
<p>函数说明：</p>
<ul>
<li>如果两个参数<code>owner</code>或<code>group</code>中的任意一个是<code>-1</code>，则不改变文件所有者或文件所属用户组</li>
<li><code>lchown</code>是改变符号链接本身的所有者，而不是该符号链接所指向的文件</li>
<li>基于BSD的系统中，只有超级用户才能更改一个文件的所有者</li>
<li>非超级用户进程调用,则在成功返回时，该文件的设置用户ID位和设置组ID位会被清除</li>
</ul>
<h3 id="Link函数"><a href="#Link函数" class="headerlink" title="Link函数"></a>Link函数</h3><p>函数原型：<code>int link ( const char *pathname, const char *newpath);</code></p>
<p>函数用途：任何一个文件可以有多个目录项指向其索引节点，创建一个指向现有文件的新目录项</p>
<p>函数说明</p>
<ul>
<li>此函数创建一个新目录项<code>newpath</code>，它指向<code>pathname</code>指向的文件。如果<code>newpath</code>已经存在，则返回出错</li>
<li>创建新目录项以及增加连接计数是一个原子操作。</li>
<li>大多数的系统规定，只有超级用户可以创建指向一个目录的新连接，目的是避免在文件系统中形成循环。</li>
</ul>
<h3 id="unlink函数"><a href="#unlink函数" class="headerlink" title="unlink函数"></a>unlink函数</h3><p>函数原型：<code>int unlink ( const char *pathname);</code></p>
<p>头文件：<code>unistd.h</code></p>
<p>函数用途：<code>unlink</code>删除目录项，并将由<code>pathname</code>所引用文件的链接计数减1，清空这个文件使用的可用的系统资源</p>
<p><code>unlink</code>是系统调用</p>
<h3 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h3><p>函数原型：<code>int remove( const char *pathname);</code></p>
<p>头文件：<code>stdio.h</code></p>
<p>函数用途：<code>remove</code>删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下的所有文件及子目录均删除</p>
<p><code>remove</code>是库函数</p>
<p><code>remove</code>的参数为普通文件时等价于<code>unlink</code></p>
<h3 id="rename函数"><a href="#rename函数" class="headerlink" title="rename函数"></a>rename函数</h3><p>函数原型：<code>int rename ( const char * oldname, const char * newname);</code></p>
<p>函数用途：更名文件或目录</p>
<p>函数说明</p>
<ul>
<li>如果<code>oldname</code>是一个文件而不是目录，那么为该文件更名</li>
<li>如果<code>oldname</code>是一个目录，那么为该目录更名</li>
<li>如果<code>oldname</code>和<code>newname</code>引用同一文件，则函数不做任何更改而成功返回</li>
<li>应对包含两个文件的目录具有写和执行许可权</li>
</ul>
<h3 id="文件的时间"><a href="#文件的时间" class="headerlink" title="文件的时间"></a>文件的时间</h3><p>每个文件有三个时间字段</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408123707548.png" alt="image-20220408123707548"></p>
<p>对文件进行一次读操作，它的访问时间就会改变</p>
<p>修改时间是文件内容最后一次被修改的时间</p>
<p>状态时间是该文件索引节点最后一次被修改的时间，影响索引节点的操作：</p>
<ul>
<li>更改文件访问权限</li>
<li>更改文件用户ID</li>
<li>更改文件链接数</li>
</ul>
<h3 id="utime函数"><a href="#utime函数" class="headerlink" title="utime函数"></a>utime函数</h3><p>函数原型：<code>int utime( const char *pathname, const struct utimbuf *times);</code></p>
<p>函数用途：设置存取和修改文件的时间</p>
<p>函数说明：此函数的操作以及执行它所要求的优先权取决于<code>times</code>参数是否是<code>NULL</code></p>
<ul>
<li>如果<code>times</code>是一个<code>NULL</code>，则存取时间和修改时间两者都设置为当前时间，但必须满足下面二者之一：<ul>
<li>进程的有效用户ID必须等于该文件的所有者</li>
<li>进程对该文件有写许可权</li>
</ul>
</li>
<li>如果<code>times</code>是非空指针，则存取时间和修改时间被设置为<code>times</code>所指向的时间，此时进程的有效用户ID必须等于该文件的所有者ID，或者进程必须是超级用户的进程</li>
</ul>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      
      
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E5%88%9D%E8%AF%861"><span class="nav-number">1.</span> <span class="nav-text">Linux初识1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIX%E5%92%8CLinux"><span class="nav-number">1.1.</span> <span class="nav-text">UNIX和Linux</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">Linux体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.</span> <span class="nav-text">系统调用与库函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%91%BD%E4%BB%A4"><span class="nav-number">1.4.</span> <span class="nav-text">文件目录命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.</span> <span class="nav-text">进程控制类命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="nav-number">1.6.</span> <span class="nav-text">用户和权限管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.</span> <span class="nav-text">编译调试方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gcc%E6%A6%82%E8%BF%B0"><span class="nav-number">1.7.1.</span> <span class="nav-text">gcc概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gdb%E6%A6%82%E8%BF%B0"><span class="nav-number">1.7.2.</span> <span class="nav-text">gdb概述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.</span> <span class="nav-text">Linux文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E5%88%87%E7%9A%86%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">一切皆文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">文件系统架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VFS"><span class="nav-number">2.3.</span> <span class="nav-text">VFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B3%A8%E5%86%8C%E5%92%8C%E6%B3%A8%E9%94%80"><span class="nav-number">2.4.</span> <span class="nav-text">文件系统的注册和注销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-number">2.5.</span> <span class="nav-text">文件系统的安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="nav-number">2.6.</span> <span class="nav-text">文件系统的卸载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C"><span class="nav-number">3.</span> <span class="nav-text">文件IO操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#open%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">open函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#creat%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">creat函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#close%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">close函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read%E5%87%BD%E6%95%B0"><span class="nav-number">3.4.</span> <span class="nav-text">read函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.</span> <span class="nav-text">write函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.6.</span> <span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ioctl%E5%87%BD%E6%95%B0"><span class="nav-number">3.7.</span> <span class="nav-text">ioctl函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E5%87%86IO"><span class="nav-number">4.</span> <span class="nav-text">标准IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fopen%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">fopen函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setbuf%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">setbuf函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setvbuf%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">setvbuf函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fdopen%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">fdopen函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D"><span class="nav-number">5.</span> <span class="nav-text">文件定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lseek%E5%87%BD%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">lseek函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pread%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">pread函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwrite%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">pwrite函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94"><span class="nav-number">5.4.</span> <span class="nav-text">对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="nav-number">6.</span> <span class="nav-text">文件共享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6"><span class="nav-number">6.1.</span> <span class="nav-text">进程共享文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dup%E5%92%8Cdup2"><span class="nav-number">6.2.</span> <span class="nav-text">dup和dup2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6"><span class="nav-number">6.3.</span> <span class="nav-text">线程共享文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="nav-number">7.</span> <span class="nav-text">目录操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ls-l"><span class="nav-number">7.1.</span> <span class="nav-text">ls -l</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95"><span class="nav-number">7.2.</span> <span class="nav-text">获取当前目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DIR%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">7.3.</span> <span class="nav-text">DIR结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E7%9B%AE%E5%BD%95"><span class="nav-number">7.4.</span> <span class="nav-text">打开目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E7%9B%AE%E5%BD%95"><span class="nav-number">7.5.</span> <span class="nav-text">关闭目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dirent%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">7.6.</span> <span class="nav-text">dirent结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6"><span class="nav-number">7.7.</span> <span class="nav-text">读取目录文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">7.8.</span> <span class="nav-text">示例：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="nav-number">7.9.</span> <span class="nav-text">创建目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90mode"><span class="nav-number">7.10.</span> <span class="nav-text">文件权限mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95"><span class="nav-number">7.11.</span> <span class="nav-text">删除目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="nav-number">7.12.</span> <span class="nav-text">改变当前工作目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%9B%AE%E5%BD%95%E8%AF%BB%E5%8F%96%E4%BD%8D%E7%BD%AE"><span class="nav-number">7.13.</span> <span class="nav-text">设置目录读取位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%9B%AE%E5%BD%95%E8%AF%BB%E5%8F%96%E4%BD%8D%E7%BD%AE"><span class="nav-number">7.14.</span> <span class="nav-text">获取目录读取位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E7%89%B9%E5%AE%9A%E7%9B%AE%E5%BD%95%E6%95%B0%E6%8D%AE"><span class="nav-number">7.15.</span> <span class="nav-text">读取特定目录数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">文件属性管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.1.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="nav-number">8.2.</span> <span class="nav-text">读取文件属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stat%E7%BB%93%E6%9E%84"><span class="nav-number">8.3.</span> <span class="nav-text">stat结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#st-mode"><span class="nav-number">8.4.</span> <span class="nav-text">st_mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B2%98%E7%9D%80%E4%BD%8D"><span class="nav-number">8.5.</span> <span class="nav-text">粘着位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#st-size"><span class="nav-number">8.6.</span> <span class="nav-text">st_size</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%88%AA%E6%96%AD"><span class="nav-number">8.7.</span> <span class="nav-text">文件截断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#passwd%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">8.8.</span> <span class="nav-text">passwd结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7"><span class="nav-number">8.9.</span> <span class="nav-text">获取用户属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#group%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">8.10.</span> <span class="nav-text">group结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%BB%84%E5%B1%9E%E6%80%A7"><span class="nav-number">8.11.</span> <span class="nav-text">获取组属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6"><span class="nav-number">8.12.</span> <span class="nav-text">设备特殊文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">文件权限管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="nav-number">9.1.</span> <span class="nav-text">文件权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90"><span class="nav-number">9.2.</span> <span class="nav-text">目录权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="nav-number">9.3.</span> <span class="nav-text">检查文件权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="nav-number">9.4.</span> <span class="nav-text">改变文件权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E6%89%80%E6%9C%89%E8%80%85"><span class="nav-number">9.5.</span> <span class="nav-text">更改文件所有者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Link%E5%87%BD%E6%95%B0"><span class="nav-number">9.6.</span> <span class="nav-text">Link函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unlink%E5%87%BD%E6%95%B0"><span class="nav-number">9.7.</span> <span class="nav-text">unlink函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove%E5%87%BD%E6%95%B0"><span class="nav-number">9.8.</span> <span class="nav-text">remove函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rename%E5%87%BD%E6%95%B0"><span class="nav-number">9.9.</span> <span class="nav-text">rename函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%B6%E9%97%B4"><span class="nav-number">9.10.</span> <span class="nav-text">文件的时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#utime%E5%87%BD%E6%95%B0"><span class="nav-number">9.11.</span> <span class="nav-text">utime函数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yanglinqi"
      src="/images/headpic.jpg">
  <p class="site-author-name" itemprop="name">yanglinqi</p>
  <div class="site-description" itemprop="description">用于做笔记，对学过的知识总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yanglinqi107" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanglinqi107" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yanglinqi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


  <script async src="/js/cursor/fireworks.js"></script>


</body>
</html>

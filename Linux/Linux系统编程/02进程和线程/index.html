<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yanglinqi107.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="学自电子科技大学，以下是一些补充内容和参考链接 C 语言中 void* 详解及应用 | 菜鸟教程 (runoob.com)  https:&#x2F;&#x2F;www.runoob.com&#x2F;w3cnote&#x2F;c-general-function.html  void * 是什么？_杨博东的博客的博客-CSDN博客_void*是什么  find &#x2F;usr&#x2F;include&#x2F; -name *.h | xargs grep">
<meta property="og:type" content="article">
<meta property="og:title" content="进程和线程">
<meta property="og:url" content="http://yanglinqi107.github.io/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="杨记">
<meta property="og:description" content="学自电子科技大学，以下是一些补充内容和参考链接 C 语言中 void* 详解及应用 | 菜鸟教程 (runoob.com)  https:&#x2F;&#x2F;www.runoob.com&#x2F;w3cnote&#x2F;c-general-function.html  void * 是什么？_杨博东的博客的博客-CSDN博客_void*是什么  find &#x2F;usr&#x2F;include&#x2F; -name *.h | xargs grep">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408151230066.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408152319518.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408152511000.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408153141627.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408153548237.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408153641182.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408153746262.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408153845177.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408154448602.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408154918504.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408155147072.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408155713660.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408160016081.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408165715572.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408170102390.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408151230066.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408152319518.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408171803255.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408175512633.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408191339232.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408210223114.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408210750881.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408212001229.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408212220015.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408213845594.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409105538106.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409105638271.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409105638271.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409110646792.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409111016348.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409111207007.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409111815455.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220412122856363.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409121804687.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409141437071.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409142558448.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220412170357636.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409151806118.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409153932168.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409154622468.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409160816138.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409165937723.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409175106240.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409200437797.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409203702015.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409232240314.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410122956953.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410124204976.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410124244462.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410124311260.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410124618074.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410135610074.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220413222409448.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220413222629672.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410144858118.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410170728545.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410170545001.png">
<meta property="article:published_time" content="2022-05-17T14:55:40.632Z">
<meta property="article:modified_time" content="2022-05-19T05:39:14.288Z">
<meta property="article:author" content="yanglinqi">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408151230066.png">

<link rel="canonical" href="http://yanglinqi107.github.io/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>进程和线程 | 杨记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杨记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">碎片化学习令人焦虑，系统化学习使人进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">20</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">89</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yanglinqi107.github.io/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headpic.jpg">
      <meta itemprop="name" content="yanglinqi">
      <meta itemprop="description" content="用于做笔记，对学过的知识总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          进程和线程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-17 22:55:40" itemprop="dateCreated datePublished" datetime="2022-05-17T22:55:40+08:00">2022-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-19 13:39:14" itemprop="dateModified" datetime="2022-05-19T13:39:14+08:00">2022-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Linux系统编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>学自电子科技大学，以下是一些补充内容和参考链接</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/c-void-intro.html">C 语言中 void* 详解及应用 | 菜鸟教程 (runoob.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/c-general-function.html">https://www.runoob.com/w3cnote/c-general-function.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangbodong22011/article/details/53224856"> void * 是什么？_杨博东的博客的博客-CSDN博客_void*是什么</a> </p>
<p><code>find /usr/include/ -name *.h | xargs grep &#39;MRT6_INIT&#39;</code></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weibo1230123/article/details/81410241">linux中pthread_join()与pthread_detach()详解_魏波-的博客-CSDN博客_pthread_detach</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/modi000/article/details/108345917">pthread_join()和pthread_detach()二者的区别_modi000的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Qiuoooooo/article/details/60573433">IPC之信号量详解_Qiuoooooo的博客-CSDN博客_ipc信号量</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44522306/article/details/89643615">IPC之信号量_车小猿的博客-CSDN博客_ipc信号量</a></p>
<span id="more"></span>

<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>程序是包含可执行代码以及执行代码需要的数据等信息的文件，存放在磁盘等介质上。</p>
<p>当程序被操作系统装载到内存并分配给它一定资源后，此时可称为进程。</p>
<p>程序是静态概念，进程是动态概念。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408151230066.png" alt="image-20220408151230066"></p>
<h3 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h3><p>进程ID、用户ID、进程状态、调度信息、文件管理、虚拟内存管理、信号（进程间通信机制）、时间和定时器、……</p>
<h3 id="task-struct结构"><a href="#task-struct结构" class="headerlink" title="task_struct结构"></a>task_struct结构</h3><p>Linux进程控制块的具体实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;	<span class="comment">// 进程id</span></span><br><span class="line"><span class="keyword">uid_t</span> uid,euid;	<span class="comment">// 用户id 有效用户id</span></span><br><span class="line"><span class="keyword">gid_t</span> gid,egid;	<span class="comment">// 用户组id 有效用户组id</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> state;	<span class="comment">// 进程状态</span></span><br><span class="line"><span class="keyword">int</span> exit_state;			<span class="comment">// 退出状态</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;	<span class="comment">// </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> policy;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">real_parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>,<span class="title">sibling</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span> 	<span class="comment">// 文件描述表 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span>	<span class="comment">// 文件表 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>	<span class="comment">// 内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span></span><br><span class="line"><span class="keyword">cputime_t</span> utime, stime;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start_time</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">real_start_time</span>;</span></span><br></pre></td></tr></table></figure>



<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p><code>volatile long state;</code></p>
<ul>
<li><p>state成员的可能取值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_ZOMBIE 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STOPPED 8</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>进程状态切换</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408152319518.png" alt="image-20220408152319518"></p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p><code>struct fs_struct *fs;     // 文件描述表 </code></p>
<p><code>struct files_struct *files;    // 文件表</code> </p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408152511000.png" alt="image-20220408152511000"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408153141627.png" alt="image-20220408153141627"></p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p><code>struct mm_struct *mm;    // 内存</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408153548237.png" alt="image-20220408153548237"></p>
<h3 id="进程组织形式"><a href="#进程组织形式" class="headerlink" title="进程组织形式"></a>进程组织形式</h3><p><strong>进程控制块的物理组织结构</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408153641182.png" alt="image-20220408153641182"></p>
<p><strong>进程控制块的逻辑组织结构</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408153746262.png" alt="image-20220408153746262"></p>
<p>使用<code>pstree</code>查看当前进程的树形图</p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408153845177.png" alt="image-20220408153845177" style="zoom: 80%;" />



<h2 id="进程属性"><a href="#进程属性" class="headerlink" title="进程属性"></a>进程属性</h2><p>使用<code>ps -aux</code>查看进程及其部分属性</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408154448602.png" alt="image-20220408154448602"></p>
<h3 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h3><p>头文件<code>/usr/include/unistd.h</code></p>
<p>函数：<code>pid_t getpid( void);</code></p>
<ul>
<li><code>pid_t</code>实际就是<code>int</code>类型</li>
<li>执行成功返回当前进程的ID，失败返回-1（错误原因存储在errorno中）</li>
</ul>
<h3 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h3><p><strong>与进程相关联的用户ID包含以下类型</strong>：</p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408154918504.png" alt="image-20220408154918504" style="zoom: 50%;" />

<p><strong>真实用户与有效用户的关系</strong>：</p>
<ul>
<li>通常情况下，有效用户与真实用户相同（有效用户ID等于真实用户ID ），有效用户组与真实用户组相同（有效用户组ID等于真实用户组ID）</li>
<li>可执行文件的文件属性可以<strong>设置特殊属性域</strong>，定义为“当执行此文件时,将进程的有效用户设置为文件的所有者”，与此类似，组ID也有类似的情况，定义为“当执行此文件时,将进程的有效用户组置为文件所有者所在组”。这两个标志位称为：<strong>设置用户ID位</strong>（setuid）和<strong>设置组ID位</strong>（setgid）</li>
<li><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408155147072.png" alt="image-20220408155147072"></li>
<li><strong>设置用户ID是图中11位，设置组ID位是图中10位</strong></li>
</ul>
<p>示例：<code>passwd</code>命令程序就设置了设置用户ID位</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408155713660.png" alt="image-20220408155713660"></p>
<p>使用<code>chmod</code>对可执行文件修改设置用户ID位</p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408160016081.png" alt="image-20220408160016081" style="zoom:80%;" />

<hr>
<p><strong>获取真实用户和真实用户组</strong></p>
<p>进程真实用户为执行命令/可执行文件的用户，真实用户组为真实用户所在的组</p>
<p><strong>获取有效用户和有效用户组</strong></p>
<p>进程有效用户和有效用户组只有当可执行文件设置了<code>setuid</code>位或<code>setgid</code>位时才会发生变化</p>
<ul>
<li>真实用户ID：<code>uid_t getuid(void);</code></li>
<li>真实用户组ID：<code>uid_t getgid(void);</code></li>
<li>有效用户ID：<code>uid_t geteuid(void);</code></li>
<li>有效用户组ID：<code>uid_t getegid(void);</code></li>
</ul>
<p>头文件：<code>/usr/include/unistd.h</code></p>
<p>执行成功返回对应ID，失败返回-1（错误原因存储在errorno中）</p>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//suid.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;real uid: %d, real gid:%d\n&quot;</span>,getuid(),getgid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;effective uid: %d, effective gid: %d\n&quot;</span>,geteuid(),getegid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408165715572.png" alt="image-20220408165715572"></p>
<hr>
<p><strong>普通用户能够修改自己的密码的原因</strong>：</p>
<ul>
<li><p><code>/etc/passwd</code>文件用来存储所有用户信息，<code>/etc/shadow</code>用来存储用户密码</p>
</li>
<li><p>所有用户都可以修改自己的密码（修改了<code>/etc/shadow</code>文件），但普通用户对/etc/shadow没有读写权限</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408170102390.png" alt="image-20220408170102390"></p>
</li>
<li><p>用户通过执行passwd命令（ <code>/usr/bin/passwd</code>文件）来修改密码；该文件设置了<code>setuid</code>位，在执行此命令时，该进程的有效用户不等于真实用户，而等于文件所有者（root）</p>
</li>
<li><p>Linux根据进程的有效用户进行权限检查，有效用户等于root则允许任何操作（包括对<code>/ect/shadow</code>文件的读写操作）</p>
</li>
<li><p>如果清除掉<code>/usr/bin/passwd</code>文件的<code>setuid</code>权限位，普通用户就不能修改自己的密码了</p>
</li>
</ul>
<h2 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h2><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408151230066.png" alt="image-20220408151230066"></p>
<h3 id="进程状态切换"><a href="#进程状态切换" class="headerlink" title="进程状态切换"></a>进程状态切换</h3><p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408152319518.png" alt="image-20220408152319518"></p>
<h3 id="进程的启动"><a href="#进程的启动" class="headerlink" title="进程的启动"></a>进程的启动</h3><p>C程序的启动函数是<code>main</code>，也是进程代码的入口点</p>
<ul>
<li><code>main ( int argc, char *argv[] );</code></li>
</ul>
<p>当内核启动C程序时，会在调用main函数前调用<strong>特殊的启动函数</strong>来获取<code>main</code>函数地址和传递给<code>main</code>函数的参数，并且将这些信息填写到进程控制块中</p>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>正常终止</p>
<ul>
<li>从<code>main</code>函数中返回</li>
<li>在任意代码中调用<code>exit</code>函数或<code>_exit</code>函数</li>
<li>最后一个线程从其启动例程中返回</li>
<li>最后一个线程调用<code>pthread_exit</code>函数</li>
</ul>
<p>异常终止</p>
<ul>
<li>在任意代码中调用<code>abort</code>函数</li>
<li>接收到终止信号</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408171803255.png" alt="image-20220408171803255"></p>
<h3 id="终止进程函数"><a href="#终止进程函数" class="headerlink" title="终止进程函数"></a>终止进程函数</h3><p>头文件<code>stdlib.h</code>，函数定义：<code>void exit( int status )</code></p>
<p>头文件<code>unistd.h</code>，函数定义：<code>void _exit (int status )</code></p>
<ul>
<li>调用这两个函数均会正常地终止一个进程</li>
<li>调用<code>_exit </code>函数将会立即返回内核</li>
<li>调用<code>exit</code>函数：<ul>
<li>执行预先注册的终止处理函数</li>
<li>执行文件I/O操作的善后工作，使得所有缓冲的输出数据被更新到相应的设备</li>
<li>返回内核</li>
</ul>
</li>
</ul>
<p><strong>exit与return的区别</strong>：</p>
<ul>
<li><code>return</code>是C语言关键字，<code>exit</code>是POSIX API函数</li>
<li>在<code>main</code>函数中，执行<code>return</code>和调用<code>exit</code>函数会产生相同的效果</li>
<li>在子函数中，执行<code>return</code>仅仅从子函数中返回，而调用<code>exit</code>函数将会退出当前进程</li>
</ul>
<h3 id="注册终止处理函数"><a href="#注册终止处理函数" class="headerlink" title="注册终止处理函数"></a>注册终止处理函数</h3><ul>
<li><p>当进程终止时，程序可能需要进行一些自身的清理工作，如日志登记、资源释放等</p>
</li>
<li><p>通过<code>atexit</code>函数或<code>on_exit</code>函数允许进程注册若干终止处理函数，当进程终止时，这些终止处理函数将会被自动调用</p>
</li>
</ul>
<p>头文件<code>stdlib.h</code></p>
<p>函数原型：</p>
<ul>
<li><code>int atexit(void (*func)(void));</code><ul>
<li>成功返回0，不成功非0</li>
</ul>
</li>
<li><code>int on_exit (void (*func)(int, void *), void *arg);</code><ul>
<li><code>func</code>第一个参数是来自最后一个exit()函数调用中的<code>status</code>或 <code>return</code></li>
<li><code>func</code>第二个参数是来自<code>on_exit()</code>函数中的arg</li>
<li>成功返回0，不成功非0</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li><code>ANSI C</code>规定一个进程最多能注册<strong>32</strong>个终止处理函数</li>
<li>当<strong>显示调用</strong>或者<strong>隐含调用</strong><code>exit</code>函数（从<code>main</code>中返回、最后一个线程退出等）终止进程将会回调这些注册的终止处理函数（最先注册的函数最后被回调）</li>
<li><strong>显示调用<code>_exit</code>函数</strong>终止进程时将不会回调这些注册的终止函数</li>
</ul>
<p><strong>示例：<code>atexit</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//atexit_text.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func1 is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func2 is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func3 is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	atexit(func1);</span><br><span class="line">	atexit(func2);</span><br><span class="line">	atexit(func3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;process exit\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408175512633.png" alt="image-20220408175512633" style="zoom:80%;" />

<p><strong>示例：<code>on_exit</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//on_exit_text.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j ,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func1 exit status is %d\n&quot;</span>, status);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func1 arg is %d\n&quot;</span>, *((<span class="keyword">int</span>*)arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func2 exit status is %d\n&quot;</span>, status);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func2 arg is %d\n&quot;</span>, *((<span class="keyword">int</span>*)arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func3 exit status is %d\n&quot;</span>, status);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func3 arg is %d\n&quot;</span>, *((<span class="keyword">int</span>*)arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> *argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i = <span class="number">3</span>;</span><br><span class="line">	on_exit(func1, (<span class="keyword">void</span>*)&amp;i);</span><br><span class="line">	j = <span class="number">4</span>;</span><br><span class="line">	on_exit(func2, (<span class="keyword">void</span>*)&amp;j);</span><br><span class="line">	k = <span class="number">5</span>;</span><br><span class="line">	on_exit(func3, (<span class="keyword">void</span>*)&amp;k);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 改成1的话，下面输出的 status值就为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408191339232.png" alt="image-20220408191339232"></p>
<h2 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>1、内核空间  2、内存空间</p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408210223114.png" alt="image-20220408210223114" style="zoom:80%;" />



<h3 id="用户空间布局"><a href="#用户空间布局" class="headerlink" title="用户空间布局"></a>用户空间布局</h3><p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408210750881.png" alt="image-20220408210750881"></p>
<ul>
<li>正文：CPU执行的代码部分，正文段通常是共享、只读的</li>
<li>初始化的数据：包含了程序中需明确赋初值的变量，如全局变量<code>int maxcount=99;</code></li>
<li>未初始化的数据：程序执行之前，将此段中的数据初始化为0，如全局变量<code>long sum[1000];</code></li>
<li>堆：用于动态分配内存</li>
<li>栈：主要用于支撑函数调用存放参数、局部变量等</li>
<li>命令行参数</li>
<li>环境变量</li>
</ul>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><ul>
<li><strong>命令行参数</strong>：命令后面的字符都是参数<ul>
<li><code>ls [参数] &lt;路径或文件名&gt;</code> ，<code>ls -l /home</code></li>
<li><code>mkdir [参数] &lt;目录名&gt;</code>， <code>mkdir -p /home/xiaokun/src</code></li>
<li><code>cp [参数] &lt;源文件路径&gt; &lt;目标文件路径&gt;</code>， <code>cp -r /usr/local/src /root</code></li>
</ul>
</li>
</ul>
<p><strong>C程序中main函数参数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myecho.C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Argument %d is %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408212001229.png" alt="image-20220408212001229"></p>
<p><font color=#ff0000>注意：</font>命令名也传入<code>main</code>中，占 0 位</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p><strong>环境变量表</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408212220015.png" alt="image-20220408212220015"></p>
<ul>
<li>每个进程都会有自己的环境变量表 </li>
<li>通过全局的环境指针 （environ）可以直接访问环境变量表（字符串数组）<ul>
<li>头文件<code>unistd.h</code> </li>
<li><code>extern char **environ;</code></li>
</ul>
</li>
<li>环境变量字符串形式为 <code>name=value</code><ul>
<li><code>name</code>是环境变量名称</li>
<li><code>value</code>为环境变量赋值</li>
</ul>
</li>
</ul>
<p><strong>获取环境变量</strong></p>
<p>获取环境变量的方法</p>
<ul>
<li>直接通过<code>environ</code>变量访问环境表</li>
<li>使用<code>getenv</code>函数</li>
</ul>
<p><code>getenv</code>函数用于获取环境变量值</p>
<ul>
<li>头文件：<code>stdlib.h</code></li>
<li>函数原型：<code>char* getenv(const char *name);</code></li>
<li>指定环境变量名称，返回环境变量字符串指针，若未找到则返回空指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *path = getenv(<span class="string">&quot;PATH&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220408213845594.png" alt="image-20220408213845594"></p>
<p><strong>设置环境变量</strong></p>
<p>设置环境变量的三种方法</p>
<ul>
<li><code>putenv</code></li>
<li><code>setenv</code></li>
<li><code>unsetenv</code></li>
</ul>
<p><code>putenv</code>函数将环境变量字符串放入环境变量表中；若该字符串已经存在，则覆盖</p>
<ul>
<li>头文件：<code>stdlib.h</code></li>
<li>函数原型：<code>int putenv(char *str);</code></li>
</ul>
<p><code>setenv</code></p>
<ul>
<li>头文件：<code>stdlib.h</code></li>
<li>函数原型：<code>int setenv(const char* name, const char* value, int rewrite);</code></li>
<li><code>setenv</code>将指定环境变量的值设置为参数指定值（更改环境变量字符串）</li>
<li>若<code>name</code>已经存在<ul>
<li><code>rewrite</code>不等于0，则删除其原先的定义</li>
<li><code>rewrite</code>等于0，则不删除其原先的定义</li>
</ul>
</li>
</ul>
<p><code>unsetenv</code></p>
<ul>
<li>头文件：<code>stdlib.h</code></li>
<li>函数原型：<code>int unsetenv(const char* name);</code></li>
<li>删除指定的环境变量字符串</li>
</ul>
<h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><h3 id="Linux进程"><a href="#Linux进程" class="headerlink" title="Linux进程"></a>Linux进程</h3><p><strong>Linux中创建进程的方式：</strong></p>
<ul>
<li>在<code>shell</code>中执行命令或可执行文件<ul>
<li>由shell进程调用<code>fork</code>函数创建子进程</li>
</ul>
</li>
<li>在代码中（已经存在的进程中）调用<code>fork </code>函数创建子进程<ul>
<li>通过<code>fork</code>函数创建的进程为已经存在进程的子进程</li>
</ul>
</li>
</ul>
<hr>
<p>Linux系统中进程0（PID=0）是由内核创建，其他所有进程都是由父进程调用<code>fork</code>函数所创建的</p>
<p>Linux系统中进程0在创建子进程（PID=1，<code>init</code>进程）后，进程0就转为交换进程或空闲进程</p>
<p>进程1（init进程）是系统中其他所有进程的共同祖先</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409105538106.png" alt="image-20220409105538106" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409105638271.png" alt="image-20220409105638271"></p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409105638271.png" alt="image-20220409105538106" style="zoom: 67%;" />



<hr>
<h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a><code>fork</code>函数</h3><p>头文件：<code>unistd.h</code><br>函数原型：<code>pid_t fork(void);</code></p>
<p>返回值：</p>
<ul>
<li><p><code>fork</code>函数被正确调用后，将会在子进程中和父进程中分别返回！！</p>
</li>
<li><p>在子进程中返回值为0（不合法的PID，提示当前运行在子进程中）</p>
</li>
<li><p>在父进程中返回值为子进程ID（让父进程掌握所创建子进程的ID号）</p>
</li>
<li><p>出错返回<code>-1</code></p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;the returned value is %d\n&quot;</span>, pid);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;in child process!!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;My PID is %d\n&quot;</span>, getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;the returned value is %d\n&quot;</span>, pid);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;in father process!!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;My PID is %d\n&quot;</span>, getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409110646792.png" alt="image-20220409110646792" style="zoom: 80%;" />



<h3 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h3><p><strong>fork函数工作流程</strong></p>
<ul>
<li>子进程是父进程的副本<ul>
<li>子进程复制/拷贝父进程的PCB、数据空间（数据段、堆和栈）</li>
<li>父子进程共享正文段（只读）</li>
</ul>
</li>
<li>子进程和父进程继续执行<code>fork</code>函数调用之后的代码</li>
<li>为了提高效率，<code>fork</code>后不并立即复制父进程数据段、堆和栈，采用了<strong>写时复制机制（Copy-On-Write）</strong><ul>
<li>当父子进程任意之一要修改数据段、堆、栈时，进行复制操作，并且仅复制修改区域</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409111016348.png" alt="image-20220409111016348" style="zoom:67%;" />



<p><strong>父子进程异同</strong></p>
<p>相同：</p>
<ul>
<li>真实用户ID，真实组ID</li>
<li>有效用户ID，有效组ID</li>
<li>环境变量</li>
<li>堆</li>
<li>栈</li>
<li>打开的文件</li>
</ul>
<p>不同：</p>
<ul>
<li><code>fork</code>的返回值</li>
<li>进程ID及父进程ID</li>
<li>子进程的 <code>tms_utime</code>, <code>tms_stime</code>,<code>tms_cutime</code>,<code>tms_ustime</code>值被设置为 0</li>
</ul>
<p><strong>父子进程共享文件</strong></p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409111207007.png" alt="image-20220409111207007" style="zoom:67%;" />

<p>父子进程对共享文件的常见处理方式：</p>
<ul>
<li>父进程等待子进程完成。当子进程终止后，文件当前位置已经得到了相应的更新</li>
<li>父子进程各自执行不同的程序段，各自关闭不需要的文件</li>
</ul>
<h3 id="fork用法"><a href="#fork用法" class="headerlink" title="fork用法"></a>fork用法</h3><ul>
<li>父进程希望复制自己（共享代码，复制数据空间），但父子进程<strong>执行相同代码中的不同分支</strong><ul>
<li>网络服务程序中，父进程等待客户端的服务请求，当请求达到时，父进程调用fork创建子进程处理该请求，而父进程继续等待下一个服务请求到达</li>
</ul>
</li>
<li>父子进程<strong>执行不同的可执行文件</strong>（父子进程具有完全不同的代码段和数据空间）<ul>
<li>子进程从<code>fork</code>返回后，立即调用<code>exec</code>类函数执行另外一个可执行文件</li>
</ul>
</li>
</ul>
<h3 id="vfork函数"><a href="#vfork函数" class="headerlink" title="vfork函数"></a>vfork函数</h3><ul>
<li><code>vfork</code>用于创建新进程，而该新进程的目的是执行另外一个可执行文件</li>
<li>由于新程序将有自己的地址空间，因此<code>vfork</code>函数并不将父进程的地址空间完全复制到子进程中</li>
<li>子进程在调用<code>exec</code>或<code>exit</code>之前，在父进程的地址空间中运行</li>
<li><code>vfork</code>函数保证子进程先执行，在它调用<code>exec</code>或者<code>exit</code>之后，父进程才会继续被调度执行（父进程处于<code>TASK_UNINTERRUPTIBLE</code>状态）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409111815455.png" alt="image-20220409111815455"></p>
<h2 id="子进程状态"><a href="#子进程状态" class="headerlink" title="子进程状态"></a>子进程状态</h2><p><strong>获知子进程状态信息改变</strong>：</p>
<p>当一个进程发生特定的状态变化（进程终止、暂停以及恢复）时，内核向其父进程发送<code>SIGCHLD</code>信号</p>
<p>父进程可以选择忽略该信号，也可以对信号进行处理（默认处理方式为忽略该信号）</p>
<p><strong><code>wait</code>或<code>waitpid</code>函数</strong>可以用于等待子进程状态信息改变，并获取其状态信息</p>
<p><strong>僵尸进程</strong></p>
<p>进程在退出之前会释放进程用户空间的所有资源，但PCB等内核空间资源不会被释放</p>
<ul>
<li>当父进程调用<code>wait</code>或<code>waitpid</code>函数后，内核将根据情况关闭该进程打开的所有文件，释放PCB（释放内核空间资源）</li>
<li>对于已经终止但父进程尚未对其调用<code>wait</code>或<code>waitpid</code>函数的进程（<code>TASK_ZOMBIE</code>状态），称为<strong>僵尸进程</strong></li>
</ul>
<p>如果父进程在子进程终止之前终止，则子进程的父进程将变为<code>init</code>进程，保证每个进程都有父进程，由<code>init</code>进程调用<code>wait</code>函数进行善后</p>
<p><strong>wait函数</strong></p>
<p>功能：获取任意子进程的状态改变信息（如果是终止状态则对子进程进行善后处理）</p>
<p>头文件：<code>sys/wait.h</code></p>
<p>函数原型：<code>pid_t wait(int *statloc);</code></p>
<ul>
<li><code>statloc</code>：用于获取子进程的状态改变</li>
<li><code>statloc</code>可以为空指针，此时父进程不需要具体了解子进程的状态变化，只是为了防止子进程成为僵尸进程，或者因为同步原因需等待子进程终止</li>
<li>若<code>statloc</code>不是空指针，则内核将子进程状态改变信息存放在它指向的存储空间中</li>
</ul>
<p>返回值：若成功返回状态信息改变子进程ID，出错返回-1</p>
<hr>
<p>子进程状态改变信息包含了多种类型的信息，可以通过系统提供的宏来快速解析子进程的状态</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>WIFEXITED(statloc)</code></td>
<td>当子进程正常终止时该宏为真，对于这种情况可进一步执行<code>WEXITSTATUS(statloc)</code>，获取子进程传递给<code>exit</code>、<code>_exit</code>函数参数的低8位</td>
</tr>
<tr>
<td><code>WIFSIGNALED(statloc)</code></td>
<td>当子进程异常终止时该宏为真，对于这种情况可进一步执行<code>WTERMSTG(statloc)</code>，获取使子进程终止的信号编号</td>
</tr>
<tr>
<td><code>WIFSTOPPED(statloc)</code></td>
<td>当子进程暂停时该宏为真，对于这种情况可进一步执行<code>WSTOPSIG(statloc)</code>，获取使子进程暂停的信号编号</td>
</tr>
<tr>
<td><code>WIFCONTINUED(statloc)</code></td>
<td>若子进程在暂停后已经继续则该宏为真</td>
</tr>
</tbody></table>
<hr>
<p>调用<code>wait</code>函数之后，父进程可能出现的情况：</p>
<ul>
<li>如果所有子进程都还在运行，则父进程被阻塞（<code>TASK_INTERRUPTIBLE</code>状态），直到有一个子进程终止或暂停，<code>wait</code>函数才返回</li>
<li>如果已经有子进程进入终止或暂停状态，则<code>wait</code>函数会立即返回</li>
<li>若进程没有任何子进程，则立即出错返回<code>-1</code></li>
</ul>
<p><strong>等待特定子进程状态改变</strong>：</p>
<p>如果一个进程有几个子进程，那么只要有一个子进程状态改变，wait函数就返回</p>
<p>如何才能使用wait函数等待某个特定子进程的状态改变？</p>
<ul>
<li>调用<code>wait</code>，然后将其返回的进程ID和所期望的子进程ID进行比较。如果ID不一致，则保存该ID，并循环调用<code>wait</code>函数，直到等到所期望的子进程ID为止</li>
<li>使用<code>waitpid</code></li>
</ul>
<p><strong>waitpid函数</strong></p>
<p>功能：等待某个特定子进程状态改变</p>
<p>头文件：<code>sys/wait.h</code></p>
<p>头文件：<code>pid_t waitpid(pid_t pid, int *statloc, int options);</code></p>
<p>返回值：成功返回终止子进程ID，失败返回-1</p>
<p>参数：</p>
<ul>
<li><code>pid</code></li>
<li><code>pid == -1</code>：等待任意子进程执行终止（同wait）</li>
<li><code>pid &gt; 0</code>：等待进程ID为pid的子进程执行终止</li>
<li><code>pid == 0</code>：等待其组ID等于调用进程组ID的任意子进程</li>
<li><code>pid &lt; -1</code>：等待其组ID等于pid绝对值的任意子进程</li>
<li><code>statloc</code>：存放子进程终止状态</li>
<li><code>options</code>：可以为0，也可以是以下常量或常量的或</li>
<li><code>WCONTINUED</code>：如果有暂停的进程由于<code>SIGCONT</code>信号的到来而继续运行，则函数将返回</li>
<li><code>WUNTRACED</code>：如果有处于终止状态的进程，则函数返回</li>
<li><code>WNOHANG</code>：如果没有任何已经终止的子进程则马上返回,，函数不等待，此时返回值为0</li>
</ul>
<p><strong>waitpid的特有功能</strong>：</p>
<ul>
<li><code>waitpid</code>可等待一个特定的进程的状态改变信息</li>
<li><code>waitpid</code>可以实现非阻塞（异步）的等待操作，有时希望取得子进程的状态改变信息，但不希望阻塞等待子进程状态改变</li>
<li><code>waitpid</code>支持作业控制（进程组控制）</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid_child, pid_return;</span><br><span class="line">    pid_child = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid_child &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occuredon forking.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid_child == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        pid_return = waitpid(pid_child, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span> (pid_return == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No child exited\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pid_return == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid_return == pid_child)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;successfullyget child %d\n&quot;</span>, pid_return);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;some error occured\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220412122856363.png" alt="image-20220412122856363"></p>
<h2 id="子进程运行可执行文件"><a href="#子进程运行可执行文件" class="headerlink" title="子进程运行可执行文件"></a>子进程运行可执行文件</h2><p>进程调用<strong>exec系列函数</strong>在进程中加载执行另外一个可执行文件</p>
<p>exec系列函数替换了当前进程（执行该函数的进程）的<strong>正文段、数据段、堆和栈</strong>（来源于加载的可执行文件）</p>
<p>执行exec系列函数后从加载可执行文件的main函数开始重新执行</p>
<p>exec系列函数并不创建新进程，所以在调用exec系列函数后其进程ID并未改变，已经打开的文件描述符不变</p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409121804687.png" alt="image-20220409121804687" style="zoom:80%;" />



<h3 id="exec系列函数"><a href="#exec系列函数" class="headerlink" title="exec系列函数"></a>exec系列函数</h3><ul>
<li><code>execl execle execlp execv execve execvp</code> 共6个函数</li>
<li><code>l</code>：表示list，每个命令行参数都说明为一个单独的参数</li>
<li><code>v</code>：表示vector，命令行参数放在数组中</li>
<li><code>e</code>：表示由函数调用者提供环境变量表</li>
<li><code>p</code>：表示通过环境变量PATH来指定路径，查找可执行文件</li>
</ul>
<h3 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a>execl函数</h3><p>头文件：<code>unistd.h</code></p>
<p>函数原型：<code>int execl(const char *pathname, const char *arg0, ...,NULL</code></p>
<p>参数：</p>
<ul>
<li><code>pathname</code>：要执行程序的绝对路径名</li>
<li>可变参数：要执行程序的命令行参数，以空指针<code>NULL</code>结束</li>
</ul>
<p>返回值：</p>
<ul>
<li>出错返回-1</li>
<li>成功该函数不返回！</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;entering main process--\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>); </span><br><span class="line">        <span class="comment">//若execl执行成功，execl后面的代码不会执行，而是运行新的可执行文件的代码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exiting main process --\n&quot;</span>); <span class="comment">//这句代码不会执行</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="execv函数"><a href="#execv函数" class="headerlink" title="execv函数"></a>execv函数</h3><p>头文件：<code>unistd.h</code></p>
<p>函数原型：<code>int execv(const char *pathname, char *const argv[]);</code></p>
<p>参数：</p>
<ul>
<li><code>pathname</code>：要执行程序的绝对路径名</li>
<li><code>argv</code>：数组指针维护的程序命令行参数列表，该数组的最后一个成员必须为空指针</li>
</ul>
<p>返回值</p>
<ul>
<li>出错返回-1</li>
<li>成功该函数不返回</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;entering main process --\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = execv(<span class="string">&quot;/bin/ls&quot;</span>, argv);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;execv error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exiting main process --\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="execle函数"><a href="#execle函数" class="headerlink" title="execle函数"></a>execle函数</h3><p>头文件：<code>unistd.h</code><br>函数原型：<code>int execle(const char *pathname, const char *arg0,... NULL, char *const envp[]);</code></p>
<p>参数：</p>
<ul>
<li><code>pathname</code>：要执行程序的绝对路径名</li>
<li>可变参数：要执行程序的命令行参数，以空指针结束</li>
<li><code>envp</code>指向环境字符串指针数组的指针，该数组的最后一个成员必须为空指针</li>
</ul>
<p>返回值：出错返回-1，成功该函数不返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *envp[] = &#123;<span class="string">&quot;PATH=/tmp&quot;</span>, <span class="string">&quot;USER=yang&quot;</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(execle(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>, envp) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;execle error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="execve函数"><a href="#execve函数" class="headerlink" title="execve函数"></a>execve函数</h3><p><code>int execve(const char *pathname,char *const argv[], char *const envp[]);</code></p>
<h3 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h3><p><code>int execlp(const char *filename,const char *arg0, ...,NULL);</code></p>
<ul>
<li><code>filename</code>参数可以是相对路径（路径信息从环境变量PATH中获取）</li>
<li>例如默认环境变量中包含的<code>PATH=/bin:/usr/bin:/usr/local/bin/</code></li>
</ul>
<h3 id="execvp函数"><a href="#execvp函数" class="headerlink" title="execvp函数"></a>execvp函数</h3><p><code>int execvp(const char *filename,char *const argv[]);</code></p>
<h3 id="exec函数的关系"><a href="#exec函数的关系" class="headerlink" title="exec函数的关系"></a>exec函数的关系</h3><p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409141437071.png" alt="image-20220409141437071"></p>
<h2 id="Linux线程"><a href="#Linux线程" class="headerlink" title="Linux线程"></a>Linux线程</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>进程</strong>的概念体现出两个特点：<strong>资源</strong>（代码和数据空间、打开的文件等）以及<strong>调度/执行</strong>。</p>
<p><strong>线程</strong>是进程内的独立执行代码的实体和<strong>调度</strong>单元</p>
<p>一个<strong>进程内的所有线程共享进程的很多资源</strong>（这种共享又带来了同步问题）</p>
<p><strong>线程间共享</strong></p>
<ul>
<li>进程指令 </li>
<li>全局变量 </li>
<li>打开的文件 </li>
<li>信号处理程序 </li>
<li>当前工作目录 </li>
<li>用户ID和组ID</li>
</ul>
<p><strong>线程私有</strong></p>
<ul>
<li>线程ID</li>
<li>寄存器集合（包括PC和栈指针）</li>
<li>栈（用于存放局部变量）</li>
<li>信号掩码</li>
<li>优先级</li>
</ul>
<h3 id="线程与进程对比"><a href="#线程与进程对比" class="headerlink" title="线程与进程对比"></a>线程与进程对比</h3><p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409142558448.png" alt="image-20220409142558448"></p>
<ul>
<li>线程只拥有少量在运行中必不可少的资源<ul>
<li>PC指针：标识当前线程执行的位置</li>
<li>寄存器：当前线程执行的上下文环境</li>
<li>栈：用于实现函数调用、局部变量（局部变量是私有的）</li>
</ul>
</li>
<li>进程占用资源多，线程占用资源少，使用灵活</li>
<li>线程不能脱离进程而存在，线程的层次关系，执行顺序并不明显，会增加程序的复杂度</li>
<li>没有通过代码显示创建线程的进程，可以看成是只有一个线程的进程</li>
</ul>
<p><strong>操作对比</strong></p>
<table>
<thead>
<tr>
<th>控制操作</th>
<th>进程操作API</th>
<th>线程操作API</th>
</tr>
</thead>
<tbody><tr>
<td>创建</td>
<td><code>fork</code>,<code>vfork</code></td>
<td><code>pthread_create</code></td>
</tr>
<tr>
<td>终止</td>
<td><code>exit</code></td>
<td><code>pthread_exit</code></td>
</tr>
<tr>
<td>等待</td>
<td><code>wait</code>、<code>waitpid</code></td>
<td><code>pthread_join</code></td>
</tr>
<tr>
<td>读取ID</td>
<td><code>getpid</code></td>
<td><code>pthread_self</code></td>
</tr>
</tbody></table>
<h3 id="线程ID"><a href="#线程ID" class="headerlink" title="线程ID"></a>线程ID</h3><p>同进程一样，每个线程也有一个线程ID</p>
<p>进程ID在整个系统中是唯一的，<strong>线程ID只在它所属的进程环境中唯一</strong></p>
<p>线程ID的类型是<code>pthread_t</code>，在Linux中的定义：<code>/usr/include/bits/pthreadtypes.h</code>（实际位置可能有变化）</p>
<ul>
<li><code>typedef unsigned long int pthread_t</code></li>
</ul>
<p><strong>获取线程ID</strong></p>
<p><code>pthread_self</code>函数可以让调用线程获取自己的线程ID</p>
<p>头文件：<code>pthread.h</code></p>
<p>函数原型：<code>pthread_t pthread_self();</code></p>
<p>返回值：调用线程的线程ID</p>
<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p><code>pthread_create</code>函数用于创建一个线程</p>
<p>头文件：<code>pthread.h</code></p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">void</span> *(*start_rtn)(<span class="keyword">void</span> *), </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用<code>pthread_create</code>函数的线程是所创建线程的父线程</p>
<p>参数：</p>
<ul>
<li><code>thread</code>：指向线程ID的指针，当函数成功返回时将存储所创建的子线程ID</li>
<li><code>attr</code>：用于指定线程属性（一般直接传入空指针NULL，采用默认线程属性）</li>
<li><code>start_rtn</code>：线程的<strong>启动例程函数</strong>（类似进程的main函数入口）指针，创建的线程首先执行该函数代码（可以调用其他函数）</li>
<li><code>arg</code>：向线程的启动例程函数传递信息的参数</li>
</ul>
<p>返回值：成功返回0，出错时返回各种错误码</p>
<h3 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h3><p>线程创建后等待系统调度，被调度后从线程启动例程函数</p>
<p>一次性创建多个线程，调度顺序与创建顺序无关</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220412170357636.png" alt="image-20220412170357636"></p>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p>线程的三种终止方式</p>
<ul>
<li>线程从启动例程函数中返回，函数返回值作为线程的退出码</li>
<li>线程被同一进程中的其他线程取消</li>
<li>线程在任意函数中调用<code>pthread_exit</code>函数终止执行</li>
</ul>
<h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a><code>pthread_exit</code></h3><p>头文件：<code>pthread.h</code></p>
<p>函数原型：<code>void pthread_exit(void *rval_ptr);</code></p>
<p>参数：<code>rval_ptr</code> 该指针将参数传递给<code>pthread_join</code>函数（与<code>exit</code>函数参数用法类似）</p>
<h3 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a><code>pthread_cancel</code></h3><p>线程调用该函数可以取消同一进程中的其他线程（即让该线程终止）</p>
<p>头文件： <code>pthread.h</code></p>
<p>函数原型：<code>int pthread_cancel(pthread_t tid);</code></p>
<p>参数：<code>tid</code> 需要取消的线程ID</p>
<p>返回值：成功返回0，出错返回错误编号</p>
<p>注：</p>
<ul>
<li>在默认情况下，<code>pthread_cancel</code>函数与被取消线程（ID等于tid的线程）自身调用<code>pthread_exit</code>函数（参数为<code>PTHREAD_CANCELED</code>）效果等同</li>
<li>线程可以选择忽略取消方式或者控制取消方式</li>
<li><code>pthread_cancel</code>并不等待线程终止，它仅仅是提出请求</li>
</ul>
<h3 id="phread-join"><a href="#phread-join" class="headerlink" title="phread_join"></a><code>phread_join</code></h3><p>头文件：<code>pthread.h</code></p>
<p>函数原型：<code>int pthread_join(pthread_t thread,void **rval_ptr);</code></p>
<p>调用该函数的父线程将一直被阻塞，直到指定的子线程终止</p>
<p>返回值：成功返回0，否则返回错误编号</p>
<p>参数：</p>
<ul>
<li><code>thread</code>：需要等待的子线程ID</li>
<li><code>rval_ptr</code>：线程返回值<ul>
<li>若线程从启动例程返回，<code>rval_ptr</code>将包含返回码</li>
<li>若线程被取消，<code>rval_ptr</code>指向的内存单元值置为<code>PTHREAD_CANCELED</code></li>
<li>若线程通过调用<code>pthread_exit</code>函数终止，<code>rval_ptr</code>就是调用<code>pthread_exit</code>时传入的参数</li>
<li>若不关心线程返回值，可直接将该参数设置为空指针NULL</li>
</ul>
</li>
</ul>
<h3 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a><code>pthread_detach</code></h3><p>头文件：<code>pthread.h</code></p>
<p>函数原型：<code>int pthread_detach(pthread_t thread);</code></p>
<p>特点：</p>
<ul>
<li>使用pthread_detach函数后，使线程处于分离态；</li>
<li>使用pthread_detach函数后，线程在退出后，会自己清理资源</li>
<li>相较pthread_join,使用pthread_detach函数不会阻塞主线程，但是无法获取线程的返回值。</li>
<li><strong>pthread_detach使用时，依然需要配合sleep函数或者while(1);，否则无法保证子线程先于主线程执行完。</strong></li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc thread_test.c -o thread_test -lpthread </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">childthread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;childthread message\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create childthread\n&quot;</span>);</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, (<span class="keyword">void</span>*)childthread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;childthread exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409151806118.png" alt="image-20220409151806118"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/llqkk/article/details/2854558"> undefined reference to ‘pthread_create’问题解决_李刘强博客的博客-CSDN博客_pthread_create undefined</a></p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="任务关系"><a href="#任务关系" class="headerlink" title="任务关系"></a>任务关系</h3><p>Linux系统中多任务（进程/线程）之间的关系</p>
<ul>
<li><strong>独立</strong>：仅竞争CPU资源</li>
<li><strong>互斥</strong>：竞争除CPU外的其他资源</li>
<li><strong>同步</strong>：协调彼此运行的步调，保证协同运行的各个任务具有正确的执行次序</li>
<li><strong>通信</strong>：数据共享，彼此间传递数据或信息，以协同完成某项工作</li>
</ul>
<h3 id="线程数据共享"><a href="#线程数据共享" class="headerlink" title="线程数据共享"></a>线程数据共享</h3><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409153932168.png" alt="image-20220409153932168" style="zoom:67%;" />



<h3 id="任务互斥问题"><a href="#任务互斥问题" class="headerlink" title="任务互斥问题"></a>任务互斥问题</h3><p><strong>任务互斥—资源共享关系（间接相互制约关系）</strong></p>
<ul>
<li>任务本身之间不存在直接联系。一个任务正在使用某个系统资源，另外一个想用该资源的任务就必须等待，而不能同时使用</li>
</ul>
<p>全局变量存储在进程数据段中，被线程所共享。线程对全局变量的访问，要经历三个步骤</p>
<ol>
<li><p>将内存单元中的数据读入寄存器</p>
</li>
<li><p>对寄存器中的值进行运算</p>
</li>
<li><p>将寄存器中的值写回内存单元</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409154622468.png" alt="image-20220409154622468" style="zoom:67%;" />

<p>解决方法：互斥量</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p><strong>临界资源</strong>：在一段时间内只允许一个任务（线程或进程）访问的资源。诸任务间应采取互斥方式，实<br>现对资源的共享</p>
<ul>
<li>共享变量，打印机等属于临界资源</li>
<li>访问临界资源的那段代码被称为<strong>临界区</strong></li>
</ul>
<p><strong>互斥量</strong>确保同一时间里只有一个线程访问临界资源或进入临界区</p>
<p><strong>互斥量（mutex）</strong>本质上是一把锁</p>
<ul>
<li>在访问临界资源前，对互斥量进行加锁</li>
<li>在访问完成后对互斥量解锁</li>
<li>对互斥量加锁后，任何其他试图对互斥量加锁的线程将会被阻塞，直到互斥量被解锁为止</li>
</ul>
<p><strong>互斥量的操作</strong>：</p>
<ol>
<li>定义互斥量变量（ <code>pthread_mutex_t mutex;</code>）</li>
<li>调用<code>pthread_mutex_init</code>初始化互斥量变量</li>
<li>访问临界资源前，调用<code>pthread_mutex_lock</code>或者<code>pthread_mutex_trylock</code>对互斥量进行加锁操作</li>
<li>访问临界资源后，调用<code>pthread_mutex_unlock</code>对互斥量解锁</li>
<li>调用<code>pthread_mutex_destroy</code>销毁互斥量变量</li>
</ol>
<p><strong>初始化互斥量</strong></p>
<p>头文件：<code>pthread.h</code></p>
<p>静态初始化</p>
<ul>
<li><code>pthread_mutex_t mlock = PTHREAD_MUTEX_INITIALIZER;</code></li>
</ul>
<p>动态初始化</p>
<ul>
<li><code>int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *attr);</code></li>
<li>参数<ul>
<li><code>mutex</code>：指向互斥量的指针</li>
<li><code>attr</code>：设置互斥量的属性，通常可采用默认属性，传入空指针（<code>NULL</code>）。</li>
</ul>
</li>
<li>成功返回0，出错返回错误码</li>
</ul>
<p><strong>销毁互斥量</strong>：</p>
<p>互斥量在使用完毕后，必须要对互斥量进行销毁，以释放资源</p>
<p>头文件：<code>pthread.h</code></p>
<p>函数原型：<code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p>
<ul>
<li><code>mutex</code>：即互斥量</li>
<li>成功返回0，出错返回错误码</li>
</ul>
<p><strong>互斥量的加锁和解锁</strong>：</p>
<p>在对临界资源访问之前和访问之后，需要对互斥量进行加锁和解锁操作</p>
<p>头文件：<code>pthread.h</code></p>
<p>函数原型：</p>
<ul>
<li>加锁：<code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code> </li>
<li>解锁：<code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></li>
<li>成功返回0，出错返回错误码</li>
</ul>
<p>当调用<code>pthread_mutex_lock</code>时，若互斥量已被加锁，则调用线程将被<strong>阻塞</strong>直到可以完成加锁操作为止。</p>
<p><strong>互斥量非阻塞加锁</strong></p>
<p>头文件： <code>pthread.h</code></p>
<p>函数原型：<code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></p>
<ul>
<li>调用该函数时，若互斥量未加锁，则对该互斥量加锁，返回0；</li>
<li>若互斥量已加锁，则函数直接返回错误码EBUSY（不会阻塞调用线程）</li>
</ul>
<h3 id="任务同步问题"><a href="#任务同步问题" class="headerlink" title="任务同步问题"></a>任务同步问题</h3><p><strong>任务同步—相互合作关系（直接相互制约关系）</strong></p>
<ul>
<li>两个或多个任务为了合作完成同一个工作，在执行速度或某个确定的时序点上必须相互协调，即一个任务的执行必须依赖另一个任务的执行情况</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409160816138.png" alt="image-20220409160816138" style="zoom:50%;" />

<p>程序设计中存在这样的情况：多个线程都要访问临界资源又要相互合作（线程间<strong>同时存在互斥关系和同步关系</strong>）</p>
<p>线程A先执行某操作（例如对全局变量x的修改）后，线程B才能（根据变量x的值判断）执行另一操作<br>（可能是对全局变量x的修改），该如何实现？</p>
<ul>
<li>Linux提供了<strong>条件变量</strong>机制：<strong>条件变量与互斥量一起使用</strong>时，允许线程以互斥的方式阻塞等待特定条件的发生（同步）</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p><strong>条件变量的操作</strong>：</p>
<ul>
<li>定义条件变量（ <code>pthread_cond_t</code>类型）,定义互斥量变量</li>
<li>初始化条件变量，初始化互斥量</li>
<li>触发条件线程x<ul>
<li>互斥量加锁-&gt;XX操作-&gt;触发条件变量-&gt;互斥量解锁</li>
</ul>
</li>
<li>等待条件线程y<ul>
<li>互斥量加锁-&gt;等待条件变量-&gt;XX操作-&gt;互斥量解锁</li>
</ul>
</li>
<li>销毁条件变量，销毁互斥量变量</li>
</ul>
<p><strong>条件变量初始化</strong>：</p>
<p>静态初始化：<code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</code></p>
<p>动态初始化：</p>
<ul>
<li>头文件：<code>pthread.h</code></li>
<li>函数原型：<code>int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *attr);</code></li>
<li><code>cond</code>：条件变量</li>
<li><code>attr</code>：条件变量属性，若为<code>NULL</code>，则使用默认属性</li>
<li>成功返回0；出错返回错误码</li>
</ul>
<p><strong>条件变量销毁</strong>：</p>
<p>头文件：<code>pthread.h</code></p>
<p>函数原型：<code>int pthread_cond_destroy(pthread_cond_t * cond);</code></p>
<ul>
<li>cond：条件变量</li>
<li>成功返回0；出错返回错误码</li>
</ul>
<p><strong>等待条件变量</strong>：</p>
<p><code>pthread_cond_wait</code>函数将使调用线程进入阻塞状态，直到条件被触发</p>
<p>头文件：<code>pthread.h</code></p>
<p>函数原型：</p>
<ul>
<li><code>int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex);</code></li>
<li><code>cond</code>：条件变量</li>
<li><code>mutex</code>：互斥量</li>
<li>成功返回0；出错返回错误码</li>
</ul>
<p><strong>为什么条件变量需要和互斥量配合使用</strong></p>
<ul>
<li>条件变量的使用场景伴随共享资源的使用，例如全局变量</li>
<li>在调用<code>pthread_cond_wait</code>前，需要使互斥量处于加锁状态，这样可以通过原子操作的方式，将调用线程放到该条件变量等待线程队列（临界资源）中</li>
</ul>
<p><strong>等待条件变量的操作：</strong></p>
<ul>
<li>调用<code>pthread_mutex_lock</code></li>
<li>调用<code>pthread_cond_wait</code></li>
<li>调用<code>pthread_mutex_unlock</code></li>
</ul>
<p><strong>调用<code>pthread_cond_wait</code>函数后内核自动执行的操作：</strong></p>
<ul>
<li>在线程阻塞等待条件变量之前，调用<code>pthread_mutex_unlock</code></li>
<li>若条件变量被其他线程触发，在该线程被唤醒后，调用<code>pthread_mutex_lock</code></li>
</ul>
<p><strong>触发条件变量</strong>：</p>
<p><code>pthread_cond_signal</code>唤醒该条件变量等待线程队列中的<strong>某一个线程</strong></p>
<p><code>pthread_cond_broadcast</code>唤醒该条件变量等待线程队列中的<strong>所有线程</strong>，这些线程会进行竞争</p>
<p>头文件： <code>pthread.h</code></p>
<p>函数原型：</p>
<ul>
<li><code>int pthread_cond_signal(pthread_cond_t *cond);</code></li>
<li><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></li>
<li><code>cond</code>：条件变量</li>
<li>成功返回0；出错返回错误码</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> count_lock;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> count_ready;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">decrement_count</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">increment_count</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;count_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;count_ready, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, decrement_count, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, increment_count, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decrement quit\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//printf(&quot;&quot;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">decrement_count</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;count_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decrement:waitting\n&quot;</span>);</span><br><span class="line">    pthread_cond_wait(&amp;count_ready, &amp;count_lock);</span><br><span class="line">    <span class="comment">/*等待条件变量，期间互斥量仍然可用*/</span></span><br><span class="line">    </span><br><span class="line">    count -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decrement:count = %d\n&quot;</span>, count);</span><br><span class="line">    pthread_mutex_unlock(&amp;count_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decrement quit\n&quot;</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">increment_count</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;count_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;increment:running\n&quot;</span>);</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;count_ready);</span><br><span class="line">    <span class="comment">/*触发条件变量*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;increment:count = %d\n&quot;</span>, count);</span><br><span class="line">    pthread_mutex_unlock(&amp;count_lock);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409165937723.png" alt="image-20220409165937723"></p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p><strong>读写锁引入</strong></p>
<p>问题描述：</p>
<ul>
<li>在对临界资源的访问中，更多的是读操作，而写操作较少，只有互斥量机制可能会影响访问效率</li>
<li>期望对临界资源的访问控制粒度更精细，任一时刻允许<strong>多个线程对临界资源进行读操作</strong>，但只允许<strong>一个线程对临界资源进行写操作</strong></li>
</ul>
<p><strong>互斥关系：</strong></p>
<ul>
<li>读操作-写操作互斥</li>
<li>写操作-写操作互斥</li>
<li>读操作-读操作不互斥</li>
</ul>
<p>同步关系：</p>
<ul>
<li>缓冲区不满，才允许写操作</li>
<li>缓冲区不空，才允许读操作 </li>
</ul>
<p><strong>读写锁通信机制</strong></p>
<p>在保证互斥的基础上，Linux提供了<strong>对临界资源访问控制粒度更细</strong>的读写锁机制</p>
<p>读写锁机制可以实现如下访问控制规则：</p>
<ul>
<li>如果有线程对互斥资源进行读操作，则允许其它线程执行读操作，但不允许任何线程进行写操作</li>
<li>如果有线程对互斥资源进行写操作，则不允许任何线程进行读操作或写操作</li>
</ul>
<p><strong>读写锁的操作</strong></p>
<p>读写锁的操作与互斥量的操作非常类似</p>
<ol>
<li>定义读写锁变量 <code>pthread_rwlock_t rwlock;</code></li>
<li>初始化读写锁变量</li>
<li>访问临界资源（读操作或写操作）前对读写锁加锁</li>
<li>访问临界资源后对读写锁解锁</li>
<li>销毁读写锁变量</li>
</ol>
<p>读写锁的加锁操作在互斥量加锁的基础上扩展，具有<strong>加读锁</strong>和<strong>加写锁</strong>两种操作</p>
<ul>
<li>如果有线程已经成功对读写锁加读锁，其它线程可以继续对该读写锁加读锁，但不能再加写锁（加写锁的线程可能会被阻塞）</li>
<li>如果有线程已经成功对读写锁加写锁，则其它线程不能对该读写锁加读锁和加写锁</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>初始化读写锁</td>
<td><code>pthread_rwlock_init</code></td>
</tr>
<tr>
<td>阻塞申请读锁</td>
<td><code>pthread_rwlock_rdlock</code></td>
</tr>
<tr>
<td>非阻塞申请读锁</td>
<td><code>pthread_rwlock_tryrdlock</code></td>
</tr>
<tr>
<td>阻塞申请写锁</td>
<td><code>pthread_rwlock_wrlock</code></td>
</tr>
<tr>
<td>非阻塞申请写锁</td>
<td><code>pthread_rwlock_trywrlock</code></td>
</tr>
<tr>
<td>解锁（包括读锁和写锁）</td>
<td><code>pthread_rwlock_unlock</code></td>
</tr>
<tr>
<td>销毁读写锁</td>
<td><code>pthread_rwlock_destroy</code></td>
</tr>
</tbody></table>
<p><strong>读写锁初始化和销毁</strong></p>
<p>头文件： <code>pthread.h</code></p>
<p>初始化读写锁变量：</p>
<ul>
<li><code>int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock, __const pthread_rwlockattr_t *__restrict __attr);</code></li>
</ul>
<p>销毁读写锁变量：</p>
<ul>
<li><code>int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock);</code></li>
</ul>
<p>返回值：成功返回0，否则返回错误码</p>
<p><strong>加读锁</strong></p>
<p>头文件：<code>pthread.h</code></p>
<p>阻塞加读锁</p>
<ul>
<li><code>int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock); </code></li>
</ul>
<p>非阻塞加读锁</p>
<ul>
<li><code>int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock);</code></li>
</ul>
<p>限时加读锁</p>
<ul>
<li><code>int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock, __const struct timespec *__restrict __abstime);</code></li>
</ul>
<p><strong>加写锁</strong></p>
<p>头文件：<code>pthread.h</code></p>
<p>阻塞加写锁</p>
<ul>
<li><code>int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock);</code></li>
</ul>
<p>非阻塞加写锁</p>
<ul>
<li><code>int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock);</code></li>
</ul>
<p>限时等待加写锁</p>
<ul>
<li><code>int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __ rwlock, __const struct timespec *__restrict __abstime);</code></li>
</ul>
<p><strong>读写锁解锁</strong></p>
<p>头文件：<code>pthread.h</code></p>
<p>函数原型：<code>int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock);</code></p>
<p>如何确定是为读锁解锁还是为写锁解锁？</p>
<ul>
<li>就近原则。加锁（读锁/写锁）与解锁配对出现，为代码中距离最近的加锁操作解锁</li>
</ul>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="进程通信机制"><a href="#进程通信机制" class="headerlink" title="进程通信机制"></a>进程通信机制</h3><p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409175106240.png" alt="image-20220409175106240"></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是最古老、最简单的UNIX进程间通信机制</p>
<p>管道是一种特殊文件</p>
<p>管道的局限性</p>
<ul>
<li>半双工：一个进程写，一个进程读</li>
<li>只能在<strong>父子进程</strong>之间使用</li>
</ul>
<p><strong>创建管道</strong></p>
<p>头文件：<code>unistd.h</code></p>
<p>函数原型：<code>int pipe(int fildes[2]);</code></p>
<ul>
<li>程序通过文件描述符<code>fildes[0]</code>和<code>fildes[1]</code>来访问管道</li>
<li><code>filedes[0]</code>只能用于管道<strong>读操作</strong>，<code>filedes[1]</code>只能用于管道<strong>写操作</strong></li>
<li>写入<code>fildes[1]</code>的数据可以按照<strong>先进先出</strong>的顺序从<code>fildes[0]</code>中读出</li>
</ul>
<p>返回值：成功返回0，出错返回<code>-1</code></p>
<p><strong>命名管道（FIFO）</strong></p>
<ul>
<li>管道只能在父子进程之间使用</li>
<li>FIFO也被称为命名管道， FIFO是一种特殊的文件（创建FIFO类似于创建文件，FIFO的路径名存在于文件系统中）</li>
<li>创建FIFO之后可以通过文件I/O对其进行操作</li>
<li><strong>非父子进程可以通过文件名来使用FIFO</strong></li>
</ul>
<p><strong>创建FIFO</strong>：</p>
<p>头文件：</p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>sys/stat.h</code></li>
</ul>
<p>函数原型：<code>int mkfifo(const char *pathname, mode_t mode) ;</code></p>
<ul>
<li><code>pathname</code>：文件名（绝对路径）</li>
<li><code>mode</code>：文件类型、权限等</li>
</ul>
<p>返回值：成功返回<code>0</code>，出错返回<code>-1</code></p>
<h3 id="XSI-IPC机制"><a href="#XSI-IPC机制" class="headerlink" title="XSI IPC机制"></a>XSI IPC机制</h3><ul>
<li><strong>信号量集（semaphore set）</strong>，用于实现进程之间的同步与互斥</li>
<li><strong>共享内存（shared memory）</strong>，用于在进程之间高效地共享数据，适用于数据量大，速度要求高的场景</li>
<li><strong>消息队列（message queue）</strong>，进程之间传递数据的一种简单方法</li>
</ul>
<p><strong>IPC对象</strong>： <code>ipcs</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409200437797.png" alt="image-20220409200437797"></p>
<p><strong>IPC对象的key值和ID</strong></p>
<p>Linux系统中的IPC对象都是全局的，为每个IPC对象分配唯一的ID</p>
<p>在IPC操作中通信各方需要通过ID来指示操作的IPC对象，需要有机制让通信各方获取获取IPC对象的ID</p>
<ul>
<li>创建IPC对象的进程通过创建IPC对象函数的返回值可获取ID值</li>
<li><font color=#ff0000>未创建IPC对象的进程如何获取IPC对象的ID值并使用该对象呢？</font></li>
</ul>
<p>IPC机制的ID值为<strong>动态分配</strong>，无法提前约定，不能跨进程传递</p>
<p>多个进程提前<strong>约定使用相同的key值</strong>做为参数来创建IPC对象或打开已经创建的IPC对象</p>
<p>如果通信各方（进程）在创建/打开IPC对象时使用相同的key值：</p>
<ul>
<li>首次使用该key值创建IPC对象的进程将<strong>真正创建</strong>该IPC对象，并获取其ID值</li>
<li>后续使用该key值创建IPC对象的进程都将<strong>在内核中找到该IPC对象</strong>并打开它，从而获取其ID值</li>
</ul>
<p>IPC对象与key值一一对应，因此<strong>key值不能重复</strong></p>
<p>通过**<code>ftok</code>函数**来产生独特的key值，避免重复</p>
<p>头文件： </p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>sys/ipc.h</code></li>
</ul>
<p>函数原型：<code>key_t ftok( char * pathname, int proj_id);</code></p>
<ul>
<li><code>pathname</code>是指定的文件名，可以是特殊文件也可以是目录文件）</li>
<li><code>proj_id</code>是子序号</li>
</ul>
<p>注：<strong>如果要确保<code>key_t</code>值不变，需要确保<code>ftok</code>所指定的文件名不被删除</strong> </p>
<table>
<thead>
<tr>
<th>信号量集</th>
<th>共享内存</th>
<th>消息队列</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>semget</code></td>
<td><code>shmget</code></td>
<td><code>msgget</code></td>
<td>创建或打开一个IPC对象，获得对IPC机制的访问权</td>
</tr>
<tr>
<td><code>semop</code></td>
<td><code>shmat</code> <code>shmdt</code></td>
<td><code>msgsnd</code> <code>msgrcv</code></td>
<td>IPC操作: 发送/接收消息；连接/释放共享内存；信号量操作</td>
</tr>
<tr>
<td><code>semctl</code></td>
<td><code>shmctl</code></td>
<td><code>msgctl</code></td>
<td>IPC控制：获得/修改IPC对象状态，“删除”IPC对象等</td>
</tr>
</tbody></table>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul>
<li>进程之间传递数据的一种简单方法</li>
<li>把每个消息看作一个记录，具有特定的格式</li>
<li>消息队列就是消息的链表</li>
<li>对消息队列有写权限的进程可以按照一定的规则添加新消息</li>
<li>对消息队列有读权限的进程则可以从消息队列中读走消息</li>
<li>消息队列能够克服管道或命名管道机制的一些缺点，例如实时性差等</li>
</ul>
<p><strong>消息队列结构</strong>：</p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409203702015.png" alt="image-20220409203702015" style="zoom: 67%;" />



<p><strong>消息队列操作</strong>：</p>
<p>头文件：</p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>sys/ipc.h</code></li>
<li><code>sys/msg.h</code></li>
</ul>
<p>打开或创建消息队列对象</p>
<ul>
<li><code>int msgget(key_t key, int msgflg);</code></li>
</ul>
<p>从消息队列接收消息</p>
<ul>
<li><code>int msgrcv(int msqid, struct msgbuf *msgp, int msgsz, long msgtyp, int msgflg); </code></li>
</ul>
<p>向消息队列发送消息</p>
<ul>
<li><code>int msgsnd(int msqid, struct msgbuf *msgp, int msgsz, intmsgflg); </code></li>
</ul>
<p>消息队列控制操作</p>
<ul>
<li><code>msgctl(int msqid, int cmd, struct msqid_ds *buf); </code></li>
</ul>
<p><strong>创建消息队列</strong></p>
<p><code>int msgget(key_t key, int oflag);</code></p>
<p>返回值：成功返回创建或打开的消息队列对象ID；出错返回<code>-1</code></p>
<ul>
<li><p><code>key</code>：创建或打开消息队列对象时指定的key值（提前约定或通过<code>ftok</code>函数创建）</p>
</li>
<li><p><code>Oflag</code>：设置访问权限，取值可以为以下一个或多个值的或</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*#define IPC_R 000400 读权限</span></span><br><span class="line"><span class="comment">#define IPC_W 000200 写和修改权限</span></span><br><span class="line"><span class="comment">#define IPC_M 010000 改变控制方式权限*/</span> 好像有错误，不对</span><br><span class="line">还可以附加以下参数值（按位或）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_CREAT 01000	<span class="comment">//如果消息队列对象不存在则创建，否则打开已经存在的消息队列对象</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_EXCL 02000	<span class="comment">//只有消息队列对象不存在的时候，才能创建新的消息队列对象，否则就产生错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_NOWAIT 04000 <span class="comment">//如果操作需要等待，则直接返回错误</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>发送信息到消息队列</strong></p>
<p><code>int msgsnd(int msgid, const void *ptr, size_t length, intflag);</code></p>
<p>返回值：成功返回0；出错返回<code>-1</code></p>
<ul>
<li><p><code>msgid</code>：消息队列ID</p>
</li>
<li><p><code>ptr</code>：指向<code>msgbuf</code>的结构体指针（其中消息类型<code>mtype</code>必须大于0，小于0的消息类型有特殊的指示作用）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> mtype; </span><br><span class="line">	<span class="keyword">char</span> mtext[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>length</code>：以字节为单位指定待发送消息的长度（<code>msgbuf</code>结构体中消息类型mtype之后的用户自定义数据的长度），该长度可以为0</p>
</li>
<li><p><code>flag</code>：可以是0，也可以是<code>IPC_NOWAIT</code>（该标志可以使函数工作在非阻塞模式）</p>
</li>
</ul>
<p>出现以下情况时：</p>
<p>1）指定的消息队列容量已满</p>
<p>2）在系统范围存在太多的消息</p>
<ul>
<li>若设置了<code>IPC_NOWAIT</code>，则<code>msgsnd</code>立即返回（返回<code>EAGAIN</code>错误）</li>
<li>若未指定该标志，则<code>msgsnd</code>导致调用进程阻塞，直到可以发送成功为止</li>
</ul>
<p><strong>从消息队列接收信息</strong></p>
<p><code>ssize_t msgrcv(int msqid, void *ptr, size_t length, long type, int flag);</code></p>
<p>返回值：成功返回实际读取数据的字节数；出错返回<code>-1</code></p>
<ul>
<li><code>msgid</code>：消息队列ID</li>
<li><code>ptr</code>：消息缓冲区指针，指向<code>msgbuf</code>的结构体指针</li>
<li><code>length</code>：消息缓冲区中数据部分的大小（<code>msgbuf</code>结构体中消息类型<code>mtype</code>之后的用户自定义数据的长度）</li>
<li><code>type</code>：指定期望从消息队列中接收什么样的消息<ul>
<li><code>type</code>为0，返回队列中第一个消息（消息队列是一个FIFO链表，所以返回的是队列中最早的消息）</li>
<li><code>type</code>大于0，返回消息队列中类型值为type的第一个消息</li>
<li><code>type</code>小于0，返回消息队列中类型值小于或等于type绝对值中类型值最小的第一个消息</li>
</ul>
</li>
<li><code>flag</code>：当消息队列中没有期望接收的消息时会如何操作<ul>
<li>若设置了<code>IPC_NOWAIT</code>标志，则函数立即返回<code>ENOMSG</code>错误</li>
<li>若未设置<code>IPC_NOWAIT</code>标志，否则<code>msgrcv</code>导致调用进程阻塞直到如下某个事件发生：<ul>
<li>有其他进程向消息队列中发送了所期望接收的消息</li>
<li>该消息队列被删除，此时返回<code>EIDRM</code>错误</li>
<li>进程被某个信号中断，此时返回<code>EINTR</code>错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>消息发送者： <code>msgsnd.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> msg_type;</span><br><span class="line">    <span class="keyword">char</span> text[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> msgid = <span class="number">-1</span>;</span><br><span class="line">    msgid = msgget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="number">0666</span> | IPC_CREAT); <span class="comment">// 0666 ?</span></span><br><span class="line">    <span class="keyword">if</span>(msgid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;megget failed with error:%d\n&quot;</span>, errno); </span><br><span class="line">        <span class="comment">// errno : int型 errno 是记录系统的最后一次错误代码 在头文件 errno.h中</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">// EXIT_FAILURE 1   stdlib.h中的宏定义</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter some text:&quot;</span>);</span><br><span class="line">        fgets(buffer, <span class="number">1024</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        data.msg_type = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(data.text, buffer);</span><br><span class="line">        <span class="keyword">if</span>(msgsnd(msgid, (<span class="keyword">void</span>*)&amp;data, <span class="number">1024</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;msgsnd failed\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buffer, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)  <span class="comment">// 字符串比较函数 在 string.h中</span></span><br><span class="line">        &#123;</span><br><span class="line">            running = <span class="number">0</span>;</span><br><span class="line">            sleep(<span class="number">1</span>); 	<span class="comment">// 在头文件 unistd.h 中定义</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS); <span class="comment">// EXIT_SUCCESS 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息接收者：<code>msgrcv.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msg_type;</span><br><span class="line">    <span class="keyword">char</span> text[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> msgid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msgtype = <span class="number">0</span>;</span><br><span class="line">    msgid = msgget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(msgid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;megget failed with error:%d\n&quot;</span>, errno);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(msgrcv(msgid, (<span class="keyword">void</span>*)&amp;data, <span class="number">1024</span>, msgtype, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;msgrcv failed with errno:%d\n&quot;</span>, errno);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You wrote:%s\n&quot;</span>, data.text);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(data.text, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            running = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(msgctl(msgid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;msgctl(IPC_RMID) failed\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220409232240314.png" alt="image-20220409232240314"></p>
<h3 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h3><p> <strong>任务资源共享情况</strong></p>
<p>临界资源：在一段时间内只允许一个任务访问的资源。诸任务间应采取互斥方式，实现对资源的共享</p>
<p>共享资源：允许多个任务同时访问同一种资源的多个实例</p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410122956953.png" alt="image-20220410122956953" style="zoom:50%;" />

<p><strong>信号量</strong></p>
<p>信号量一般分为<strong>三种类型</strong>：</p>
<ul>
<li><strong>互斥信号量</strong>：任务之间互斥访问临界资源</li>
<li><strong>计数信号量</strong>：任务之间竞争访问共享资源</li>
<li><strong>二值信号量</strong>：任务之间的同步机制</li>
</ul>
<p>信号量是操作系统提供的管理资源共享的有效手段</p>
<p><strong>信号量作为操作系统核心代码执行，其地位高于任务（进程或线程），任务调度不能终止其运行</strong></p>
<p><strong>信号量的实现</strong></p>
<p>信号量<code>s</code>一般包含以下成员：</p>
<ul>
<li>整数值<code>s.count</code>（实现资源计数）</li>
<li>任务阻塞队列<code>s.queue</code></li>
</ul>
<p>信号量操作：初始化、P操作、V操作</p>
<ul>
<li><p>在进程初始化信号量将<code>s.count</code>指定为一个非负整数值，表示可用的共享资源实例总数</p>
</li>
<li><p>运行中<code>s.count</code>可为负值（其绝对值表示当前等待访问该共享资源的进程数）</p>
</li>
<li><p>P操作<code>wait(s)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--s.count;<span class="comment">//表示申请一个资源;</span></span><br><span class="line"><span class="keyword">if</span> (s.count &lt; <span class="number">0</span>)<span class="comment">//表示没有空闲资源;</span></span><br><span class="line">&#123;</span><br><span class="line">    调用进程进入阻塞队列s.<span class="built_in">queue</span>;</span><br><span class="line">    阻塞调用进程;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>V操作<code>signal(s)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">++s.count; <span class="comment">//表示释放一个资源</span></span><br><span class="line"><span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>) <span class="comment">//表示有进程处于阻塞状态</span></span><br><span class="line">&#123;</span><br><span class="line">    从等待队列s.<span class="built_in">queue</span>中取出一个进程p;</span><br><span class="line">    进程P进入就绪队列;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>互斥信号量状态图</strong></p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410124204976.png" alt="image-20220410124204976" style="zoom: 50%;" />

<p><strong>计数信号量状态图</strong></p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410124244462.png" alt="image-20220410124244462" style="zoom:50%;" />

<p><strong>二值信号量状态图</strong></p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410124311260.png" alt="image-20220410124311260" style="zoom:50%;" />



<p><strong>信号量集结构</strong></p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410124618074.png" alt="image-20220410124618074" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>      </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">sem_base</span>;</span>   <span class="comment">/* 指向信号量数组的指针 */</span>       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">sem_pending</span>;</span>                     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> **<span class="title">sem_pending_last</span>;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">sem_undo</span> *<span class="title">undo</span>;</span>    </span><br><span class="line">    <span class="keyword">time_t</span> sem_otime; <span class="comment">/* 最后一次操作的时间 */</span></span><br><span class="line">	<span class="keyword">time_t</span> sem_ctime; <span class="comment">/* 最后一次改变此结构的时间 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sem_nsems; <span class="comment">/* 集合中信号量个数*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">pid_t</span> sempid; <span class="comment">/* 最后操作该信号量的进程ID */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> semncnt ; <span class="comment">/* 等待对该信号量执行P操作的进程数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> semzcnt; <span class="comment">/* 等待semval为0的进程数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> semval; <span class="comment">/* 信号量当前值 */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>XSI IPC信号量集操作</strong></p>
<p>头文件：</p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>sys/ipc.h</code></li>
<li><code>sys/sem.h</code></li>
</ul>
<p>创建或打开信号量集对象</p>
<ul>
<li><code>int semget(key_t key, int nsems, int semflg);</code></li>
</ul>
<p>信号量集操作（信号量的PV操作）</p>
<ul>
<li><code>int semop(int semid, struct sembuf *sops, unsigned nsops);</code></li>
</ul>
<p>信号量集控制（信号量初始化和删除操作）</p>
<ul>
<li><code>int semctl(int semid, int semnum, int cmd, union semun arg);</code></li>
</ul>
<h4 id="semget函数"><a href="#semget函数" class="headerlink" title="semget函数"></a>semget函数</h4><ul>
<li><p>头文件<code>sys/sem.h</code></p>
</li>
<li><p><code>int semget(key_t key, int nsems, int semflg);</code></p>
</li>
<li><p>返回值：成功返回创建或打开的信号量集对象（IPC对象）ID；失败返回<code>-1</code>；</p>
</li>
<li><p><code>key</code>：用于创建或打开信号量集对象时指定的<code>key</code>值（约定或通过<code>ftok</code>函数创建）或者0(<code>IPC_PRIVATE</code>)—— 创建一个只有创建进程可以访问的信号量。</p>
</li>
<li><p><code>nsems</code>：信号量集对象中包含的信号量数量（例如取值为1，则信号量集只包含1个信号量）</p>
</li>
<li><p><code>semflg</code>：设置访问权限，取值可以为以下某个值或多个值的或，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">semflg 是 <span class="number">32</span>位的整数 ， IPC_CREAT和IPC_EXCL只用到了高<span class="number">24</span>位</span><br><span class="line">低<span class="number">8</span>位是权限位，一般是<span class="number">0666</span>，<span class="number">6</span>的二进制是<span class="number">110</span>，表示可读，可写，不可执行，三个<span class="number">6</span>分别对应当前用户，group组用户，其他用户    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/*#define IPC_R 000400 读权限</span></span><br><span class="line"><span class="comment">#define IPC_W 000200 写和修改权限</span></span><br><span class="line"><span class="comment">#define IPC_M 010000 改变控制方式权限*/</span> 好像有错误，不对</span><br><span class="line">还可以附加以下参数值（按位或）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_CREAT 01000	<span class="comment">//如果消息队列对象不存在则创建，否则打开已经存在的消息队列对象</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_EXCL 02000	<span class="comment">//只有消息队列对象不存在的时候，才能创建新的消息队列对象，否则就产生错误EEXIST</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_NOWAIT 04000 <span class="comment">//如果操作需要等待，则直接返回错误</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYKEY 0x1a0a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> semid;</span><br><span class="line">        semid = semget(MYKEY, <span class="number">1</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;semid = %d\n&quot;</span>, semid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410135610074.png" alt="image-20220410135610074"></p>
</li>
</ul>
<h4 id="semop函数"><a href="#semop函数" class="headerlink" title="semop函数"></a>semop函数</h4><ul>
<li>头文件<ul>
<li><code>sys/types.h</code></li>
<li><code>sys/ipc.h</code></li>
<li><code>sys/sem.h</code></li>
</ul>
</li>
<li><code>int semop(int semid, struct sembuf sops[], size_t nsops);</code></li>
<li>成功返回0；失败返回-1</li>
<li><code>semid</code>：信号量集对象ID（<code>semget</code>的返回值）</li>
<li><code>sops</code>：指向<code>sembuf</code>结构数组的指针</li>
<li><code>nsops</code>：第二个参数中<code>sembuf</code>结构数组的元素个数</li>
</ul>
<p><strong>sembuf结构：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sem_num; <span class="comment">//信号量序号，指示本次是操作信号量集中的哪个信号量（序号从0开始）</span></span><br><span class="line"><span class="keyword">short</span> sem_op;	<span class="comment">//信号量操作码</span></span><br><span class="line"><span class="comment">/*该值为正，信号量V操作，增加信号量的值（为n，则加n）</span></span><br><span class="line"><span class="comment">该值为负，信号量P操作，减小信号量的值（为-n，则减n）</span></span><br><span class="line"><span class="comment">该值为0，对信号量的当前值是否为0的测试*/</span></span><br><span class="line"><span class="keyword">short</span> sem_flg; <span class="comment">// semop操作控制标志</span></span><br></pre></td></tr></table></figure>

<p><code>sem_flg</code>对<code>semop</code>操作进行控制，主要有2个控制标志：</p>
<ul>
<li><code>IPC_NOWAIT</code><ul>
<li>当指定的PV操作不能完成时，进程不会被阻塞，<code>semop</code>函数立即返回。返回值为-1，<code>errno</code>置为<code>EAGAIN</code>。</li>
<li>例如：信号量值在P操作后小于0，如果操作控制标志没有设置<code>IPC_NOWAIT</code>，则将调用进程阻塞，<code>semop</code>函数将不会返回直到资源可用为止；若设置了<code>IPC_NOWAIT</code>，则<code>semop</code>函数直接返回，调用进程将不会阻塞</li>
</ul>
</li>
<li><code>SEM_UNDO</code><ul>
<li>进程异常退出时，执行信号量解除（undo）操作</li>
<li>例如：进程执行了P操作后异常退出，如果操作控制标志设置了<code>SEM_UNDO</code>，则内核会对该进程执行V操作，保证安全性</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semaphore_p</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>; <span class="comment">// P操作</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;semaphore_p failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_v</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>; <span class="comment">// V操作</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;semaphore_v failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="semctl函数"><a href="#semctl函数" class="headerlink" title="semctl函数"></a>semctl函数</h4><p>头文件：</p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>sys/ipc.h</code></li>
<li><code>sys/sem.h</code></li>
</ul>
<p><code>int semctl(int semid, int semnum, int cmd, union semun arg);</code></p>
<ul>
<li><p>返回值：成功返回值大于或等于0；失败返回值-1</p>
</li>
<li><p><code>semid</code>：信号量集对象的ID（<code>semget</code>的返回值）</p>
</li>
<li><p><code>semnum</code>：信号量集中信号量的编号（如果控制是针对整个信号量集，则将该值设置为0）</p>
</li>
<li><p><code>cmd</code>：要执行的控制命令</p>
<ul>
<li><p>针对<strong>整个信号量集</strong>的控制命令主要包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IPC_RMID	<span class="comment">//删除</span></span><br><span class="line">IPC_SET		<span class="comment">//设置ipc_perm参数</span></span><br><span class="line">IPC_STAT	<span class="comment">//获取ipc_perm参数</span></span><br><span class="line">IPC_INFO 	<span class="comment">//获取系统信息</span></span><br></pre></td></tr></table></figure></li>
<li><p>针对信号量集中<strong>某个信号量</strong>的控制命令主要包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SETVAL	<span class="comment">//设置信号量的值（一般用于信号量初始化时设置初始值）</span></span><br><span class="line">GETVAL	<span class="comment">//获取信号量的值</span></span><br><span class="line">GETPID	<span class="comment">//获取信号量拥有者进程的PID值</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>arg</code>：与控制命令配合的参数（可选）</p>
<ul>
<li>```c<br>union semun {<pre><code>int val;   /* Value for SETVAL */
struct semid_ds *buf; /*Buffer for IPC_STAT,IPC_SET */
unsigned short *array;/* Array for GETALL, SETALL */
struct seminfo *__buf;  /* Buffer for IPC_INFO */
</code></pre>
};<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`semctl`函数的控制命令通常为以下两种情况：</span><br><span class="line"></span><br><span class="line">- `SETVAL`：用来把信号量集中的某个信号量初始化为一个给定值， 这个值通过arg参数（union semun中的val成员）来指定</span><br><span class="line">- `IPC_RMID`：用于删除信号量集对象，此时arg参数无需赋值</span><br><span class="line">- `GETVAL`：返回值就是get得到的信号量的值</span><br><span class="line"></span><br><span class="line">#### 示例1</span><br><span class="line"></span><br><span class="line">这个示例有点问题，会死锁，参照示例2，然后可以改改示例1 ？？??</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/sem.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line"></span><br><span class="line">#define MYKEY 0x1a0a</span><br><span class="line"></span><br><span class="line">union semun &#123;    // semun 要自己添加</span><br><span class="line">    int val; </span><br><span class="line">    struct semid_ds *buf; </span><br><span class="line">    unsigned short *arry;</span><br><span class="line">    struct seminfo *__buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*信号量初始化（赋值函数）*/</span><br><span class="line">int init_sem(int sem_id, int init_value)</span><br><span class="line">&#123;</span><br><span class="line">	union semun sem_union;</span><br><span class="line">    sem_union.val = init_value;	// init_value为初始值</span><br><span class="line">    if(semctl(sem_id, 0, SETVAL, sem_union) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;Initialize semaphore\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*从系统中删除信号量的函数*/</span><br><span class="line">int del_sem(int sem_id)</span><br><span class="line">&#123;</span><br><span class="line">    union semun sem_union;</span><br><span class="line">    if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;Delete semaphore\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*P 操作函数*/</span><br><span class="line">int sem_p(int sem_id)</span><br><span class="line">&#123;</span><br><span class="line">    struct sembuf sem_b;</span><br><span class="line">    sem_b.sem_num = 0;	//信号量编号，单个信号量的编号为0</span><br><span class="line">    sem_b.sem_op = -1;	//信号量操作，-1 为 P操作</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;	//在进程没释放信号量而退出时，系统自动释放该进程中未释放的信号量</span><br><span class="line">    if(semop(sem_id, &amp;sem_b, 1) == -1) //进行P操作</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;V operation\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*V 操作函数*/</span><br><span class="line">int sem_v(int sem_id)</span><br><span class="line">&#123;</span><br><span class="line">    struct sembuf sem_b;</span><br><span class="line">    sem_b.sem_num = 0;	//信号量编号，单个信号量的编号为0</span><br><span class="line">    sem_b.sem_op = 1;	//信号量操作，1 为 v操作</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;	//在进程没释放信号量而退出时，系统自动释放该进程中未释放的信号量</span><br><span class="line">    if(semop(sem_id, &amp;sem_b, 1) == -1) //进行V操作</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;V operation\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t result;</span><br><span class="line">    int sem_id;</span><br><span class="line">    /*创建一个信号量*/</span><br><span class="line">    //sem_id = semget(ftok(&quot;.&quot;, &#x27;a&#x27;), 1, 0666 | IPC_CREAT);</span><br><span class="line">    sem_id = semget(MYKEY, 1, 0666 | IPC_CREAT);</span><br><span class="line">    init_sem(sem_id, 0);</span><br><span class="line">    /*调用fork()函数*/</span><br><span class="line">    result = fork();</span><br><span class="line">    if(result == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fork\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(result == 0) /*返回值为0代表子进程*/</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Child progress will wait for some seconds...\n&quot;);</span><br><span class="line">        sleep(3); //睡眠3秒，执行父进程</span><br><span class="line">        printf(&quot;The returned value is %d in the child progress(PID=%d)\n&quot;, result, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    else /*返回值大于0代表父进程*/</span><br><span class="line">    &#123;</span><br><span class="line">    	sem_p(sem_id);</span><br><span class="line">        printf(&quot;The returned value is %d in the father progress(PID=%d)\n&quot;, result, getpid());</span><br><span class="line">        sem_v(sem_id);</span><br><span class="line">        del_sem(sem_id);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220413222409448.png" alt="image-20220413222409448"></p>
<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;               <span class="comment">/* value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>  <span class="comment">/* buffer for IPC_STAT &amp; IPC_SET */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>; <span class="comment">/* array for GETALL &amp; SETALL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span> <span class="comment">/* buffer for IPC_INFO */</span></span><br><span class="line">    <span class="keyword">void</span> *__pad;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span></span>; <span class="comment">// P操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span></span>; <span class="comment">// V操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> semid, ret;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;/tmp&quot;</span>, <span class="number">0x04</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok key error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.创建信号量 （创建了三个信号量，实际只用0号信号量）</span></span><br><span class="line">    semid = semget(key, <span class="number">3</span>, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (semid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;create semget error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.对0号信号量设置初始值</span></span><br><span class="line">    arg.val = <span class="number">1</span>;</span><br><span class="line">    ret = semctl(semid, <span class="number">0</span>, SETVAL, arg);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;semctl error&quot;</span>);</span><br><span class="line">        semctl(semid, <span class="number">0</span>, IPC_RMID, arg);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.打印当前0号信号量的值</span></span><br><span class="line">    ret = semctl(semid, <span class="number">0</span>, GETVAL, arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after semctl setval  sem[0].val = %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="comment">// 4.开始P操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;P operate begin\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem_p(semid, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;P operate error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;P operate end\n&quot;</span>);</span><br><span class="line">    ret = semctl(semid, <span class="number">0</span>, GETVAL, arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after P sem[0].val= %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="comment">// 5.延时10s		（这个时间段内去执行另一个进程sem2，会在它的P操作那阻塞等待sem执行完V操作）</span></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">time_t</span> tNow = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;delay 60S，now time is:%s\n&quot;</span>, ctime(&amp;tNow));</span><br><span class="line">    <span class="comment">// 6.开始V操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;V operate begin\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem_v(semid, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;V operate error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;V operate end\n&quot;</span>);</span><br><span class="line">    ret = semctl(semid, <span class="number">0</span>, GETVAL, arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after V sem[0].val= %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="comment">// 7.移除信号量</span></span><br><span class="line">    sleep(<span class="number">15</span>);</span><br><span class="line">    semctl(semid, <span class="number">0</span>, IPC_RMID, arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对信号量数组semnum编号的信号量做P操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span>;</span></span><br><span class="line">    op.sem_num = <span class="number">0</span>;</span><br><span class="line">    op.sem_op = <span class="number">-1</span>;</span><br><span class="line">    op.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">return</span> (semop(semid, &amp;op, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对信号量数组semnum编号的信号量做V操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span>;</span></span><br><span class="line">    op.sem_num = <span class="number">0</span>;</span><br><span class="line">    op.sem_op = +<span class="number">1</span>;</span><br><span class="line">    op.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">return</span> (semop(semid, &amp;op, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220413222629672.png" alt="image-20220413222629672"></p>
<p>分别用两个终端运行<code>./IPC_sem</code>，等待约二十秒查看结果，注意删除信号量之前睡眠15秒是为了等待另一进程完成PV操作，<strong>即删除信号量时需保证所有使用该信号量的进程完成PV操作，否则会出错</strong></p>
<p><strong>PV操作类似线程的加锁和解锁</strong></p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul>
<li>共享内存是内核为进程间通信创建的<strong>特殊内存段</strong></li>
<li>不同进程可以将同一段共享内存连接到自己的地址空间</li>
<li>最快的进程间通信方式</li>
<li>本身不具有互斥访问机制</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410144858118.png" alt="image-20220410144858118" style="zoom: 40%;" />

<p><strong>共享内存的操作</strong></p>
<p>头文件：</p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>sys/ipc.h</code></li>
<li><code>sys/shm.h</code></li>
</ul>
<p>打开或创建共享内存对象</p>
<ul>
<li><code>int shmget(key_t key, int size, int flag);</code></li>
</ul>
<p>将共享内存连接到进程空间</p>
<ul>
<li><code>void *shmat(int shmid, void *addr, int flag);</code></li>
</ul>
<p>断开进程空间和共享内存的连接</p>
<ul>
<li><code>int shmdt(void *addr);</code></li>
</ul>
<p>共享内存控制操作</p>
<ul>
<li><code>int shmctl(int shmid, int cmd, struct 4 shmid_ds *buf);</code></li>
</ul>
<h4 id="shmget函数"><a href="#shmget函数" class="headerlink" title="shmget函数"></a>shmget函数</h4><p><code>int shmget(key_t key, size_t size, int shmflag)</code></p>
<ul>
<li><p>成功返回创建或打开的共享内存标识符；失败返回-1</p>
</li>
<li><p><code>key</code>：创建或打开共享内存对象时指定的key值（提前约定或通过ftok函数创建）</p>
</li>
<li><p><code>size</code>：指定创建的共享内存大小（首次创建共享内存对象时通过该参数指定共享内存段的大小）</p>
</li>
<li><p><code>shmflag</code>：设置共享内存的访问权限 ，取值可以为以下一个或多个值的或</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*#define IPC_R 000400 读权限</span></span><br><span class="line"><span class="comment">#define IPC_W 000200 写和修改权限</span></span><br><span class="line"><span class="comment">#define IPC_M 010000 改变控制方式权限*/</span> 好像有错误，不对</span><br><span class="line">还可以附加以下参数值（按位或）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_CREAT 01000	<span class="comment">//如果消息队列对象不存在则创建，否则打开已经存在的消息队列对象</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_EXCL 02000	<span class="comment">//只有消息队列对象不存在的时候，才能创建新的消息队列对象，否则就产生错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_NOWAIT 04000 <span class="comment">//如果操作需要等待，则直接返回错误</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="shmat函数"><a href="#shmat函数" class="headerlink" title="shmat函数"></a>shmat函数</h4><p><code>void *shmat(int shm_id, const void *addr, int shmflg);</code></p>
<ul>
<li>成功<strong>返回共享内存在进程空间中的连接地址</strong>；失败返回 -1</li>
<li><code>shm_id</code>：共享内存对象ID</li>
<li><code>addr</code>：指明共享内存连接到的进程空间地址；通常指定为空指针，让Linux系统决定共享内存连接到进程空间中的哪个地址</li>
<li><code>shmflg</code>：可以设置以下两个标志位之一或者不设置（值为0）<ul>
<li><code>SHM_RND</code>（ addr参数指定的地址应被规整到内存页面大小的整数倍）</li>
<li><code>SHM_RDONLY</code>（共享内存连接到进程空间时被限制为只读）</li>
</ul>
</li>
</ul>
<h4 id="shmdt函数"><a href="#shmdt函数" class="headerlink" title="shmdt函数"></a>shmdt函数</h4><p><code>int shmdt(const void *shmaddr);</code></p>
<ul>
<li>从调用进程的地址空间中，取消由<code>shmaddr</code>参数所指向的，共享内存映射区域</li>
<li>成功返回0；失败返回-1</li>
<li><code>shmaddr</code>：共享内存在进程空间中的连接地址，一般为<code>shmat</code>函数返回的地址。</li>
<li>内核将该共享内存的加载计数减1</li>
</ul>
<h4 id="shmctl函数"><a href="#shmctl函数" class="headerlink" title="shmctl函数"></a>shmctl函数</h4><p><code>int shmctl(int shm_id, int command, struct shmid_ds *buf);</code></p>
<ul>
<li>成功返回0；失败返回-1</li>
<li><code>shm_id</code>：共享内存对象ID</li>
<li><code>commad</code>：执行的控制命令<ul>
<li><code>IPC_RMID</code>，从系统中删除该共享内存对象</li>
<li><code>IPC_STAT</code>，获取共享内存对象的内核结构值</li>
<li><code>IPC_SET</code>，设置共享内存对象的内核结构值</li>
</ul>
</li>
<li><code>buf</code>：指向<code>shmid_ds</code>结构的指正，当控制命令为<code>IPC_STAT</code>或<code>IPC_SET</code>时，用于获取或设置共享内存对象的内核结构</li>
</ul>
<h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者/消费者问题"></a>生产者/消费者问题</h4><p>问题描述：进程之间通过共享缓冲池（包含一定数量的缓冲区）交换数据。其中，“生产者”进程不断写入，而“消费者”进程不断读出；任何时刻只能有一个任务可对共享缓冲池进行操作。</p>
<ul>
<li>进程之间的共享缓冲池可以通过共享内存机制实现</li>
</ul>
<p>消费者读取共享内存：<code>consume.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> Buffer[<span class="number">5</span>][<span class="number">100</span>]; <span class="comment">// 5 个缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> Index[<span class="number">5</span>];	<span class="comment">//缓冲区状态</span></span><br><span class="line">    <span class="comment">// 0 表示 对应的缓冲区未被生产者使用，可生产但不可消费</span></span><br><span class="line">    <span class="comment">// 1 表示 对应的缓冲区已被生产者使用，不可生产但可消费</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> *shm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span> *<span class="title">shared</span>;</span></span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    shmid = shmget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="keyword">sizeof</span>(struct BufferPool), <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    shm = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(*((<span class="keyword">int</span>*)shm) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    shared = (struct BufferPool*)shm;</span><br><span class="line">    <span class="keyword">while</span>(running)</span><br><span class="line">    &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(shared-&gt;Index[index] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;consume buffer: %s&quot;</span>, shared-&gt;Buffer[index]);</span><br><span class="line">            shared-&gt;Index[index] = <span class="number">0</span>;</span><br><span class="line">            sleep(rand() % <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(shared-&gt;Buffer[index], <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shmctl(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成者写入共享内存：<code>product.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> Buffer[<span class="number">5</span>][<span class="number">100</span>]; <span class="comment">// 5 个缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> Index[<span class="number">5</span>];	<span class="comment">//缓冲区状态</span></span><br><span class="line">    <span class="comment">// 0 表示 对应的缓冲区未被生产者使用，可生产但不可消费</span></span><br><span class="line">    <span class="comment">// 1 表示 对应的缓冲区已被生产者使用，不可生产但可消费</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> *shm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span> *<span class="title">shared</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line">    shmid = shmget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="keyword">sizeof</span>(struct BufferPool), <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    shm = shmat(shmid, (<span class="keyword">void</span>*)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(*((<span class="keyword">int</span>*)shm) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Memory attached at %X\n&quot;</span>, (<span class="keyword">int</span>*)shm);</span><br><span class="line">    shared = (struct BufferPool*)shm;</span><br><span class="line">    <span class="keyword">while</span>(running)</span><br><span class="line">    &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(shared-&gt;Index[index] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Enter some text:&quot;</span>);</span><br><span class="line">            fgets(buffer, <span class="number">100</span>, <span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">strncpy</span>(shared-&gt;Buffer[index], buffer, <span class="number">100</span>);</span><br><span class="line">            shared-&gt;Index[index] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buffer, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shmctl(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>警告不理会</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410170728545.png" alt="image-20220410170728545"></p>
<p>两个终端运行：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/images/Linux-img/image-20220410170545001.png" alt="image-20220410170545001"></p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      
      
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%88PCB%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">进程控制块（PCB）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#task-struct%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">task_struct结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">1.3.</span> <span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-number">1.4.</span> <span class="nav-text">文件管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F"><span class="nav-number">1.6.</span> <span class="nav-text">进程组织形式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">进程属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8BID"><span class="nav-number">2.1.</span> <span class="nav-text">获取进程ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84"><span class="nav-number">2.2.</span> <span class="nav-text">用户和用户组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.</span> <span class="nav-text">进程生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">3.1.</span> <span class="nav-text">进程创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2"><span class="nav-number">3.2.</span> <span class="nav-text">进程状态切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">3.3.</span> <span class="nav-text">进程的启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="nav-number">3.4.</span> <span class="nav-text">进程的终止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.5.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.</span> <span class="nav-text">终止进程函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E7%BB%88%E6%AD%A2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">3.7.</span> <span class="nav-text">注册终止处理函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="nav-number">4.</span> <span class="nav-text">进程环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">4.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="nav-number">4.2.</span> <span class="nav-text">用户空间布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">命令行参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">4.4.</span> <span class="nav-text">环境变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">创建进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">Linux进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fork%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">fork函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.3.</span> <span class="nav-text">父子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fork%E7%94%A8%E6%B3%95"><span class="nav-number">5.4.</span> <span class="nav-text">fork用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vfork%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.</span> <span class="nav-text">vfork函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">6.</span> <span class="nav-text">子进程状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-number">7.</span> <span class="nav-text">子进程运行可执行文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exec%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0"><span class="nav-number">7.1.</span> <span class="nav-text">exec系列函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execl%E5%87%BD%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">execl函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execv%E5%87%BD%E6%95%B0"><span class="nav-number">7.3.</span> <span class="nav-text">execv函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execle%E5%87%BD%E6%95%B0"><span class="nav-number">7.4.</span> <span class="nav-text">execle函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execve%E5%87%BD%E6%95%B0"><span class="nav-number">7.5.</span> <span class="nav-text">execve函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execlp%E5%87%BD%E6%95%B0"><span class="nav-number">7.6.</span> <span class="nav-text">execlp函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execvp%E5%87%BD%E6%95%B0"><span class="nav-number">7.7.</span> <span class="nav-text">execvp函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exec%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">7.8.</span> <span class="nav-text">exec函数的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E7%BA%BF%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">Linux线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">8.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="nav-number">8.2.</span> <span class="nav-text">线程与进程对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8BID"><span class="nav-number">8.3.</span> <span class="nav-text">线程ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">8.4.</span> <span class="nav-text">线程创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8"><span class="nav-number">8.5.</span> <span class="nav-text">线程启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">8.6.</span> <span class="nav-text">线程终止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-exit"><span class="nav-number">8.7.</span> <span class="nav-text">pthread_exit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cancel"><span class="nav-number">8.8.</span> <span class="nav-text">pthread_cancel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phread-join"><span class="nav-number">8.9.</span> <span class="nav-text">phread_join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-detach"><span class="nav-number">8.10.</span> <span class="nav-text">pthread_detach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">8.11.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">9.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%85%B3%E7%B3%BB"><span class="nav-number">9.1.</span> <span class="nav-text">任务关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="nav-number">9.2.</span> <span class="nav-text">线程数据共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98"><span class="nav-number">9.3.</span> <span class="nav-text">任务互斥问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">9.4.</span> <span class="nav-text">互斥量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-number">9.5.</span> <span class="nav-text">任务同步问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">9.6.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">9.7.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">9.8.</span> <span class="nav-text">读写锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">10.</span> <span class="nav-text">进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-number">10.1.</span> <span class="nav-text">进程通信机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">10.2.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XSI-IPC%E6%9C%BA%E5%88%B6"><span class="nav-number">10.3.</span> <span class="nav-text">XSI IPC机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">10.4.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">10.5.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86"><span class="nav-number">10.6.</span> <span class="nav-text">信号量集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#semget%E5%87%BD%E6%95%B0"><span class="nav-number">10.6.1.</span> <span class="nav-text">semget函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#semop%E5%87%BD%E6%95%B0"><span class="nav-number">10.6.2.</span> <span class="nav-text">semop函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#semctl%E5%87%BD%E6%95%B0"><span class="nav-number">10.6.3.</span> <span class="nav-text">semctl函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2"><span class="nav-number">10.6.4.</span> <span class="nav-text">示例2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">10.7.</span> <span class="nav-text">共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shmget%E5%87%BD%E6%95%B0"><span class="nav-number">10.7.1.</span> <span class="nav-text">shmget函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shmat%E5%87%BD%E6%95%B0"><span class="nav-number">10.7.2.</span> <span class="nav-text">shmat函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shmdt%E5%87%BD%E6%95%B0"><span class="nav-number">10.7.3.</span> <span class="nav-text">shmdt函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shmctl%E5%87%BD%E6%95%B0"><span class="nav-number">10.7.4.</span> <span class="nav-text">shmctl函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">10.7.5.</span> <span class="nav-text">生产者&#x2F;消费者问题</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yanglinqi"
      src="/images/headpic.jpg">
  <p class="site-author-name" itemprop="name">yanglinqi</p>
  <div class="site-description" itemprop="description">用于做笔记，对学过的知识总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yanglinqi107" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanglinqi107" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yanglinqi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


  <script async src="/js/cursor/fireworks.js"></script>


</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>爬虫概述</title>
    <url>/00%20%E7%88%AC%E8%99%AB%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>学自路飞学城樵夫</p>
<span id="more"></span>

<h3 id="爬虫概述"><a href="#爬虫概述" class="headerlink" title="爬虫概述"></a>爬虫概述</h3><p>爬虫分为善意的爬虫和恶意的爬虫</p>
<ul>
<li><p>善意的爬虫, 不破坏被爬取的?站的资源(正常访问, 一般频率不高, 不窃取用户隐私)</p>
</li>
<li><p>恶意的爬虫, 影响网站的正常运营（抢票, 秒杀, 疯狂solo网站资源造成网站宕机）</p>
<p>要安分守己. 时常优化爬虫程序避免干扰到网站的正常运行. 并且在使爬取到的数据时,发现涉及到用户隐私和商业机密等敏感内容时, 一定要及时终止爬取和传播。</p>
</li>
</ul>
<p>爬虫的予与盾</p>
<p>反爬机制 门户网站，可以通过制定相应的策略或者技术手段，防止爬虫程序进行网站数据的爬取。</p>
<p>反反爬策略爬虫程序可以通过制定相关的策略或者技术手段，破解门户网站中具备的反爬机制，从而可以获取门户网站中相关的数据</p>
<p>robots.txt协议：君子协议。规定了网站中哪些数据可以被爬虫爬取哪些数据不可以被爬取</p>
<p>在网站网址后加上 <code>/robots.txt</code>可查看协议</p>
<p>如：查看B站<code>https://www.bilibili.com/</code>  的爬虫协议  <code>https://www.bilibili.com/robots.txt</code></p>
<p>![image-20220118155704342](00 爬虫概述/image-20220118155704342.png)</p>
<h3 id="爬虫程序样例"><a href="#爬虫程序样例" class="headerlink" title="爬虫程序样例"></a>爬虫程序样例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen	<span class="comment"># 一般爬虫不直接使用这个库了</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line">resp = urlopen(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;mybaidu.html&quot;</span>, mode=<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(resp.read().decode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 读取到网页的页面源代码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;over!&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>网络数据请求过程</p>
<ul>
<li>C/S        Client     客户端     Server服务器端<ul>
<li>安全，避免大量数据的传输</li>
</ul>
</li>
<li>B/S        Brower    浏览器    Server服务器端</li>
</ul>
<p>爬虫究竟是合法还是违法的？</p>
<ul>
<li>在法律中是不被禁止</li>
<li>具有违法风险</li>
<li>善意爬虫    恶意爬虫</li>
</ul>
<p>爬虫带来的风险可以体现在如下2方面：</p>
<ul>
<li>爬虫干扰了被访问网站的正常运营</li>
<li>爬虫抓取了收到法律保护的特定类型的数</li>
</ul>
<p>如何在使用编写爬虫的过程中避免进入局子的厄远</p>
<ul>
<li>时常的优化自己的程序，避免干扰被访问</li>
<li>在使用，传播爬取到的数据时，审查抓取到的内容，如果发现了涉及到用户隐私商业机密等敏感内容需要及时停止爬取或传播</li>
</ul>
<p>爬虫在使用场景中的分类<br>    - 通用爬虫：<br>        - 抓取系统重要组成部分</p>
<ul>
<li>聚焦爬虫：</li>
<li>增量式爬虫：</li>
</ul>
<p>模拟登录：</p>
<pre><code>- 基于某些用户的用户信息。
</code></pre>
<p>需求：对人人网进行模拟登录。</p>
<pre><code>- 点击登录按钮之后会发起一个post请求
- post请求中会携带登录之前录入的相关的登录信息(用户名，密码，验证码，，,,,,)
</code></pre>
<ul>
<li>验证码：每次请求都会变化</li>
</ul>
<p>http:/httpst协议特性：无状态</p>
<p>没有请求到对应页面数据的原因：</p>
<pre><code>- 发起第二次请求的时候，服务器端并不知道该此请求是基于登录状态下的请求。
</code></pre>
<p>cookie:用来让服务器端记录客户端的相关状态</p>
<pre><code>- 手动处理：通过抓包工具获取 cookie值，将该值封装到 headers中。（不建议）

- 自动处理：
        - cookie值的来源是哪里？
    
    - 模拟登录post请求后，由服务器端创建
    
- session会话对象：

  - 作用：

    1.可以进行请求的发送

    2.如果请求过程中产生了 cookie,则该 cookies会被自动存储/携带在该session对象

- 创建一个session对象： `session=requests.Session()`

  使用session对象进行模拟登录post请求的发送( cookie就会被存储在 session中)
</code></pre>
<p>代理：破解封IP这种反爬机制<br>什么是代理：</p>
<ul>
<li>代理服务器</li>
</ul>
<p>代理的作用：</p>
<ul>
<li>突破自身IP访问的限制</li>
<li>隐藏自身真实的IP</li>
</ul>
<p>代理相关网站：</p>
<ul>
<li>快代理</li>
<li>西祠代理</li>
<li><a href="http://www.goubanjia.com/">www.goubanjia.com</a></li>
</ul>
<p>代理IP的类型：</p>
<ul>
<li>http：应用到http协议对应的url中</li>
<li>https：应用到https协议对应的url中</li>
</ul>
<p>代理IP的匿名度：</p>
<ul>
<li>透明：服务器知道请求使用了代理，也知道真实IP</li>
<li>匿名：知道使用了代理，不知道真实IP</li>
<li>高匿：不知道使用了代理，更不知道真实IP</li>
</ul>
<p>高性能异步爬虫</p>
<p>目的：在爬虫中使用异步实现高性能的数据爬取操作</p>
<p>异步爬虫的方式：</p>
<ul>
<li><p>多线程，多进程（不推荐）<br>  好处：可以为相关阻塞的操作单独开启线程或者进程，阻塞操作就可以异步执行<br>  弊端：无法无限制的开启多线程或者多进程</p>
</li>
<li><p>线程池，进程池（适当使用）<br>  好处：可以降低系统对进程或者线程创建和销毁的频率，从而降低系统的开销<br>  弊端：池中线程或进程的数量是有上限</p>
</li>
<li><p>单线程+异步协程（推荐）<br>  <code>event_loop</code>: 事件循环，相当于一个无限循环，我们可以把一些函数注册到这个事件循环上当满足某些条件的时候，函数就会被循环执行</p>
</li>
</ul>
<p><code>coroutine</code>: 协程对象，我们可以将协程对象注册到事件循环中，它会被事件循环调用我们可以使用async关量字来定义一个方法，这个方法在调用时不会立即被执行，而是返回一个协程对象</p>
<pre><code>`task `任务，它是对协程对象的进一步封装，包含了任务的各个状态
</code></pre>
<p><code>future </code>代表将来执行或还没有执行的任务，实际上和task没有本质区别<br>    <code>async </code>定义一个协程<br>    <code>await </code>用来挂起阻塞方法的执行</p>
<p><code>selenium</code>模块的基本使用</p>
<p>问题： selenium模块和爬虫之间具有怎样的关联？</p>
<ul>
<li>便捷的获取网站中动态加载的数据</li>
<li>便捷实现模拟登录</li>
</ul>
<p>什么是 selenium模块？</p>
<pre><code>- 基于浏览器自动化的一个模块
</code></pre>
<p>selenium使用流程：</p>
<ul>
<li>环境安装：<code>pip install selenium</code></li>
<li>下载浏览器驱动程序</li>
<li>实例化浏览器对象</li>
<li>编写基于浏览器的自动化代码<ul>
<li>发起请求：get(url)</li>
<li>标签定位：find系列</li>
<li>标签交互：send_keys(‘xxx’)</li>
<li>执行js程序：execute_script(‘jsCode’)</li>
<li>前进，回退 forward()  back()</li>
<li>关闭浏览器：quit()</li>
</ul>
</li>
<li>selenium处理iframe<ul>
<li>如果定位的标签在iframe标签中，则必须使用switch_to.frame(id)</li>
<li>动作链（拖动）：from selenium.webdriver import ActionChains<ul>
<li>实例化一个动作链对象：action = ActionChains(bro)</li>
<li>click_and_hold(div)  长按且点击操作</li>
<li>move_by_offset(x,y)</li>
<li>perform() 让动作链立即执行</li>
<li>action.release() 释放动作链对象</li>
</ul>
</li>
</ul>
</li>
<li>无头浏览器<br>  option = Options()<br>  option.add_argument(‘–headless’)<br>  option.add_argument(‘–disable-gpu’)</li>
<li>规避检测（在抓包工具的控制台输入window.navigator.webdriver）<br>option.addgument(‘–disable-blink-features=AutomationControlled’)</li>
</ul>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>requests模块</title>
    <url>/01%20requests%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>学自路飞学城樵夫，requests模块</p>
<span id="more"></span>

<h3 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h3><p>requests模块：python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率极高。</p>
<p>作用：模拟浏览器发请求。</p>
<p>如何使用：（requests模块的编码流程）<br>    - 指定url<br>        - UA伪装<br>        - 请求参数的处理</p>
<ul>
<li>发起请求</li>
<li>获取响应数据</li>
<li>持久化存储</li>
</ul>
<p>请求的两种方式</p>
<ul>
<li>requests.get(url)</li>
<li>requests.post(url)</li>
</ul>
<p>函数参数：（都是 字典dic ）</p>
<ul>
<li>headers     请求头，UA</li>
<li>param        请求的参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装requests</span></span><br><span class="line"><span class="comment"># pip install requests</span></span><br><span class="line"><span class="comment"># 国内源</span></span><br><span class="line"><span class="comment"># pip install -i https://pypi.tuna.tsinghua.edu.cn/simple requests</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests	</span><br><span class="line">query = <span class="built_in">input</span>(<span class="string">&quot;输入一个你喜欢的明星&quot;</span>)</span><br><span class="line"></span><br><span class="line">url = <span class="string">f&#x27;https://www.sogou.com/web?query=<span class="subst">&#123;query&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(url, headers=headers)  <span class="comment"># 处理一个小小的反爬</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(resp)</span><br><span class="line"><span class="built_in">print</span>(resp.text)  <span class="comment"># 拿到页面源代码</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://fanyi.baidu.com/sug&quot;</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">input</span>(<span class="string">&quot;请输入你要翻译的英文单词&quot;</span>)</span><br><span class="line">dat = &#123;</span><br><span class="line">    <span class="string">&quot;kw&quot;</span>: s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送post请求, 发送的数据必须放在字典中, 通过data参数进行传递</span></span><br><span class="line">resp = requests.post(url, data=dat)</span><br><span class="line"><span class="built_in">print</span>(resp.json())  <span class="comment"># 将服务器返回的内容直接处理成json()  =&gt; dict</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://movie.douban.com/j/chart/top_list&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新封装参数</span></span><br><span class="line">param = &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;24&quot;</span>,</span><br><span class="line">    <span class="string">&quot;interval_id&quot;</span>: <span class="string">&quot;100:90&quot;</span>,</span><br><span class="line">    <span class="string">&quot;action&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;limit&quot;</span>: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(url=url, params=param, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(resp.json())</span><br><span class="line">resp.close()  <span class="comment"># 关掉resp</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#1.指定url</span></span><br><span class="line">    post_url = <span class="string">&#x27;https://fanyi.baidu.com/sug&#x27;</span></span><br><span class="line">    <span class="comment">#2.进行UA伪装</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>:</span><br><span class="line">        <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#3.post请求参数处理（同get请求一致）</span></span><br><span class="line">    word = <span class="built_in">input</span>(<span class="string">&#x27;enter a word:&#x27;</span>)</span><br><span class="line">    data = &#123;<span class="string">&#x27;kw&#x27;</span>: word&#125;</span><br><span class="line">    <span class="comment">#4.请求发送</span></span><br><span class="line">    session = requests.Session()</span><br><span class="line">    response = session.post(url=post_url, data=data, headers=headers)</span><br><span class="line">    <span class="comment">#5.获取响应数据:json()方法返回的是obj（如果确认响应数据是json类型的，才可以使用json（））</span></span><br><span class="line">    dic_obj = response.json()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#持久化存储</span></span><br><span class="line">    fileName = word + <span class="string">&#x27;.json&#x27;</span></span><br><span class="line">    fp = <span class="built_in">open</span>(fileName, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    json.dump(dic_obj, fp=fp, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;over!!!&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="请求头headers"><a href="#请求头headers" class="headerlink" title="请求头headers"></a>请求头headers</h4><p> header为HTTP协议中的请求头。一般存放一些和请求内容无关的数据. 有时也会存放一些安全验证信息。比如常见的User-Agent, token, cookie等</p>
<p>通过 requests发送的请求，我们可以把请求头信息放在 headers中。也可以单独进行存放，最终由 requests自动帮我们拼接成完整的http请求头</p>
<p>模拟登录：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话</span></span><br><span class="line">session = requests.session()</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;loginName&quot;</span>: <span class="string">&quot;18614075987&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;q6035945&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 登录</span></span><br><span class="line">url = <span class="string">&quot;https://passport.17k.com/ck/user/login&quot;</span></span><br><span class="line">session.post(url, data=data)</span><br><span class="line"><span class="comment"># print(resp.text)</span></span><br><span class="line"><span class="comment"># print(resp.cookies)  # 看cookie</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 拿书架上的数据</span></span><br><span class="line"><span class="comment"># 刚才的那个session中是有cookie的</span></span><br><span class="line">resp = session.get(<span class="string">&#x27;https://user.17k.com/ck/author/shelf?page=1&amp;appKey=2406394919&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(resp.json())</span><br></pre></td></tr></table></figure>

<p>防盗链处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取视频的网址</span></span><br><span class="line">url = <span class="string">&quot;https://www.pearvideo.com/video_1721605&quot;</span></span><br><span class="line">contId = url.split(<span class="string">&quot;_&quot;</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">videoStatusUrl = <span class="string">f&quot;https://www.pearvideo.com/videoStatus.jsp?contId=<span class="subst">&#123;contId&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.192 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="comment"># 防盗链: 溯源, 当前本次请求的上一级是谁</span></span><br><span class="line">    <span class="string">&quot;Referer&quot;</span>: url</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(videoStatusUrl, headers=headers)</span><br><span class="line">dic = resp.json()</span><br><span class="line"></span><br><span class="line">srcUrl = dic[<span class="string">&#x27;videoInfo&#x27;</span>][<span class="string">&#x27;videos&#x27;</span>][<span class="string">&#x27;srcUrl&#x27;</span>]</span><br><span class="line">systemTime = dic[<span class="string">&#x27;systemTime&#x27;</span>]</span><br><span class="line">srcUrl = srcUrl.replace(systemTime, <span class="string">f&quot;cont-<span class="subst">&#123;contId&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载视频</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;a.mp4&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(requests.get(srcUrl).content)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代理ip：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com/s?wd=ip&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">proxies = &#123;<span class="string">&quot;http&quot;</span>: <span class="string">&#x27;203.57.226.156&#x27;</span>&#125; <span class="comment"># 目前不一定有效了</span></span><br><span class="line"><span class="comment"># 或者 proxies = &#123;&quot;https&quot;: &#x27;https://203.57.226.156&#x27;&#125;</span></span><br><span class="line">page_text = requests.get(url=url, headers=headers, proxies=proxies).text</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(page_text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反爬机制：  封ip</span></span><br><span class="line"><span class="comment"># 反反爬策略：使用代理进行请求发送</span></span><br></pre></td></tr></table></figure>

<p>综合案例——抓取网易云音乐评论：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 找到未加密的参数                       # window.arsea(参数, xxxx,xxx,xxx)</span></span><br><span class="line"><span class="comment"># 2. 想办法把参数进行加密(必须参考网易的逻辑), params  =&gt; encText, encSecKey =&gt; encSecKey</span></span><br><span class="line"><span class="comment"># 3. 请求到网易. 拿到评论信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要安装pycrypto:   pip install pycrypto</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求方式是POST</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;csrf_token&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cursor&quot;</span>: <span class="string">&quot;-1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;offset&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;orderType&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pageNo&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pageSize&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rid&quot;</span>: <span class="string">&quot;R_SO_4_1325905146&quot;</span>,</span><br><span class="line">    <span class="string">&quot;threadId&quot;</span>: <span class="string">&quot;R_SO_4_1325905146&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务于d的</span></span><br><span class="line">f = <span class="string">&quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot;</span></span><br><span class="line">g = <span class="string">&quot;0CoJUm6Qyw8W8jud&quot;</span></span><br><span class="line">e = <span class="string">&quot;010001&quot;</span></span><br><span class="line">i = <span class="string">&quot;d5bpgMn9byrHNtAh&quot;</span>  <span class="comment"># 手动固定的. -&gt; 人家函数中是随机的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_encSecKey</span>():</span>  <span class="comment"># 由于i是固定的. 那么encSecText就是固定的.  c()函数的结果就是固定的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;1b5c4ad466aabcfb713940efed0c99a1030bce2456462c73d8383c60e751b069c24f82e60386186d4413e9d7f7a9c7cf89fb06e40e52f28b84b8786b476738a12b81ac60a3ff70e00b085c886a6600c012b61dbf418af84eb0be5b735988addafbd7221903c44d027b2696f1cd50c49917e515398bcc6080233c71142d226ebb&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把参数进行加密</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_params</span>(<span class="params">data</span>):</span>  <span class="comment"># 默认这里接收到的是字符串</span></span><br><span class="line">    first = enc_params(data, g)</span><br><span class="line">    second = enc_params(first, i)</span><br><span class="line">    <span class="keyword">return</span> second  <span class="comment"># 返回的就是params</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转化成16的倍数, 位下方的加密算法服务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_16</span>(<span class="params">data</span>):</span></span><br><span class="line">    pad = <span class="number">16</span> - <span class="built_in">len</span>(data) % <span class="number">16</span></span><br><span class="line">    data += <span class="built_in">chr</span>(pad) * pad</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密过程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc_params</span>(<span class="params">data, key</span>):</span></span><br><span class="line">    iv = <span class="string">&quot;0102030405060708&quot;</span></span><br><span class="line">    data = to_16(data)</span><br><span class="line">    aes = AES.new(key=key.encode(<span class="string">&quot;utf-8&quot;</span>), IV=iv.encode(<span class="string">&#x27;utf-8&#x27;</span>), mode=AES.MODE_CBC)  <span class="comment"># 创建加密器</span></span><br><span class="line">    bs = aes.encrypt(data.encode(<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 加密, 加密的内容的长度必须是16的倍数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(b64encode(bs), <span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 转化成字符串返回,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理加密过程</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    function a(a = 16) &#123;  # 随机的16位字符串</span></span><br><span class="line"><span class="string">        var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;;</span></span><br><span class="line"><span class="string">        for (d = 0; a &gt; d; d += 1)  # 循环16次</span></span><br><span class="line"><span class="string">            e = Math.random() * b.length,  # 随机数 1.2345</span></span><br><span class="line"><span class="string">            e = Math.floor(e),  # 取整  1 </span></span><br><span class="line"><span class="string">            c += b.charAt(e);  # 去字符串中的xxx位置 b</span></span><br><span class="line"><span class="string">        return c</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    function b(a, b) &#123;  # a是要加密的内容, </span></span><br><span class="line"><span class="string">        var c = CryptoJS.enc.Utf8.parse(b) #  # b是秘钥</span></span><br><span class="line"><span class="string">          , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;)</span></span><br><span class="line"><span class="string">          , e = CryptoJS.enc.Utf8.parse(a)  # e是数据</span></span><br><span class="line"><span class="string">          , f = CryptoJS.AES.encrypt(e, c, &#123;  # c 加密的秘钥</span></span><br><span class="line"><span class="string">            iv: d,  # 偏移量</span></span><br><span class="line"><span class="string">            mode: CryptoJS.mode.CBC  # 模式: cbc</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">        return f.toString()</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    function c(a, b, c) &#123;   # c里面不产生随机数</span></span><br><span class="line"><span class="string">        var d, e;</span></span><br><span class="line"><span class="string">        return setMaxDigits(131),</span></span><br><span class="line"><span class="string">        d = new RSAKeyPair(b,&quot;&quot;,c),</span></span><br><span class="line"><span class="string">        e = encryptedString(d, a)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    function d(d, e, f, g) &#123;  d: 数据,   e: 010001, f: 很长, g: 0CoJUm6Qyw8W8jud</span></span><br><span class="line"><span class="string">        var h = &#123;&#125;  # 空对象</span></span><br><span class="line"><span class="string">          , i = a(16);  # i就是一个16位的随机值, 把i设置成定值 </span></span><br><span class="line"><span class="string">        h.encText = b(d, g)  # g秘钥</span></span><br><span class="line"><span class="string">        h.encText = b(h.encText, i)  # 返回的就是params  i也是秘钥</span></span><br><span class="line"><span class="string">        h.encSecKey = c(i, e, f)  # 得到的就是encSecKey, e和f是定死的 ,如果此时我把i固定, 得到的key一定是固定的</span></span><br><span class="line"><span class="string">        return h</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    两次加密: </span></span><br><span class="line"><span class="string">    数据+g =&gt; b =&gt; 第一次加密+i =&gt; b = params</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求. 得到评论结果</span></span><br><span class="line">resp = requests.post(url, data=&#123;</span><br><span class="line">    <span class="string">&quot;params&quot;</span>: get_params(json.dumps(data)),</span><br><span class="line">    <span class="string">&quot;encSecKey&quot;</span>: get_encSecKey()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(resp.text)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>正则</title>
    <url>/02%20re%E6%AD%A3%E5%88%99%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>re正则解析，用于提取字符串</p>
<span id="more"></span>

<p><code>re   Regular Expression</code></p>
<p>反斜杠不仅可以把特殊符号变成普通符号,还可以把善通符号变成特殊符号。例如“n”只是一个善通的字母,但是“n”代表换行符；*  在正则中是通配符，* 就是普通的 *</p>
<p><font color="#ff0000">findall</font></p>
<p>Python的正则表达式模块包含一个findall方法，它能够以列表的形式返回所有满足要求的字符串。</p>
<p>findall的函数原型为：</p>
<p><code>re.findall(pattern, string, flags=0)</code></p>
<p>pattern表示正则表达式，string表示原来的字符串，flags表示一些特殊功能的标志。</p>
<p>findall的结果是一个列表，包含了所有的匹配到的结果。如果没有匹配到结果，就会返回空列表</p>
<p>如果包含多个<code> (.*? )</code>，返回的仍然是一个列表，但是列表里面的元素变为了元组</p>
<p>flags参数。这个参数是可以省略的。当不省略的时候，具有一些辅助功能，例如忽略大小写、忽略换行符等。使用<code>re.S</code>作为flag来忽略换行符</p>
<p><font color="#ff0000">search</font></p>
<p>search()的用法和findall()的用法一样，但是search()只会返回第1个满足要求的字符串。一旦找到符合要求的内容，它就会停止查找。对于从超级大的文本里面只找第1个数据特别有用，可以大大提高程序的运行效率。</p>
<p>search()的函数原型为：</p>
<p><code>re.search(pattern, string, flags=0)</code></p>
<p>对于结果，如果匹配成功，则是一个正则表达式的对象；如果没有匹配到任何数据，就是None。如果需要得到匹配到的结果，则需要通过<code>.group()</code>这个方法来获取里面的值</p>
<p>只有在.group()里面的参数为1的时候，才会把正则表达式里面的括号中的结果打印出来</p>
<p>group()的参数最大不能超过正则表达式里面括号的个数。参数为1表示读取第1个括号中的内容，参数为2表示读取第2个括号中的内容，以此类推</p>
<p>Python 3中正则表达式模块的源代码的入口文件为re.py。这个文件里面的注释就是学习Python正则表达式模块非常好的文档，它包含了正则表达式各种符号的简单说明和这个模块内部各个方法的使用。</p>
<p>re.py在Python 3安装文件夹下面的Lib文件夹中。</p>
<p>正则的语法: 使用元字符进行排列组合用来匹配字符串 在线测试正则表达式<a href="https://tool.oschina.net/regex/">https://tool.oschina.net/regex/</a></p>
<p>元字符: 具有固定含义的特殊符号 常用元字符：（下面的<code>[]</code>和<code>&#123;&#125;</code>在使用时注意转义问题）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.			匹配 除换行以外的任意字符</span><br><span class="line">\w			匹配 字母、数字、下划线</span><br><span class="line">\W			匹配 非字母或数字或下划线，\w取反</span><br><span class="line">\s			匹配 任意的空白符，包括空格、制表符、换页符等等。等价于[ \f \n \r \t \v ]</span><br><span class="line">\S			匹配 非空白符，\s补集</span><br><span class="line">\d			匹配 数字</span><br><span class="line">\D			匹配 非数字</span><br><span class="line">\n			匹配 一个换行符</span><br><span class="line">\t			匹配 一个制表符</span><br><span class="line"></span><br><span class="line">^			匹配 字符串的开始</span><br><span class="line">$			匹配 字符串的结尾</span><br><span class="line">a|b			匹配 字符a或字符b</span><br><span class="line">()			匹配 括号内的表达式，表示一个组</span><br><span class="line">[]			匹配 字符组中的字符</span><br><span class="line">[^...]		匹配除了字符组中的字符的所有字符</span><br></pre></td></tr></table></figure>

<p>量词: 控制前面的元字符出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">*			 重复&gt;=<span class="number">0</span>次</span><br><span class="line">+			 重复&gt;=<span class="number">1</span>次</span><br><span class="line">?			 重复<span class="number">0</span>或<span class="number">1</span>次</span><br><span class="line">&#123;n&#125;			 重复n次</span><br><span class="line">&#123;n,&#125;		 重复&gt;=n次</span><br><span class="line">&#123;n,m&#125;		 重复n到m次</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.*			贪婪匹配</span><br><span class="line">.*?			惰性匹配（爬虫用的很多）</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># findall:  匹配字符串中所有的符合正则的内容，返回list</span></span><br><span class="line">lst = re.findall(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;我的电话号是:10086, 我女朋友的电话是:10010&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># finditer: 匹配字符串中所有的内容[返回的是迭代器], 从迭代器中拿到内容需要.group()</span></span><br><span class="line">it = re.finditer(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;我的电话号是:10086, 我女朋友的电话是:10010&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span>(i.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># search, 找到一个结果就返回, 返回的结果是match对象. 拿数据需要.group()</span></span><br><span class="line">s = re.search(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;我的电话号是:10086, 我女朋友的电话是:10010&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.group())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># match是从头开始匹配</span></span><br><span class="line">s = re.match(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;10086, 我女朋友的电话是:10010&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预加载正则表达式 compile()</span></span><br><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&quot;\d+&quot;</span>)</span><br><span class="line"></span><br><span class="line">ret = obj.finditer(<span class="string">&quot;我的电话号是:10086, 我女朋友的电话是:10010&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> ret:</span><br><span class="line">    <span class="built_in">print</span>(it.group())</span><br><span class="line"></span><br><span class="line">ret = obj.findall(<span class="string">&quot;呵呵哒, 我就不信你不换我1000000000&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;jay&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;郭麒麟&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;jj&#x27;&gt;&lt;span id=&#x27;2&#x27;&gt;宋铁&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;jolin&#x27;&gt;&lt;span id=&#x27;3&#x27;&gt;大聪明&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;sylar&#x27;&gt;&lt;span id=&#x27;4&#x27;&gt;范思哲&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;tory&#x27;&gt;&lt;span id=&#x27;5&#x27;&gt;胡说八道&lt;/span&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (?P&lt;分组名字&gt;正则) 可以单独从正则匹配的内容中进一步提取内容</span></span><br><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&quot;&lt;div class=&#x27;.*?&#x27;&gt;&lt;span id=&#x27;(?P&lt;id&gt;\d+)&#x27;&gt;(?P&lt;wahaha&gt;.*?)&lt;/span&gt;&lt;/div&gt;&quot;</span>, re.S)  <span class="comment"># re.S: 让.能匹配换行符</span></span><br><span class="line"></span><br><span class="line">result = obj.finditer(s)</span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> result:</span><br><span class="line">    <span class="built_in">print</span>(it.group(<span class="string">&quot;wahaha&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(it.group(<span class="string">&quot;id&quot;</span>))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>xpath解析</title>
    <url>/04%20xpath%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>xpath解析</p>
<span id="more"></span>

<p>安装lxml模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install lxml -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<ul>
<li>将要解析的html内容构造出etree对象。</li>
<li>使用etree对象的xpath()方法配合xpath表达式来完成对数据的提取。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">属性定位：</span><br><span class="line">    <span class="comment">#找到class属性值为song的div标签</span></span><br><span class="line">    //div[@<span class="class"><span class="keyword">class</span>=&quot;<span class="title">song</span>&quot;] </span></span><br><span class="line"><span class="class">层级&amp;索引定位：</span></span><br><span class="line"><span class="class">    #找到<span class="title">class</span>属性值为<span class="title">tang</span>的<span class="title">div</span>的直系子标签<span class="title">ul</span>下的第二个子标签<span class="title">li</span>下的直系子标签<span class="title">a</span></span></span><br><span class="line"><span class="class">    //<span class="title">div</span>[@<span class="title">class</span>=&quot;<span class="title">tang</span>&quot;]/<span class="title">ul</span>/<span class="title">li</span>[2]/<span class="title">a</span></span></span><br><span class="line"><span class="class">逻辑运算：</span></span><br><span class="line"><span class="class">    #找到<span class="title">href</span>属性值为空且<span class="title">class</span>属性值为<span class="title">du</span>的<span class="title">a</span>标签</span></span><br><span class="line"><span class="class">    //<span class="title">a</span>[@<span class="title">href</span>=&quot;&quot; <span class="title">and</span> @<span class="title">class</span>=&quot;<span class="title">du</span>&quot;]</span></span><br><span class="line"><span class="class">模糊匹配：</span></span><br><span class="line"><span class="class">    //<span class="title">div</span>[<span class="title">contains</span>(<span class="params">@<span class="keyword">class</span>, <span class="string">&quot;ng&quot;</span></span>)]</span></span><br><span class="line"><span class="class">    //<span class="title">div</span>[<span class="title">starts</span>-<span class="title">with</span>(<span class="params">@<span class="keyword">class</span>, <span class="string">&quot;ta&quot;</span></span>)]</span></span><br><span class="line"><span class="class">取文本：</span></span><br><span class="line"><span class="class">    # /表示获取某个标签下的文本内容</span></span><br><span class="line"><span class="class">    # //表示获取某个标签下的文本内容和所有子标签下的文本内容</span></span><br><span class="line"><span class="class">    //<span class="title">div</span>[@<span class="title">class</span>=&quot;<span class="title">song</span>&quot;]/<span class="title">p</span>[1]/<span class="title">text</span>()</span></span><br><span class="line"><span class="class">    //<span class="title">div</span>[@<span class="title">class</span>=&quot;<span class="title">tang</span>&quot;]//<span class="title">text</span>()</span></span><br><span class="line"><span class="class">取属性：</span></span><br><span class="line"><span class="class">    //<span class="title">div</span>[@<span class="title">class</span>=&quot;<span class="title">tang</span>&quot;]//<span class="title">li</span>[2]/<span class="title">a</span>/@<span class="title">href</span></span></span><br></pre></td></tr></table></figure>



<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;book&gt;</span></span><br><span class="line"><span class="string">    &lt;id&gt;1&lt;/id&gt;</span></span><br><span class="line"><span class="string">    &lt;name&gt;野花遍地香&lt;/name&gt;</span></span><br><span class="line"><span class="string">    &lt;price&gt;1.23&lt;/price&gt;</span></span><br><span class="line"><span class="string">    &lt;nick&gt;臭豆腐&lt;/nick&gt;</span></span><br><span class="line"><span class="string">    &lt;author&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;10086&quot;&gt;周大强&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;10010&quot;&gt;周芷若&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick class=&quot;joy&quot;&gt;周杰伦&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick class=&quot;jolin&quot;&gt;蔡依林&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;nick&gt;热热热热热1&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;</span></span><br><span class="line"><span class="string">            &lt;nick&gt;热热热热热2&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;/author&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;partner&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;ppc&quot;&gt;胖胖陈&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;ppbc&quot;&gt;胖胖不陈&lt;/nick&gt;</span></span><br><span class="line"><span class="string">    &lt;/partner&gt;</span></span><br><span class="line"><span class="string">&lt;/book&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">tree = etree.XML(xml)</span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book&quot;</span>)  <span class="comment"># /表示层级关系. 第一个/是根节点</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/name/text()&quot;</span>)  <span class="comment"># text() 拿文本</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/author//nick/text()&quot;</span>)  <span class="comment"># // 后代</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book/author/*/nick/text()&quot;</span>)  <span class="comment"># * 任意的节点. 通配符(会儿)</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">result = tree.xpath(<span class="string">&quot;/book//nick/text()&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># [&lt;Element book at 0x1ef1c91e2c0&gt;]</span></span><br><span class="line"><span class="comment"># [&lt;Element name at 0x1ef1c9c0e00&gt;]</span></span><br><span class="line"><span class="comment"># [&#x27;野花遍地香&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;周大强&#x27;, &#x27;周芷若&#x27;, &#x27;周杰伦&#x27;, &#x27;蔡依林&#x27;, &#x27;热热热热热1&#x27;, &#x27;热热热热热2&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;热热热热热1&#x27;, &#x27;热热热热热2&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;臭豆腐&#x27;, &#x27;周大强&#x27;, &#x27;周芷若&#x27;, &#x27;周杰伦&#x27;, &#x27;蔡依林&#x27;, &#x27;热热热热热1&#x27;, &#x27;热热热热热2&#x27;, &#x27;胖胖陈&#x27;, &#x27;胖胖不陈&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>b.html文件的内容，用于下个示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.google.com&quot;</span>&gt;</span>谷歌<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.sogou.com&quot;</span>&gt;</span>搜狗<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;feiji&quot;</span>&gt;</span>飞机<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;dapao&quot;</span>&gt;</span>大炮<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;huoche&quot;</span>&gt;</span>火车<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;job&quot;</span>&gt;</span>李嘉诚<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;common&quot;</span>&gt;</span>胡辣汤<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">tree = etree.parse(<span class="string">&quot;b.html&quot;</span>)</span><br><span class="line">result = tree.xpath(<span class="string">&#x27;/html&#x27;</span>)</span><br><span class="line">result = tree.xpath(<span class="string">&quot;/html/body/ul/li/a/text()&quot;</span>)</span><br><span class="line">result = tree.xpath(<span class="string">&quot;/html/body/ul/li[1]/a/text()&quot;</span>)  <span class="comment"># xpath的顺序是从1开始数的, []表示索引</span></span><br><span class="line"></span><br><span class="line">result = tree.xpath(<span class="string">&quot;/html/body/ol/li/a[@href=&#x27;dapao&#x27;]/text()&quot;</span>)  <span class="comment"># [@xxx=xxx] 属性的筛选</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">ol_li_list = tree.xpath(<span class="string">&quot;/html/body/ol/li&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> ol_li_list:</span><br><span class="line">    <span class="comment"># 从每一个li中提取到文字信息</span></span><br><span class="line">    result = li.xpath(<span class="string">&quot;./a/text()&quot;</span>)  <span class="comment"># 在li中继续去寻找. 相对查找</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    result2 = li.xpath(<span class="string">&quot;./a/@href&quot;</span>)  <span class="comment"># 拿到属性值: @属性</span></span><br><span class="line">    <span class="built_in">print</span>(result2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tree.xpath(<span class="string">&quot;/html/body/ul/li/a/@href&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tree.xpath(<span class="string">&#x27;/html/body/div[1]/text()&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(tree.xpath(<span class="string">&#x27;/html/body/ol/li/a/text()&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># [&#x27;大炮&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;飞机&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;feiji&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;大炮&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;dapao&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;火车&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;huoche&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;http://www.baidu.com&#x27;, &#x27;http://www.google.com&#x27;, &#x27;http://www.sogou.com&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;李嘉诚&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;飞机&#x27;, &#x27;大炮&#x27;, &#x27;火车&#x27;]</span></span><br></pre></td></tr></table></figure>



<p>注意：</p>
<p>xpath路径中不能有tbody</p>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>线程和进程</title>
    <url>/05%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>线程和进程的写法</p>
<span id="more"></span>

<p>Python中，多线程和多进程的写法几乎一样。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  多线程</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread  <span class="comment"># 线程类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;func&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = Thread(target=func)  <span class="comment"># 创建线程并给线程安排任务</span></span><br><span class="line">    t.start()  <span class="comment"># 多线程状态为可以开始工作状态, 具体的执行时间由CPU决定</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, i)</span><br></pre></td></tr></table></figure>



<p>继承Thread类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  多线程</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread  <span class="comment"># 线程类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">Thread</span>):</span>  <span class="comment"># 继承线程类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span>  <span class="comment"># 固定的    -&gt; 当线程被执行的时候, 被执行的就是run()</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;子线程&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = MyThread()</span><br><span class="line">    <span class="comment"># t.run()  # 方法的调用了. -&gt; 单线程????</span></span><br><span class="line">    t.start()  <span class="comment"># 开启线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;主线程&quot;</span>, i)</span><br></pre></td></tr></table></figure>





<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>示例：</p>
<p>第一种写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;子进程&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=func)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;主进程&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<p>第二种写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;MyProcess&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    t = MyProcess()</span><br><span class="line">    t.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, i)</span><br></pre></td></tr></table></figure>





<p>传参问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Thread(target=func, args=(<span class="string">&quot;周杰伦&quot;</span>,))  <span class="comment"># 传递参数必须是元组</span></span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">    t2 = Thread(target=func, args=(<span class="string">&quot;王力宏&quot;</span>,))</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池和进程池</title>
    <url>/06%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>线程池和进程池的写法</p>
<span id="more"></span>

<p>Python中，线程池和进程池的写法几乎一样，只不过线程池是<code>ThreadPoolExecutor</code>，进程池是<code>ProcessPoolExecutor</code></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>存放固定数量的线程，由线程池分配任务</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建线程池</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">50</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            t.submit(fn, name=<span class="string">f&quot;线程<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 等待线程池中的任务全部执行完毕. 才继续执行(守护)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>例2：使用的库不同，方法也不同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 导入线程池模块对应的类</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool</span><br><span class="line"><span class="comment"># 使用线程池方式执行</span></span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在下载 ：&quot;</span>, <span class="built_in">str</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;下载成功：&#x27;</span>, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name_list = [<span class="string">&#x27;xiaozi&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个线程池对象</span></span><br><span class="line">pool = Pool(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 将列表中每一个列表元素传递给get_page进行处理。</span></span><br><span class="line">pool.<span class="built_in">map</span>(get_page, name_list)</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br><span class="line">end_time = time.time()</span><br><span class="line"><span class="built_in">print</span>(end_time - start_time)</span><br></pre></td></tr></table></figure>



<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建进程池</span></span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(<span class="number">50</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            t.submit(fn, name=<span class="string">f&quot;线程<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 等待进程池中的任务全部执行完毕. 才继续执行(守护)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>协程</title>
    <url>/07%20%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<p>协程的用法</p>
<span id="more"></span>

<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>宏观上是多线程，微观上是单线程，对CPU的利用率高。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫赛利亚&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    g = func()  <span class="comment"># 此时的函数是异步协程函数. 此时函数执行得到的是一个协程对象</span></span><br><span class="line">    <span class="comment"># print(g)</span></span><br><span class="line">    asyncio.run(g)  <span class="comment"># 协程程序运行需要asyncio模块的支持</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;正在请求的url是&#x27;</span>, url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;请求成功,&#x27;</span>, url)</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># async修饰的函数，调用之后返回的一个协程对象</span></span><br><span class="line">c = request(<span class="string">&#x27;www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个事件循环对象</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将协程对象注册到loop中，然后启动loop</span></span><br><span class="line">loop.run_until_complete(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # task的使用</span></span><br><span class="line"><span class="comment"># loop = asyncio.get_event_loop()</span></span><br><span class="line"><span class="comment"># task = loop.create_task(c) # 基于loop创建了一个task对象</span></span><br><span class="line"><span class="comment"># print(task)</span></span><br><span class="line"><span class="comment"># loop.run_until_complete(task)</span></span><br><span class="line"><span class="comment"># print(task)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # future的使用</span></span><br><span class="line"><span class="comment"># loop = asyncio.get_event_loop()</span></span><br><span class="line"><span class="comment"># task = asyncio.ensure_future(c)</span></span><br><span class="line"><span class="comment"># print(task)</span></span><br><span class="line"><span class="comment"># loop.run_until_complete(task)</span></span><br><span class="line"><span class="comment"># print(task.result())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback_func</span>(<span class="params">task</span>):</span></span><br><span class="line">    <span class="comment"># result返回的就是任务对象中封装的协程对象对应函数的返回值</span></span><br><span class="line">    <span class="built_in">print</span>(task.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定回调</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = asyncio.ensure_future(c)</span><br><span class="line"><span class="comment"># 将回调函数绑定到任务对象中</span></span><br><span class="line">task.add_done_callback(callback_func)</span><br><span class="line">loop.run_until_complete(task)</span><br></pre></td></tr></table></figure>





<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫潘金莲&quot;</span>)</span><br><span class="line">    <span class="comment"># time.sleep(3)  # 当程序出现了同步操作的时候. 异步就中断了</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)  <span class="comment"># 异步操作的代码</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫潘金莲&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;func1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫王建国&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫王建国&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;func2&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func3</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫李雪琴&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫李雪琴&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;func3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法一：</span></span><br><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="comment">#     f1 = func1()</span></span><br><span class="line"><span class="comment">#     f2 = func2()</span></span><br><span class="line"><span class="comment">#     f3 = func3()</span></span><br><span class="line"><span class="comment">#     tasks = [</span></span><br><span class="line"><span class="comment">#         f1, f2, f3</span></span><br><span class="line"><span class="comment">#     ]</span></span><br><span class="line"><span class="comment">#     t1 = time.time()</span></span><br><span class="line"><span class="comment">#     # 一次性启动多个任务(协程)</span></span><br><span class="line"><span class="comment">#     asyncio.run(asyncio.wait(tasks))</span></span><br><span class="line"><span class="comment">#     t2 = time.time()</span></span><br><span class="line"><span class="comment">#     print(t2 - t1)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 写法二：    </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 第一种写法</span></span><br><span class="line">    <span class="comment"># f1 = func1()</span></span><br><span class="line">    <span class="comment"># await f1  # 一般await挂起操作放在协程对象前面</span></span><br><span class="line">    <span class="comment"># 第二种写法(推荐)</span></span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.create_task(func1()),  <span class="comment"># py3.8以后加上asyncio.create_task()</span></span><br><span class="line">        asyncio.create_task(func2()),</span><br><span class="line">        asyncio.create_task(func3())</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line">    <span class="comment"># 协程输出返回值</span></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        <span class="built_in">print</span>(task.result())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;main&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    <span class="comment"># 一次性启动多个任务(协程)</span></span><br><span class="line">    text = asyncio.run(main())</span><br><span class="line">    <span class="built_in">print</span>(text)</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    <span class="built_in">print</span>(t2 - t1)    </span><br></pre></td></tr></table></figure>





<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;正在下载&#x27;</span>, url)</span><br><span class="line">    <span class="comment"># 在异步协程中如果出现了同步模块相关的代码，那么就无法实现异步。</span></span><br><span class="line">    <span class="comment"># time.sleep(2)</span></span><br><span class="line">    <span class="comment"># 当在asyncio中遇到阻塞操作必须进行手动挂起</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;下载完毕&#x27;</span>, url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">urls = [<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;www.sogou.com&#x27;</span>, <span class="string">&#x27;www.goubanjia.com&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务列表：存放多个任务对象</span></span><br><span class="line">stasks = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">    c = request(url)</span><br><span class="line">    task = asyncio.ensure_future(c)</span><br><span class="line">    stasks.append(task)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 需要将任务列表封装到wait中</span></span><br><span class="line">loop.run_until_complete(asyncio.wait(stasks))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.time() - start)</span><br></pre></td></tr></table></figure>





<p>多任务协程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;正在下载&#x27;</span>, url)</span><br><span class="line">    <span class="comment"># 在异步协程中如果出现了同步模块相关的代码，那么就无法实现异步。</span></span><br><span class="line">    <span class="comment"># time.sleep(2)</span></span><br><span class="line">    <span class="comment"># 当在asyncio中遇到阻塞操作必须进行手动挂起</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;下载完毕&#x27;</span>, url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">urls = [<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;www.sogou.com&#x27;</span>, <span class="string">&#x27;www.goubanjia.com&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务列表：存放多个任务对象</span></span><br><span class="line">stasks = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">    c = request(url)</span><br><span class="line">    task = asyncio.ensure_future(c)</span><br><span class="line">    stasks.append(task)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 需要将任务列表封装到wait中</span></span><br><span class="line">loop.run_until_complete(asyncio.wait(stasks))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.time() - start)</span><br></pre></td></tr></table></figure>



<h3 id="aiohttp模块"><a href="#aiohttp模块" class="headerlink" title="aiohttp模块"></a>aiohttp模块</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&quot;http://kr.shanghai-jiuxin.com/file/2020/1031/191468637cab2f0206f7d1d9b175ac81.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://kr.shanghai-jiuxin.com/file/2020/1031/563337d07af599a9ea64e620729f367e.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://kr.shanghai-jiuxin.com/file/2020/1031/774218be86d832f359637ab120eba52d.jpg&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">aiodownload</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 发送请求.</span></span><br><span class="line">    <span class="comment"># 得到图片内容</span></span><br><span class="line">    <span class="comment"># 保存到文件</span></span><br><span class="line">    name = url.rsplit(<span class="string">&quot;/&quot;</span>, <span class="number">1</span>)[<span class="number">1</span>]  <span class="comment"># 从右边切, 切一次. 得到[1]位置的内容</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:  <span class="comment"># requests</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:  <span class="comment"># resp = requests.get()</span></span><br><span class="line">            <span class="comment"># 请求回来了. 写入文件</span></span><br><span class="line">            <span class="comment"># 可以自己去学习一个模块, aiofiles</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(name, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:  <span class="comment"># 创建文件</span></span><br><span class="line">                f.write(<span class="keyword">await</span> resp.content.read())  <span class="comment"># 读取内容是异步的. 需要await挂起, resp.text()</span></span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&quot;搞定&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        tasks.append(aiodownload(url))</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>



<h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><p>asyncio模块<br>python asyncio获取协程返回值和使用callback   <a href="https://www.cnblogs.com/callyblog/p/11216961.html">https://www.cnblogs.com/callyblog/p/11216961.html</a></p>
<p>aiohttp模块</p>
<p>学习链接  <a href="https://www.cnblogs.com/lymmurrain/p/13805690.html">https://www.cnblogs.com/lymmurrain/p/13805690.html</a></p>
<p>aiohttp中拿文本    resp.text改成resp.text()</p>
<p>resp.content改成    resp.content.read()</p>
<p>代理，请求头 见下面的ssl 错误     博客链接<a href="https://blog.csdn.net/qq_43965708/article/details/109622238">https://blog.csdn.net/qq_43965708/article/details/109622238</a></p>
<p>sess.get(url=url, headers=headers, proxy=’<a href="http://xxx.xxx.xxx&/#39;">http://xxx.xxx.xxx&#39;</a>, proxy_auth=auto.proxy_auth) as res:</p>
<p>防止协程被封：降低爬取速度，或者使用多个代理ip</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">timeout = aiohttp.ClientTimeout(total=<span class="number">600</span>)  <span class="comment"># 将超时时间设置为600秒</span></span><br><span class="line">connector = aiohttp.TCPConnector(limit=<span class="number">50</span>)  <span class="comment"># 将并发数量降低</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(connector=connector, timeout=timeout) <span class="keyword">as</span> session:</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.request(<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">		<span class="string">&#x27;http://python.org/&#x27;</span>) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">assert</span> resp.status == <span class="number">200</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">await</span> resp.text())</span><br><span class="line"><span class="comment">#将协程放入时间循环        </span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(fetch()) </span><br></pre></td></tr></table></figure>



<p>Session 封装了一个<strong>连接池</strong>（<strong>连接器</strong>实例），并且默认情况下支持keepalive。除非在应用程序的生存期内连接到大量未知的不同服务器，否则建议您在应用程序的生存期内使用单个会话以受益于连接池。</p>
<p>不要为每个请求创建Session 。每个应用程序很可能需要一个会话，以完全执行所有请求。</p>
<p>更复杂的情况可能需要在每个站点上进行一次会话，例如，一个会话用于Github，另一个会话用于Facebook API。无论如何，为每个请求建立会话是一个<strong>非常糟糕的</strong>主意。</p>
<p>会话内部包含一个连接池。连接重用和保持活动状态（默认情况下均处于启用状态）可能会提高整体性能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment">#传入client使用</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">client,url</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> client.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">assert</span> resp.status == <span class="number">200</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> resp.text()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> client:</span><br><span class="line">        html = <span class="keyword">await</span> fetch(client,url)</span><br><span class="line">        <span class="built_in">print</span>(html)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p>aiohttp 指定 tls 版本 (ssl 错误)  <a href="https://blog.csdn.net/qq_31720329/article/details/82023393">https://blog.csdn.net/qq_31720329/article/details/82023393</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host www.mdnkids.com:443 ssl:&lt;ssl.SSLContext object at 0x1096634a8&gt; [None]</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> auto</span><br><span class="line">asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy()) <span class="comment"># 加上这一行</span></span><br><span class="line"><span class="comment"># proxy=auto.proxies, proxy_auth=auto.proxy_auth 这里的代理需要换成自己的</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">quest</span>(<span class="params">url,  headers</span>):</span></span><br><span class="line">    con = aiohttp.TCPConnector(ssl=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(connector=con, trust_env=<span class="literal">True</span>) <span class="keyword">as</span> sess: <span class="comment"># 加上trust_env=True</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> sess.get(url=url, headers=headers, proxy=auto.proxies, proxy_auth=auto.proxy_auth) <span class="keyword">as</span> res:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> res.read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forever</span>(<span class="params">loop</span>):</span></span><br><span class="line">    asyncio.set_event_loop(loop)</span><br><span class="line">    loop.run_forever()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) 		 Gecko/20100101 Firefox/79.0&#x27;</span>&#125;</span><br><span class="line">    url = <span class="string">&#x27;https://baidu.com&#x27;</span></span><br><span class="line"></span><br><span class="line">    loop = asyncio.new_event_loop()</span><br><span class="line">    t = threading.Thread(target=forever, args=(loop,))</span><br><span class="line">    t.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    ret = asyncio.run_coroutine_threadsafe(quest(url, headers), loop)</span><br><span class="line">    <span class="built_in">print</span>(ret.result())</span><br></pre></td></tr></table></figure>



<h3 id="爬取视频案例"><a href="#爬取视频案例" class="headerlink" title="爬取视频案例"></a>爬取视频案例</h3><p>可能以及运行不了了</p>
<p>![image-20220119112527357](07 协程/image-20220119112527357.png)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">思路:</span></span><br><span class="line"><span class="string">    1. 拿到主页面的页面源代码, 找到iframe</span></span><br><span class="line"><span class="string">    2. 从iframe的页面源代码中拿到m3u8文件的地址</span></span><br><span class="line"><span class="string">    3. 下载第一层m3u8文件 -&gt; 下载第二层m3u8文件(视频存放路径)</span></span><br><span class="line"><span class="string">    4. 下载视频</span></span><br><span class="line"><span class="string">    5. 下载秘钥, 进行解密操作</span></span><br><span class="line"><span class="string">    6. 合并所有ts文件为一个mp4文件</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> aiofiles</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  <span class="comment"># pycryptodome</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_iframe_src</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    main_page = BeautifulSoup(resp.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    src = main_page.find(<span class="string">&quot;iframe&quot;</span>).get(<span class="string">&quot;src&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> src</span><br><span class="line">    <span class="comment"># return &quot;https://boba.52kuyun.com/share/xfPs9NPHvYGhNzFp&quot;  # 为了测试</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_first_m3u8_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="comment"># print(resp.text)</span></span><br><span class="line">    obj = re.<span class="built_in">compile</span>(<span class="string">r&#x27;var main = &quot;(?P&lt;m3u8_url&gt;.*?)&quot;&#x27;</span>, re.S)</span><br><span class="line">    m3u8_url = obj.search(resp.text).group(<span class="string">&quot;m3u8_url&quot;</span>)</span><br><span class="line">    <span class="comment"># print(m3u8_url)</span></span><br><span class="line">    <span class="keyword">return</span> m3u8_url</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_m3u8_file</span>(<span class="params">url, name</span>):</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(name, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(resp.content)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_ts</span>(<span class="params">url, name, session</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">f&quot;video2/<span class="subst">&#123;name&#125;</span>&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">await</span> f.write(<span class="keyword">await</span> resp.content.read())  <span class="comment"># 把下载到的内容写入到文件中</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>下载完毕&quot;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">aio_download</span>(<span class="params">up_url</span>):</span>  <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/hls/</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:  <span class="comment"># 提前准备好session</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">&quot;越狱第一季第一集_second_m3u8.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># line就是xxxxx.ts</span></span><br><span class="line">                line = line.strip()  <span class="comment"># 去掉没用的空格和换行</span></span><br><span class="line">                <span class="comment"># 拼接真正的ts路径</span></span><br><span class="line">                ts_url = up_url + line</span><br><span class="line">                task = asyncio.create_task(download_ts(ts_url, line, session))  <span class="comment"># 创建任务</span></span><br><span class="line">                tasks.append(task)</span><br><span class="line">            <span class="keyword">await</span> asyncio.wait(tasks)  <span class="comment"># 等待任务结束</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> resp.text</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">dec_ts</span>(<span class="params">name, key</span>):</span></span><br><span class="line">    aes = AES.new(key=key, IV=<span class="string">b&quot;0000000000000000&quot;</span>, mode=AES.MODE_CBC)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">f&quot;video2/<span class="subst">&#123;name&#125;</span>&quot;</span>, mode=<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f1,\</span><br><span class="line">        aiofiles.<span class="built_in">open</span>(<span class="string">f&quot;video2/temp_<span class="subst">&#123;name&#125;</span>&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">        bs = <span class="keyword">await</span> f1.read()  <span class="comment"># 从源文件读取内容</span></span><br><span class="line">        <span class="keyword">await</span> f2.write(aes.decrypt(bs))  <span class="comment"># 把解密好的内容写入文件</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>处理完毕&quot;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">aio_dec</span>(<span class="params">key</span>):</span></span><br><span class="line">    <span class="comment"># 解密</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">&quot;越狱第一季第一集_second_m3u8.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            line = line.strip()</span><br><span class="line">            <span class="comment"># 开始创建异步任务</span></span><br><span class="line">            task = asyncio.create_task(dec_ts(line, key))</span><br><span class="line">            tasks.append(task)</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_ts</span>():</span></span><br><span class="line">    <span class="comment"># mac: cat 1.ts 2.ts 3.ts &gt; xxx.mp4</span></span><br><span class="line">    <span class="comment"># windows: copy /b 1.ts+2.ts+3.ts xxx.mp4</span></span><br><span class="line">    lst = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;越狱第一季第一集_second_m3u8.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            line = line.strip()</span><br><span class="line">            lst.append(<span class="string">f&quot;video2/temp_<span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br><span class="line">    s = <span class="string">&quot; &quot;</span>.join(lst)  <span class="comment"># 1.ts 2.ts 3.ts</span></span><br><span class="line">    os.system(<span class="string">f&quot;cat <span class="subst">&#123;s&#125;</span> &gt; movie.mp4&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;搞定!&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 1. 拿到主页面的页面源代码, 找到iframe对应的url</span></span><br><span class="line">    iframe_src = get_iframe_src(url)</span><br><span class="line">    <span class="comment"># 2. 拿到第一层的m3u8文件的下载地址</span></span><br><span class="line">    first_m3u8_url = get_first_m3u8_url(iframe_src)</span><br><span class="line">    <span class="comment"># 拿到iframe的域名</span></span><br><span class="line">    <span class="comment"># &quot;https://boba.52kuyun.com/share/xfPs9NPHvYGhNzFp&quot;</span></span><br><span class="line">    iframe_domain = iframe_src.split(<span class="string">&quot;/share&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 拼接出真正的m3u8的下载路径</span></span><br><span class="line">    first_m3u8_url = iframe_domain+first_m3u8_url</span><br><span class="line">    <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/index.m3u8?sign=548ae366a075f0f9e7c76af215aa18e1</span></span><br><span class="line">    <span class="comment"># print(first_m3u8_url)</span></span><br><span class="line">    <span class="comment"># 3.1 下载第一层m3u8文件</span></span><br><span class="line">    download_m3u8_file(first_m3u8_url, <span class="string">&quot;越狱第一季第一集_first_m3u8.txt&quot;</span>)</span><br><span class="line">    <span class="comment"># 3.2 下载第二层m3u8文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;越狱第一季第一集_first_m3u8.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                line = line.strip()  <span class="comment"># 去掉空白或者换行符  hls/index.m3u8</span></span><br><span class="line">                <span class="comment"># 准备拼接第二层m3u8的下载路径</span></span><br><span class="line">                <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/ + hls/index.m3u8</span></span><br><span class="line">                <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/hls/index.m3u8</span></span><br><span class="line">                <span class="comment"># https://boba.52kuyun.com/20170906/Moh2l9zV/hls/cFN8o3436000.ts</span></span><br><span class="line">                second_m3u8_url = first_m3u8_url.split(<span class="string">&quot;index.m3u8&quot;</span>)[<span class="number">0</span>] + line</span><br><span class="line">                download_m3u8_file(second_m3u8_url, <span class="string">&quot;越狱第一季第一集_second_m3u8.txt&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;m3u8文件下载完毕&quot;</span>)</span><br><span class="line">    <span class="comment"># 4. 下载视频</span></span><br><span class="line">    second_m3u8_url_up = second_m3u8_url.replace(<span class="string">&quot;index.m3u8&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="comment"># 异步协程</span></span><br><span class="line">    asyncio.run(aio_download(second_m3u8_url_up))  <span class="comment"># 测试的使用可以注释掉</span></span><br><span class="line">    <span class="comment"># 5.1 拿到秘钥</span></span><br><span class="line">    key_url = second_m3u8_url_up + <span class="string">&quot;key.key&quot;</span>  <span class="comment"># 偷懒写法, 正常应该去m3u8文件里去找</span></span><br><span class="line">    key = get_key(key_url)</span><br><span class="line">    <span class="comment"># 5.2 解密</span></span><br><span class="line">    asyncio.run(aio_dec(key))</span><br><span class="line">    <span class="comment"># 6. 合并ts文件为mp4文件</span></span><br><span class="line">    merge_ts()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url = <span class="string">&quot;https://www.91kanju.com/vod-play/541-2-1.html&quot;</span></span><br><span class="line">    main(url)</span><br><span class="line">    <span class="comment"># 简单的问题复杂化, 复杂的问题简单化</span></span><br><span class="line">    <span class="comment"># 秒杀()</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库定义和数据更新</title>
    <url>/1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89%E5%92%8C%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>mysql的安装和配置，mysql一些基本命令，数据库和表的创建、修改、删除，数据的导入</p>
<span id="more"></span>

<p><strong>菜鸟教程学习链接：</strong></p>
<p>&ensp;&ensp;<a href="https://www.runoob.com/MySQL/MySQL-tutorial.html">https://www.runoob.com/MySQL/MySQL-tutorial.html</a></p>
<h2 id="MySQL安装："><a href="#MySQL安装：" class="headerlink" title="MySQL安装："></a>MySQL安装：</h2><ul>
<li>zip压缩包安装：<a href="https://blog.csdn.net/a802976/article/details/119255644">https://blog.csdn.net/a802976/article/details/119255644</a></li>
<li>msi安装程序安装：<a href="https://blog.csdn.net/zqh529/article/details/114734950">https://blog.csdn.net/zqh529/article/details/114734950</a><br><img src="/1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89%E5%92%8C%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0/20211211173551.png" alt="msi安装会遇到的选项" title="msi安装会遇到的选项"></li>
</ul>
<h2 id="MySQL配置："><a href="#MySQL配置：" class="headerlink" title="MySQL配置："></a>MySQL配置：</h2><h3 id="启动和停止MySQL服务（cmd-exe管理员运行）"><a href="#启动和停止MySQL服务（cmd-exe管理员运行）" class="headerlink" title="启动和停止MySQL服务（cmd.exe管理员运行）"></a>启动和停止MySQL服务（cmd.exe管理员运行）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">net <span class="keyword">start</span> mysql</span><br><span class="line">net stop mysql</span><br></pre></td></tr></table></figure>

<h3 id="登录MySQL数据库"><a href="#登录MySQL数据库" class="headerlink" title="登录MySQL数据库"></a>登录MySQL数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u root –p</span><br></pre></td></tr></table></figure>
<p>输入密码即可出现欢迎界面</p>
<h3 id="设置MySQL字符集"><a href="#设置MySQL字符集" class="headerlink" title="设置MySQL字符集"></a>设置MySQL字符集</h3><p>为了让MySQL数据库能够支持中文，必须设置系统字符集编码。</p>
<p>输入命令查看当前联接系统的参数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> ‘<span class="type">char</span><span class="operator">%</span>’ ;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> ‘<span class="keyword">collation</span><span class="operator">%</span>’;</span><br></pre></td></tr></table></figure>
<p>输入命令将数据库和服务器的字符集均设为gbk：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> CHARACTER_SET_DATABASE<span class="operator">=</span> ‘gbk’ ;</span><br><span class="line"><span class="keyword">SET</span> CHARACTER_SET_SERVER<span class="operator">=</span> ‘gbk’ ;</span><br></pre></td></tr></table></figure>
<p>输入命令查看状态：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">STATUS;</span><br></pre></td></tr></table></figure>

<h2 id="MySQL命令说明"><a href="#MySQL命令说明" class="headerlink" title="MySQL命令说明"></a>MySQL命令说明</h2><p>在描述命令格式时，用[ ]表示可选项</p>
<p>MySQL命令不区分大小写，为了读者阅读方便，在描述命令格式和<br>命令实例时，命令关键字用大写表示，其他用小写表示。但在实际对<br>MySQL操作时为了避免大小写频繁切换，一般都用小写。</p>
<p>命令关键字可以只写前面4个字符。<br><code>DESCRIBE user;</code>与 <code>DESC user;</code> 效果是一样的。</p>
<p>在MySQL中，服务器处理语句的时候是以分号为结束标志的。<br>使用<code>DELIMITER</code>命令可以将MySQL语句的结束标志修改为其他符号。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*以\\结束*/</span></span><br><span class="line">DELTMITER \\</span><br></pre></td></tr></table></figure>
<h2 id="MySQL命令"><a href="#MySQL命令" class="headerlink" title="MySQL命令"></a>MySQL命令</h2><p>查看MySQL系统的已有的数据库，输入命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure>
<p>创建一个测试数据库，输入命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE myTest;</span><br></pre></td></tr></table></figure>
<p>进入某个数据库，切换数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE database_name;</span><br></pre></td></tr></table></figure>
<p>查看当前数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> database();</span><br></pre></td></tr></table></figure>
<p>显示当前数据库中所有表的名称:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> tables;</span><br><span class="line"><span class="comment">/*显示指定数据库的所有表名称*/</span></span><br><span class="line"><span class="keyword">SHOW</span> tables <span class="keyword">from</span> database_name;</span><br></pre></td></tr></table></figure>
<p>显示创建基本表的语句：（即创建这个基本表时所用的语句）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">create</span> <span class="keyword">table</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*此方法用处很多*/</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database db_name;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 数据库.触发器名;</span><br></pre></td></tr></table></figure>
<p>显示表中所有列名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在选择进入了某个数据库之后，可以不指定数据库名称，否则按后两行格式来写*/</span></span><br><span class="line"><span class="keyword">SHOW</span> columns <span class="keyword">from</span> table_name;	</span><br><span class="line"><span class="keyword">SHOW</span> columns <span class="keyword">from</span> table_name <span class="keyword">from</span> database_name;</span><br><span class="line"><span class="keyword">SHOW</span> columns <span class="keyword">from</span> database_name.table_name;</span><br></pre></td></tr></table></figure>
<p>显示一个用户的权限：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> user_name;</span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> root<span class="variable">@localhost</span>;</span><br></pre></td></tr></table></figure>
<p>显示一些系统特定资源的信息，例如，正在运行的线程数量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> status;</span><br></pre></td></tr></table></figure>
<p>显示系统变量的名称和值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> variables;</span><br><span class="line"><span class="comment">/*可以用like缩小范围或精确变量*/</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><code>DESCRIBE</code>语句用于显示表中各列的信息，语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&#123;<span class="keyword">DESCRIBE</span> <span class="operator">|</span> <span class="keyword">DESC</span>&#125; 表名 [列名 <span class="operator">|</span> wild];</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>explain table_name\G</code>来显示表信息</p>
<h3 id="创建数据库："><a href="#创建数据库：" class="headerlink" title="创建数据库："></a>创建数据库：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 [选项...];</span><br><span class="line"><span class="comment">/*选项如下*/</span></span><br><span class="line">[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集</span><br><span class="line">[<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span> 校对规则名</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE DBST</span><br><span class="line"><span class="type">CHARACTER</span> <span class="keyword">SET</span> gbk</span><br><span class="line"><span class="keyword">COLLATE</span> gbk_chinese_ci;</span><br></pre></td></tr></table></figure>

<h3 id="修改数据库："><a href="#修改数据库：" class="headerlink" title="修改数据库："></a>修改数据库：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE [数据库名] 选项... ;</span><br><span class="line">选项：</span><br><span class="line">[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集名</span><br><span class="line">[<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span> 校对规则名</span><br></pre></td></tr></table></figure>
<h3 id="删除数据库："><a href="#删除数据库：" class="headerlink" title="删除数据库："></a>删除数据库：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] database_name;</span><br></pre></td></tr></table></figure>

<p><font color="#FF0000"> 注：</font>除列名区分大小写，数据库名、表名等，以及<code>create</code>、<code>delete</code>等既可大写也可小写</p>
<h3 id="创建表（全新创建）"><a href="#创建表（全新创建）" class="headerlink" title="创建表（全新创建）"></a>创建表（全新创建）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] table_name</span><br><span class="line">[([列定义]...<span class="operator">|</span>[表索引定义])]</span><br><span class="line">[表选项][<span class="keyword">select</span>语句];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">IF NOT EXISTS：在创建表前加上一个判断，只有该表目前尚不存在时才执行CREATE TABLE操作</span></span><br><span class="line"><span class="comment">列定义格式：名称 类型 属性</span></span><br><span class="line"><span class="comment">表索引项定义：主要定义表的索引、主键、外键等</span></span><br><span class="line"><span class="comment">select语句：用于在一个已有表的基础上创建表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*简单例子*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student</span><br><span class="line">(</span><br><span class="line">studentkey <span class="type">char</span>(<span class="number">6</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">name <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">major <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">null</span>,</span><br><span class="line">gender tinyint(<span class="number">1</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">birth <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">totalcredit tinyint(<span class="number">1</span>) <span class="keyword">null</span>,</span><br><span class="line">comment <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employee` (</span><br><span class="line">  `employeeID` <span class="type">char</span>(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `education` <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `birth` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gender` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  `workYear` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `address` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone` <span class="type">char</span>(<span class="number">12</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `departmentID` <span class="type">char</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`employeeID`),</span><br><span class="line">  KEY `on_employee` (`name`,`address`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>gbk;</span><br></pre></td></tr></table></figure>

<h3 id="创建表（复制现成的表）"><a href="#创建表（复制现成的表）" class="headerlink" title="创建表（复制现成的表）"></a>创建表（复制现成的表）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] table_name</span><br><span class="line">[() <span class="keyword">LIKE</span> 已有表名 [ ] <span class="operator">|</span> [<span class="keyword">AS</span> (表达式)];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例1*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_copy1 <span class="keyword">LIKE</span> student; </span><br><span class="line"><span class="comment">/*例2*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_copy2 <span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student);</span><br></pre></td></tr></table></figure>

<h3 id="修改表："><a href="#修改表：" class="headerlink" title="修改表："></a>修改表：</h3><p>ALTER TABLE用于更改原有表的结构。例如，可以增加（删减）列、创建（取消）索引、更改原有列的类型、重新命名列或表，还可以更改表的评注和表的类型。语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> [IGNORE] <span class="keyword">TABLE</span> table_name 选项...;</span><br><span class="line">选项：</span><br><span class="line"><span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] 列定义 [<span class="keyword">FIRST</span> <span class="operator">|</span> AFTER 列名]    <span class="comment">/*添加列*/</span></span><br><span class="line"><span class="keyword">ALTER</span> [<span class="keyword">COLUMN</span>] 列名 &#123;<span class="keyword">SET</span> <span class="keyword">DEFAULT</span> iteral <span class="operator">|</span> <span class="keyword">DROP</span> <span class="keyword">DEFAULT</span>&#125; <span class="comment">/*修改默认值*/</span></span><br><span class="line">CHANGE [<span class="keyword">COLUMN</span>] 列名 原列名 [<span class="keyword">FIRST</span> <span class="operator">|</span> AFTER 列名]    <span class="comment">/*列名重定义*/</span></span><br><span class="line">MODIFY [<span class="keyword">COLUMN</span>] 列定义 [<span class="keyword">FIRST</span> <span class="operator">|</span> AFTER 列名] <span class="comment">/*修改列数据类型*/</span></span><br><span class="line"><span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>] 列名                         <span class="comment">/*删除列*/</span></span><br><span class="line">RENAME [<span class="keyword">TO</span>] 新表名                         <span class="comment">/*重命名该表*/</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名                              <span class="comment">/*排序*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student</span><br><span class="line"><span class="keyword">ADD</span> scholarship tinyint(<span class="number">1</span>) <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>直接修改表名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> 旧表名 <span class="keyword">TO</span> 新表名 ...;</span><br></pre></td></tr></table></figure>

<h3 id="删除表："><a href="#删除表：" class="headerlink" title="删除表："></a>删除表：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>]</span><br></pre></td></tr></table></figure>

<h3 id="从文件中导入数据至表中"><a href="#从文件中导入数据至表中" class="headerlink" title="从文件中导入数据至表中"></a>从文件中导入数据至表中</h3><p><font color="#FF0000">  注意：</font><br> 后面向表中导入本地文件所存储的数据时，文件需完整路径名，且文件路径名不能有中文和空格，路径用/不能用\。谨慎避坑。</p>
<p>同时导入数据可能遇到</p>
<p><code>The MySQL server is running with the --secure-file-priv option so it cannot execute</code></p>
<p>需要如下修改my.ini文件<br>在mysql安装文件夹下的my.ini文件中修改或添加以下内容，之后重启mysql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">secure_file_priv=&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>secure-file-priv的值有三种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">secure_file_prive=null ––限制mysqld 不允许导入导出</span><br><span class="line">secure_file_priv=/path/ – --限制mysqld的导入导出只能发生在默认的/path/目录下</span><br><span class="line">secure_file_priv=&#x27;&#x27; – --不对mysqld 的导入 导出做限制</span><br></pre></td></tr></table></figure>
<p>详情见：<a href="https://blog.csdn.net/weixin_44595372/article/details/88723191">https://blog.csdn.net/weixin_44595372/article/details/88723191</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*想在table中导入csv文件中的data*/</span></span><br><span class="line">LOAD DATA INFILE <span class="string">&#x27;D:/XXX/XXX/XXX.csv&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="type">CHARACTER</span> <span class="keyword">SET</span> gbk</span><br><span class="line">FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">LINES TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">[(col_name,col_name,.....)];</span><br></pre></td></tr></table></figure>

<h3 id="插入记录（全新记录）"><a href="#插入记录（全新记录）" class="headerlink" title="插入记录（全新记录）"></a>插入记录（全新记录）</h3><p>插入一个全新记录到表里面，使用INSERT命令，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [LOW_PRIORITY <span class="operator">|</span> DELAYED <span class="operator">|</span> HIGH_PRIORITY] </span><br><span class="line">[IGNORE] [<span class="keyword">INTO</span>] 表名 [(列名,...)]</span><br><span class="line"><span class="keyword">VALUES</span> (&#123;expr <span class="operator">|</span> <span class="keyword">DEFAULT</span>&#125;,...),</span><br><span class="line"><span class="operator">|</span> <span class="keyword">SET</span> 列名<span class="operator">=</span>&#123;expr <span class="operator">|</span> <span class="keyword">DEFAULT</span>&#125;, ...</span><br><span class="line">[ <span class="keyword">ON</span> DUPLICATE KEY UPDATE 列名<span class="operator">=</span>expr, ... ];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例：注意 除数字外，字符串需要用&#x27;&#x27;合起来*/</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;081101&#x27;</span>,<span class="string">&#x27;王林&#x27;</span>,<span class="string">&#x27;计算机&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1994-02-10&#x27;</span>,<span class="number">50</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(studentkey,name)</span><br><span class="line"><span class="keyword">values</span>(<span class="string">&#x27;00001&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>),(<span class="string">&#x27;0002&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="插入记录（已有记录）"><a href="#插入记录（已有记录）" class="headerlink" title="插入记录（已有记录）"></a>插入记录（已有记录）</h3><p>从已有表中选择记录到当前表中，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [LOW_PRIORITY <span class="operator">|</span> HIGH_PRIORITY] [IGNORE] [<span class="keyword">INTO</span>] </span><br><span class="line">表名 [(列名,...)]</span><br><span class="line"><span class="keyword">SELECT</span>语句</span><br><span class="line">[ <span class="keyword">ON</span> DUPLICATE KEY UPDATE 列名<span class="operator">=</span>expr, ... ];</span><br><span class="line"><span class="comment">/*注：若有primary key冲突，可以用replace命令*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user1</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
<h3 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h3><p>修改基本表中的记录，使用UPDATE命令，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE [LOW_PRIORITY] [IGNORE] 表名</span><br><span class="line"><span class="keyword">SET</span> 列名<span class="number">1</span><span class="operator">=</span>expr1 [, 列名<span class="number">2</span><span class="operator">=</span>expr2 ...]</span><br><span class="line">[<span class="keyword">WHERE</span> 条件]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</span><br><span class="line">[LIMIT row_count];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line">UPDATE student</span><br><span class="line"><span class="keyword">SET</span> totalcredit<span class="operator">=</span>totalcreadit<span class="operator">+</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><p>删除基本表中的记录，使用DELETE命令，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> [LOW_PRIORITY] [QUICK] [IGNORE] <span class="keyword">FROM</span> 表名</span><br><span class="line">[<span class="keyword">WHERE</span> 条件]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</span><br><span class="line">[LIMIT row_count];</span><br><span class="line"><span class="comment">/*注：*/</span></span><br><span class="line"><span class="comment">/*清除所有记录，下面两语句任选其一*/</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*删除表table*/</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*向表中插入数据*/</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLE_NAME</span><br><span class="line">[(col_name,col_name,.....)]</span><br><span class="line"><span class="keyword">VALUES</span>(xx,<span class="string">&#x27;xx&#x27;</span>,.....)</span><br><span class="line"><span class="comment">/*从其他表中插入数据到另一个表中*/</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLE_NAME</span><br><span class="line">[(col_name,col_name,.....)]</span><br><span class="line"><span class="keyword">SELECT</span> [<span class="operator">*</span><span class="operator">|</span>col_name,col_name,...]</span><br><span class="line"><span class="keyword">FROM</span> table_nam</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理概论</title>
    <url>/1%E3%80%81%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<p>编译原理 第一部分</p>
<span id="more"></span> 

<h2 id="翻译程序（Translator）"><a href="#翻译程序（Translator）" class="headerlink" title="翻译程序（Translator）"></a>翻译程序（Translator）</h2><p>将源程序译成逻辑上等价的目标程序的程序。翻译程序有二种工作方式：编译和解释</p>
<h3 id="解释方式-Interpret"><a href="#解释方式-Interpret" class="headerlink" title="解释方式 ( Interpret )"></a>解释方式 ( Interpret )</h3><p>以源程序作为输入，输入一句解释执行一句，不产生完整的目标程序，相应的翻译程序称为解释程序(Interpreter) </p>
 <img src="/1%E3%80%81%E6%A6%82%E8%AE%BA/image-20220102142837260.png" alt="image-20220102142837260" style="zoom:80%;">

<p>解释方式主要特点是：用户程序是消极的。用户程序运行时，控制点在解释程序，即用户程序的执行离不开解释程序。</p>
<h3 id="编译方式-Compile"><a href="#编译方式-Compile" class="headerlink" title="编译方式 ( Compile )"></a>编译方式 ( Compile )</h3><p>将源程序全部译为目标程序，该目标程序可在操作系统环境下直接执行，相应的翻译程序称为编译程序(Compiler) </p>
<img src="/1%E3%80%81%E6%A6%82%E8%AE%BA/image-20220102143329383.png" alt="image-20220102143329383" style="zoom: 80%;">

<ul>
<li>编辑程序的工作结果是ASCII码形式的源程序。</li>
<li>编译程序以ASCII码形式的源程序为输入，它的工作结果是二进制形式的目标程序，但并未包括用户程序中所使用的系统函数的目标代码。从整体上来看，程序是不完整的，程序中的部分地址尚未确定（例系统函数的调用）。</li>
<li>将二进制形式的用户程序和系统函数目标代码连接成一个程序，对未确定的地址进行定位。</li>
<li>由操作系统将用户程序装入内存后运行。程序在运行过程中读入数据，经处理加工后输出计算结果。</li>
</ul>
<p> 编译方式主要特点是：用户程序是积极的。用户程序执行时，控制点在用户程序自身。除操作系统外，程序运行无需其它支撑软件。</p>
<h3 id="二种翻译方式比较"><a href="#二种翻译方式比较" class="headerlink" title="二种翻译方式比较"></a>二种翻译方式比较</h3><p> 解释方式和编译方式的主要区别是：目标代码的执行方式不同，基本原理和方法没有本质上的区别。<br>1）解释方式的优点</p>
<ul>
<li><p>提供一种直接的交互调试功能，容易获得较好的动态调试效果。</p>
</li>
<li><p>使用变量可不预先定义。</p>
</li>
<li><p>变量性质可动态修改。<br>2）解释方式的缺点</p>
</li>
<li><p>在执行时需动态地对程序进行分析翻译，开销大，其执行速度相当于编译方式的1/10至1/100。</p>
</li>
<li><p>解释方式占用内存大</p>
</li>
</ul>
<p>显然解释程序的优点就是编译程序的缺点，反之亦然，对于编译程序的优缺点不再重复叙述。</p>
<p>对任何一种高级语言，既可采用编译方式，也可采用解释方式，包括汇编语言在内（MASM方式和DEBUG方式）</p>
<h3 id="几种程序介绍"><a href="#几种程序介绍" class="headerlink" title="几种程序介绍"></a>几种程序介绍</h3><p>【翻译程序】将源语言程序转换为目标语言程序的等价的程序称为翻译程序。</p>
<p>【编译程序】将高级语言源程序翻译为低级语言目标程序的程序称为编译程序。</p>
<p>  编译程序的意义：使得多数计算机用户不必考虑与机器有关的繁琐细节，使程序员和程序专家独立于机器。</p>
<p>【汇编程序】将汇编语言源程序翻译为机器语言目标程序的程序称为汇编程序。</p>
<p>【反汇编程序】将机器语言源程序翻译为汇编语言目标程序的程序称为反汇编程序。</p>
<h3 id="编译程序与解释程序的异同"><a href="#编译程序与解释程序的异同" class="headerlink" title="编译程序与解释程序的异同"></a>编译程序与解释程序的异同</h3><p>高级语言有两种翻译途径：==编译与解释==。</p>
<p>它们的主要区别在于==是否产生目标程序==。</p>
<p>解释程序不产生目标程序，而是边解释边执行源程序本身，是一种“会话型”语言。（如python）</p>
<h3 id="高级语言程序的处理过程"><a href="#高级语言程序的处理过程" class="headerlink" title="高级语言程序的处理过程"></a>高级语言程序的处理过程</h3><img src="/1%E3%80%81%E6%A6%82%E8%AE%BA/image-20220102144639527.png" alt="image-20220102144639527" style="zoom:80%;">

<h3 id="编译程序的5个阶段"><a href="#编译程序的5个阶段" class="headerlink" title="编译程序的5个阶段"></a>编译程序的5个阶段</h3><p>1、词法分析</p>
<blockquote>
<p>任务：从左至右读字符流的源程序，识别(拼)单词。<br>【单词】单词是具有独立意义的最小语法单位。<br>多数程序语言中，单词符号一般包括 —各类型的常数、保留字、标识符、运算符、界符等等。<br>识别原则：词法规则<br>描述工具：正规式<br>                  正规文法<br>                  有穷自动机FA<br>自动生成工具：LEX</p>
</blockquote>
<p>2、语法分析</p>
<blockquote>
<p>任务：依据源程序的语法规则把源程序的单词序列组成更大的语法成分——“组词成句” (表示成语法树) 。<br>识别原则：语法规则<br>描述工具：上下文无关文法<br>                    下推自动机PDA<br>自动生成工具：YACC</p>
</blockquote>
<p>3、语义分析与中间代码生成</p>
<blockquote>
<p>任务：对语法分析所识别出的各类语法范畴，分析其含义，并进行初步翻译（产生中间代码）。<br>语义审查(静态语义)：上下文相关性、类型匹配、类型转换<br>识别原则：语义规则<br>描述工具：属性文法<br>实现方法：语法制导翻译</p>
<p>【中间代码】 是一种含义明确、便于处理的记号系统，它通常独立于具体的硬件。这种记号系统或者与现代计算机的指令形式有某种程度的接近，或者能够比较容易地把它变换成现代计算机的机器指令。<br>    许多编译程序采用了一种与“三地址指令”非常近似的“四元式”作为中间代码，其形式是：<br>    (算符 , 运算对象1 , 运算对象2 , 结果)<br>    常用的中间代码有：四元式，三元式，间接三元式，逆波兰记号和树形表示等等。</p>
</blockquote>
<p>4、代码优化</p>
<blockquote>
<p>任务：对前段产生的中间代码进行加工变换，以期在最后阶段能产生出更为高效（省时间和空间）的目标代码。<br>主要包括：公共子表达式的提取<br>                    循环优化<br>                    删除无用代码等等<br>优化所依循的原则：程序的等价变换规则。</p>
</blockquote>
<p>5、目标代码生成</p>
<blockquote>
<p>任务：把中间代码（或经优化处理之后）变换成特定机器上的低级语言代码。<br>生成原则：硬件系统结构和机器指令含义。<br>目标代码的形式：<br>        绝对指令代码<br>        可重定位的指令代码<br>        汇编指令代码   </p>
</blockquote>
<p>编译程序的另外两个重要的工作是==表格管理==和==出错处理==。</p>
<blockquote>
<p>编译过程中源程序的各种信息被保留在种种不同的表格里，编译各阶段的工作都涉及到构造、查找或更新有关的表格，因此需要有表格管理的工作；</p>
<p>如果编译过程中发现源程序有错误，编译程序应报告错误的性质和错误发生的地点，并且将错误所造成的影响限制在尽可能小的范围内，使得源程序的其余部分能继续被编译下去，有些编译程序还能自动校正错误，这些工作称之为出错处理。</p>
</blockquote>
<h3 id="符号表管理"><a href="#符号表管理" class="headerlink" title="符号表管理"></a>符号表管理</h3><p>符号表 </p>
<ul>
<li><p>记录源程序中使用的名字</p>
</li>
<li><p>收集每个名字的各种属性信息：类型、作用域、分配存储信息</p>
</li>
</ul>
<p>符号表是由若干记录组成的数据结构，每个标识符在表中有一条记录，每条记录有多个域，每个域记载标识符的一个属性。例如下面一条记录说明标识符aaa是整型变量及分配的内存地址</p>
<table>
<thead>
<tr>
<th>标识符名</th>
<th>标识符类型</th>
<th>类型</th>
<th align="center">地址</th>
</tr>
</thead>
<tbody><tr>
<td>aaa</td>
<td>1（表示变量）</td>
<td>1（表示整型）</td>
<td align="center">0001</td>
</tr>
</tbody></table>
<p>标识符的各种属性是在编译的不同阶段填入符号表的。词法分析阶段只能分析出标识符名，语法分析阶段只能判断标识符在语句中出现是否合法，只有到了语义分析阶段，才能将标识符的各种属性填入符号表并使用这些属性生成中间代码。 </p>
<h3 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h3><p>出错处理程序的任务包括 检查错误、报告出错信息、排错、恢复编译工作。</p>
<h3 id="编译程序的组成"><a href="#编译程序的组成" class="headerlink" title="编译程序的组成"></a>编译程序的组成</h3><p>词法分析程序、语法分析程序、语义分析程序、中间代码生成程序、代码优化程序、目标代码生成程序、表格管理程序和出错处理程序</p>
<img src="/1%E3%80%81%E6%A6%82%E8%AE%BA/image-20220102150408304.png" alt="image-20220102150408304" style="zoom:80%;">

<h3 id="遍（pass）"><a href="#遍（pass）" class="headerlink" title="遍（pass）"></a>遍（pass）</h3><p>【遍】就是对源程序或源程序的中间结果从头到尾扫描一次，并作有关的加工处理，生成新的中间结果或目标程序。<br>Turbo C是一遍完成编译，以及预处理和后续处理。<br>两遍编译：</p>
<ul>
<li>1.进行词法分析、语法分析、语义分析，生成中间代码作为文件保留，以及符号表文件。</li>
<li>2.优化后生成目标代码作为文件保留。</li>
</ul>
<p>三遍编译：</p>
<ul>
<li>3.对目标代码的优化。</li>
</ul>
<h3 id="编译程序涉及的三种语言"><a href="#编译程序涉及的三种语言" class="headerlink" title="编译程序涉及的三种语言"></a>编译程序涉及的三种语言</h3><p>【源语言】要深刻理解源语言(如 FORTRAN、Pascal或 C)结构(语法)和含义(语义)；<br>【目标语言】最终的目标语言还是机器语言，则必须搞清楚硬件的系统结构和操作系统的功能；<br>【宿主语言】编写编译程序的语言。自编译程序：宿主语言是源语言。例如PASCAL</p>
<h3 id="编译程序的生成"><a href="#编译程序的生成" class="headerlink" title="编译程序的生成"></a>编译程序的生成</h3><ul>
<li>手工<ul>
<li>机器语言</li>
<li>汇编</li>
<li>系统程序设计语言，自编译，移植，交叉编译等方式</li>
</ul>
</li>
<li>自动构造工具：lex  yacc</li>
</ul>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>文法和语言</title>
    <url>/2%E3%80%81%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>编译原理    第二部分</p>
<p>文法，推导/归约；</p>
<p>句型，句子，语言；</p>
<p>文法的类型，正规文法，上下文无关文法，文法等价；</p>
<p>语法树与二义性</p>
<span id="more"></span> 

<h3 id="程序设计语言的描述"><a href="#程序设计语言的描述" class="headerlink" title="程序设计语言的描述"></a>程序设计语言的描述</h3><ul>
<li>语法(Syntax):涉及语言的构成规律，即程序的结构或形式；</li>
<li>语义(Semantics): 指语言所代表的含义；</li>
<li>语用(Pragmatics): 涉及到实际应用。</li>
</ul>
<h3 id="程序设计语言的形式描述"><a href="#程序设计语言的形式描述" class="headerlink" title="程序设计语言的形式描述"></a>程序设计语言的形式描述</h3><p>不考虑语义和语用，即只从语法这一侧面来看语言，这种意义下的语言称作==形式语言==</p>
<p>“形式”是指：语言的所有规则只以什麽符号串能出现的方式来陈述。形式语言理论是对符号串集合的表示法、结构及其特性的研究。是程序设计语言语法分析研究的基础。</p>
<h3 id="形式语言"><a href="#形式语言" class="headerlink" title="形式语言"></a>形式语言</h3><h4 id="符号和符号串"><a href="#符号和符号串" class="headerlink" title="符号和符号串"></a>符号和符号串</h4><p>【字母表】有穷非空符号（元素）集。用大写字母表示。</p>
<p>【符号】可以相互区别的记号（元素）。用小写字母或数字</p>
<p>【符号串】由字母表中的符号组成的任何有穷序列称为该字母表上的符号串。简称为串、行</p>
<p>【空串】不含任何符号的串。用 ε 表示</p>
<h4 id="符号串和符号串集合的运算"><a href="#符号串和符号串集合的运算" class="headerlink" title="符号串和符号串集合的运算"></a>符号串和符号串集合的运算</h4><p>【长度】符号串中符号的个数。串β的长度记为|β |。特别地有：|ε| ＝0</p>
<p>【连接】串x、y的连接,是把y的符号写在x的符号之后得到的符号串xy 。记为xy 或x·y 。特别地有：εx = xε = x</p>
<p>【串的方幂】串x自身连接n次。记为$x^n$。特别的有 $x^0=ε$</p>
<p>【积】设A、B为两个符号串集合，其乘积A·B是x∈A且y∈B的所有符号串xy构成的集合。记为AB或A·B。即AB＝｛xy | x∈A，y∈B｝。特别地有：｛ε｝A＝A｛ε｝＝A</p>
<p>注意：ε，｛ε｝，$\emptyset$ 三者之间的区别</p>
<p>【集合的方幂】设A为符号串集合，则串集合A的幂运算<br>递归定义如下：$ A^0＝｛ε｝, $ $A^n ＝AA ……AA ＝A^{n－1}A ＝AA^{n－1} （n＞0）$</p>
<p>【闭包】设A为符号串集合，则串集合A的闭包表示为$A^*$，定义为：$$A^*＝A^0∪A^1∪…… ∪ A^k ∪ ……$$</p>
<p>【正闭包】串集合A的正闭包表示为$A^+$，定义为：$$A^＋＝A^1∪A^2∪…… ∪ A^k ∪ ……$$</p>
<p>具有以下性质：$$A^<em>＝A^0∪A^＋ , A^＋＝AA^</em>＝A^*A$$</p>
<p>==形式语言==是一个字母表上按某种规则构成的所有符号串的集合。</p>
<ul>
<li><p>字母表∑， $∑^*$包含由∑上符号构成的所有符号串</p>
</li>
<li><p>∑上每个语言是$∑^*$ 的一个子集</p>
</li>
<li><p>∑上按某种规则构成的符号串称为句子</p>
</li>
</ul>
<h4 id="如何来描述一种语言"><a href="#如何来描述一种语言" class="headerlink" title="如何来描述一种语言"></a>如何来描述一种语言</h4><blockquote>
<p>如果语言是有穷的（只含有有穷多个句子），可以将句子逐一枚举出来表示;<br>如果语言是无穷的，找出语言的有穷表示。语言的有穷表示有两个途经：</p>
<ul>
<li>生成方式 （文法）：语言中的每个句子可以用严格定义的规则来构造。</li>
<li>识别方式（自动机）：用一个过程，当输入的一任意串属于语言时，该过程经有限次计算后就会停止并回答“是”，若不属于，要么能停止并回答“不是”，（要么永远继续下去。）</li>
</ul>
</blockquote>
<h3 id="文法的形式定义"><a href="#文法的形式定义" class="headerlink" title="文法的形式定义"></a>文法的形式定义</h3><p>【非终结符号】一系列需要定义的语法成分，即规则中用尖括号括起来的，由它们可推出其它句子成分。例如：＜主语＞，＜谓语＞ 等。</p>
<p>【终结符号】若干基本符号，是组成句子的最基本符号。例如：张三，是，学生。</p>
<p>【产生式】一组产生句子的规则：P→α 或 P ::＝α</p>
<p>【开始符号】语言中的句子只能从它开始推导。 ＜句子＞是开始符号，是语言的目标，而其它语法成分只是构造语言目标时的中间变量。</p>
<h4 id="文法定义"><a href="#文法定义" class="headerlink" title="文法定义"></a>文法定义</h4><p><font color="#ff0000">文法定义</font>为四元组 $G＝(V_N，V_T，P，S )$。其中：</p>
<p>$V_N$为非终结符号(或语法实体，或变量)集；</p>
<p>$V_T$为终结符号集；$ V_N ∩ V_T = \emptyset$，通常用$V$表示$V_N ∪ V_T$，称为文法$G$的字母表；</p>
<p>$P$为产生式或规则$（α→β或α∷=β）$的集合， 其中$α∈V^+$，且 $α$ 中至少要包含一个非终结符，$β∈V^*$</p>
<p>$S$是识别符号或开始符号，它是一个非终结符，至少要在一条产生式中作为左部出现。</p>
<h4 id="产生式"><a href="#产生式" class="headerlink" title="产生式"></a>产生式</h4><p>规则，也称重写规则、产生式或生成式，是形如：<br>         $$ α→β  或  α∷=β$$<br>   的$(α，β)$有序对，其中$α$是字汇表$V$的正闭包$V^+$中的一个符号$(即α∈V^+)$， $β$中至少要包含一个非终结符，是$V^*$中的一个符号$(即β∈V^*)$。<br>α称为产生式的左部，β称作产生式的右部（候选式）</p>
<h4 id="文法的多种写法"><a href="#文法的多种写法" class="headerlink" title="文法的多种写法"></a>文法的多种写法</h4><img src="/2%E3%80%81%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/image-20220102161207938.png" alt="image-20220102161207938" style="zoom:80%;">



<img src="/2%E3%80%81%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/image-20220102161237577.png" alt="image-20220102161237577" style="zoom: 67%;">

<h4 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h4><p>元符号：$\rightarrow \ ::= \ | $</p>
<p>习惯表示：  大写字母：非终结符      小写字母：终结符</p>
<h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><p>直接推导 $\Rightarrow$  给定文法$G=（V_N，V_T，P，S）$，如果$α→β$是文法$G$的产生式，若有$v,w$满足：$v=γαδ,w= γβδ$, 其中 $γ∈V^*,δ∈V^* $, 则称$v$直接推导到$w$,记作 $v \Rightarrow w$, 也称$w$直接归约到$v$</p>
<p>多步推导</p>
<p>$\stackrel{+}{\Rightarrow}$  若存在$v\Rightarrow w_0 \Rightarrow w_1 \Rightarrow … \Rightarrow w_n=w,(n&gt;0)$则记为$v \stackrel{+}{\Rightarrow} w$，$v$推导出$w$，或$w$归约到$v$</p>
<p>$\stackrel{<em>}{\Rightarrow}$  若有$v \stackrel{+}{\Rightarrow} w$，或v=w，则记为$v \stackrel{</em>}{\Rightarrow} w $</p>
<p>【最左推导】如果在推导每一步过程中总是考虑对句型中最左的非终结符进行替换，则称这种推导为最左推导。</p>
<p>【最右推导】如果在推导每一步过程中总是考虑对句型中最右的非终结符进行替换，则称这种推导为最右推导。</p>
<p>【规范推导】即最右推导。</p>
<p>【规范句型】由规范推导推导出的句型。</p>
<h3 id="句型和句子"><a href="#句型和句子" class="headerlink" title="句型和句子"></a>句型和句子</h3><p>【句型】若$S\stackrel{*}{\Rightarrow} α $，则称$α$是文法$G$的句型。</p>
<p>【句子】若$S\stackrel{<em>}{\Rightarrow} α $，且$α∈V_T^</em>$，则称$α$是文法$G$的句子。(即仅含终结符的句型称为句子)</p>
<h3 id="语言的形式定义"><a href="#语言的形式定义" class="headerlink" title="语言的形式定义"></a>语言的形式定义</h3><p>文法$G$所描述的全部句子的集合称为语言，记为$L(G)$。</p>
<p>即 $L(G)={α|S \stackrel {<em>}{\Rightarrow}  α，$ 其中S为文法的开始符号，且$α∈V_T^</em>$}</p>
<p>【文法等价】若$L(G1)=L(G2)$ ，则称文法$G1和G2$是等价的。</p>
<p>注意：属于$V_T^*$的符号串，不一定属于$L(G)$,即$L(G)$是$V_T^*$的子集，故$L(G)$是定义于字母表$V_T$上的。</p>
<p><font color="#ff0000">文法与语言的关系不是一对一的关系</font></p>
<h3 id="由文法推导出语言"><a href="#由文法推导出语言" class="headerlink" title="由文法推导出语言"></a>由文法推导出语言</h3><p><img src="/2%E3%80%81%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/image-20220102170506838.png" alt="image-20220102170506838"></p>
<h3 id="文法与语言的分类"><a href="#文法与语言的分类" class="headerlink" title="文法与语言的分类"></a>文法与语言的分类</h3><h4 id="0型文法（短语文法）"><a href="#0型文法（短语文法）" class="headerlink" title="0型文法（短语文法）"></a>0型文法（短语文法）</h4><p>$产生式α→β中α∈ (V_N∪V_T)^+,且至少含有一个非终结符，而β∈(V_N∪V_T)^*。$</p>
<p>0型文法对应的语言称为0型语言。​</p>
<p>0型文法对应的自动机称为图灵机(Turing)。</p>
<h4 id="1型文法（上下文有关文法）"><a href="#1型文法（上下文有关文法）" class="headerlink" title="1型文法（上下文有关文法）"></a>1型文法（上下文有关文法）</h4><p>$产生式 α→β 中 |α|≤ |β| $  </p>
<p>等价定义为：<br>        对于产生式$α_1Aα_2 → α_1 β α_2(β≠ ε， α1与α2不同时为ε)$，当用$β$替换$A$时，只能在上下文为$α_1$和$α_2$时才可进行 。</p>
<p>1型文法对应的语言称为1型语言（上下文有关语言）</p>
<p>1型文法对应的自动机是线性界限自动机</p>
<h4 id="2型文法（上下文无关文法）"><a href="#2型文法（上下文无关文法）" class="headerlink" title="2型文法（上下文无关文法）"></a>2型文法（上下文无关文法）</h4><p>$产生式A→β，都有A∈V_N ， β∈(V_N∪V_T)^*$</p>
<p>2型文法对应的语言称为2型语言（上下文无关语言）</p>
<p>2型文法对应的自动机是下推自动机。</p>
<p>上下文无关文法用来描述高级语言的语法规则。</p>
<h4 id="3型文法（正规文法）"><a href="#3型文法（正规文法）" class="headerlink" title="3型文法（正规文法）"></a>3型文法（正规文法）</h4><p>右线性文法： $A→aB或A→a$<br>左线性文法： $A→Ba或A→a$<br>其中，$A、B ∈V_N ，a ∈V_T $。</p>
<p>3型文法对应的语言称为3型语言(正规集)</p>
<p>3型文法对应的自动机是有穷自动机。</p>
<p>正规文法用来描述高级语言的词法规则。</p>
<h4 id="四种文法之间是逐级包含的"><a href="#四种文法之间是逐级包含的" class="headerlink" title="四种文法之间是逐级包含的"></a>四种文法之间是逐级包含的</h4><p>四个文法类的定义是逐渐增加限制的，因此每一种正规文法都是上下文无关的，每一种上下文无关文法都是上下文有关的，而每一种上下文有关文法都是0型文法。</p>
<h3 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h3><p>设文法$G=(V_N ，V_T ，P，S)$下的语法树具有以下特征：</p>
<p>1.根结点是S；</p>
<p>2.每个结点上的$标记符∈V＝V_N∪V_T$ ；</p>
<p>3.若一结点$A$至少有一个后代，则有$A∈V_N$ ；</p>
<p>4.若一棵子树的根结点标记为$A$,且其所有直接后代结点从左向右排列的顺序分别为$A_1，A_2，…，A_k，$则$A→A_1A_2…A_k∈P$。</p>
<p>5.若树的所有叶子上的标记从左向右排列为串$ω$，则$ω$是$G$的句型；若$ω$中仅含终结符，则它是$G$所产生的句子</p>
<p>从左到右读出叶子的标记而构成的串是该语法树识别的句子</p>
<p>推导过程（最左推导，最右推导，一般推导）不同，语法树的生长过程也不同，但最终生成的语法树完全相同</p>
<h3 id="文法的二义性"><a href="#文法的二义性" class="headerlink" title="文法的二义性"></a>文法的二义性</h3><p>若文法$G$中存在某个句子对应两棵不同的语法树，则称该文法具有二义性。<br>或者，若文法$G$中存在某个句子有两个不同的最左（右）推导，则称该文法具有二义性。</p>
<p>注意：判定任给的一个上下文无关文法是否具有二义性，或它是否产生一个先天二义性的上下文无关语言，这两个问题是递归不可解的，但可以为无二义性寻找一组充分条件。</p>
<p>二义性的解决办法有两个：</p>
<ul>
<li><p>根据提出的条件修改编译算法</p>
</li>
<li><p>根据预先提出的条件直接修改文法</p>
</li>
</ul>
<p>如果产生上下文无关语言的每一个文法都是二义性的，则说此语言是先天二义性的。对于一个程序设计语言来说，常常希望它的文法是无二义性的，因为希望对它的每个语句的分析是唯一的。</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据查询和视图</title>
    <url>/2%E3%80%81%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<p>单表查询、分组统计查询和连接查询，视图的创建，删除等</p>
<span id="more"></span>

<hr>
<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p>关系运算</p>
<ul>
<li>选择运算(Selection)</li>
<li>投影运算(Projection)</li>
<li>连接运算(Join)<ul>
<li>等值连接</li>
<li>自然连接</li>
</ul>
</li>
</ul>
<h3 id="Select-语句，SQL核心，语法格式如下："><a href="#Select-语句，SQL核心，语法格式如下：" class="headerlink" title="Select 语句，SQL核心，语法格式如下："></a>Select 语句，SQL核心，语法格式如下：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> <span class="operator">|</span> DISTINCTROW ][HIGH_PRIORITY]...</span><br><span class="line">列名表达式 …</span><br><span class="line">[<span class="keyword">FROM</span> table_reference ... ]     <span class="comment">/*FROM子句*/</span></span><br><span class="line">[<span class="keyword">WHERE</span> 条件]                    <span class="comment">/*WHERE子句*/</span></span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;列名<span class="operator">|</span> 表达式 <span class="operator">|</span> position&#125; [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>], ... [<span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>]]</span><br><span class="line"><span class="comment">/*GROUP BY子句*/</span></span><br><span class="line">[<span class="keyword">HAVING</span> 条件]                   <span class="comment">/*HAVING 子句*/</span></span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;列名 <span class="operator">|</span> 表达式 <span class="operator">|</span> position&#125; [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>] , ...]</span><br><span class="line"><span class="comment">/*ORDER BY子句*/</span></span><br><span class="line">[LIMIT &#123;[<span class="keyword">offset</span>,] row_count<span class="operator">|</span>row_count <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;];  <span class="comment">/*LIMIT子句*/</span></span><br></pre></td></tr></table></figure>

<h3 id="聚合函数，通常与GROUP-BY子句一起使用："><a href="#聚合函数，通常与GROUP-BY子句一起使用：" class="headerlink" title="聚合函数，通常与GROUP BY子句一起使用："></a>聚合函数，通常与GROUP BY子句一起使用：</h3><table>
<thead>
<tr>
<th align="left">函 数 名</th>
<th align="left">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">COUNT</td>
<td align="left">求组中项数，返回int类型整数</td>
</tr>
<tr>
<td align="left">MAX</td>
<td align="left">求最大值</td>
</tr>
<tr>
<td align="left">MIN</td>
<td align="left">求最小值</td>
</tr>
<tr>
<td align="left">SUM</td>
<td align="left">返回表达式中所有值的和</td>
</tr>
<tr>
<td align="left">AVG</td>
<td align="left">求组中值的平均值</td>
</tr>
<tr>
<td align="left">STD或STDDEV</td>
<td align="left">返回给定表达式中所有值的标准差</td>
</tr>
<tr>
<td align="left">VARIANCE</td>
<td align="left">返回给定表达式中所有值的方差</td>
</tr>
<tr>
<td align="left">GROUP_CONCAT</td>
<td align="left">返回由属于一组的列值连接组合而成的结果</td>
</tr>
<tr>
<td align="left">BIT_AND</td>
<td align="left">逻辑或</td>
</tr>
<tr>
<td align="left">BIT_OR</td>
<td align="left">逻辑与</td>
</tr>
<tr>
<td align="left">BIT_XOR</td>
<td align="left">逻辑异或</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*下面都是例子例*/</span></span><br><span class="line"><span class="keyword">SELECT</span> name, major, totalcredit <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">/*聚合函数，查询学生总人数*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> `total student number` <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">/*聚合函数，查询选修101课程的学生的最高分和最低分*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">max</span>(<span class="keyword">result</span>), <span class="built_in">min</span>(<span class="keyword">result</span>) <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> coursekey<span class="operator">=</span><span class="string">&#x27;101&#x27;</span>;</span><br><span class="line"><span class="comment">/*聚合函数，查询选修101课程的学生的平均成绩*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">avg</span>(<span class="keyword">result</span>) <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> coursekey<span class="operator">=</span><span class="string">&#x27;101&#x27;</span>;</span><br><span class="line"><span class="comment">/*全连接，查找DBST中所有学生选过的课程名和课程号*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> course.name, score.coursekey </span><br><span class="line"><span class="keyword">FROM</span> course, score </span><br><span class="line"><span class="keyword">WHERE</span> course.coursekey<span class="operator">=</span>score.coursekey;</span><br><span class="line"><span class="comment">/*JOIN连接，查找选修了206课程且成绩在80分以上的学生姓名及成绩*/</span></span><br><span class="line"><span class="keyword">SELECT</span> name, <span class="keyword">result</span> </span><br><span class="line"><span class="keyword">FROM</span> student </span><br><span class="line"><span class="keyword">JOIN</span> score </span><br><span class="line"><span class="keyword">ON</span> student.studentkey<span class="operator">=</span>score.studentkey </span><br><span class="line"><span class="keyword">WHERE</span> coursekey<span class="operator">=</span><span class="string">&#x27;206&#x27;</span> <span class="keyword">AND</span> <span class="keyword">result</span><span class="operator">&gt;=</span><span class="number">80</span>;</span><br><span class="line"><span class="comment">/*模式匹配，查找所有姓“王”的学生学号、姓名*/</span></span><br><span class="line"><span class="keyword">SELECT</span> studentkey, name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;王%&#x27;</span>;</span><br><span class="line"><span class="comment">/*GROUP BY子句，求DBST中各专业的学生数*/</span></span><br><span class="line"><span class="keyword">SELECT</span> major, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_student </span><br><span class="line"><span class="keyword">FROM</span> student </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> major;</span><br><span class="line"><span class="comment">/*HAVING子句，查找平均成绩在85分以上的学生的学号和平均成绩*/</span></span><br><span class="line"><span class="keyword">SELECT</span> studentkey, <span class="built_in">avg</span>(<span class="keyword">result</span>) <span class="keyword">AS</span> avg_result <span class="keyword">FROM</span> score </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> studentkey <span class="keyword">HAVING</span> <span class="built_in">avg</span>(<span class="keyword">result</span>)<span class="operator">&gt;=</span><span class="number">85</span>;</span><br><span class="line"><span class="comment">/*ORDER BY子句，将通信工程专业的学生按出生日期排序*/</span></span><br><span class="line"><span class="keyword">SELECT</span> studentkey, name, major, birth </span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> major<span class="operator">=</span><span class="string">&#x27;通信工程&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> birth;</span><br><span class="line"><span class="comment">/*LIMIT子句，查找student表中从第4位学生开始的5名学生信息*/</span></span><br><span class="line"><span class="keyword">SELECT</span> studentkey, name, major, gender, birth, totalcredit</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> studentkey LIMIT <span class="number">3</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="SQL查询语法要点"><a href="#SQL查询语法要点" class="headerlink" title="SQL查询语法要点"></a>SQL查询语法要点</h3><hr>
<h4 id="通配符-可以表示所有字段"><a href="#通配符-可以表示所有字段" class="headerlink" title="通配符 * 可以表示所有字段"></a><strong>通配符 * 可以表示所有字段</strong></h4><hr>
<h4 id="可以使用-数学表达式，列与列之间的运算"><a href="#可以使用-数学表达式，列与列之间的运算" class="headerlink" title="可以使用+ - * / 数学表达式，列与列之间的运算"></a><strong>可以使用+ - * / 数学表达式，列与列之间的运算</strong></h4><hr>
<h4 id="AS-别名"><a href="#AS-别名" class="headerlink" title="AS 别名"></a><strong>AS 别名</strong></h4><hr>
<h4 id="ORDER-BY-排序"><a href="#ORDER-BY-排序" class="headerlink" title="ORDER BY 排序"></a><strong>ORDER BY 排序</strong></h4><pre><code>默认升序ASC
降序  ORDER BY 字段 DESC,字段 DESC;
</code></pre>
<hr>
<h4 id="DISTINCT-去重"><a href="#DISTINCT-去重" class="headerlink" title="DISTINCT 去重"></a><strong>DISTINCT 去重</strong></h4><pre><code>需放在第一个字段名之前，否则报错
作用于后面跟着的所有字段      
</code></pre>
<hr>
<h4 id="WHERE-条件语句"><a href="#WHERE-条件语句" class="headerlink" title="WHERE + 条件语句"></a><strong>WHERE + 条件语句</strong></h4><table>
<thead>
<tr>
<th align="left"></th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">大于</td>
<td>&gt;</td>
</tr>
<tr>
<td align="left">小于</td>
<td>&lt;</td>
</tr>
<tr>
<td align="left">等于</td>
<td>=</td>
</tr>
<tr>
<td align="left">不等于</td>
<td>!= 或 &lt;&gt;</td>
</tr>
<tr>
<td align="left">大于等于</td>
<td>&gt;=</td>
</tr>
<tr>
<td align="left">小于等于</td>
<td>&lt;=</td>
</tr>
</tbody></table>
<hr>
<h4 id="多条件连接-AND-OR-NOT"><a href="#多条件连接-AND-OR-NOT" class="headerlink" title="多条件连接 AND  OR  NOT"></a><strong>多条件连接 AND  OR  NOT</strong></h4><p><code>WHERE age&gt;12 AND (gender=&#39;男&#39; OR gender=&#39;女&#39;)</code></p>
<hr>
<h4 id="BETWEEN…AND"><a href="#BETWEEN…AND" class="headerlink" title="BETWEEN…AND"></a><strong>BETWEEN…AND</strong></h4><p>范围条件，包括左右边界</p>
<p><code>WHERE birthday BETWEEN &#39;2001-01-01&#39; AND &#39;2021-12-31&#39;</code></p>
<hr>
<h4 id="IN"><a href="#IN" class="headerlink" title="IN"></a><strong>IN</strong></h4><p>满足X或Y或Z   IN(X,Y,Z)</p>
<p>eg: <code>WHERE province IN(&#39;四川省&#39;,&#39;重庆市&#39;)</code></p>
<hr>
<h4 id="NULL-缺失值-空"><a href="#NULL-缺失值-空" class="headerlink" title="NULL  缺失值 空"></a><strong>NULL  缺失值 空</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> phone_number <span class="operator">=</span> <span class="keyword">NULL</span>; <span class="comment">/*是错的*/</span></span><br><span class="line"><span class="keyword">WHERE</span> phone_number <span class="keyword">IS</span> <span class="keyword">NULL</span>  或  <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a><strong>LIKE</strong></h4><p>通配符%  零到任意数量个常规字符 </p>
<p>通配符_  一个常规字符</p>
<p>eg: <code>WHERE text LIKE &#39;%&lt;img&#39;</code></p>
<p>eg: <code>WHERE text LIKE &#39;_ary&#39;</code></p>
<hr>
<h4 id="五大聚类函数"><a href="#五大聚类函数" class="headerlink" title="五大聚类函数"></a><strong>五大聚类函数</strong></h4><ol>
<li><p>COUNT() </p>
<p> COUNT(*)统计所有行数，包括列中是NULL的行和重复的行</p>
<p> COUNT(X字段)统计X列中不为NULL的行数</p>
<p> COUNT(DISTINCT X)统计X列中不为NULL的行数，并去重</p>
</li>
<li><p>MAX()</p>
<p> eg: <code>SELECT account_id,MAX(total_price) AS max_price</code></p>
<p> MAX()找最大的数值或日期值</p>
<p> MAX()函数忽略列值为NULL的行</p>
<p> 在MySQL中，可以用于文本列字母排序的最高值</p>
</li>
<li><p>MIN()和MAX()类似</p>
</li>
<li><p>SUM()<br> 返回指定列值的和</p>
<p> 必须指定列名如：<code>SUM(total_price)</code></p>
<p> 忽略列值为NULL的行</p>
<p> eg: <code>SELECT SUM(total_price)/50000 AS ROI</code></p>
</li>
<li><p>AVG()<br> 计算数值列的平均值</p>
<p> 忽略列值为NULL的行</p>
<p> eg: <code>SELECT AVG(total_price) AS avg_price</code></p>
</li>
</ol>
<hr>
<h4 id="GROUP-BY-分组"><a href="#GROUP-BY-分组" class="headerlink" title="GROUP BY   分组"></a><strong>GROUP BY   分组</strong></h4><p><code>GROUP BY account_id;</code> 通过account_id分组</p>
<hr>
<h4 id="HAVING-条件语句"><a href="#HAVING-条件语句" class="headerlink" title="HAVING + 条件语句"></a><strong>HAVING + 条件语句</strong></h4><pre><code>对分组设置筛选条件
HAVING必须在GROUP BY之后使用
HAVING过滤组，WHERE过滤行
</code></pre>
<hr>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a><strong>子查询</strong></h4><p>子查询就是将一个查询（子查询）的结果作为另一个查询（主查询）的数据来源或判断条件的查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> account_2c</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> account_id</span><br><span class="line"><span class="keyword">FROM</span> address</span><br><span class="line"><span class="keyword">WHERE</span> city<span class="operator">=</span><span class="string">&#x27;成都市&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>ANY：子查询结果至少存在一个满足</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="keyword">ANY</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> salary</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;设计&#x27;</span>);</span><br><span class="line"><span class="comment">/*等价于*/</span></span><br><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;设计&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>ALL：子查询结果所有均要满足</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">SELECT</span> department</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="keyword">ALL</span>(</span><br><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;法务&#x27;</span>);</span><br><span class="line"><span class="comment">/*等价于*/</span></span><br><span class="line"><span class="keyword">SELECT</span> department</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary)</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;法务&#x27;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="内联结（连接）JOIN-ON"><a href="#内联结（连接）JOIN-ON" class="headerlink" title="内联结（连接）JOIN ON"></a><strong>内联结（连接）JOIN ON</strong></h4><p>INNER JOIN 内联结（INNER可省略)</p>
<p>ON 设定联结键的条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例：将商品名与品牌表的数据联结，并筛选出所有的商品编号、商品名、品牌名*/</span></span><br><span class="line"><span class="keyword">SELECT</span> c.id,sku_name,brand_name</span><br><span class="line"><span class="keyword">FROM</span> commodity <span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> brand <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> c.brand_id<span class="operator">=</span>b.id;</span><br><span class="line"><span class="comment">/*多表查询列名冲突时，表名限定列名*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="外联结（连接）"><a href="#外联结（连接）" class="headerlink" title="外联结（连接）"></a><strong>外联结（连接）</strong></h4><p>左外联结：LEFT JOIN</p>
<p>右外联结：RIGHT JOIN</p>
<p><img src="/2%E3%80%81%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%A7%86%E5%9B%BE/1639229747848.jpg" alt="多表连接查询"></p>
<hr>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a><strong>limit</strong></h4><p>limit 位置偏移量,行数;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> .. .. limit <span class="number">4</span>;   <span class="comment">/*取最后结果的前四行*/</span></span><br><span class="line"><span class="keyword">select</span> .. .. limit <span class="number">5</span>,<span class="number">4</span>; <span class="comment">/*最后结果的去掉前5行，再去4行*/</span>    </span><br></pre></td></tr></table></figure>
<hr>
<p>SQL书写顺序</p>
<p><img src="/2%E3%80%81%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%A7%86%E5%9B%BE/20211211215820.png" alt="SQL书写顺序"></p>
<p>SQL执行顺序</p>
<p><img src="/2%E3%80%81%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%A7%86%E5%9B%BE/20211211215856.png" alt="SQL执行顺序"></p>
<p>使用AS关键字时，执行顺序这一点会有体现，尤其注意！</p>
<hr>
<p>注：字符串加单引号’’，字段名即列名在特殊情况下用 `` (英文键盘下Tab上面的键)包裹</p>
<p>注：多个表连接时的格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> xxx</span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">join</span> table1_name</span><br><span class="line"><span class="keyword">on</span> 条件</span><br><span class="line"><span class="keyword">join</span> table2_name</span><br><span class="line"><span class="keyword">on</span> 条件</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="视图，数据库的外模式"><a href="#视图，数据库的外模式" class="headerlink" title="视图，数据库的外模式"></a>视图，数据库的外模式</h2><p>视图是一个虚拟表，非真实存在</p>
<p>视图在数据库中作为一个对象存储，视图一经定义以后，就可以像表一样被查询、修<br>改、删除和更新。使用视图有以下优点：</p>
<p><code>为用户集中数据</code>，简化用户的数据查询和处理。有时用户所需要的数据分散在多个表中，定义视图可将它们集中在一起，从而方便用户的数据查询和处理</p>
<p><code>屏蔽数据库的复杂性</code>。用户不必了解复杂的数据库中的表结构，并且数据库表的更改也不影响用户对数据库的使用</p>
<p><code>简化用户权限的管理</code>。只需授予用户使用视图的权限，而不必指定用只能使用表的特定列，也增加了安全性便于数据共享。各用户不必都定义和存储自己所需的数据，可共享数<br>据库的数据，这样同样的数据只需存储一次</p>
<p><code>可以重新组织数据以便输出到其他应用程序中</code></p>
<hr>
<h3 id="不可更新视图"><a href="#不可更新视图" class="headerlink" title="不可更新视图"></a>不可更新视图</h3><p>如果视图包含下述结构中的一种，则视图不可更新：</p>
<pre><code>（1）聚合函数；（2）DISTINCT关键字；（3）GROUP BY子句；
（4）ORDER BY子句；（5）HAVING子句；（6）UNION运算符；
（7）位于选择列表中的子查询；（8）FROM子句中包含多个表；
（9）SELECT语句中引用了不可更新视图；
（10）WHERE子句中的子查询，引用FROM子句中的表；
</code></pre>
<hr>
<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] [ALGORITHM <span class="operator">=</span> &#123;UNDEFINED <span class="operator">|</span> </span><br><span class="line"><span class="keyword">MERGE</span> <span class="operator">|</span> TEMPTABLE&#125;] [DEFINER <span class="operator">=</span> &#123; <span class="keyword">user</span> <span class="operator">|</span> <span class="built_in">CURRENT_USER</span> &#125;] </span><br><span class="line">[<span class="keyword">SQL</span> SECURITY &#123; DEFINER <span class="operator">|</span> INVOKER &#125;]</span><br><span class="line"><span class="keyword">VIEW</span> 视图名 [(列名 ... )]</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span>语句</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION];</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例1，创建计算机专业学生的成绩视图v_cs，包括学生学号、选修的课程号及成绩，要求对视图的修改符合专业名为“计算机”*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_cs <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> student.studentkey, coursekey, <span class="keyword">result</span> </span><br><span class="line"><span class="keyword">FROM</span> student, score </span><br><span class="line"><span class="keyword">WHERE</span> student.studentkey<span class="operator">=</span>score.studentkey <span class="keyword">AND</span> student.major<span class="operator">=</span><span class="string">&#x27;计算机&#x27;</span> </span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br><span class="line"><span class="comment">/*例2，创建DBST数据库上的计算机专业学生平均成绩视图v_cs_avg，包括学号(s_key)和平均成绩(avg_result)*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_cs_avg(s_key, avg_result) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> studentkey, <span class="built_in">avg</span>(<span class="keyword">result</span>) </span><br><span class="line"><span class="keyword">FROM</span> v_cs </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> studentkey;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>]</span><br><span class="line">view_name [,view_name]...</span><br><span class="line">[RESTRICT <span class="operator">|</span> CASCADE];</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="注意："><a href="#注意：" class="headerlink" title=" 注意："></a><font color="#ff0000"> 注意：</font></h3><p>视图的查询与表查询一样</p>
<p>可更新视图的更新与表更新一样</p>
<p>可更新视图简单点理解就是视图数据的来源只能是一张表上的全部或部分数据</p>
<p>可更新视图更新后，对应视图数据来源的表中的数据也会变化，即上例中v_cs的更新，score也会相应更新（from跟两个表，按理说v_cs不能更新的，但我测试却能更新成功，不知道是mysql的问题，还是说虽然跟着student，score两张表，但由于v_cs的数据来源于score，所以能更新？）</p>
<p> <img src="/2%E3%80%81%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%A7%86%E5%9B%BE/20211211235959.png" alt="更新v_cs视图"></p>
<p> 上图更新v_cs视图成功，但下图就指明 v_cs 是<code>join view</code>，不能删除，但却能更新，奇怪</p>
<p> <img src="/2%E3%80%81%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%A7%86%E5%9B%BE/20211212000030.png" alt="删除数据"></p>
<p>若视图 view1 数据来源于 表1、表2… 则 表1、表2…等表的数据更新会导致 view1 的数据一同更新；若还有视图 view2 的数据来源于 view1 ，则view2 也会跟着变化；<code>即表table的数据更新一定会导致对应视图view的更新，不论是可变或不可变视图，而可变视图的数据更新也会导致对应表数据的更新</code> </p>
<p>如果视图关联了一个表中的所有字段，而该表中添加了新字段，视图中是否能查询到新字段？<code>不能</code></p>
<p><img src="/2%E3%80%81%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%A7%86%E5%9B%BE/2021121200001.png"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>索引和完整性</title>
    <url>/3%E3%80%81%E7%B4%A2%E5%BC%95%E5%92%8C%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
    <content><![CDATA[<p>索引的创建，查看和删除；实体完整性和参照完整性</p>
<span id="more"></span>

<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>参考链接：<a href="https://www.cnblogs.com/whgk/p/6179612.html">https://www.cnblogs.com/whgk/p/6179612.html</a> 推荐</p>
<pre><code>索引是根据表中一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表。在列上创建了索引之后，查找数据时可以直接根据该列上的索引找到对应行的位置，从而快速地找到数据。
</code></pre>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>快速读取数据、提高检索效率</li>
<li>保证数据记录的唯一性</li>
<li>实现表与表之间的参照完整性</li>
</ul>
<p>有关数据库索引效率，可参考以下文章<a href="http://inter12.iteye.com/blog/1430144">http://inter12.iteye.com/blog/1430144</a></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="B-TREE索引"><a href="#B-TREE索引" class="headerlink" title="B-TREE索引"></a><code>B-TREE索引</code></h4><ul>
<li><p><code>普通索引(INDEX)</code>：最基本索引，没有唯一性限制</p>
</li>
<li><p><code>唯一性索引(UNIQUE)</code>：索引列的所有值只能出现一次</p>
</li>
<li><p><code>主键(PRIMARY KEY)</code>：创建表的时候指定，每个表只能有一个主键</p>
</li>
</ul>
<h4 id="HASH索引"><a href="#HASH索引" class="headerlink" title="HASH索引"></a><code>HASH索引</code></h4><p>（当表类型为MEMORY或HEAP时可用）</p>
<h4 id="R-TREE索引"><a href="#R-TREE索引" class="headerlink" title="R-TREE索引"></a><code>R-TREE索引</code></h4><p>MySQL支持对空间数据库进行R-TREE索引，参考以下文章<a href="https://yq.aliyun.com/articles/50625">https://yq.aliyun.com/articles/50625</a></p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>使用<code>CREATE INDEX</code>语句在已有表上创建索引，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT] INDEX 索引名 [索引类型] <span class="keyword">ON</span> 表</span><br><span class="line">名 (索引列名) [索引选项];</span><br></pre></td></tr></table></figure>
<p><code>索引列名＝列名[(长度)][ASC|DESC]</code></p>
<p><code>索引类型＝USING &#123;BTREE|HASH&#125;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例，根据student表中的studentkey字段，建议一个升序索引in_student*/</span></span><br><span class="line"><span class="keyword">create</span> index in_studnet <span class="keyword">on</span> student(studentkey <span class="keyword">asc</span>);</span><br></pre></td></tr></table></figure>

<p><code>注:</code>也可以使用<code>ALTER TABLE</code>在已有表上创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book</span><br><span class="line"><span class="keyword">ADD</span> INDEX BkNameIdx(bookname);</span><br></pre></td></tr></table></figure>


<p><code>创建表的时候创建索引</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名[字段名 数据类型]  </span><br><span class="line">[<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL<span class="operator">|</span>...] [INDEX<span class="operator">|</span>KEY] [索引名字](字段名[length]) 　</span><br><span class="line">[<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book</span><br><span class="line">(</span><br><span class="line">bookid <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">bookname <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">authors <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">info <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">comment <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NULL</span>,</span><br><span class="line">year_publication <span class="keyword">YEAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">INDEX(year_publication)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查看索引："><a href="#查看索引：" class="headerlink" title="查看索引："></a>查看索引：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> table_name\G;  <span class="comment">/*\G让格式更好看*/</span></span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>使用DROP INDEX语句删除索引，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX 索引名 <span class="keyword">ON</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">drop</span> index in_student <span class="keyword">on</span> student;</span><br></pre></td></tr></table></figure>

<p><code>注：</code>也可以用<code>ALTER TABLE</code>来删除索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例：删除主码*/</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure>

<h3 id="一些示例"><a href="#一些示例" class="headerlink" title="一些示例"></a>一些示例</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*创建唯一索引*/</span></span><br><span class="line"><span class="comment">/*在department表的departName字段上创建唯一性索引*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index by_name <span class="keyword">on</span> department(departName <span class="keyword">asc</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建复合索引*/</span></span><br><span class="line"><span class="comment">/*在employee表的name和address两个字段上创建一个复合索引*/</span></span><br><span class="line"><span class="keyword">create</span> index on_employee <span class="keyword">on</span> employee(name,address);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建hash索引*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmpEmployee</span><br><span class="line">(</span><br><span class="line">employeeID <span class="type">char</span>(<span class="number">6</span>),</span><br><span class="line">name <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">education <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">key <span class="keyword">using</span> hash(employeeID)</span><br><span class="line">)engine<span class="operator">=</span>memory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在已有表上创建主码*/</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">primary</span> key(studentkey);</span><br></pre></td></tr></table></figure>


<h2 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h2><p>定义主键约束</p>
<ul>
<li><p>列级实体完整性</p>
<p> 列定义时加上关键字 <code>PRIMARY KEY</code></p>
</li>
<li><p>表级实体完整性</p>
<p> 表定义时，在语句最后加上<code>PRIMARY KEY (col_name,…)</code></p>
</li>
</ul>
<p>定义替代键约束</p>
<ul>
<li>替代键是没有被选作主键的候选键，用<code>UNIQUE</code>来定义</li>
</ul>
<p><code>注：CONSTRAINT</code>可以用来指定表完整性约束的名字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> key_name <span class="keyword">PRIMARY</span> KEY(key)</span><br></pre></td></tr></table></figure>

<h3 id="创建表时定义实体完整性"><a href="#创建表时定义实体完整性" class="headerlink" title="创建表时定义实体完整性"></a>创建表时定义实体完整性</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*创建一个学生表student1，学号为主键，姓名为替代键*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student1</span><br><span class="line">(</span><br><span class="line">studentkey <span class="type">char</span>(<span class="number">6</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">name <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">birth <span class="type">date</span> <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(studentkey),</span><br><span class="line"><span class="keyword">UNIQUE</span>(name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="创建表后添加实体完整性"><a href="#创建表后添加实体完整性" class="headerlink" title="创建表后添加实体完整性"></a>创建表后添加实体完整性</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*创建表后添加实体完整性约束*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> key_name] <span class="keyword">PRIMARY</span> KEY(col_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例：添加主码*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(studentkey);</span><br></pre></td></tr></table></figure>

<h3 id="删除实体完整性"><a href="#删除实体完整性" class="headerlink" title="删除实体完整性"></a>删除实体完整性</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*删除表中的主码索引	[]内的内容表示可以加或不加*/</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">primary</span> key[(col_studentkey)];</span><br></pre></td></tr></table></figure>

<h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>创建表时定义参照完整性</p>
<ul>
<li><p>列级参照完整性<code>（不会生效，仅用于备注）</code></p>
<p> 列定义时加上关键字 <code>REFERENCES ref_table_name(ref_key)</code></p>
</li>
</ul>
<p>表级参照完整性</p>
<ul>
<li><p>表定义时，在语句最后加上</p>
<p> <code>CONSTRAINT ref_key_name FOREIGN KEY (ref_key)   REFERENCES ref_table_name(ref_key)</code></p>
</li>
</ul>
<p>创建表后定义参照完整性</p>
<ul>
<li>使用<code>ALTER TABLE</code>命令</li>
</ul>
<h3 id="参照性定义"><a href="#参照性定义" class="headerlink" title="参照性定义"></a>参照性定义</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">参照性定义<span class="operator">=</span>：</span><br><span class="line"></span><br><span class="line"><span class="keyword">REFERENCES</span> 表名 [(索引列名 ... )]</span><br><span class="line">[<span class="keyword">ON</span> <span class="keyword">DELETE</span> &#123;RESTRICT <span class="operator">|</span> CASCADE <span class="operator">|</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NO</span> ACTION&#125;]</span><br><span class="line">[<span class="keyword">ON</span> UPDATE &#123;RESTRICT <span class="operator">|</span> CASCADE <span class="operator">|</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NO</span> ACTION&#125;]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>索引列名=：</p>
<p>  <code>列名 [(长度)] [ASC | DESC]</code></p>
</li>
</ul>
<h3 id="参照动作"><a href="#参照动作" class="headerlink" title="参照动作"></a>参照动作</h3><p>指定这个参照动作应用哪一条语句：这里有两条相关的语句，即<code>UPDATE</code>和<code>DELETE</code>语句；</p>
<p>指定采取哪个动作：可能采取的动作是<code>RESTRICT、CASCADE、SET NULL、NO ACTION和SET DEFAULT</code></p>
<p>不同参照动作含义:</p>
<p><code>RESTRICT</code>：当要删除或更新父表中被参照列上在外键中出现的值时，拒绝对父表的删除或更新操作</p>
<p><code>CASCADE</code>：从父表删除或更新行时自动删除或更新子表中匹配的行</p>
<p><code>SET NULL</code>：当从父表删除或更新行时，设置子表中与之对应的外键列为NULL。如果外键列没有指定NOT NULL限定词，这就是合法的</p>
<p><code>NO ACTION</code>：NO ACTION意味着不采取动作，就是如果有一个相关的外键值在被参考的表里，删除或更新父表中主要键值的企图不被允许，和RESTRICT一样</p>
<p><code>SET DEFAULT</code>：作用和SET NULL一样，只不过SET DEFAULT是指定子表中的外键列为默认值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*创建学生表student1，以学生表student为参照，所有student1表中</span></span><br><span class="line"><span class="comment">的学生学号都必须来源于student表中*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student1</span><br><span class="line">(</span><br><span class="line">studentkey <span class="type">char</span>(<span class="number">6</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">name <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">birth <span class="type">date</span> <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(name),</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(studnetkey)</span><br><span class="line"><span class="keyword">REFERENCES</span> student(studentkey)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT</span><br><span class="line"><span class="keyword">ON</span> UPDATE RESTRICT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*创建表后追加表级参照完整性*/</span><br><span class="line">alter table student1</span><br><span class="line">add foreign key(studentkey)</span><br><span class="line">on delete cascade</span><br><span class="line">on update cascade;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>设置外键的时候需要注意以下几点：<br>（1）外键是用于两个表的数据之间建立连接，可以是一列或者多列，即一个表可以有一个或多个外键。</p>
<p>（2）这个表里面设置的外键必须是另外一个表的主键！</p>
<p>（3）外键可以不是这个表的主键，但必须和另外一个表的主键相对应（字段的类型和值必须一样）。</p>
<p>（4）带有主键的那张表称为父表，含外键的是子表，必须先删除外键约束才能删除父表。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>词法分析</title>
    <url>/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>这个人很懒，什么都没有写</p>
<p>编译原理    第三部分</p>
<span id="more"></span> 

<h3 id="词法分析的任务"><a href="#词法分析的任务" class="headerlink" title="词法分析的任务"></a>词法分析的任务</h3><p>从左到右逐个字符地对源程序进行扫描和分解，根据语言的词法规则识别出一个个的单词符号。</p>
<p>词法分析是编译的基础。执行词法分析的程序就是==词法分析器(扫描器)==，其功能是输入源程序，输出单词符号。</p>
<h4 id="词法分析程序"><a href="#词法分析程序" class="headerlink" title="词法分析程序"></a>词法分析程序</h4><p>主要任务</p>
<ul>
<li>从左至右扫描构成源程序的字符流</li>
<li>识别出有词法意义的单词</li>
<li>返回单词记录，或词法错误信息</li>
</ul>
<p>除以上主要任务外，常伴有如下任务:</p>
<blockquote>
<p>滤掉空格，跳过注释、换行符，追踪换行标志，复制出错源程序，宏展开，……<br>也可能包含访问符号表的操作等。</p>
</blockquote>
<p>与语法分析程序的接口方式</p>
<p>方式1：词法分析程序作为单独的程序，输入源程序，输出单词文件，提供给语法分析程序使用。</p>
<p>方式2：词法分析程序作为语法分析程序的子程序，提供给语法分析程序调用，不产生中间文件。</p>
<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220102223452200.png" alt="image-20220102223452200" style="zoom:80%;">

<h3 id="单词，分类，输出形式"><a href="#单词，分类，输出形式" class="headerlink" title="单词，分类，输出形式"></a>单词，分类，输出形式</h3><p>【单词】单词是语言中具有独立意义的最小语法单位。包括保留字、标识符、运算符、标点符号和常量等。</p>
<p>分类程序设计语言的单词符号一般可分成下列5种：</p>
<ul>
<li>关键字(基本字，保留字)：具有固定意义的标识符，如PASCAL语言中的begin,end,if和while等。</li>
<li>标识符:用来表示各种名字，如常量名、变量名和过程名等。</li>
<li>常数:各种类型的常数，如25，3.1415，TRUE和“ABC”等。</li>
<li>运算符:如+，*，&lt;=等。</li>
<li>界符:如逗点，分号，括号等。</li>
</ul>
<p>输出形式</p>
<blockquote>
<p>二元组表示：(单词种别，单词自身的值)</p>
<p>单词的种别表示单词的种类，它是语法分析需要的信息。通常的方法是让每种单词对应一个整数码，其目的是最大限度地把各个单词区别开来。<br>       关键字：一字一种；<br>       标识符：统一归为一种；<br>       常数：按类型（整型、实型、布尔型等）分种，一类一种；<br>       运算符和界符：一符一种。</p>
</blockquote>
<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220102225922957.png" alt="image-20220102225922957" style="zoom:80%;">

<h3 id="单词的描述工具："><a href="#单词的描述工具：" class="headerlink" title="单词的描述工具："></a>单词的描述工具：</h3><h4 id="正规文法"><a href="#正规文法" class="headerlink" title="正规文法"></a>正规文法</h4><blockquote>
<p>正规文法的形式：<br>右线性文法： A→aB或A→a<br>其中，A、B为单个的非终结符，a为单个的终结符。</p>
</blockquote>
<h4 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h4><p>正规表达式（regular expression）是说明单词的模式(pattern)的一种重要的表示法（记号），是定义正规集的工具。 </p>
<p>正规式也称正则表达式，也是表示正规集的数学工具。</p>
<p>正规式的递归定义</p>
<ul>
<li>$\emptyset $是一个正规式，它所表示的正规集为${\emptyset }$ ；</li>
<li>$ε$是一个正规式，它所表示的正规集为${ε}$；</li>
<li>$a∈V_T$是一个正规式，它所表示的正规集为${a}$；</li>
<li>设$e_1$和$e_2$分别是表示的正规集$L(e_1)$和$L(e_2)$的正规式,则：<ul>
<li>$e_1|e_2$是正规式, 表示的正规集为$L(e_1)∪L(e_2)$;</li>
<li>$e_1·e_2$是正规式,表示的正规集为 $L(e_1)L(e_2)$;</li>
<li>$e_1^*$是正规式,表示的正规集为$(L(e_1))^*$。</li>
</ul>
</li>
</ul>
<blockquote>
<p>规定运算符的优先顺序为：$* → · → | $ 。<br>     正规式定义中的“|”读为“或”（也有使用“+”代替 “|” 的）；“·”读为“连接”；“*”读为“闭包”（即，任意有限次的自重复连接）。<br>       连接符“·”一般可省略不写。“*”、“·”和“|” 都是左结合的。</p>
</blockquote>
<p>正规式等价</p>
<blockquote>
<p>若两个正规式$e_1$和$e_2$所表示的正规集相同,即$L(e_1)=L(e_2)$,则$e_1$和$e_2$等价,记为$e_1=e_2$。<br>$e_1= a|b， e_2 = b|a$，显然等价；<br>$e_1= b(ab)^*,  e_2 =(ba)^<em>b$均为bababab……ababab，等价；<br>$e_1= (a|b)^</em>  ,  e_2 =(a^*|b^*)^*$均表示由a和b组成的任意的符号串，所以等价。</p>
</blockquote>
<h4 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h4><p>有穷自动机(也称有限自动机)作为一种识别装置，它能准确地识别正规集，即识别正规文法所定义的语言和正规式所表示的集合，引入有穷自动机这个理论，正是为词法分析程序的自动构造寻找特殊的方法和工具。</p>
<p>有穷自动机分为两类：确定的有穷自动机(Deterministic Finite Automata)和不确定的有穷自动机(Nondeterministic Finite Automata)。</p>
<p>有穷自动机的模型</p>
<blockquote>
<p>有穷自动机FA是具有离散输入输出系统的数学模型。</p>
<p>系统的状态概括了对过去输入处理情况的信息。系统只需要根据当前所处的状态和面临的输入就可以决定系统的后继行为。每当系统出来了当前的输入后，系统的内部状态也将发生变化</p>
</blockquote>
<p>接收方式</p>
<blockquote>
<p>FA在初始状态下开始读入第一个输入符。<br>FA接收输入串：终态方式。若读头在输入带上最后一个符号时，恰好进入某个终止状态，则宣布接收该输入串；否则，不接收</p>
</blockquote>
<h4 id="确定的有穷自动机DFA"><a href="#确定的有穷自动机DFA" class="headerlink" title="确定的有穷自动机DFA"></a>确定的有穷自动机DFA</h4><p>【DFA定义】一个确定的有穷自动机(DFA)$M$是一个五元组：$M=（S，Σ，f， s_0 ，Z）$，其中：</p>
<p>$S$是一个有穷状态集，它的每个元素称为一个状态；</p>
<p>$Σ$是一个有穷字母表，它的每个元素称为一个输入符号，所以也称$Σ$为输入符号字母表；</p>
<p>$f$是状态转换函数，是定义在$S×Σ→S$上的单值映射，即若 $f(q_1，a)=q_2$，表示在当前状态为$q_1$，输入符为$a$时，将转换为下一个状态$q_2$， $q_2$称作$q_1$的后继状态；</p>
<p>$s_0  \in S$是唯一的初态；</p>
<p>$Z \subseteq S$是一个终态集，终态也称可接受状态或结束状态。</p>
<p><strong>状态转换矩阵</strong></p>
<blockquote>
<p>DFA可以用一个矩阵表示:</p>
<p>行:表示状态$q$;</p>
<p>列:表示输入字符$a$;</p>
<p>矩阵元素：表示$f(q,a)$的值,即在$q$状态下读入输入符$a$时应转换到的下一个状态。</p>
</blockquote>
<blockquote>
<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220102233633250.png" alt="image-20220102233633250" style="zoom:80%;">
</blockquote>
<p><strong>状态转换图</strong></p>
<blockquote>
<p>DFA也可以表示成一张（确定的）状态转换图：</p>
<p>结点：表示状态，用圆圈圈起来；</p>
<p>箭弧→ ：表示状态转移的方向；</p>
</blockquote>
<blockquote>
<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220102234014568.png" alt="image-20220102234014568" style="zoom: 67%;">
</blockquote>
<p>对于$\Sigma^*$中的任何一个字符串$\alpha$，若存在一条从初态结点到某一终态结点的通路，且这条通路上所有箭弧的标记符连接成的字符串等于$\alpha$，则称串$\alpha$为DFA M所识别（读出或接受）。</p>
<p>若M的初态结点同时又是终态结点，则为空字$\varepsilon$可为M所识别</p>
<p>DFA M所能识别的字符串的全体记为$L(M)$</p>
<h4 id="不确定的有穷自动机NFA"><a href="#不确定的有穷自动机NFA" class="headerlink" title="不确定的有穷自动机NFA"></a>不确定的有穷自动机NFA</h4><p>【NFA定义】不确定的有穷自动机(NFA) $M$是一个五元组：$M=（S，Σ，f， S_0 ，Z）$，其中：</p>
<p>$S$是一个有穷状态集；</p>
<p>$Σ$是一个有穷字母表；</p>
<p>$f$是状态转换函数，是定义在$S×Σ→2^S$上的多值映射，即若 $f(q_1，a)={q_2,q_2}$，表示在当前状态为$q_1$，输入符为$a$时，将转换为下一个状态$q_2$和$q_3$；</p>
<p>$S_0  \subseteq S$是初态集；</p>
<p>$Z \subseteq S$是一个终态集。</p>
<p><strong>状态转换矩阵</strong></p>
<p><img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103100043362.png" alt="image-20220103100043362"></p>
<p><strong>状态转换图</strong></p>
<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103100112679.png" alt="image-20220103100112679" style="zoom: 80%;">

<p>对于$\Sigma^*$中的任何一个字符串$\alpha$，若存在一条从初态结点到某一终态结点的通路，且这条通路上所有箭弧的标记符连接成的字符串等于$\alpha$，则称串$\alpha$为NFA M所识别（读出或接受）。</p>
<p>NFA $M$所能识别的字符串的全体记为$L(M)$。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>DFA是NFA的特例</p>
<p>对于每个NFA $M$都一定存在一个DFA $M^′$，使$L(M)=L(M′)$。即：</p>
<ul>
<li>对每个NFA $M$存在着与之等价的DFA $M′$ 。</li>
<li>与某一NFA等价的DFA不唯一。</li>
</ul>
<h3 id="正规式与FA等价转换"><a href="#正规式与FA等价转换" class="headerlink" title="正规式与FA等价转换"></a>正规式与FA等价转换</h3><img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103101333587.png" alt="image-20220103101333587" style="zoom:80%;">

<h4 id="正规式-转换-NFA"><a href="#正规式-转换-NFA" class="headerlink" title="正规式 转换 NFA"></a>正规式 转换 NFA</h4><p>正规式与有穷自动机的等价性：</p>
<ul>
<li>对于$∑$上的一个正规式 $r$，可以构造一个$∑$上的NFA $M$，使得$L(M)=L(r)$。</li>
<li>对于$∑$上的NFA $M$，可以构造一个$∑$上的正规式 $r$ ，使得$L(r)=L(M)$。</li>
</ul>
<p>构造方法</p>
<p>引进初始结点X和终态结点Y，把正规式r表示成拓广转换图</p>
<p><img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103101956261.png" alt="image-20220103101956261"></p>
<p>分析正规式 $r$ 的语法结构，使用如下规则为 $r$ 中的每个基本符号构造NFA</p>
<ul>
<li>对于正规式 $\emptyset $，所构造的NFA为</li>
</ul>
<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103102116477.png" alt="image-20220103102116477" style="zoom:80%;">

<ul>
<li>对于正规式 $ε$，所构造的NFA为</li>
</ul>
<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103102240871.png" alt="image-20220103102240871" style="zoom:80%;">

<ul>
<li>对于正规式$a，a∈Σ$，所构造的NFA为</li>
</ul>
<p><img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103102405073.png" alt="image-20220103102405073"></p>
<ul>
<li>对正规式 $r_1, r_2$ ，所构造的NFA如下</li>
</ul>
<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103102520153.png" alt="image-20220103102520153" style="zoom:80%;">

<ul>
<li>对正规式 $r_1 | r_2$ ，所构造的NFA如下</li>
</ul>
<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103102605813.png" alt="image-20220103102605813" style="zoom:80%;">

<ul>
<li>对正规式 $r_1^*$，所构造的NFA如下</li>
</ul>
<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103102705434.png" alt="image-20220103102705434" style="zoom:80%;">

<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103104242624.png" alt="image-20220103104242624" style="zoom:80%;">

<h4 id="NFA-确定化-DFA"><a href="#NFA-确定化-DFA" class="headerlink" title="NFA 确定化 DFA"></a>NFA 确定化 DFA</h4><p>NFA到相应的DFA的构造的基本思路是： DFA的每一个状态对应NFA的一组状态。 DFA使用它的状态去记录在NFA读入一个输入符号后可能达到的所有状态。</p>
<p>确定化方法：==状态子集法==。</p>
<p>【定义】状态子集 $I$ 的$ε-$闭包：$ε- Closure(I) $</p>
<blockquote>
<p>(1)若$q∈I$，则 $q∈ε- Closure(I)$</p>
<p>(2)若$q∈I$，那么从$q$出发经任意条$ε$弧而能到达的任何状态$q’$都属于$ε-Closure(I)$</p>
</blockquote>
<p>【定义】状态子集$I_a=ε-Closure(J)$</p>
<blockquote>
<p>其中 $I$ 是NFA $M$的一个状态子集，$a∈∑$，$J$是那些可从 $I$ 中的某一状态结点出发经过一条$a$弧而到达的状态结点的全体</p>
</blockquote>
<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103103946098.png" alt="image-20220103103946098" style="zoom: 80%;">

<p>==状态子集法==</p>
<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103105708298.png" style="zoom:80%;">

<p>从NFA $M=(S,Σ,f, S_0 ,Z)$构造等价的DFA $M ’＝(K,Σ,f ,k_0,F )$的基本方法是：</p>
<blockquote>
<p>1.求DFA的初态 $k_0 ＝\varepsilon -closure({NFA的初态})\<br>                   ＝\varepsilon -closure({X})\<br>                   ＝{X，2，1}$</p>
<p>2.求DFA $M ’$的状态集$K$中的其它状态以及状态转换函数$f$,用求$I_a，I_b$的方法：<br>设$I＝ {k_0} \<br>f(k_0 ，a)＝I_a＝{k_0}_a \<br>f(k_0 ，b)＝I_b＝{k_0}_b$<br>因为$Σ＝{a,b}$,所以只需求$I_a，I_b$即可。<br>子集$I_a，I_b$求出后得到一个新状态就添加到DFA的状态集$K$中；如此继续，直至不再产生新的状态为止。即可得到DFA的全部状态$K$和状态转换函数$f$。</p>
<p>3.包含原NFA的终态的子集都是DFA的终态，DFA的终态可能有多个状态</p>
</blockquote>
<blockquote>
<p><img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103110100900.png" alt="image-20220103110100900"></p>
<p><img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103110131799.png" alt="image-20220103110131799"></p>
</blockquote>
<h4 id="DFA-化简"><a href="#DFA-化简" class="headerlink" title="DFA 化简"></a>DFA 化简</h4><p>确定有穷自动机M的化简是指：寻找一个状态数比DFA $M$少的DFA $M’$，使得$L(M)＝L(M’)$。</p>
<p><strong>多余状态</strong>：从有穷自动机的初态出发，任何输入串也不能到达的那个状态；或者从这个状态没有通路到达终态</p>
<p><strong>等价</strong>：如果有穷自动机DFA M的两个状态s和t能够识别同样的符号串，则称状态s和t等价</p>
<p><strong>可区别状态</strong>：如果有穷自动机DFA M的两个状态s和t不等价，则称这两个状态是可区别的</p>
<blockquote>
<p>终态与非终态是可区别的</p>
</blockquote>
<p>最小状态DFA的含义：</p>
<blockquote>
<p>无多余状态 —— 消除多余转态</p>
<p>无等价状态 —— 合并等价状态</p>
</blockquote>
<p>两个状态s和t可区别：不满足</p>
<blockquote>
<p>兼容性——同是终态或同是非终态</p>
<p>传播性——从$s$出发读入某个$a(a\in \Sigma)$和从 $t$ 出发读入某个 $a$ 到达的状态等价。</p>
</blockquote>
<p>DFA的最小化过程：==分割法==</p>
<blockquote>
<p>一个 DFA $M$的状态最少化过程是指将 $M$ 的状态集分割成一些不相交的子集，使得任何不同的两子集中的状态都是可区别的，而同一子集中的任何两个状态都是等价的。最后，在每个子集中选出一个代表，同时消去其它等价状态。</p>
</blockquote>
<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20211219135557.png" style="zoom:80%;">

<p>DFA的状态集$K＝{0，1，2 ，3，4，5，6}$</p>
<ul>
<li>首先把$M$的状态$K$分为两组：</li>
</ul>
<blockquote>
<p>终态集$K1={3，4，5，6}$<br>非终态集$K2={0，1，2}$<br>显然$K1$与$K2$不等价。</p>
</blockquote>
<ul>
<li>试图$K1，K2$在中寻找一个子集和一个输入符号使得这个子集中的状态可区别的；若可区别，则再分割；继续，一直到不能再分割为止<blockquote>
<p>讨论终态集$K1={3，4，5，6}$ 是否可分割：<br>${3，4，5，6}_a \subset K1$<br>${3，4，5，6}_b \subset K1$<br>所以状态3，4，5，6均等价，因此$K1$不能再分割。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>讨论非终态集$K2={0，1，2}$ 是否可分割：<br>${0，1，2}_a \subset {1，3}$<br>它既不属于$K2＝{0，1，2}$，也不属于$K1＝{3，4，5，6}\$<br>将其一分为二<br>${0，2}_a＝{1}\$<br>${1}_a＝{3}$</p>
<p>$K21＝{1}$<br>$K22＝{0，2}$</p>
</blockquote>
<blockquote>
<p>再讨论$K22={0，2}$ 是否可分割：<br>${0，2}_b ＝{2 ，5}$<br>而它未包括在$K1 ，K21与K22$中，故${0，2}$应一分为二：<br>$K221＝{0}$<br>$K222＝{2}$<br>所以$K$分为四组${3，4，5，6}，{0}，{1}，{2}$。每个组都不可再分。</p>
</blockquote>
<ul>
<li>最后，令状态3代表${3，4，5，6}$。把原来到达4，5，6的弧都导入3，并删除4，5，6状态。即可得到化简后的DFA。</li>
</ul>
<p><img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/20211219141825.png"></p>
<h3 id="正规文法与FA的等价转换"><a href="#正规文法与FA的等价转换" class="headerlink" title="正规文法与FA的等价转换"></a>正规文法与FA的等价转换</h3><p>对于正规文法$G$和有穷自动机FA $M$，如果$L(G)=L(M)$,则称$G$和$M$等价</p>
<p>右线性文法的转换方法</p>
<blockquote>
<p>引入一个终态$F$</p>
<p>设右线性文法$G＝(V_N,V_T,P,S)$, 则相应的自动机为$M＝(V_N ∪ {F}, V_T,f,S,{F})$。</p>
<p>状态转换函数 $f$ 由以下规则定义：</p>
<ul>
<li>$P$中形如$A→aB$的产生式，则有$f(A,a)=B$;</li>
<li>$P$中形如$A→a$的产生式，则有$f(A,a)=F$ ; </li>
<li>对$V_T$中的每个$a$，都有$f(F,a)=\emptyset $ 。</li>
</ul>
</blockquote>
<p>示例：</p>
<p>$G_{11}[I]: $ $ \ I→lB|l \ B→lB | dB | l | d$</p>
<p>1、转换为NFA</p>
<blockquote>
<p>引入一个终态F，则相应的NFA为：$M＝({I,B,F},{l,d},f,{I},{F})$,其中$f$可确定为：</p>
<p>由$I→ lB$ 可得$ f(I，l)＝B$<br>由$I→ l $可得 $f(I，l)＝F$<br>由$B→ lB$ 可得$ f(B，l)＝B$<br>由$B→ dB$ 可得 $f(B，d)＝B$<br>由$B→ l $可得 $f(B，l)＝F$<br>由$B→ d$ 可得 $f(B，d)＝F$ </p>
</blockquote>
<p>2、用状态转换图表示为：</p>
<blockquote>
<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103115259635.png" alt="image-20220103115259635">
</blockquote>
<p>3、NFA 转 DFA</p>
<p>4、DFA化简</p>
<h3 id="设计和实现词法分析程序"><a href="#设计和实现词法分析程序" class="headerlink" title="设计和实现词法分析程序"></a>设计和实现词法分析程序</h3><p>设计词法分析程序的途径有两种:</p>
<ul>
<li>手工编写：直接依据词法规则编写程序。</li>
<li>自动生成：利用词法自动生成工具产生词法分析程序，依据的原理就是将正规表达式转换成等价的有限自动机，要分三步：<img src="/3%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20220103101333587.png" alt="image-20220103101333587" style="zoom:80%;"></li>
</ul>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>存储过程和触发器设计</title>
    <url>/4%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>存储过程的创建、调用、删除，触发器的创建、调用、删除</p>
<span id="more"></span>

<h1 id="过程式数据库对象"><a href="#过程式数据库对象" class="headerlink" title="过程式数据库对象"></a>过程式数据库对象</h1><ul>
<li><p>存储过程(PROCEDURE)</p>
</li>
<li><p>函数(FUNCTION)</p>
</li>
<li><p>触发器(TRIGGER)</p>
</li>
<li><p>事件(EVENT)</p>
</li>
</ul>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>推荐链接：<a href="https://www.runoob.com/w3cnote/mysql-stored-procedure.html">https://www.runoob.com/w3cnote/mysql-stored-procedure.html</a></p>
<pre><code>存储过程是一组为了完成特定功能的SQL语句集，存储在数据库中供调用执行，类似于一个函数或一个脚本
</code></pre>
<p>使用存储过程的优点</p>
<ul>
<li><p>在服务器端运行，执行速度快</p>
</li>
<li><p>第一次编译执行之后，其执行规划就驻留在高速缓存内，在以后的操作中无需再次编译，提高了系统性能</p>
</li>
<li><p>确保数据库安全</p>
</li>
</ul>
<h3 id="存储过程VS函数"><a href="#存储过程VS函数" class="headerlink" title="存储过程VS函数"></a>存储过程VS函数</h3><ul>
<li><p>函数的参数列表只有输入参数，存储过程可以有输入参数、输出参数、可输入输出的参数</p>
</li>
<li><p>函数有只能返回一个变量的限制，存储过程可以返回多个变量</p>
</li>
<li><p>函数可以嵌入SQL中使用，如在SELECT语句中调用，存储过程不能</p>
</li>
<li><p>除此之外，两者本质一致</p>
</li>
</ul>
<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>使用CREATE PROCEDURE语句创建存储过程，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名([参数…])</span><br><span class="line">[特征…] 主体</span><br></pre></td></tr></table></figure>
<p><code>注：</code>系统默认在当前数据库中创建存储过程，如果需要在特定数据库中创建存储过程，要在名称前面加上数据库名称，数据库名.存储过程名</p>
<p><code>说明：</code></p>
<ul>
<li><p>存储过程参数</p>
<pre><code>  参数＝: [IN|OUT|INOUT] 参数名 参数类型
  IN 输入参数：表示调用者向过程传入值（传入值可以是字面量或变量）
  OUT 输出参数：表示过程向调用者传出值(可以返回多个值)（传出值只能是变量）
  INOUT 输入输出参数：既表示调用者向过程传入值，又表示过程向调用者传出值（值只能是变量）
</code></pre>
</li>
<li><p>存储过程主体</p>
<p>  包含在过程调用时候必须执行的语句，以<code>BEGIN</code>开始，以<code>END</code>结束，可嵌套（嵌套最好添加标签）</p>
</li>
</ul>
<h3 id="存储过程体中的语句规范"><a href="#存储过程体中的语句规范" class="headerlink" title="存储过程体中的语句规范"></a>存储过程体中的语句规范</h3><ul>
<li><p>局部变量：<code>DECLARE 变量名 类型 [默认值]</code><br>  <font color="#ff0000">注意：</font>局部变量声明一定要放在存储过程体的开始，不然会报错</p>
</li>
<li><p>赋值语句：<code>SET 变量名 = 表达式</code></p>
</li>
<li><p>SELECT语句赋值：<code>SELECT 列名 INTO 变量名 FROM … WHERE…;</code></p>
</li>
<li><p>流程控制一 IF语句：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">IF 条件 <span class="keyword">THEN</span> 语句</span><br><span class="line">[ELSEIF 条件 <span class="keyword">THEN</span> 语句]</span><br><span class="line">[<span class="keyword">ELSE</span> 语句]</span><br><span class="line"><span class="keyword">END</span> IF</span><br></pre></td></tr></table></figure>
</li>
<li><p>流程控制二 循环语句：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">WHILE 条件 DO </span><br><span class="line">语句</span><br><span class="line"><span class="keyword">END</span> WHILE</span><br><span class="line">REPEAT</span><br><span class="line">语句</span><br><span class="line">UNTIL 条件</span><br><span class="line"><span class="keyword">END</span> REPEAT</span><br><span class="line">LOOP</span><br><span class="line">语句</span><br><span class="line"><span class="keyword">END</span> LOOP</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="查询存储过程"><a href="#查询存储过程" class="headerlink" title="查询存储过程"></a>查询存储过程</h3><p>查询某个数据库的所有存储过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> mysql.proc <span class="keyword">where</span> db<span class="operator">=</span><span class="string">&#x27;数据库名&#x27;</span>;  <span class="comment">/*可能会报错 Table &#x27;mysql.proc&#x27; doesn&#x27;t exist*/</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="comment">/*推荐使用这一种*/</span></span><br><span class="line"><span class="keyword">select</span> routine_name <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> routine_schema<span class="operator">=</span><span class="string">&#x27;数据库名&#x27;</span>;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> status <span class="keyword">where</span> db<span class="operator">=</span><span class="string">&#x27;数据库名&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查询某个存储过程的创造过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 数据库.存储过程名;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*此方法也可以套用，如查询表的创建过程*/</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 数据库.存储过程名;</span><br></pre></td></tr></table></figure>

<h3 id="存储过程的修改"><a href="#存储过程的修改" class="headerlink" title="存储过程的修改"></a>存储过程的修改</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PROCEDURE</span></span><br></pre></td></tr></table></figure>

<h3 id="存储过程的调用"><a href="#存储过程的调用" class="headerlink" title="存储过程的调用"></a>存储过程的调用</h3><p>调用之前要先选择数据库</p>
<ul>
<li><p>直接调用</p>
<p>  <code>CALL 存储过程名([参数…]);</code></p>
</li>
<li><p>以SQL脚本文件形式执行</p>
<p>  将存储过程保存在<code>xx.sql</code>文件中，调用格式:<code>source xx.sql;</code> </p>
<p>   注：在mysql环境下运行，不是cmd，实际中要加路径</p>
</li>
</ul>
<h3 id="存储过程的删除"><a href="#存储过程的删除" class="headerlink" title="存储过程的删除"></a>存储过程的删除</h3><p>使用DROP PROCEDURE语句删除存储过程，语法格式为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> [IF <span class="keyword">EXISTS</span>] 存储过程名;</span><br></pre></td></tr></table></figure>

<p><code>注：</code>下例@开头的变量是设置成了用户变量，最好不要滥用</p>
<h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例：用存储过程实现删除一个特定学生的信息*/</span></span><br><span class="line">delimiter $$    <span class="comment">/*mysql默认;结束，将结束符号设为$$*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> delete_student (<span class="keyword">in</span> p_studentkey <span class="type">char</span>(<span class="number">6</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> studentkey<span class="operator">=</span>p_studentkey;</span><br><span class="line"><span class="keyword">end</span>$$</span><br><span class="line">delimiter ;     <span class="comment">/*将结束符号设回;*/</span></span><br><span class="line"><span class="comment">/*调用*/</span></span><br><span class="line"><span class="keyword">call</span> delete_student(<span class="string">&#x27;123&#x27;</span>);<span class="comment">/*123为表student中studentkey字段的值*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例：*/</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> in_param(<span class="keyword">in</span> p_in <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">/*select 在终端将p_in的值按表格的形式打印出来，可以理解为程序语言的输出*/</span></span><br><span class="line"><span class="keyword">select</span> p_in; </span><br><span class="line"><span class="keyword">set</span> p_in<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> P_in;</span><br><span class="line"><span class="keyword">end</span>$$</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="comment">/*调用*/</span></span><br><span class="line"><span class="keyword">call</span> in_param(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例：创建一个存储过程，比较两个员工的实际收入，若前者比后者高就输出0，否则输出1，员工用其员工编号识别*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*employee表数据在后面*/</span></span><br><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> compare_salary(<span class="keyword">in</span> e1 <span class="type">char</span>(<span class="number">6</span>),<span class="keyword">in</span> e2 <span class="type">char</span> (<span class="number">6</span>),<span class="keyword">out</span> <span class="keyword">result</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">/*变量在最前面定义*/</span></span><br><span class="line"><span class="keyword">declare</span> el_salary <span class="type">real</span>;</span><br><span class="line"><span class="keyword">declare</span> e2_salary <span class="type">real</span>;</span><br><span class="line"><span class="comment">/*将返回值result值设为1*/</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span><span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">/*取e1的income-outcome的差给e1_salary*/</span></span><br><span class="line"><span class="keyword">select</span> income<span class="operator">-</span>outcome <span class="keyword">into</span> e1_salary</span><br><span class="line"><span class="keyword">from</span> salary</span><br><span class="line"><span class="keyword">where</span> employeeID<span class="operator">=</span>e1;</span><br><span class="line"><span class="comment">/*取e2的income-outcome的差给e2_salary*/</span></span><br><span class="line"><span class="keyword">select</span> income<span class="operator">-</span>outcome <span class="keyword">into</span> e2_salary</span><br><span class="line"><span class="keyword">from</span> salary</span><br><span class="line"><span class="keyword">where</span> employeeID<span class="operator">=</span>e2</span><br><span class="line"><span class="comment">/*比较大小，来更改result的值*/</span></span><br><span class="line">if e1_salary<span class="operator">&gt;</span>e2_salary <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span><span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="comment">/*调用函数*/</span></span><br><span class="line"><span class="keyword">call</span> compare_salary(<span class="string">&#x27;000001&#x27;</span>,<span class="string">&#x27;010008&#x27;</span>, <span class="variable">@result</span>);</span><br><span class="line"><span class="comment">/*查询返回结果*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@result</span>;</span><br><span class="line"><span class="comment">/*删除用户变量，即将该用户变量置空，不要这命令也无所谓，退出mysql后好像会自己置空*/</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@result</span><span class="operator">=</span><span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*out 返回值好像只能用需要定义一个用户变量传给procedure，即@xxx*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p><img src="/4%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AE%BE%E8%AE%A1/20211217221700.png"></p>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>推荐链接：<a href="https://www.cnblogs.com/geaozhang/p/6819648.html">https://www.cnblogs.com/geaozhang/p/6819648.html</a></p>
<p>可以用来实现参照完整性约束</p>
<p><code>！！尽量少使用触发器，不建议使用。</code></p>
<p>　　假设触发器触发每次执行1s，insert table 500条数据，那么就需要触发500次触发器，光是触发器执行的时间就花费了500s，而insert 500条数据一共是1s，那么这个insert的效率就非常低了。因此我们特别需要注意的一点是触发器的begin end;之间的语句的执行效率一定要高，资源消耗要小。</p>
<p>　　触发器尽量少的使用，因为不管如何，它还是很消耗资源，如果使用的话要谨慎的使用，确定它是非常高效的：<code>触发器是针对每一行的；对增删改非常频繁的表上切记不要使用触发器，因为它会非常消耗资源。</code></p>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>使用CREATE TRIGGER语句创建触发器，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名 触发时刻 触发事件</span><br><span class="line"><span class="keyword">ON</span> 表名 <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> 触发器动作;</span><br></pre></td></tr></table></figure>

<p><code>FOR EACH ROW：</code>这个声明用来指定，对于受触发事件影响的每一行，都要激活触发器的动作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例：创建一个表table1，其中只有一列整形a。在表上面创建一个触发器，每次插入新记录，都将用户变量str的值设为“trigger is working”*/</span></span><br><span class="line"><span class="comment">/*建表*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table1(a <span class="type">integer</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建触发器 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> t_table1_insert after <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> table1 <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@str</span><span class="operator">=</span>‘<span class="keyword">trigger</span> <span class="keyword">is</span> working’;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*验证：*/</span> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 <span class="keyword">values</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@str</span>;</span><br></pre></td></tr></table></figure>

<h3 id="触发器中关联表中的列"><a href="#触发器中关联表中的列" class="headerlink" title="触发器中关联表中的列"></a>触发器中关联表中的列</h3><ul>
<li><p>在MySQL触发器中的SQL语句可以关联表中的任意列。但不能直接使用列的名称去标志，那会使系统混淆，因为激活触发器的语句可能已经修改、删除或添加了新的列名，而列的旧名同时存在。因此必须用这样的语法来标志：<code>&quot;NEW.column_name&quot;</code>或者<code>&quot;OLD.column_name&quot;</code>。<code>NEW.column_name</code>用来引用新行的一列，<code>OLD.column_name</code>用来引用更新或删除它之前的已有行的一列。</p>
</li>
<li><p><code>对于INSERT语句，只有NEW是合法的；对于DELETE语句，只有OLD才合法；而UPDATE语句可以与NEW或OLD同时使用。</code></p>
</li>
<li><p>OLD是只读的，而NEW则可以在触发器中使用 SET 赋值，这样不会再次触发触发器，造成循环调用（如每插入一个学生前，都在其学号前加”2013”）</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例：创建一个触发器，当删除表student中某个学生的信息时，同时将score表中与该学生有关的数据全部删除*/</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> t_student_delete after <span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> student <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> score <span class="keyword">where</span> studentkey<span class="operator">=</span>old.studentkey;</span><br><span class="line"><span class="keyword">end</span>$$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*修改employee表时，若将employee表中的员工工作时间增加一年，则将收入增加500，增加两年则收入增加1000，以此类推*/</span></span><br><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> t_student update after update</span><br><span class="line"><span class="keyword">on</span> employee <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> change_num <span class="type">int</span>;</span><br><span class="line"><span class="keyword">set</span> change_num<span class="operator">=</span>new.workYear<span class="operator">-</span>old.workYear;</span><br><span class="line">if change_num<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">update salary <span class="keyword">set</span> income<span class="operator">=</span>income<span class="operator">+</span>change.num<span class="operator">*</span><span class="number">500</span></span><br><span class="line"><span class="keyword">where</span> employeeID<span class="operator">=</span>old.employeeID;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span><span class="operator">/</span><span class="operator">/</span></span><br></pre></td></tr></table></figure>

<h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h3><ul>
<li><p>查询某数据库触发器信息：</p>
<p>  <code>SHOW TRIGGERS\G;</code></p>
</li>
<li><p>查询指定触发器信息</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.triggers </span><br><span class="line"><span class="keyword">where</span> trigger_name<span class="operator">=</span>触发器名称\G;</span><br></pre></td></tr></table></figure>

  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.triggers <span class="keyword">where</span> trigger_name<span class="operator">=</span><span class="string">&#x27;t_employee_delete&#x27;</span>\G;</span><br></pre></td></tr></table></figure></li>
<li><p>万能查询模板<br>  <code>show create trigger 数据库.触发器名\G;</code></p>
</li>
</ul>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><p>使用DROP TRIGGER语句删除触发器，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> 触发器名;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库备份和恢复</title>
    <url>/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<p>数据库使用SQL语句备份和恢复，使用客户端sqldump和sqlimport备份和恢复</p>
<span id="more"></span>


<h2 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h2><ul>
<li>物理备份：复制数据库物理文件</li>
<li>逻辑备份：将数据库对象的定义和数据导出到指定文件</li>
<li>增量备份：只备份上次备份以来有变化的数据</li>
<li>完全备份：备份整个数据库</li>
</ul>
<p>MySQL保证数据安全的方法</p>
<ul>
<li>数据库备份：通过导出数据或者表文件的副本来保护数据</li>
<li>二进制日志文件：保存更新数据的所有语句</li>
<li>数据库复制：MySQL内部复制功能，建立在两个或两个以上服务器之间，通过设定主从关系来实现</li>
</ul>
<h2 id="SQL语句备份：导出表数据"><a href="#SQL语句备份：导出表数据" class="headerlink" title="SQL语句备份：导出表数据"></a><code>SQL语句备份：导出表数据</code></h2><p>导出到文本文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SELECT...INTO...OUTFILE</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name INFO OUTFILE <span class="string">&#x27;FILENAME&#x27;</span></span><br><span class="line">[FIELDS</span><br><span class="line">    [TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;string&#x27;</span>]</span><br><span class="line">    [[OPTIONALLY]ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;char&#x27;</span>]</span><br><span class="line">    [ESCAPED <span class="keyword">BY</span> <span class="string">&#x27;char&#x27;</span>]</span><br><span class="line">]</span><br><span class="line">[LINES TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;string&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">select</span> employeeID,name,education</span><br><span class="line"><span class="keyword">from</span> employee</span><br><span class="line"><span class="keyword">into</span> outfile <span class="string">&#x27;D:/FileRecv/DB experiment/dataset2/employee2.csv&#x27;</span></span><br><span class="line">fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">lines terminated <span class="keyword">by</span> <span class="string">&#x27;\r\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><font color="#008000">  说明 </font>   </p>
<p><code>fields terminated by &#39;string&#39;</code>: 指定字段值之间用某个string分隔，默认为’\t’</p>
<p><code>fields enclosed by &#39;char&#39;</code>: 指定包裹文件中字符值的符号，若使用optionally，则所有的值都放在指定符号之间，默认为空</p>
<p><code>fields escaped by &#39;char&#39;</code>: 指定转义字符，默认为\</p>
<p><code>lines terminated by &#39;string&#39;</code>: 指定一行结束的标志，默认为 \n </p>
<p>导入表数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">&#x27;FILENAME&#x27;</span> [REPLACE<span class="operator">|</span>IGNORE] <span class="keyword">INTO</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">[FIELDS</span><br><span class="line">    [TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;string&#x27;</span>]</span><br><span class="line">    [[OPTIONALLY]ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;char&#x27;</span>]</span><br><span class="line">    [ESCAPED <span class="keyword">BY</span> <span class="string">&#x27;char&#x27;</span>]</span><br><span class="line">]</span><br><span class="line">[LINES [STARTING <span class="keyword">BY</span> <span class="string">&#x27;string&#x27;</span>] [TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;string&#x27;</span>]]</span><br><span class="line">[IGNORE number LINES]</span><br><span class="line">[(列名或用户变量)]</span><br><span class="line">[<span class="keyword">SET</span> 列名<span class="operator">=</span>表达式]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"> load data</span><br><span class="line"> infile <span class="string">&#x27;D:/FileRecv/DB experiment/dataset2/salary2.csv&#x27;</span> ignore</span><br><span class="line"> <span class="keyword">into</span> <span class="keyword">table</span> salary</span><br><span class="line"> fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line"> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\r\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><font color="#008000">  说明 </font> </p>
<p><code>replace|ignore</code>: 指定replace，则当文件中出现与原有行相同的唯一关键字值时，输入行会替换原有行；指定ignore，则把与原有行有相同关键字值的输入行跳过</p>
<p><code>lines starting by &#39;string&#39;</code>: 指定一个前缀，导入数据行时，忽略行中该前缀和前缀之前的内容。如果某行不包括该前缀，则整个行被跳过。</p>
<p>例如：某文件中有 xxx ‘row’, 1，如果导入数据时指定starting by ‘xxx’，则最后得到数据 (‘row’, 1)</p>
<p><code>IGNORE number LINES</code>: 忽略文件前几行</p>
<h2 id="客户端工具备份与恢复"><a href="#客户端工具备份与恢复" class="headerlink" title="客户端工具备份与恢复"></a><code>客户端工具备份与恢复</code></h2><p><font color="##ff0000">注意：</font></p>
<p>以下除<code>mysqldump</code>和<code>mysqlimport</code>开头的命令直接在cmd终端执行，不要在mysql下运行</p>
<p>可以看到在mysql目录的bin文件下有mysqldump.exe，mysqlimport.exe文件</p>
<ul>
<li><p>使用mysqldump备份数据</p>
<pre><code>  mysqldump程序可用于备份数据，并且可以在导出的文件中包含表结构的SQL语句，因此可以备份数据库表的结构，而且可以备份整个数据库，甚至整个数据库系统。
</code></pre>
</li>
<li><p>使用mysql恢复数据库</p>
<pre><code>  mysql命令可以恢复由mysqldump备份的数据库文件
</code></pre>
</li>
<li><p>使用mysqlimport恢复数据</p>
<pre><code>  mysqlimport程序可以恢复基本表中的数据，它提供了一个LOAD DATA INFILE语句的命令行接口，发送命令到服务器来运作
</code></pre>
</li>
</ul>
<p>备份数据库</p>
<p><font color="##FF0000"> 注： </font><br>备份的文件可以指定路径，不指定路径则默认保存至终端所当前显示的目录下</p>
<p><font color="#ff0000">这个命令是在cmd上运行，不要登录Mysql运行</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump [OPTIONS] <span class="comment">--databases [OPTIONS] DB1 [DB2 DB3...]&gt;filename</span></span><br><span class="line"></span><br><span class="line">OPTIONS：<span class="operator">-</span>h[hostname] <span class="operator">-</span>u[username] <span class="operator">-</span>p[password]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line">mysqldump <span class="operator">-</span>hlocalhost <span class="operator">-</span>uroot <span class="operator">-</span>p123456 <span class="comment">--databases DBST&gt;backup_DBST.sql</span></span><br><span class="line"><span class="comment">/*注*/</span></span><br><span class="line"><span class="comment">/*不要加; 不然会报错</span></span><br><span class="line"><span class="comment">mysqldump: Got error: 1049: Unknown database &#x27;dbst;&#x27; when selecting the database*/</span></span><br><span class="line"><span class="comment">/*会有警告：说密码显示出来不安全</span></span><br><span class="line"><span class="comment">mysqldump: [Warning] Using a password on the command line interface can be insecure.*/</span></span><br><span class="line"><span class="comment">/*-p 后面可以先不输入密码，回车后会提示输入密码*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*路径最好用引号包括，防止空格导致的错误*/</span></span><br><span class="line">mysqldump <span class="operator">-</span>hlocalhost <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="comment">--databases tft&gt;&quot;D:\Program Files\mysql-8.0.27-winx64\data_backup\backup_tft.sql&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*备份所有数据库*/</span></span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p123456 <span class="comment">--all-databases&gt;backup_all.sql</span></span><br></pre></td></tr></table></figure>

<p>备份表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*filename尽量设为xxxx.sql这种，可以选择备份哪几张表*/</span></span><br><span class="line">mysqldump [OPTIONS] db_name [<span class="keyword">table</span> <span class="keyword">table</span> ...]<span class="operator">&gt;</span>filename</span><br><span class="line">OPTIONS: <span class="operator">-</span>h[hostname] <span class="operator">-</span>u[username] <span class="operator">-</span>p[password]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line">mysqldump <span class="operator">-</span>hlocalhost <span class="operator">-</span>uroot <span class="operator">-</span>p123456 DBST student course<span class="operator">&gt;</span>backup_StudentCourse.sql</span><br><span class="line"><span class="comment">/*注：此处可以不用写密码，而sql文件必须保存到有写权限的路径*/</span></span><br></pre></td></tr></table></figure>
<p>恢复数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql[OPTIONS] db_name&lt;filename</span><br><span class="line"></span><br><span class="line">/*例，对应上例的备份*/</span><br><span class="line">mysqldump -uroot -p123456 DBST &lt; backup_DBST.sql</span><br></pre></td></tr></table></figure>

<p>恢复表数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*注：这各方法对应的是上文SQL语句备份那里导出的文本文件*/</span></span><br><span class="line"><span class="comment">/*不推荐，限制太多，路径不能有空格、中文，文件名需和表名相同，文件必须是似乎必须是txt文件，字段需用\t分隔，行需用\r\n分隔有很多限制，会遇到各种错误*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*备份表的filename，恢复时需要完整路径*/</span></span><br><span class="line"><span class="comment">/*备份的.sql文件中是保存了表结构和表数据，即创建表和导入数据的sql语句和数据*/</span></span><br><span class="line"><span class="comment">/*使用这语句需要数据库中存在该表，若不存在，需要复制.sql文件中创建表的语句在mysql中创建表，当然也可以手敲*/</span></span><br><span class="line">mysqlimport [OPTIONS] db_name filename</span><br><span class="line"></span><br><span class="line">OPTIONS：</span><br><span class="line"><span class="comment">--d|--delete 在导入文件前清空表格</span></span><br><span class="line"><span class="comment">--replace|--ignore  关键字值相同时替换 | 忽略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line">mysqlimport <span class="operator">-</span>uroot <span class="operator">-</span>p123456 <span class="comment">--replace dbst student.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*推荐，此方法对应的是mysqldump备份的.sql，简单，方便*/</span></span><br><span class="line"><span class="comment">/*除了在MySQL中直接使用MySQL语句之外，还可以在本地直接创建 filename.sql，再写入sql语句，在mysql中使用 source filename.sql执行文件中的sql语句*/</span></span><br><span class="line"><span class="comment">/*所以可以直接运行mysqldump备份的.sql文件*/</span></span><br><span class="line">mysql<span class="operator">&gt;</span>source filename.sql</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>语义计算和属性文法</title>
    <url>/5%E3%80%81%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97%E5%92%8C%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95/</url>
    <content><![CDATA[<p>编译原理    第五部分</p>
<span id="more"></span> 

<h2 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h2><p>语法制导翻译是处理语义的基本方法，它以语法分析为基础，在语法分析得到语言结构的结果时，对附着于此结构的语义进行处理，如计算表达式的值、生成中间代码等。</p>
<p>语法与语义的关系</p>
<blockquote>
<p>语法是指语言的结构、即语言的“样子”；语义是指附着于语言结构上的实际含意 ，即语言的“意义”</p>
<p>语义不能离开语法独立存在</p>
<p>语义远比语法复杂</p>
<p>同一语言结构可以包含多种含意，不同语言结构表示相同含意</p>
<p>语法与语义之间没有明确的界线。</p>
</blockquote>
<p>语义分析的两个作用</p>
<blockquote>
<p>检查是否结构正确的句子所表示的意思也合法</p>
</blockquote>
<pre><code>执行规定的语义动作，如：表达式求值、符号表填写、中间代码生成等
</code></pre>
<p>语义分析的方法</p>
<blockquote>
<p>语法制导翻译</p>
</blockquote>
<p>语义规则有两种常用的描述形式：</p>
<blockquote>
<p>语法制导定义：定义翻译所必须的语义属性和语义规则，一般不涉及计算顺序。</p>
<p>翻译模式： 除了定义翻译所必须的语义属性和语义规则，还给出计算顺序。</p>
</blockquote>
<p>语法制导的定义</p>
<blockquote>
<p>语法制导的定义是在上下文无关文法的基础上为每个文法符号（终结符或非终结符）配备若干个相关的“值”（称为属性）。这些属性代表与文法符号相关的信息，例如它的类型、值、代码序列、符号表内容等等。属性和变量一样，可以进行计算和传递。</p>
<p>属性一般分为两类：综合属性和继承属性。简单的说，综合属性用于“自下而上”传递信息，而继承属性用于“自上而下”传递信息。</p>
<p>属性加工的过程即是语义处理的过程，对于文法的每一个产生式都配备了一组属性的计算规则，则称为语义规则。</p>
</blockquote>
<p>语法制导翻译的基本思想(Syntax-Directed Translations)</p>
<blockquote>
<p>以语法分析为基础，伴随语法分析的各个步骤，执行相应的语义动作。</p>
<p>具体方法：</p>
<ul>
<li>将文法符号所代表的语言结构的意思，用附着于该文法符号的属性表示；</li>
<li>用语义规则规定产生式所代表的语言结构之间的关系（即属性之间的关系），即用语义规则实现属性计算。</li>
</ul>
<p>语义规则的执行：</p>
<p>在语法分析的适当时刻（如推导或归约）执行附着在对应产生式上的语义规则，以实现 对语言结构语义的处理，如计算、查填符号表、生成中间代码、发布出错信息等。</p>
</blockquote>
<h2 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h2><p>属性文法是在上下文无关文法的基础上为每个文法符号（终结符或非终结符）配备若干个相关的“值”（称为属性）。这些属性代表与文法符号相关的信息，例如它的类型、值、代码序列、符号表内容等等。属性和变量一样，可以进行计算和传递。</p>
<p>属性一般分为两类：综合属性和继承属性。简单的说，综合属性用于“自下而上”传递信息，而继承属性用于“自上而下”传递信息。</p>
<p>终结符只有综合属性，它由词法分析器提供</p>
<p>非终结符既可以有综合属性也可以有继承属性，文法开始符号的所有继承属性作为属性计算前的初始值</p>
<p><img src="/5%E3%80%81%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97%E5%92%8C%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95/image-20220104114027254.png" alt="image-20220104114027254"></p>
<p><img src="/5%E3%80%81%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97%E5%92%8C%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95/image-20220104114047331.png" alt="image-20220104114047331"></p>
<p><img src="/5%E3%80%81%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97%E5%92%8C%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95/image-20220104114102146.png" alt="image-20220104114102146"></p>
<p>终合属性</p>
<blockquote>
<p>在语法树中，一个结点的综合属性的值由其子结点的属性值确定。因此，通常使用自底向上的方法在每一个结点处使用语义规则计算综合属性的值。仅仅使用综合属性的属性文法称S—属性文法。</p>
</blockquote>
<p>继承属性</p>
<blockquote>
<p>在语法树中，一个结点的继承属性由此结点的父结点和/或兄弟结点的某些属性确定。用继承属性来表示程序语言结构中的上下文依赖关系很方便。</p>
</blockquote>
<p>S-属性文法：只包含综合属性，S-属性文法是L-属性文法的一个特例</p>
<p> L-属性文法</p>
<ul>
<li>可以包含综合属性，也可以包含继承属性</li>
<li>产生式右端某文法符号的继承属性的计算只取决于该符号左边文法符号的属性 （对于产生式左边文法符号，只能是继承属性）</li>
</ul>
<p><img src="/5%E3%80%81%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97%E5%92%8C%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95/image-20220104114553121.png" alt="image-20220104114553121"></p>
<p><img src="/5%E3%80%81%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97%E5%92%8C%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95/image-20220104114608713.png" alt="image-20220104114608713"></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>自主存取控制和并发控制</title>
    <url>/6%E3%80%81%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>用户的添加、查看、删除、信息修改；并发控制，事务，隔离</p>
<span id="more"></span>


<h2 id="自主存取控制实验"><a href="#自主存取控制实验" class="headerlink" title="自主存取控制实验"></a>自主存取控制实验</h2><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p>使用<code>CREATE USER</code>命令创建用户并设置密码，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户 [IDENTIFIED <span class="keyword">BY</span><span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"><span class="comment">/*用户=&#x27;用户名@登录主机名&#x27;*/</span>    <span class="comment">/*初始用户一般是root@localhost*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;ALEX&#x27;</span>@<span class="string">&#x27;LOCALHOST&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> yanglinqi<span class="variable">@localhost</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*使用以下命令查看所有用户*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> mysql.user;</span><br></pre></td></tr></table></figure>

<p><img src="/6%E3%80%81%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/20211217090736.png"></p>
<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>使用<code>DROP USER</code>命令删除用户，语法格式如下：</p>
<p><font color="#FF0000">注：</font>只有用户当前数据库全局权限的用户才能使用<code>DROP</code>命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> 用户; </span><br><span class="line"><span class="comment">/*用户形式  用户名@主机  例：yanglinqi@localhost  用户吗是区分大小写的*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> yanglinqi<span class="variable">@localhost</span>;</span><br></pre></td></tr></table></figure>



<p><img src="/6%E3%80%81%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/20211217091041.png"></p>
<h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>使用<code>SET PASSWORD</code>命令修改某用户登录密码，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*8.0版本之前*/</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> 用户<span class="operator">=</span>PASSWORD(<span class="string">&#x27;新密码&#x27;</span>);</span><br><span class="line"><span class="comment">/*8.0版本及之后*/</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> 用户<span class="operator">=</span><span class="string">&#x27;新密码&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> ALEX<span class="variable">@LOCALHOST</span><span class="operator">=</span><span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>mysql -u 用户名 -p 密码</code>（密码可以回车后再输入）</p>
<p><img src="/6%E3%80%81%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/20211217092509.png" alt="登录测试成功"></p>
<p>也可以使用以下命令修改密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;ALEX&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>还可以使用<code>update</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE user SET password=PASSWORD(&#x27;123456&#x27;) WHERE user=&#x27;root&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h3 id="修改用户名"><a href="#修改用户名" class="headerlink" title="修改用户名"></a>修改用户名</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*相当于修改mysql.user这张存有用户信息的表，将ALEX修改为alex*/</span></span><br><span class="line">update mysql.user <span class="keyword">set</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;alex&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;ALEX&#x27;</span>;</span><br></pre></td></tr></table></figure>


<h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><h4 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h4><p>可授予用户列权限、表权限、数据库权限、用户权限等，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> priv_type <span class="keyword">ON</span> [object_type] &#123;表名<span class="operator">|</span>数据库名&#125; <span class="keyword">TO</span> 用户</span><br><span class="line">[IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>][<span class="keyword">WITH</span> <span class="keyword">grant</span> option];</span><br></pre></td></tr></table></figure>
<p><font color="#ff0000">说明：</font></p>
<p><code>object_type=TABLE|FUNCTION|PROCEDURE</code></p>
<p><font color="#ff0000">注：</font>若指定密码，则原密码将会被覆盖，如果权限授予一个不存在的用户，则MySQL会自动创建这个用户，但必须为该用户指定密码。</p>
<p><code>pri_type</code></p>
<p>列权限、表权限、数据库权限、用户权限参照<code>权限一览表</code></p>
<p>如果要授予所有权限，则用<code>ALL</code>或者<code>ALL PRIVILEGES</code>表示。</p>
<p><code>WITH GRANT OPTION</code></p>
<p>若加上了WITH GRANT OPTION子句，获得某种权限的用户还可以把这种权限再授予其他的用户。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="comment">/*说明：student是dbst数据库的一张表，需要先使用use dbst;选择该数据库，当然数据库和表都要先创建*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这条命令给予ALEX表student的权限*/</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> student <span class="keyword">to</span> ALEX<span class="variable">@LOCALHOST</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> update(name) <span class="keyword">on</span> student <span class="keyword">to</span> ALEX<span class="variable">@LOCALHOST</span>;</span><br><span class="line"><span class="comment">/*这条命令给予ALEX更新studnet表中name列的权限*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*?这条命令干嘛的？*/</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> DBST.<span class="operator">*</span> <span class="keyword">TO</span> ALEX<span class="variable">@LOCALHOST</span>;</span><br></pre></td></tr></table></figure>

<h4 id="查看权限："><a href="#查看权限：" class="headerlink" title="查看权限："></a>查看权限：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="keyword">user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> root<span class="variable">@localhost</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> ALEX<span class="variable">@LOCALHOST</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/6%E3%80%81%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/20211217095750.png"></p>
<h4 id="回收权限"><a href="#回收权限" class="headerlink" title="回收权限"></a>回收权限</h4><p>使用REVOKE命令可以回收授予的权限，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> priv_type <span class="keyword">ON</span> &#123;表名<span class="operator">|</span>数据库名&#125; <span class="keyword">FROM</span> 用户;</span><br><span class="line">或 </span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEDGES,<span class="keyword">GRANT</span> OPTION <span class="keyword">FROM</span> 用户;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">ON</span> student <span class="keyword">from</span> ALEX<span class="variable">@LOCALHOST</span>;</span><br></pre></td></tr></table></figure>

<p><font color="#ff0000">注：</font>只有拥有当前数据库全局CREATE或者UPDATE权限的用户才能使用REVOKE命令。</p>
<h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*创建user_1用户*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> user_1<span class="variable">@localhost</span> identified <span class="keyword">by</span> <span class="string">&#x27;1234&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改user_1用户密码 1234 成 123456*/</span></span><br><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> user_1<span class="variable">@localhost</span><span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改user_1用户名为user_2*/</span></span><br><span class="line">update mysql.user <span class="keyword">set</span> <span class="keyword">user</span><span class="operator">=</span>user_2 <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;user_1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*授予用户对DBEM数据库中employee表的查询、插入、修改、删除等操作*/</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">insert</span>,update,<span class="keyword">drop</span> <span class="keyword">on</span> dbem.employee <span class="keyword">to</span> user_1<span class="variable">@localhost</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*授予用户user_1对DBEM数据库中employee表的查询、插入、修改、删除权限，并允许其将权限授予给其他用户*/</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">insert</span>,update,<span class="keyword">drop</span> <span class="keyword">on</span> dbem.employee <span class="keyword">to</span> user_1<span class="variable">@localhost</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*回收user_1用户查询数据库dbem的employee表的权限*/</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> dbem.employee <span class="keyword">from</span> user_1<span class="variable">@localhost</span>;</span><br></pre></td></tr></table></figure>

<h3 id="权限一览表"><a href="#权限一览表" class="headerlink" title="权限一览表"></a>权限一览表</h3><table>
<thead>
<tr>
<th>语    句</th>
<th>用 户 权 限</th>
<th>数据库权限</th>
<th>表  权  限</th>
<th>列  权  限</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>INSERT</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>DELETE</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>UPDATE</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>REFERENCES</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>CREATE</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>ALTER</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>DROP</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>INDEX</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>CREATE TEMPORARY TABLES</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>CREATE VIEW</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>SHOW VIEW</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>CREATE ROUTINE</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>ALTER ROUTINE</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>EXECUTE ROUTINE</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>LOCK TABLES</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>CREATE USER</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>SHOW DATABASES</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>FILE</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>PROCESS</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>RELOAD</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>REPLICATION CLIENT</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>REPLICATION SLAVE</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>SUPER</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>USAGE</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
</tbody></table>
<hr>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><h3 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a><code>事务的概念</code></h3><p>事务由作为一个单独单元的一个或多个SQL语句组成。这个单元中的<br>SQL语句是相互依赖的，整个单元是不可分割的。如果单元中的一个语<br>句不能完成，整个单元就会回滚（撤销操作），所有影响到的数据将返<br>回到事务开始以前的状态。（银行交易、网上购物等）</p>
<h3 id="ACID原则"><a href="#ACID原则" class="headerlink" title="ACID原则"></a><code>ACID原则</code></h3><ul>
<li>原子性 Atomicity</li>
<li>一致性 Consistency</li>
<li>隔离性 Isolation</li>
<li>持久性 Durabili</li>
</ul>
<h3 id="并发控制问题"><a href="#并发控制问题" class="headerlink" title="并发控制问题"></a><code>并发控制问题</code></h3><pre><code>丢失修改：两个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，因此最后的更新将重写由其他事务所做的更新，导致数据丢失

脏读：一个事务正在访问数据，而其他事务正在更新该数据，但尚未提交，此时会发生脏读问题，即第一个事务所读取的数据是“脏”的

不可重复读：在一个事务内多次读同一数据，在该事务还没有结束时，另外的事务也访问该数据并对其做修改，从而导致第一个事务两次读取的数据不一样

幻读：当一个事务对某行执行了插入或删除操作时，由于该行在另外的事务读取的范围内，从而导致两次读取多出了一行或者消失了一行
</code></pre>
<p>对并发控制出现的问题，提出四个隔离级别</p>
<h3 id="四级隔离级别：定义用户之间隔离和交互的程度"><a href="#四级隔离级别：定义用户之间隔离和交互的程度" class="headerlink" title="四级隔离级别：定义用户之间隔离和交互的程度"></a><code>四级隔离级别</code>：定义用户之间隔离和交互的程度</h3><ul>
<li><p>读未提交(read uncommitted)：可以<code>读</code>到其他事务还<code>没有提交的数据</code>，仅避免丢失修改，会导致大量数据变化，一级封锁协议</p>
</li>
<li><p>读已提交(read committed)：可以<code>看</code>到其他事务添加的<code>新纪录</code>，而且其他事务对现存记录做出的修改一旦被提交，也可以看到，避免丢失修改和脏读，二级封锁协议</p>
</li>
<li><p>可重复读(repeatable read)：当前在执行的事务的变化无法被看到，同一事务中执行<code>select数次结果都相同</code>，避免丢失修改、脏读和不可重复读，增强的二级封锁协议</p>
</li>
<li><p>可串行化(serializable)：用户之间一个接一个执行事务，避免所有并发控制问题，最大限度的隔离，三级封锁协议</p>
</li>
</ul>
<p><font color="#ff0000">注：</font>MySQL默认为repeatable read隔离级别</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>丢失修改</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>X</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>读已提交</td>
<td>X</td>
<td>X</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>可重复读</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>可串行化</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
</tbody></table>
<pre><code>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。
</code></pre>
<h3 id="事务控制语句："><a href="#事务控制语句：" class="headerlink" title="事务控制语句："></a><code>事务控制语句：</code></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> 或 <span class="keyword">START</span> TRANSACTION 显式地开启一个事务；</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> 也可以使用 <span class="keyword">COMMIT</span> WORK，不过二者是等价的。<span class="keyword">COMMIT</span> 会提交事务，并使已对数据库进行的所有修改成为永久性的；</span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span> 也可以使用 <span class="keyword">ROLLBACK</span> WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</span><br><span class="line"></span><br><span class="line"><span class="keyword">SAVEPOINT</span> identifier，<span class="keyword">SAVEPOINT</span> 允许在事务中创建一个保存点，一个事务中可以有多个 <span class="keyword">SAVEPOINT</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> identifier 把事务回滚到标记点；</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p><code>MYSQL 事务处理主要有两种方法：</code></p>
<p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p>
<ul>
<li>BEGIN 开始一个事务</li>
<li>ROLLBACK 事务回滚</li>
<li>COMMIT 事务确认</li>
</ul>
<p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p>
<ul>
<li>SET AUTOCOMMIT=0 禁止自动提交</li>
<li>SET AUTOCOMMIT=1 开启自动提交</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a><code>例子</code></h3><p>假设dbem数据库的employee表有如下数据：</p>
<p><img src="/6%E3%80%81%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E5%92%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/20211217153708.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*以下涉及三个mysql账号登录，可以打开三个终端登录三个账号，也可以使用mysql workbench这个软件*/</span></span><br><span class="line"><span class="comment">/*在root登录情况下*/</span></span><br><span class="line"><span class="comment">/*创建用户clientA*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;clientA&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*授予操作DBEM数据库的权限*/</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> DBEM.<span class="operator">*</span> <span class="keyword">to</span> clientA<span class="variable">@localhost</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用clientA登录mysql*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置clientA的隔离级别为‘读已提交’*/</span></span><br><span class="line"><span class="keyword">set</span> session transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取消自动提交事务的功能，改为显示事务提交*/</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span><span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查看自动提交事务是否关闭，0关闭，1开启*/</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/*查看事务等级*/</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用clientA登录mysql，修改数据库dbem的salary表，salary有三个字段(employeeID,income,outcome)*/</span></span><br><span class="line">update dbem.salary <span class="keyword">set</span> income<span class="operator">=</span><span class="number">1000</span> <span class="keyword">where</span> employeeID<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*登录clientB，查看salary表，结果(1,1300,0)*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> salary <span class="keyword">where</span> employeeID<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*clientA提交事务*/</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*clientB，查看salary表，结果(1,1000,0)*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*若在clientA提交前，clientB也修改salary表会报错*/</span></span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>


<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><code>注意：</code>用户的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录。如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录。也可以指定某台机器可以远程登录。</p>
<p><code>flush privileges;</code>  刷新系统权限表</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>语义分析和中间代码生成</title>
    <url>/6%E3%80%81%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<p>编译原理    第六部分</p>
<span id="more"></span> 

<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>一张符号表的每一项（或称入口）包含两大栏（或称区段、字域），即名字栏和信息栏。</p>
<p>信息栏包含许多子栏和标志位，用来记录相应名字和种种不同属性，由于查填符号表一般是通过匹配名字来实现的，因此，名字栏也称主栏。主栏的内容称为关键字（key word）</p>
<p>在整个编译期间，对于符号表的操作大致可归纳为五类：</p>
<blockquote>
<p>对给定名字，查询名字是否已在表中；</p>
<p>往表中填入一个新的名字；</p>
<p>对给定名字，访问它的某些信息；</p>
<p>对给定名字，填写或更新它的某些信息；</p>
<p>删除一个或一组无用的项。</p>
<p>不同种类的表格所涉及的操作往往也是不同的。上述五个方面只是一些基本的共同操作。</p>
</blockquote>
<p>符号属性(信息）</p>
<blockquote>
<p>符号名 </p>
<p>符号的类型 </p>
<p>符号的存储类别 </p>
<p>符号的作用域及可视性 </p>
<p>符号变量的存储分配信息 </p>
<p>符号的其它属性 ：</p>
<ul>
<li>数组内情向量 </li>
<li>记录结构型的成员信息</li>
<li>函数及过程的形参 </li>
</ul>
</blockquote>
<p>符号表的组织</p>
<blockquote>
<p>由于处理对象的作用和作用域可以有多种，所以符号表也有多种组织方式。</p>
<p>按照处理对象的特点，符号表的组织方式一般可以分为直接方式和间接方式</p>
<p>符号表按照标识符的种属进行组织：根据符号属性相似程度分类组织成若干张表，每张表中记录的符号都有比较多的相同属性</p>
</blockquote>
<p>符号表项的组织传统上采用三种构造方法。即 线性法，二分法 及 散列法。</p>
<p>线性组织</p>
<blockquote>
<p>这种方法规定符号表中表项按它的符号被扫描到的先后顺序建立</p>
</blockquote>
<p>排序组织及二分法</p>
<blockquote>
<p>排序组织的符号表，就是在符号表中的表项按其符号的字符代码串的值的大小排列．</p>
<p>关于排序表的表项建立及符号查找，通常采用“二分法”．</p>
</blockquote>
<p>散列组织</p>
<blockquote>
<p>散列法又称为杂凑法或Hash法．散列法的基本思想是：设置一个足够大的空间M，构造一个散列函数Hash(Ki)，函数值的取值范围在0~M-1之间．这样查找Ki时，Hash(Ki)就决定了Ki在M中的位置．由此可见，构造Hash函数是散列法的关键问题．</p>
<p>构造Hash函数的方法，如，可以设M为素数，将Hash(Ki)定义为Ki/M的余数．</p>
</blockquote>
<h3 id="中间代码"><a href="#中间代码" class="headerlink" title="中间代码"></a>中间代码</h3><p>翻译为中间语言的好处：</p>
<ul>
<li>便于进行与机器无关的代码优化；</li>
<li>使编译程序改变目标机更容易；</li>
<li>使编译程序的结构在逻辑上更为简单明确，以中间语言为界面，编译前端和后端的接口更清晰。</li>
</ul>
<p>编译程序所使用的中间代码有多种形式。常见的有逆波兰式、三元式和树形、四元式表示。</p>
<p>逆波兰式</p>
<blockquote>
<p>这种表示法将运算对象写在前面，把运算符号写在后面，比如把a+b写成ab+，把a*b写成ab*，用这种表示法表示的表达式也称做后缀表达式</p>
</blockquote>
<p>三元式</p>
<blockquote>
<p>每个三元式由三个部分组成，分别是：</p>
<p>(算符op，第一运算对象ARG1，第二运算对象ARG2)</p>
<p>运算对象可能是源程序中的变量，也可能是某个三元式的结果，用三元式的编号表示。</p>
<p>对于一目算符op，只需选用一个运算对象，不妨规定只用ARG1。至于多目算符，可用若干个相继的三元式表示。</p>
</blockquote>
<p>树形表示</p>
<blockquote>
<img src="/6%E3%80%81%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/image-20220104120110825.png" alt="image-20220104120110825" style="zoom:67%;">
</blockquote>
<p>四元式</p>
<blockquote>
<p>四元式是一种比较普遍采用的中间代码形式。</p>
<p>四元式的四个组成成分是：</p>
<ul>
<li>算符op</li>
<li>第一运算对象ARG1</li>
<li>第二运算对象ARG2</li>
<li>运算结果RESULT</li>
</ul>
<p>运算对象和运算结果有时指用户自己定义的变量，有时指编译程序引进的临时变量。</p>
<p>四元式形式： (op ,arg1,arg2,result) </p>
<p>【例如】a=b * c+d*e的四元式为：</p>
<p>（1）（*，　b，　c，　T1）</p>
<p>（2）（*，　d，　e，　T2）</p>
<p>（3）（+，   T1， T2，    T3）</p>
<p>（4）（=，   T3， －，     a）</p>
<p>四元式表示很类似于三地址指令，确实，有时把这类中间表示称为“三地址代码”，因为这种表示可看作一种虚拟三地址机的通用汇编码，即这种虚拟机的每条“指令”包含操作符和三个地址，两个是为运算对象的，一个是为结果的。这种表示对于代码优化和目标代码生成都较有利</p>
</blockquote>
<p>简单赋值语句的翻译</p>
<blockquote>
<p>语义过程GEN表示产生一个四元式，并且填入四元式表中。</p>
<p>语义过程Newtemp表示生成一个临时变量，每调用一次，生成一新的临时变量。</p>
<p>语义变量E.place，表示存放E值的变量名在符号表的登录项或一整数码（若此变量是一个临时变量）。</p>
<p>语义变量Entry(id)回送标识符id在符号表中的入口地址。</p>
</blockquote>
<p>布尔表达式的翻译</p>
<blockquote>
<p>程序设计语言中的布尔表达式有两个作用</p>
<p>一是计算逻辑值</p>
<p>二是用做改变控制流语句中的条件表达式，如在if-then，if-then-else，或是while-do语句中那样</p>
<p>计算布尔表达式的值有两种办法</p>
<p>第一种办法，如同计算算术表达式一样，计算出各部分的真假值，最后计算出整个表达式的值</p>
<p>第二种办法，采取某种优化措施，只计算部分表达式</p>
</blockquote>
<p>拉链</p>
<blockquote>
<p>为了记录需回填地址的四元式，常采用一种“拉链”的办法。</p>
<p>把需回填E.TC的四元式拉成一条链子，把需回填E.FC的四元式拉成一条链子，分别称做”真”链和”假”链。</p>
</blockquote>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>存储空间组织</title>
    <url>/7%E3%80%81%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%BB%84%E7%BB%87/</url>
    <content><![CDATA[<p>编译原理    第七部分</p>
<span id="more"></span> 

<h3 id="数据空间"><a href="#数据空间" class="headerlink" title="数据空间"></a>数据空间</h3><p>数据空间包括：用户定义的各种类型的数据对象(变量和常数)所需的存储空间，作为保留中间结果和传递参数的临时工作单元，调用过程时所需的连接单元，以及组织输入/输出所需的缓冲区。</p>
<p>目标代码所占用空间的大小在编译时能确定。有些数据对象所占用的空间也能在编译时确定，其地址可以编译进目标代码中。而有些数据对象具有可变体积和待分配性质，无法在编译时确定存储空间的位置。</p>
<p>存储管理复杂程度取决于源语言本身，包括：</p>
<ul>
<li><p>允许的数据类型的多少</p>
</li>
<li><p>语言中允许的数据项是   </p>
<ul>
<li>静态确定</li>
<li>动态确定</li>
</ul>
</li>
<li><p>程序决定名字的作用域的规则和结构</p>
<ul>
<li>段结构</li>
<li>过程定义不嵌套，只允许过程递归调用                      </li>
<li>分程序结构 <ul>
<li>分程序嵌套</li>
<li>过程定义嵌套</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/7%E3%80%81%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%BB%84%E7%BB%87/image-20220104121803760.png" alt="image-20220104121803760"></p>
<p>数据空间的三种分配策略</p>
<p>运行时数据空间的三种分配策略：</p>
<ul>
<li>静态存储分配</li>
<li>动态存储分配    <ul>
<li>栈式动态存储分配</li>
<li>堆式动态存储分配</li>
</ul>
</li>
</ul>
<p>采用哪种分配策略是由源语言的语义决定的。</p>
<p>静态存储分配</p>
<blockquote>
<p>如果在编译时就能确定目标程序运行中所需要的全部数据空间的大小，则编译时就能安排好目标程序的全部数据空间，并能确定每个数据项的单元地址、存储空间，这种分配方法叫做静态存储分配</p>
</blockquote>
<p>动态存储分配</p>
<blockquote>
<p>如果一个程序设计语言允许递归过程、可变数组或允许用户自由申请和释放空间，那么，就需要采用动态存储管理技术。因为对于这种程序在编译时无法知道它在运行时需要多大的存储空间，它所需要的数据空间的大小需待程序运行时动态地确定。</p>
</blockquote>
<p>栈式存储分配</p>
<blockquote>
<p>在允许递归调用且每次调用都要重新分配局部变量的语言中，编译程序不能静态地分配活动记录。对于这种语言应该采用栈式存储分配，其分配策略是将整个存储空间设计成一个栈，每当调用一个过程时就将它的活动记录压入栈，在栈顶形成过程工作时的数据区，当过程结束时再将其活动记录弹出栈。</p>
<p>过程的活动记录AR(Activation Record)，是一段连续的存储区，用以存放过程的一次执行所需要的动态信息</p>
<p>栈式动态存储分配策略适用于PASCAL，C，ALGOL之类具有递归结构的语言的实现。</p>
</blockquote>
<p>简单栈式存储分配</p>
<blockquote>
<p>对于没有分程序结构，过程定义不允许嵌套但允许过程递归调用的语言，可以采用一种简单的栈式存储分配策略。</p>
<p>C语言就是满足上述特点的一种语言，其过程的活动记录一般采用如图所示的结构。</p>
<p>过程的每一个局部变量或形参在活动记录中的相对地址是确定的，因此可以知道程序运行时，变量和形参在栈上的绝对地址是：绝对地址＝活动记录基地址（SP）十相对地址</p>
</blockquote>
<p>堆式存储分配</p>
<blockquote>
<p>如果一种程序语言允许数据对象能够自由地分配和释放，那么由于空间的使用不一定按照“先申请后释放”的原则，这时栈式存储分配就不适用了。对于这种语言通常采用堆式存储分配方法。</p>
<p>堆式存储分配方法的基本思想是：一个程序开始执行时有很大一块存储空间，运行期间如果需要就从里面申请一块存储空间，使用完毕归还。</p>
<p>堆式存储分配最简单的实现方法是按定长进行分配。初始化时将堆存储空间分成若干个长度相等的块，按邻块的顺序把这些块链成一个链表。每次申请空间时就从链表最前面的未使用结点开始分配，归还时把结点插入链表，归还时最好保证第一个未使用的结点之后没有已分配的块。采用这种方式，编译程序不需要知道分配出去的存储块将存放何种类型的数据，用户可以根据需要使用整个存储块。</p>
<p>定长块管理实现起来比较方便，但是内存的使用效率偏低，堆式存储分配通常按变长块进行。按这种方法，初始化存储区时没有把空间分段，每次申请时都从空闲区分出满足要求的最小块；归还时，如果新归还的块能和现有的空闲块合并就把它们合成一块。如果有若干个空闲块满足需要时，通常采用以下几种不同的分配策略。</p>
<ul>
<li>首次匹配法</li>
<li>最优匹配法</li>
<li>最差匹配法</li>
</ul>
<p>无论采用哪种分配策略，当找不到合适的空闲区时，就要调用碎片收集程序，将无法使用的碎片连成一块以备使用</p>
</blockquote>
<p>临时变量的存储分配</p>
<blockquote>
<p>在产生中间代码时，为了暂存中间结果，编译程序会大量引进临时变量名。临时变量都是简单变量，它们的属性非常简单，因此没有登记到符号表内，而只要在它们出现的地方加上类型信息即可</p>
</blockquote>
<p>临时变量的分配原则</p>
<blockquote>
<p>一般的分配原则是：如果两个临时变量名的作用域不相交，则它们可以分配到同一单元中。</p>
<p>一个临时变量名自它第一次被赋值的地方起直至它最后一次被引用的地方止，这区间的程序所能到达的全体四元式构成了它的作用域。</p>
</blockquote>
<p>活动记录</p>
<blockquote>
<p>过程活动记录</p>
</blockquote>
<pre><code> 活动记录在运行栈上的分配

活动记录的结构

嵌套过程

Display表的结构和维护
</code></pre>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>C++存储类</title>
    <url>/C++%E5%AD%98%E5%82%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>auto，register，static，extern，mutable，thread_local</p>
<span id="more"></span>

<h1 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C++ 存储类"></a>C++ 存储类</h1><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>mutable</li>
<li>thread_local (C++11)</li>
</ul>
<p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p>
<h2 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h2><p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p>
<p>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C++17 中已删除这一用法。</p>
<p>根据初始化表达式自动推断被声明的变量的类型，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=<span class="number">3.14</span>;      <span class="comment">//double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  <span class="comment">//const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in"><span class="keyword">auto</span></span>(<span class="number">9</span>); <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3=<span class="string">&#x27;r&#x27;</span>;<span class="comment">//错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure>



<h2 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">register</span> <span class="keyword">int</span>  miles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
<h2 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>
<p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数声明 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>; <span class="comment">/* 全局变量 */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>; <span class="comment">// 局部静态变量</span></span><br><span class="line">    i++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;变量 i 为 &quot;</span> &lt;&lt; i ;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; , 变量 count 为 &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量 i 为 6 , 变量 count 为 9</span><br><span class="line">变量 i 为 7 , 变量 count 为 8</span><br><span class="line">变量 i 为 8 , 变量 count 为 7</span><br><span class="line">变量 i 为 9 , 变量 count 为 6</span><br><span class="line">变量 i 为 10 , 变量 count 为 5</span><br><span class="line">变量 i 为 11 , 变量 count 为 4</span><br><span class="line">变量 i 为 12 , 变量 count 为 3</span><br><span class="line">变量 i 为 13 , 变量 count 为 2</span><br><span class="line">变量 i 为 14 , 变量 count 为 1</span><br><span class="line">变量 i 为 15 , 变量 count 为 0</span><br></pre></td></tr></table></figure>



<h2 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>
<p>第一个文件：main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> count ;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">write_extern</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   count = <span class="number">5</span>;</span><br><span class="line">   <span class="built_in">write_extern</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个文件：support.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_extern</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ g++ main.cpp support.cpp -o write</span><br></pre></td></tr></table></figure>

<p>这会产生 <strong>write</strong> 可执行程序，尝试执行 <strong>write</strong>，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./write</span><br><span class="line">Count is 5</span><br></pre></td></tr></table></figure>



<h2 id="mutable-存储类"><a href="#mutable-存储类" class="headerlink" title="mutable 存储类"></a>mutable 存储类</h2><p><strong>mutable</strong> 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p>
<h2 id="thread-local-存储类"><a href="#thread-local-存储类" class="headerlink" title="thread_local 存储类"></a>thread_local 存储类</h2><p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p>
<p>thread_local 说明符可以与 static 或 extern 合并。</p>
<p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p>
<p>以下演示了可以被声明为 thread_local 的变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> x;  <span class="comment">// 命名空间下的全局变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">thread_local</span> std::string s; <span class="comment">// 类的static成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> std::string X::s;  <span class="comment">// X::s 是需要定义的</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> std::vector&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">// 本地变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 日期和时间</title>
    <url>/C++%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>C++的日期和时间继承自C</p>
<span id="more"></span>

<p>C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用<code>&lt;ctime&gt;</code>头文件。</p>
<p>有四个与时间相关的类型：<strong>clock_t、time_t、size_t</strong> 和 <strong>tm</strong>。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。</p>
<p>结构类型 <strong>tm</strong> 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> tm_sec;   <span class="comment">// 秒，正常范围从 0 到 59，但允许至 61</span></span><br><span class="line">  <span class="keyword">int</span> tm_min;   <span class="comment">// 分，范围从 0 到 59</span></span><br><span class="line">  <span class="keyword">int</span> tm_hour;  <span class="comment">// 小时，范围从 0 到 23</span></span><br><span class="line">  <span class="keyword">int</span> tm_mday;  <span class="comment">// 一月中的第几天，范围从 1 到 31</span></span><br><span class="line">  <span class="keyword">int</span> tm_mon;   <span class="comment">// 月，范围从 0 到 11</span></span><br><span class="line">  <span class="keyword">int</span> tm_year;  <span class="comment">// 自 1900 年起的年数</span></span><br><span class="line">  <span class="keyword">int</span> tm_wday;  <span class="comment">// 一周中的第几天，范围从 0 到 6，从星期日算起</span></span><br><span class="line">  <span class="keyword">int</span> tm_yday;  <span class="comment">// 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起</span></span><br><span class="line">  <span class="keyword">int</span> tm_isdst; <span class="comment">// 夏令时</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是 C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/cplusplus/c-function-time.html"><strong>time_t time(time_t *time);</strong></a></td>
<td>该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 -1。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cplusplus/c-function-ctime.html"><strong>char *ctime(const time_t *time);</strong></a></td>
<td>该返回一个表示当地时间的字符串指针，字符串形式 <em>day month year hours:minutes:seconds year\n\0</em>。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cplusplus/c-function-localtime.html"><strong>struct tm *localtime(const time_t *time);</strong></a></td>
<td>该函数返回一个指向表示本地时间的 <strong>tm</strong> 结构的指针。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cplusplus/c-function-clock.html"><strong>clock_t clock(void);</strong></a></td>
<td>该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 -1。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cplusplus/c-function-asctime.html"><strong>char * asctime ( const struct tm * time );</strong></a></td>
<td>该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\n\0。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cplusplus/c-function-gmtime.html"><strong>struct tm *gmtime(const time_t *time);</strong></a></td>
<td>该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cplusplus/c-function-mktime.html"><strong>time_t mktime(struct tm *time);</strong></a></td>
<td>该函数返回日历时间，相当于 time 所指向结构中存储的时间。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cplusplus/c-function-difftime.html"><strong>double difftime ( time_t time2, time_t time1 );</strong></a></td>
<td>该函数返回 time1 和 time2 之间相差的秒数。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cplusplus/c-function-strftime.html"><strong>size_t strftime();</strong></a></td>
<td>该函数可用于格式化日期和时间为指定的格式。</td>
</tr>
</tbody></table>
<p><strong>当前日期和时间</strong></p>
<p>下面的实例获取当前系统的日期和时间，包括本地时间和协调世界时（UTC）。</p>
<p><strong>实例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 基于当前系统的当前日期/时间</span></span><br><span class="line">   <span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 把 now 转换为字符串形式</span></span><br><span class="line">   <span class="keyword">char</span>* dt = <span class="built_in">ctime</span>(&amp;now);</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;本地日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 把 now 转换为 tm 结构</span></span><br><span class="line">   tm *gmtm = <span class="built_in">gmtime</span>(&amp;now);</span><br><span class="line">   dt = <span class="built_in">asctime</span>(gmtm);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;UTC 日期和时间：&quot;</span>&lt;&lt; dt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本地日期和时间：Thu Feb 10 16:15:26 2022</span><br><span class="line"></span><br><span class="line">UTC 日期和时间：Thu Feb 10 16:15:26 2022</span><br></pre></td></tr></table></figure>



<p><strong>使用结构 tm 格式化时间</strong></p>
<p><strong>tm</strong> 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。</p>
<p>在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -&gt; 运算符来访问结构成员。</p>
<p><strong>实例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 基于当前系统的当前日期/时间</span></span><br><span class="line">   <span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;1970 到目前经过秒数:&quot;</span> &lt;&lt; now &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   tm *ltm = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出 tm 结构的各个组成部分</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;年: &quot;</span>&lt;&lt; <span class="number">1900</span> + ltm-&gt;tm_year &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;月: &quot;</span>&lt;&lt; <span class="number">1</span> + ltm-&gt;tm_mon&lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;日: &quot;</span>&lt;&lt;  ltm-&gt;tm_mday &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;时间: &quot;</span>&lt;&lt; ltm-&gt;tm_hour &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">   cout &lt;&lt; ltm-&gt;tm_min &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">   cout &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1970 到目前经过秒数:1644509659</span><br><span class="line">年: 2022</span><br><span class="line">月: 2</span><br><span class="line">日: 10</span><br><span class="line">时间: 16:14:19</span><br></pre></td></tr></table></figure>



<p><strong>clock_t实例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">clock_t</span> <span class="keyword">start_t</span>, <span class="keyword">end_t</span>;</span><br><span class="line">   <span class="keyword">double</span> <span class="keyword">total_t</span>;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;程序启动，start_t = %ld\n&quot;</span>, <span class="keyword">start_t</span>);</span><br><span class="line">    </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;开始一个大循环，start_t = %ld\n&quot;</span>, <span class="keyword">start_t</span>);</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; <span class="number">10000000</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">end_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;大循环结束，end_t = %ld\n&quot;</span>, <span class="keyword">end_t</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">total_t</span> = (<span class="keyword">double</span>)(<span class="keyword">end_t</span> - <span class="keyword">start_t</span>) / CLOCKS_PER_SEC;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;CPU 占用的总时间：%f\n&quot;</span>, <span class="keyword">total_t</span>  );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;程序退出...\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">程序启动，start_t = 1541</span><br><span class="line">开始一个大循环，start_t = 1541</span><br><span class="line">大循环结束，end_t = 26010</span><br><span class="line">CPU 占用的总时间：0.024469</span><br><span class="line">程序退出...</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++补充</title>
    <url>/C++%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>学习C++过程中碰到的新的知识点，可能会记录在此</p>
<span id="more"></span>

<p>C++ setw() 函数用于设置字段的宽度，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setw(n)</span><br></pre></td></tr></table></figure>

<p>n 表示宽度，用数字表示。</p>
<p>setw() 函数只对紧接着的输出产生作用。</p>
<p>在头文件<code>&lt;iomanip&gt;</code>中</p>
<p><strong>当后面紧跟着的输出字段长度小于 n 的时候，在该字段前面用空格补齐，当输出字段长度大于 n 时，全部整体输出。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __gcd(value, value);	<span class="comment">//gcc编译器自带的函数，求最大公约数</span></span><br><span class="line"><span class="keyword">int</span> __builtin_popcount(value);		<span class="comment">//计算value的二进制形式中有多少个1，如32就是一个1</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">min</span>(value1, value2);</span><br><span class="line"><span class="built_in">max</span>(value1, value2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">min_element</span>(first, last, comp);</span><br><span class="line"><span class="built_in">max_element</span>(first, last, comp); </span><br></pre></td></tr></table></figure>



<h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">all_of</span> <span class="params">(InputIterator first, InputIterator last, UnaryPredicate pred)</span></span>;	序列中的所有元素都可以使谓词返回 <span class="function"><span class="literal">true</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">none_of</span> <span class="params">(InputIterator first, InputIterator last, UnaryPredicate pred)</span></span>; 序列中的无元素可以使谓词返回 <span class="function"><span class="literal">true</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">any_of</span> <span class="params">(InputIterator first, InputIterator last, UnaryPredicate pred)</span></span>; 序列中的任一元素可以使谓词返回 <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span>    <span class="comment">// std::all_of</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span>        <span class="comment">// std::array</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,8&gt; foo = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> ( std::<span class="built_in">all_of</span>(foo.<span class="built_in">begin</span>(), foo.<span class="built_in">end</span>(), [](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i%<span class="number">2</span>;&#125;) )</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;All the elements are odd numbers.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>查看类型名称 <code>typeid(value).name();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">	cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(n).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(string).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">(string)</span></span>; 	string 转 C风格字符串</span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="keyword">char</span>*);	c风格字符串 转 <span class="function">string</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;			c风格字符串 转 数字</span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(value)</span></span>;			数字转字符串</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">itoa</span><span class="params">(<span class="keyword">int</span> value,<span class="keyword">char</span>*string,<span class="keyword">int</span> radix)</span></span>;<span class="comment">//value: 要转换的整数，string: 转换后的字符串,radix: 转换进制数，如2,8,10,16 进制等。不是标准的，编译器可能不支持</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="数字和字符串转换"><a href="#数字和字符串转换" class="headerlink" title="数字和字符串转换"></a>数字和字符串转换</h3><p>数字转字符串</p>
<p><code>int sprintf ( char * str, const char * format, ... );</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1234321</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(str,<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;字符串&quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;长度&quot;</span>&lt;&lt;len&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">double</span> b=<span class="number">123.321</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(str1,<span class="string">&quot;%.3lf&quot;</span>,b);</span><br><span class="line">    <span class="keyword">int</span> len1=<span class="built_in">strlen</span>(str1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;字符串&quot;</span>&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;长度&quot;</span>&lt;&lt;len1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>stringsteam</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">123.32</span>;</span><br><span class="line">	string res;</span><br><span class="line">    stringstream ss;          <span class="comment">//定义流ss</span></span><br><span class="line">	ss &lt;&lt; a;                <span class="comment">//将数字a转化成流ss</span></span><br><span class="line">    ss &gt;&gt; res;                <span class="comment">//将流ss转化成字符串</span></span><br><span class="line">    <span class="comment">//string res = ss.str();</span></span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>字符串转数字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span> <span class="params">(<span class="keyword">const</span> string&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>; <span class="comment">// base是进制，默认10进制</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">stol</span> <span class="params">(<span class="keyword">const</span> string&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">stoll</span> <span class="params">(<span class="keyword">const</span> string&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>



<p><code>int sscanf ( const char * s, const char * format, ...);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[]=<span class="string">&quot;1234321&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">sscanf</span>(str,<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str1[]=<span class="string">&quot;123.321&quot;</span>;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="built_in">sscanf</span>(str1,<span class="string">&quot;%lf&quot;</span>,&amp;b);</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>stringstream</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a ;</span><br><span class="line">    string res= <span class="string">&quot;123.32&quot;</span>;</span><br><span class="line">    stringstream ss;  </span><br><span class="line">    ss &lt;&lt; res;                  </span><br><span class="line">    ss &gt;&gt; a;</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="清除键盘缓冲区"><a href="#清除键盘缓冲区" class="headerlink" title="清除键盘缓冲区"></a>清除键盘缓冲区</h3><p>C：<code>fflush(stdin);</code></p>
<p>C++：</p>
<ul>
<li><code>cin.clear();</code>  将错误标识置为0；</li>
<li><code>cin.sync();</code>     </li>
<li><code>cin.ignore(100, &#39;\n&#39;);</code> 丢弃字符直到遇到 ‘\n’ (包含 ‘\n’ )，如果丢去了100个字符还没遇到 ‘\n’ ，也停止，100是丢弃的最大字符数。</li>
</ul>
<p>C/C++还可以使用<code>while(getchar() != &#39;\n&#39;);</code>  推荐这个，前面的几个感觉有问题。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>数组作为形参传递到被调函数中，是以指针的形式指向数组的首地址，无法使用<code>sizeof</code>计算数组大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span> t[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(t) &lt;&lt; endl; 	<span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>*) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">	<span class="keyword">char</span> t[] = <span class="string">&quot;abcdfjie&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(t) &lt;&lt; endl;	<span class="comment">// 9</span></span><br><span class="line">	<span class="built_in">test</span>(t);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组批量赋值"><a href="#数组批量赋值" class="headerlink" title="数组批量赋值"></a>数组批量赋值</h3><p><strong><code>memset</code>函数</strong>，一般是用于对字符数组操作，头文件<code>&lt;cstring&gt;</code>或<code>&lt;string.h&gt;</code></p>
<p><code>void * memset ( void * ptr, int value, size_t num );</code> </p>
<p><code>ptr</code>数组的起始地址，<code>num</code>是有多长的字节设置为value，<code>value</code>是对num长度的字节都设置为value，范围0~255</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;almost every programmer should know memset!&quot;</span>;</span><br><span class="line">    <span class="built_in">memset</span> (str,<span class="string">&#x27;-&#x27;</span>,<span class="number">6</span>);</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;	<span class="comment">// ------ every programmer should know memset!</span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="number">5</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));	<span class="comment">// 没问题</span></span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">1</span>, <span class="number">5</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));	<span class="comment">// 结果不是&#123;1,1,1,1,1&#125; 因为一个int是4个字节，memset是对接下来20个字节每个字节都设为1，如果初始化为0就没问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**<code>fill函数</code>**，头文件<code>&lt;algorithm&gt;</code></p>
<p><code>void fill (ForwardIterator first, ForwardIterator last, const T&amp; val);</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[5];</span><br><span class="line">	fill(a, a+5, 1);	//a: 1,1,1,1,1</span><br><span class="line">	</span><br><span class="line">	vector&lt;int&gt; myvector (8);                       // myvector: 0 0 0 0 0 0 0 0</span><br><span class="line">	fill (myvector.begin(),myvector.begin()+4,5);   // myvector: 5 5 5 5 0 0 0 0</span><br><span class="line">	fill (myvector.begin()+3,myvector.end()-2,8);   // myvector: 5 5 5 8 8 8 0 0</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>C强制转换与C++强制转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(type-id)expression 	<span class="comment">//转换格式1</span></span><br><span class="line"></span><br><span class="line">type-id(expression) 	<span class="comment">//转换格式2</span></span><br></pre></td></tr></table></figure>

<p>c++除了能使用c语言的强制类型转换外，还新增了四种强制类型转换：<code>static_cast、dynamic_cast、const_cast、reinterpret_cast</code>，主要运用于继承关系类间的强制转化，语法为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;new_type&gt;      (expression)</span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;new_type&gt;     (expression) </span><br><span class="line"><span class="keyword">const_cast</span>&lt;new_type&gt;       (expression) </span><br><span class="line"><span class="keyword">reinterpret_cast</span>&lt;new_type&gt; (expression)</span><br></pre></td></tr></table></figure>

<p><code>new_type</code>为目标数据类型，<code>expression</code>为原始数据类型变量或者表达式</p>
<p><a href="https://www.cnblogs.com/chenyangchun/p/6795923.html">C++强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast - SpartacusIn21 - 博客园 (cnblogs.com)</a></p>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p><strong>优先队列</strong>具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的</p>
<p>和队列基本操作相同:</p>
<ul>
<li>top 访问队头元素</li>
<li>empty 队列是否为空</li>
<li>size 返回队列内元素个数</li>
<li>push 插入元素到队尾 (并排序)</li>
<li>emplace 原地构造一个元素并插入队列</li>
<li>pop 弹出队头元素</li>
<li>swap 交换内容</li>
</ul>
<p>定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Container</span> =</span> vector&lt;T&gt;,</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;<span class="keyword">typename</span> Container::value_type&gt; &gt; <span class="class"><span class="keyword">class</span> <span class="title">priority_queue</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>T——数据类型</li>
<li>Container——容器类型（必须是数组实现的容器如：vector，deque等，不能是list）</li>
<li>Compare——比较方式，自定义数据类型必要；基本数据类型默认是大顶堆</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序队列，小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//降序队列，大顶堆</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数</span></span><br><span class="line"><span class="comment">//greater是将大的元素放在前面：5 4 3 2 1	降序序列</span></span><br><span class="line"><span class="comment">//less相反：1 2 3 4 5	升序序列</span></span><br><span class="line"><span class="comment">//priority_queue对greater和less好像反了一样</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; pq; <span class="comment">//默认情况</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; pql;    <span class="comment">//降序</span></span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pqg; <span class="comment">//升序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i : &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">50</span>,<span class="number">34</span>&#125;) &#123;</span><br><span class="line">	    pq.<span class="built_in">push</span>(i);</span><br><span class="line">	    pql.<span class="built_in">push</span>(i);</span><br><span class="line">	    pqg.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a greater：&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> a[] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">50</span>,<span class="number">34</span>&#125;;</span><br><span class="line">	<span class="built_in">sort</span>(a, a + <span class="number">6</span>, greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">//按降序排序 greater</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">	    cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pq 默认：&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;    <span class="comment">//输出队列pq的元素 默认less</span></span><br><span class="line">	    cout&lt;&lt;pq.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;    <span class="comment">//队首元素</span></span><br><span class="line">	    pq.<span class="built_in">pop</span>();   <span class="comment">//出队</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pql less：&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>(!pql.<span class="built_in">empty</span>()) &#123;    <span class="comment">//输出队列pql的元素 less</span></span><br><span class="line">	    cout&lt;&lt;pql.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;    <span class="comment">//队首元素</span></span><br><span class="line">	    pql.<span class="built_in">pop</span>();   <span class="comment">//出队</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pqg greater：&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>(!pqg.<span class="built_in">empty</span>()) &#123;    <span class="comment">//输出队列pqg的元素 greater</span></span><br><span class="line">	    cout&lt;&lt;pqg.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;    <span class="comment">//队首元素</span></span><br><span class="line">	    pqg.<span class="built_in">pop</span>();   <span class="comment">//出队</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a greater：50 34 8 5 3 2 </span><br><span class="line">pq 默认：50 34 8 5 3 2 </span><br><span class="line">pql less：50 34 8 5 3 2 </span><br><span class="line">pqg greater：2 3 5 8 34 50 </span><br></pre></td></tr></table></figure>



<p>pair的比较，先比较第一个元素，第一个相等比较第二个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; a;</span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">push</span>(d);</span><br><span class="line">    a.<span class="built_in">push</span>(c);</span><br><span class="line">    a.<span class="built_in">push</span>(b);</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>



<p>对自定义数据类型，可以重载运算符&lt;，或写仿函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp1</span> //运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="keyword">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> tmp1&amp; a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp2</span> //重写仿函数，也可以是类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(tmp1 a, tmp1 b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">tmp1 <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    priority_queue&lt;tmp1&gt; d;</span><br><span class="line">    d.<span class="built_in">push</span>(b);</span><br><span class="line">    d.<span class="built_in">push</span>(c);</span><br><span class="line">    d.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; d.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        d.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span><br><span class="line">    f.<span class="built_in">push</span>(c);</span><br><span class="line">    f.<span class="built_in">push</span>(b);</span><br><span class="line">    f.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!f.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        f.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原文链接：<a href="https://blog.csdn.net/weixin_36888577/article/details/79937886">https://blog.csdn.net/weixin_36888577/article/details/79937886</a></p>
<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line">std::bitset&lt;8&gt; bs;      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板参数是一个size_t类型的数值（value），而非一个类型</span></span><br><span class="line"><span class="comment">// numeric_limits&lt;size_t&gt;::min() == 0</span></span><br><span class="line"><span class="comment">// std::bitset&lt;8&gt; 表示的二进制位为8位，</span></span><br><span class="line"><span class="comment">// 默认的构造函数将其初始为全0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; bs.<span class="built_in">to_ulong</span>() &lt;&lt; endl;      <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; bs.<span class="built_in">to_string</span>() &lt;&lt; endl;     <span class="comment">// 00000000</span></span><br></pre></td></tr></table></figure>

<p>bs[0]表示的是将该数值转换为二进制时的最末尾元素，而非首位（其意义和数组并不相同）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::bitset&lt;8&gt; bs;</span><br><span class="line"><span class="comment">//bs[0] = 1;            // 0000 0001</span></span><br><span class="line"><span class="comment">//bs[7] = 1;            // 1000 0000</span></span><br></pre></td></tr></table></figure>

<p>使用string对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">bs</span><span class="params">(<span class="string">&quot;00000111&quot;</span>)</span></span>;</span><br><span class="line">bs.<span class="built_in">to_ulong</span>();      <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p><strong>bitset的操作</strong></p>
<table>
<thead>
<tr>
<th><strong>成员函数</strong></th>
<th><strong>函数功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>bs.any()</td>
<td>是否存在值为1的二进制位</td>
</tr>
<tr>
<td>bs.none()</td>
<td>是否不存在值为1的二进制位 或者说是否全部位为0</td>
</tr>
<tr>
<td>bs.size()</td>
<td>位长，也即是非模板参数值</td>
</tr>
<tr>
<td>bs.count()</td>
<td>值为1的个数</td>
</tr>
<tr>
<td>bs.test(pos)</td>
<td>测试pos处的二进制位是否为1 与0做或运算</td>
</tr>
<tr>
<td>bs.set()</td>
<td>全部位置1</td>
</tr>
<tr>
<td>bs.set(pos)</td>
<td>pos位处的二进制位置1 与1做或运算</td>
</tr>
<tr>
<td>bs.reset()</td>
<td>全部位置0</td>
</tr>
<tr>
<td>bs.reset(pos)</td>
<td>pos位处的二进制位置0 与0做或运算</td>
</tr>
<tr>
<td>bs.flip()</td>
<td>全部位逐位取反</td>
</tr>
<tr>
<td>bs.flip(pos)</td>
<td>pos处的二进制位取反</td>
</tr>
<tr>
<td>bs.to_ulong()</td>
<td>将二进制转换为unsigned long输出</td>
</tr>
<tr>
<td>bs.to_string()</td>
<td>将二进制转换为字符串输出</td>
</tr>
<tr>
<td>~bs</td>
<td>按位取反 效果等效为bs.flip()</td>
</tr>
<tr>
<td>os &lt;&lt; b</td>
<td>将二进制位输出到os流 小值在右，大值在左</td>
</tr>
</tbody></table>
<p>原文链接：<a href="https://blog.csdn.net/lanchunhui/article/details/49644373"> C++基础——简单而强大的bitset_五道口纳什的博客-CSDN博客_c++bitset</a> </p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>DFA化简</title>
    <url>/DFA%E5%8C%96%E7%AE%80/</url>
    <content><![CDATA[<p>编译原理的词法分析实验：DFA化简</p>
<span id="more"></span>

<h2 id="DFA化简"><a href="#DFA化简" class="headerlink" title="DFA化简"></a>DFA化简</h2><ul>
<li>确定有穷自动机M的化简是指：寻找一个状态数比DFA M少的DFA M’，使得L(M)＝ L(M’)。</li>
<li>一个有穷自动机是化简了的，即是它没有多余状态，并且它的状态中没有两个是互相等价的。</li>
<li>一个有穷自动机可以通过消除多余状态和合并等价状态而转换成一个最小的与之等价的有穷自动机。</li>
</ul>
<p>多余状态</p>
<blockquote>
<p>所谓有穷自动机的多余状态，是指这样的状态：从有穷自动机<br>的初态出发，任何输入串也不能到达的那个状态；或者从这个状态<br>没有通路到达终态</p>
</blockquote>
<p>等价和可区别的</p>
<blockquote>
<p>等价：如果有穷自动机DFA M的两个状态s和t能够识别同样的符号串，则称状态s和t等价。<br><br>可区别的：如果有穷自动机DFA M的两个状态s和t不等价，<br>则称这两个状态是可区别的。<br><br>例如终态与非终态是可区别的。</p>
</blockquote>
<h2 id="DFA的最小化过程："><a href="#DFA的最小化过程：" class="headerlink" title="DFA的最小化过程："></a>DFA的最小化过程：</h2><p>最小状态DFA的含义:</p>
<ul>
<li>没有多余状态(死状态)</li>
<li>没有两个状态是互相等价（不可区别）</li>
</ul>
<h3 id="分割法"><a href="#分割法" class="headerlink" title="分割法"></a>分割法</h3><p>确定有限自动机M的化简的过程也就是其状态最少化过程：</p>
<pre><code>    一个DFA M的状态最少化过程是指将 M的状态集分割成一些不相交的子集，使得任何不同的两子集中的状态都是可区别的，而同一子集中的任何两个状态都是等价的。最后，在每个子集中选出一个代表，同时消去其它等价状态。
</code></pre>
<hr>
<p>例：化简下图的DFA</p>
<p><img src="/DFA%E5%8C%96%E7%AE%80/20211219135557.png"></p>
<p>DFA的状态集$K＝{0，1，2 ，3，4，5，6}$</p>
<ul>
<li>首先把$M$的状态$K$分为两组：</li>
</ul>
<blockquote>
<p>终态集$K1={3，4，5，6}$<br>非终态集$K2={0，1，2}$<br>显然$K1$与$K2$不等价。</p>
</blockquote>
<ul>
<li>试图$K1，K2$在中寻找一个子集和一个输入符号使得这个子集中的状态可区别的；若可区别，则再分割；继续，一直到不能再分割为止。</li>
</ul>
<blockquote>
<p>讨论终态集$K1={3，4，5，6}$ 是否可分割：<br>${3，4，5，6}_a \subset K1$<br>${3，4，5，6}_b \subset K1$<br>所以状态3，4，5，6均等价，因此$K1$不能再分割。</p>
</blockquote>
<blockquote>
<p>讨论非终态集$K2={0，1，2}$ 是否可分割：<br>${0，1，2}_a \subset {1，3}$<br>它既不属于$K2＝{0，1，2}$，也不属于$K1＝{3，4，5，6}\$<br>将其一分为二<br>${0，2}_a＝{1}\$<br>${1}_a＝{3}$</p>
</blockquote>
<p>$K21＝{1}$<br>$K22＝{0，2}$</p>
<blockquote>
<p>再讨论$K22={0，2}$ 是否可分割：<br>${0，2}_b ＝{2 ，5}$<br>而它未包括在$K1 ，K21与K22$中，故${0，2}$应一分为二：<br>$K221＝{0}$<br>$K222＝{2}$<br>所以$K$分为四组${3，4，5，6}，{0}，{1}，{2}$。每个组都不可再分。</p>
</blockquote>
<ul>
<li>最后，令状态3代表${3，4，5，6}$。把原来到达4，5，6的弧都导入3，并删除4，5，6状态。即可得到化简后的DFA。</li>
</ul>
<p><img src="/DFA%E5%8C%96%E7%AE%80/20211219141825.png"></p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>【问题描述】DFA化简问题的一种描述是：</p>
<p>编写一个程序，输入一个确定的有穷自动机（DFA），输出与DFA等价的最简的确定有穷自动机（DFA）。</p>
<p>【基本要求】设置DFA初始状态X，终态Y，过程态用数字表示：0 1 2 3………</p>
<p>【测试用例】<br>测试数据： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X X-a-&gt;0 X-b-&gt;1</span><br><span class="line">Y Y-a-&gt;0 Y-b-&gt;1</span><br><span class="line">0 0-a-&gt;0 0-b-&gt;2</span><br><span class="line">1 1-a-&gt;0 1-b-&gt;1</span><br><span class="line">2 2-a-&gt;0 2-b-&gt;Y</span><br></pre></td></tr></table></figure>
<p>输出结果应为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X X-a-&gt;0 X-b-&gt;X</span><br><span class="line">Y Y-a-&gt;0 Y-b-&gt;X</span><br><span class="line">0 0-a-&gt;0 0-b-&gt;2</span><br><span class="line">2 2-a-&gt;0 2-b-&gt;Y</span><br></pre></td></tr></table></figure>



<p>第一步，读取DFA</p>
<p><img src="/DFA%E5%8C%96%E7%AE%80/20211220172727.png"></p>
<p>第二步，分组</p>
<p><img src="/DFA%E5%8C%96%E7%AE%80/20211221111505.png"></p>
<p><img src="/DFA%E5%8C%96%E7%AE%80/image-20211230223852010.png" alt="image-20211230223852010"></p>
<p><img src="/DFA%E5%8C%96%E7%AE%80/image-20211230223858998.png" alt="image-20211230223858998"></p>
<p><img src="/DFA%E5%8C%96%E7%AE%80/image-20211230234549148.png" alt="image-20211230234549148"></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>MFC使用</title>
    <url>/MFC/</url>
    <content><![CDATA[<p>MFC的简单使用，学习自黑马程序员&amp;传智教育</p>
<span id="more"></span>



<p><code>Afx</code>开头的函数都是全局函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置窗体不可被拖大</span></span><br><span class="line"><span class="built_in">ModifyStyle</span>(WS_THICKFRAME, <span class="number">0</span>, SWP_FRAMECHANGED | SWP_DRAWFRAME);</span><br></pre></td></tr></table></figure>





<h3 id="创建简单窗口"><a href="#创建简单窗口" class="headerlink" title="创建简单窗口"></a>创建简单窗口</h3><p>创建项目-》Win32或Windows桌面应用程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxwin.h&gt;</span>  <span class="comment">//mfc头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> :</span> <span class="keyword">public</span> CWinApp   <span class="comment">//CWinApp应用程序类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//程序入口</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span> :</span> <span class="keyword">public</span> CFrameWnd   <span class="comment">//窗口框架类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyFrame</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mfc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyApp app;	<span class="comment">//全局应用程序变量，有且仅有一个</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">MyApp::InitInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyFrame* frame = <span class="keyword">new</span> MyFrame;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示和更新</span></span><br><span class="line">	frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOWNORMAL);</span><br><span class="line">	frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//保存指向应用程序的主窗口的指针</span></span><br><span class="line">    <span class="comment">//m_pMainWnd是CWinThread的数据成员，CWinApp是CWinThread的子类</span></span><br><span class="line">	m_pMainWnd = frame;		</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyFrame::<span class="built_in">MyFrame</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Create</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;mfc&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目-》配置属性-》高级-》MFC使用改成在共享DLL中使用MFC</p>
<h3 id="消息映射"><a href="#消息映射" class="headerlink" title="消息映射"></a>消息映射</h3><p>消息映射机制</p>
<ul>
<li>声明宏 写在<code>.h</code>中类中  <code>DECLARE_MESSAGE_MAP</code> </li>
<li>分界宏 写在.cpp中 <ul>
<li><code>BEGIN_MESSAGE_MAP( theClass, baseClass )</code> </li>
<li><code>END_MESSAGE_MAP( )</code> </li>
</ul>
</li>
<li>消息宏：写在 分界宏 中间<ul>
<li>鼠标左键按下 <code>ON_WM_LBUTTONDOWN()</code> </li>
<li>键盘 <code>ON_WM_CHAR()</code> </li>
<li>绘图 <code>ON_WM_PAINT()</code> </li>
</ul>
</li>
<li>函数原型 声明写到 <code>.h</code>中 （<code>afx_msg</code> 没有作用，是一个标识）<ul>
<li>鼠标左键按下 <code>afx_msg void OnLButtonDown(UINT, CPoint);</code> </li>
<li>键盘 <code>afx_msg void OnChar(UINT, UINT, UINT);</code></li>
<li>绘图 <code>afx_msg void OnPaint();</code> </li>
</ul>
</li>
<li>函数实现写到 <code>.cpp</code> 中</li>
</ul>
<h3 id="char-和CString"><a href="#char-和CString" class="headerlink" title="char*和CString"></a>char*和CString</h3><p><code>char* -&gt; CString</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* p3 = <span class="string">&quot;ccc&quot;</span>;</span><br><span class="line">CString str = <span class="built_in">CString</span>(p3);</span><br></pre></td></tr></table></figure>

<p><code>CString -&gt; char*</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CString <span class="title">str</span><span class="params">(_T<span class="string">&quot;ABC&quot;</span>)</span></span>;</span><br><span class="line">CStringA tmp;</span><br><span class="line">tmp = str;</span><br><span class="line"><span class="keyword">char</span>* p = tmp.<span class="built_in">GetBuffer</span>();</span><br></pre></td></tr></table></figure>



<h3 id="Windows字符集"><a href="#Windows字符集" class="headerlink" title="Windows字符集"></a>Windows字符集</h3><p>1）多字节（8位的ANSI字符集）：1个字符对应1个字节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> sz[] = <span class="string">&quot;ABCDEFG&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *psz = <span class="string">&quot;ABCDEFG&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(sz);</span><br></pre></td></tr></table></figure>

<p>2）宽字节（16位Unicode字符集）：ANSI字符集的超集，支持中文，日文等</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在字符串前加字母L表示将ANSI字符集转换成Unicode字符集</span></span><br><span class="line"><span class="keyword">wchar_t</span> wsz[] = <span class="string">L&quot;ABCDEFG&quot;</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> *pwsz[] = <span class="string">L&quot;ABCDEFG&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">wcslen</span>(wsz); <span class="comment">//获取宽字节字符串的长度</span></span><br></pre></td></tr></table></figure>

<p>3）<strong>TEXT</strong> (_T)宏</p>
<p>MFC中的TEXT宏可以自动适应字符类型，如果定义了预处理器程序符号_UNICODE，那么编译器将使用Unicode字符，如果没用定义该预处理器程序符号，那么编译器将使用ANSI字符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MessageBox</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;鼠标左键&quot;</span>));</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;鼠标左键&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>4）<strong>TCHAR</strong>类型</p>
<p>如果定义了_UNICODE符号TCHAR将变为wchar_t类型。如果没用定义_UNICODE符号，TCHAR将变为普通古老的char类型。</p>
<p>模态对话框</p>
<p><code>dlg.DoModal</code></p>
<p>非模态对话框</p>
<p><code>dlg.Create(IDD_SHOW);</code> 先创建窗口</p>
<p><code>dlg.ShowWindow(SW_SHOWNORMAL);</code> 再显示窗口</p>
<p>添加变量 以STATIC结尾的ID不可以添加变量，要先修改ID</p>
<p>设置内容 <code>SetWindowTextW()</code></p>
<p>获取内容 <code>GetWindowTextW()</code> </p>
<p>禁用按钮 <code>EnableWindow(FALSE)</code></p>
<p>获取大小 <code>GetWindowRect(Rect)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置静态控件窗口风格为位图居中显示</span></span><br><span class="line">m_pic.<span class="built_in">ModifyStyle</span>(<span class="number">0xf</span>, SS_BITMAP | SS_CENTERIMAGE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过路径获取bitmap句柄</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HBMP(filepath,width,height) (HBITMAP)LoadImage(AfxGetInstanceHandle(),filepath,IMAGE_BITMAP,width,height,LR_LOADFROMFILE|LR_CREATEDIBSECTION)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//宽高设置 按照图片大小设置</span></span><br><span class="line">CRect rect;</span><br><span class="line">m_pic.<span class="built_in">GetWindowRect</span>(rect);</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态控件设置bitmap</span></span><br><span class="line">m_pic.<span class="built_in">SetBitmap</span>(<span class="built_in">HBMP</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;./1.bmp&quot;</span>), rect.<span class="built_in">Width</span>(), rect.<span class="built_in">Height</span>()));</span><br></pre></td></tr></table></figure>



<p>编辑框 <code>Edit Control</code></p>
<ul>
<li>属性<ul>
<li><code>mutiline</code> 多行</li>
<li><code>want return</code> 想要返回</li>
<li>滚动条 水平 垂直</li>
</ul>
</li>
<li>默认小bug，点击回车就关闭对话框<ul>
<li>重写对话框的<code>OnOK</code> 把 <code>CDialog::OnOK()</code>注释掉</li>
</ul>
</li>
</ul>
<p>添加变量时 选择<code>value值</code></p>
<ul>
<li><code>UpdateData(FALSE);</code> 将value同步到控件中</li>
<li><code>UpdateData(TRUE);</code> 将控件的值同步到变量value中</li>
</ul>
<p>下拉框 <code>Combo Box</code></p>
<ul>
<li>属性中数据data   <code>;</code>分割</li>
<li>默认排序 <code>sort</code>  ，设置false不排序</li>
<li>类型默认<code>DropDown</code>可编辑  ， 设置<code>DropList</code>下拉列表不可编辑</li>
<li>添加 <code>AddString</code></li>
<li>删除 <code>DeleteString</code></li>
<li>插入 <code>InsertString</code></li>
<li>设置默认选项 <code>SetCurSel</code></li>
<li>获取当前索引 <code>GetCurSel</code></li>
<li>根据索引获取内容 <code>GetLBText</code> </li>
<li>控件事件 <code>CBN_SELCHANGE</code> <code>OnCbnSelchangexxx</code> </li>
</ul>
<p><code>CListCtrl</code>   list Control 列表控件</p>
<ul>
<li>属性 <code>view</code>  选择报表模式 <code>Report</code></li>
<li>添加表头 <code>InsertColumn</code></li>
<li>添加正文 从0开始索引</li>
<li>添加第0行0列 <code>InsertItem(0, CString)</code></li>
<li>添加第0行其它列 <code>setItemText(0, 列号, CString)</code></li>
<li>设置风格 整行选中 网格显示<ul>
<li><code>m_list.SetExtendedStyle(m_list.GetExtendedStyle() | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);</code></li>
</ul>
</li>
</ul>
<p><code>CTreeCtrl</code>树控件</p>
<ul>
<li>设置属性  行在根处、具有行、具有按钮</li>
<li>设置图片集合<ul>
<li><code>SetImageList(CImageList *, TVSIL_NORMAL);</code> </li>
</ul>
</li>
<li>添加节点 <code>InsertItem(节点名称, 显示图片, 选中后显示的图, 父节点);</code></li>
<li>设置默认节点 <code>SelectItem</code></li>
<li>节点切换 触发事件<ul>
<li><code>TVN_SELCHANGED</code> <code>OnTvnSelchangedTree1</code> </li>
<li>获取当前项 <code>GetSelectItem</code></li>
<li>获取内容 <code>GetItemText(item);</code> </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MFC</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title>C创建窗口</title>
    <url>/Win32API/</url>
    <content><![CDATA[<p>使用C语言创建一个简单窗口，学习自黑马程序员&amp;传智教育</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6 处理消息（窗口过程）</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//程序入口函数</span></span><br><span class="line"><span class="comment">//WINAPI宏定义 __stdcall，参数的传递顺序 从右到左依次入栈，并在函数返回前清空堆栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,    <span class="comment">//H 句柄  应用程序的实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,    <span class="comment">//前一个应用程序的句柄，在win32环境下，一般为NULL，不起作用</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,        <span class="comment">//char *argv[] </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nShowCmd)</span>           <span class="comment">//显示命令，最大化，最小化，正常</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1 设计窗口</span></span><br><span class="line">    <span class="comment">//2 注册窗口</span></span><br><span class="line">    <span class="comment">//3 创建窗口</span></span><br><span class="line">    <span class="comment">//4 显示和更新</span></span><br><span class="line">    <span class="comment">//5 通过循环取消息</span></span><br><span class="line">    <span class="comment">//6 处理消息（窗口过程）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 设计窗口</span></span><br><span class="line">    WNDCLASS wc;</span><br><span class="line">    wc.cbClsExtra = <span class="number">0</span>;  <span class="comment">//类的额外的内存</span></span><br><span class="line">    wc.cbWndExtra = <span class="number">0</span>;  <span class="comment">//窗口的额外内存</span></span><br><span class="line">    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);     <span class="comment">//设置背景</span></span><br><span class="line">    wc.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_HAND);      <span class="comment">//设置光标, 第一个参数为NULL，代表使用系统提供的光标</span></span><br><span class="line">    wc.hIcon = LoadIcon(<span class="literal">NULL</span>, IDI_ERROR);         <span class="comment">//设置图标,第一个参数为NULL，代表使用系统提供的图标</span></span><br><span class="line">    wc.hInstance = hInstance;                     <span class="comment">//应用程序示例句柄    传入WinMain中的形参即可</span></span><br><span class="line">    wc.lpfnWndProc = WindowProc;                  <span class="comment">//窗口过程 回调函数</span></span><br><span class="line">    wc.lpszClassName = TEXT(<span class="string">&quot;WIN&quot;</span>);      <span class="comment">//指定窗口类名称</span></span><br><span class="line">    wc.lpszMenuName = <span class="literal">NULL</span>;             <span class="comment">//菜单名称</span></span><br><span class="line">    wc.style = <span class="number">0</span>;                       <span class="comment">//显示风格，0代表默认</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 注册窗口</span></span><br><span class="line">    RegisterClass(&amp;wc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 创建窗口</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    lpClassName,   类名</span></span><br><span class="line"><span class="comment">    lpWindowName,  标题名</span></span><br><span class="line"><span class="comment">    dwStyle,       窗口样式  WS_OVERLAPPEDWINDOW </span></span><br><span class="line"><span class="comment">    x,             窗口水平坐标  CW_USEDEFAULT</span></span><br><span class="line"><span class="comment">    y,             窗口垂直坐标</span></span><br><span class="line"><span class="comment">    nWidth,        宽</span></span><br><span class="line"><span class="comment">    nHeight,       高  </span></span><br><span class="line"><span class="comment">    hWndParent,    父窗口  NULL</span></span><br><span class="line"><span class="comment">    hMenu,         菜单   NULL</span></span><br><span class="line"><span class="comment">    hInstance,     实例句柄 hInstance</span></span><br><span class="line"><span class="comment">    lpParam        附加值 NULL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    HWND hwnd = CreateWindow(wc.lpszClassName, TEXT(<span class="string">&quot;WINDOWS&quot;</span>), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 显示和更新</span></span><br><span class="line">    ShowWindow(hwnd, SW_SHOWNORMAL);</span><br><span class="line">    UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5 通过循环取消息</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    HWND        hwnd;   主窗口句柄</span></span><br><span class="line"><span class="comment">    UINT        message; 具体消息名称</span></span><br><span class="line"><span class="comment">    WPARAM      wParam;  附加消息 键盘消息</span></span><br><span class="line"><span class="comment">    LPARAM      lParam;  附加消息 鼠标消息</span></span><br><span class="line"><span class="comment">    DWORD       time;    消息产生时间</span></span><br><span class="line"><span class="comment">    POINT       pt;      附加消息 鼠标消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        _Out_ LPMSG lpMsg,     消息</span></span><br><span class="line"><span class="comment">        _In_opt_ HWND hWnd,    捕获窗口，填NULL代表捕获所有的窗口</span></span><br><span class="line"><span class="comment">        _In_ UINT wMsgFilterMin,  最小和最大的过滤消息 一般填0</span></span><br><span class="line"><span class="comment">        _In_ UINT wMsgFilterMax);  填0代表捕获所有消息</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>) == FALSE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不为FALSE</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//翻译消息 </span></span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分发消息</span></span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6 处理消息（窗口过程）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//6 处理消息（窗口过程）</span></span><br><span class="line"><span class="comment">//CALLBACK 宏定义 __stdcall，参数的传递顺序 从右到左依次入栈，并在函数返回前清空堆栈</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hwnd,   <span class="comment">//消息所属的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uMsg,   <span class="comment">//具体消息名称 WM_XXXX消息名</span></span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,  <span class="comment">//键盘附加消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam   <span class="comment">//鼠标附加消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:  <span class="comment">//点击窗口的关闭</span></span><br><span class="line">        DestroyWindow(hwnd);  <span class="comment">//DestroyWindow发送另一个消息 WM_DESTROY</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);   </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:  <span class="comment">//鼠标左键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xPos = LOWORD(lParam);</span><br><span class="line">        <span class="keyword">int</span> yPos = HIWORD(lParam);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        wsprintf(buf, TEXT(<span class="string">&quot;x = %d y = %d&quot;</span>), xPos, yPos);</span><br><span class="line">        MessageBox(hwnd, buf, TEXT(<span class="string">&quot;鼠标左键按下&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> WM_KEYDOWN: <span class="comment">//键盘</span></span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(hwnd, TEXT(<span class="string">&quot;键盘按下&quot;</span>), TEXT(<span class="string">&quot;键盘按下&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT: <span class="comment">//绘图</span></span><br><span class="line">    &#123;</span><br><span class="line">        PAINTSTRUCT ps; <span class="comment">//绘图结构体</span></span><br><span class="line">        HDC hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">        TextOut(hdc, <span class="number">100</span>, <span class="number">100</span>, TEXT(<span class="string">&quot;HELLO&quot;</span>), <span class="built_in">strlen</span>(<span class="string">&quot;HELLO&quot;</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值默认处理方式</span></span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MFC</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title>base64</title>
    <url>/base64/</url>
    <content><![CDATA[<p>使用C++实现base64伪加密</p>
<span id="more"></span>

<h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2><h3 id="编码原理"><a href="#编码原理" class="headerlink" title="编码原理"></a>编码原理</h3><p>将其它编码转化为如下编码</p>
<table>
<thead>
<tr>
<th align="center">Value</th>
<th align="center">Char</th>
<th align="center">Value</th>
<th align="center">Char</th>
<th align="center">Value</th>
<th align="center">Char</th>
<th align="center">Value</th>
<th align="center">Char</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">A</td>
<td align="center">16</td>
<td align="center">Q</td>
<td align="center">32</td>
<td align="center">g</td>
<td align="center">48</td>
<td align="center">w</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">B</td>
<td align="center">17</td>
<td align="center">R</td>
<td align="center">33</td>
<td align="center">h</td>
<td align="center">49</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">C</td>
<td align="center">18</td>
<td align="center">S</td>
<td align="center">34</td>
<td align="center">i</td>
<td align="center">50</td>
<td align="center">y</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">D</td>
<td align="center">19</td>
<td align="center">T</td>
<td align="center">35</td>
<td align="center">j</td>
<td align="center">51</td>
<td align="center">z</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">E</td>
<td align="center">20</td>
<td align="center">U</td>
<td align="center">36</td>
<td align="center">k</td>
<td align="center">52</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">F</td>
<td align="center">21</td>
<td align="center">V</td>
<td align="center">37</td>
<td align="center">l</td>
<td align="center">53</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">G</td>
<td align="center">22</td>
<td align="center">W</td>
<td align="center">38</td>
<td align="center">m</td>
<td align="center">54</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">H</td>
<td align="center">23</td>
<td align="center">X</td>
<td align="center">39</td>
<td align="center">n</td>
<td align="center">55</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">I</td>
<td align="center">24</td>
<td align="center">Y</td>
<td align="center">40</td>
<td align="center">o</td>
<td align="center">56</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">J</td>
<td align="center">25</td>
<td align="center">Z</td>
<td align="center">41</td>
<td align="center">p</td>
<td align="center">57</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">K</td>
<td align="center">26</td>
<td align="center">a</td>
<td align="center">42</td>
<td align="center">q</td>
<td align="center">58</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">L</td>
<td align="center">27</td>
<td align="center">b</td>
<td align="center">43</td>
<td align="center">r</td>
<td align="center">59</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">M</td>
<td align="center">28</td>
<td align="center">c</td>
<td align="center">44</td>
<td align="center">s</td>
<td align="center">60</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">N</td>
<td align="center">29</td>
<td align="center">d</td>
<td align="center">45</td>
<td align="center">t</td>
<td align="center">61</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">O</td>
<td align="center">30</td>
<td align="center">e</td>
<td align="center">46</td>
<td align="center">u</td>
<td align="center">62</td>
<td align="center">+</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">P</td>
<td align="center">31</td>
<td align="center">f</td>
<td align="center">47</td>
<td align="center">v</td>
<td align="center">63</td>
<td align="center">/</td>
</tr>
</tbody></table>
<p><strong>步骤</strong>：</p>
<ol>
<li>将所有字符转化为ASCII码</li>
<li>将ASCII码转化为8位二进制</li>
<li>每3位ASCII码（即24位二进制）为一组，最后一组若不足24位，则补0补齐</li>
<li>重新分组，每6位二进制为一个字符，对应上表的字符（$2^6-1=63$）</li>
<li>最后一组若有字符的值为0，且其6位二进制都是补0补足的，则其所对应的字符为<code>=</code>而不是<code>A</code> </li>
</ol>
<p><strong>示例</strong>：（有一定的规律）</p>
<ul>
<li>输入：<code>a</code></li>
<li>转化为二进制：   <code>01100001</code>  （8位）</li>
<li>补0：    <code>01100001 00000000 00000000</code>   补了16个0</li>
<li>分组：  <code>011000 010000 000000 000000</code>  （后两个字符不是<code>AA</code>，是<code>==</code>，0全部是补足的）</li>
<li>对应的base64编码： <code>YQ==</code> </li>
</ul>
<ul>
<li>输入：<code>abc</code></li>
<li>二进制： <code>01100001 01100010 01100011</code> </li>
<li>不需要补0</li>
<li>分组：    <code>011000 010110 001001 100011</code> </li>
<li>对应base64编码：<code>YWJj</code> </li>
</ul>
<ul>
<li>输入：<code>abcde</code></li>
<li>二进制： <code>01100001 01100010 01100011 01100100 01100101</code> </li>
<li>补0：      <code>01100001 01100010 01100011 01100100 01100101 00000000</code>  补了8个0</li>
<li>分组：    <code>011000 010110 001001 100011 011001 000110 010100 000000</code> 最后一个分组的0都是补足的</li>
<li>对应base64编码：<code>YWJjZGU=</code> </li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//base64.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string to_base64 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入字符串 并转化为 二进制序列 存入字符串bits</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strToBits</span><span class="params">(string &amp;bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">	cin&gt;&gt;str;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c : str) </span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="function">bitset&lt;8&gt; <span class="title">bs</span><span class="params">(c)</span></span>;</span><br><span class="line">	    bits += bs.<span class="built_in">to_string</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6位一组进行分组，转化为base64编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">group</span><span class="params">(string &amp;bits, string &amp;encryptStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//若bits长度不是6的倍速，补0</span></span><br><span class="line">    <span class="keyword">int</span> sur = bits.<span class="built_in">size</span>() % <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span>(sur != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        bits += <span class="built_in">string</span>(<span class="number">6</span> - sur, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将bits中的二进制每6位一个字符转化位base64编码字符，存入字符串encryptStr中</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos &lt;= bits.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">bitset&lt;6&gt; <span class="title">bs</span><span class="params">(bits.substr(pos - <span class="number">6</span>, pos))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> temp = bs.<span class="built_in">to_ulong</span>();</span><br><span class="line">        encryptStr += to_base64[temp];</span><br><span class="line">        pos += <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若得到的encryptStr不是4的倍数，补=</span></span><br><span class="line">    sur = encryptStr.<span class="built_in">size</span>() % <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(sur != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        encryptStr += <span class="built_in">string</span>(<span class="number">4</span> - sur, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string bits;</span><br><span class="line">	<span class="built_in">strToBits</span>(bits);</span><br><span class="line">	string encryptStr;</span><br><span class="line">	<span class="built_in">group</span>(bits, encryptStr);</span><br><span class="line">    cout&lt;&lt;encryptStr&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在linux上使用<code>g++</code>编译链接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yang@Ubuntu18:~$ g++ -o base64 base64.cpp</span><br><span class="line">yang@Ubuntu18:~$ ./base64</span><br><span class="line">yang</span><br><span class="line">eWFuZw==</span><br><span class="line">yang@Ubuntu18:~$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 试了一下，中文也行</span></span><br><span class="line">yang@Ubuntu18:~$ ./base64</span><br><span class="line">我的世界你不懂</span><br><span class="line">5oiR55qE5LiW55WM5L2g5LiN5oeC</span><br><span class="line">yang@Ubuntu18:~$</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU和Makefile</title>
    <url>/gcc%E5%92%8Cgdb/</url>
    <content><![CDATA[<p>GCC，GDB，Makefile的quickstart</p>
<p>快速入门后最好是看官方文档系统学习</p>
<span id="more"></span>

<h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><blockquote>
<p>When you invoke GCC, it normally does preprocessing, compilation, assembly and linking.</p>
</blockquote>
<p>四个过程：</p>
<ul>
<li>预处理 <code>gcc -E test.c -o test.i</code>  将<code>.c .h</code>文件预处理为<code>.i</code>文件    C/C++的语言代码</li>
<li>编译 <code>gcc -S test.i -o test.s</code>      生成汇编文件<code>.s</code>              汇编语言代码</li>
<li>汇编  <code>gcc -c test.s -o test.o</code>     将汇编文件编译为目标文件<code>.o</code> <code>.obj</code>      二进制</li>
<li>链接 <code>gcc test.o -o test</code>        生成可执行文件 <code>.exe</code> <code>.elf</code></li>
</ul>
<p>直接生成可执行文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gcc test.c -o test <span class="comment">//如果未指定输出文件名称，默认输出为a.out。</span></span><br></pre></td></tr></table></figure>

<p>编译优化指令，有四个级别0~3,级别越高优化越好，但编译时间越长，中间代码可读性越差。0级无优化效果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gcc <span class="number">-01</span> test.c -o test</span><br></pre></td></tr></table></figure>



<h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p><a href="https://sourceware.org/gdb/?msclkid=a7109ca4b19211ec93e50bc84cb80734">GDB: The GNU Project Debugger (sourceware.org)</a> </p>
<p><strong>1、基本命令</strong></p>
<p>若要使用gdb调试程序，在编译源代码时必须带上**<code>-g</code>**参数 ：<code>gcc -g hello.c -o hello.out</code></p>
<p><strong>进入gdb交互界面</strong>：<code>gdb .out文件</code> </p>
<ul>
<li>没有调试信息 <code>Reading symbols from base64...(no debugging symbols found)...done.</code></li>
<li>可以调试 <code>Reading symbols from test.out...done.</code></li>
</ul>
<p>也可以使用<code>readelf -S 文件名 | grep debug</code>查看是否能调试</p>
<p><code>start</code>     运行程序，停在第一执行语句</p>
<p><code>break b</code>        打断点    行号 或 函数名   或 文件名:行号</p>
<ul>
<li><code>b 12</code></li>
<li><code>b main</code></li>
<li><code>b test.c:main</code></li>
<li><code>b 12 if num&gt;0 </code>    # 设置程序在断点停止的条件</li>
<li><code>info breakpoints</code> 查看所有断点，会显示断点编号Num</li>
<li><code>delete 1</code> 删除编号为1的断点</li>
</ul>
<p><code>run r</code>           运行程序</p>
<p><code>print p</code>      打印变量的值，或变量的地址</p>
<ul>
<li><code>print a</code> 查看变量a的值</li>
<li><code>print &amp;a</code> 查看变量a的地址</li>
<li><code>print *a</code> 查看指针a指向的内容</li>
<li><code>print &#39;test.c&#39;::i</code></li>
<li><code>print &#39;sum&#39;::i</code> </li>
</ul>
<p><code>continue c</code>          从断点处继续运行</p>
<p><code>next n</code>                       单步调试（逐过程，函数直接执行）</p>
<p><code>step s</code>                 单步执行（逐语句，进入函数内部）</p>
<p><code>list l</code>             查看源代码</p>
<ul>
<li><code>list 6,21</code> 列出6到21行的代码</li>
<li><code>list test.c:main</code> 列出test.c文件的main函数</li>
<li></li>
</ul>
<p><code>quit q</code>             退出gdb交互界面</p>
<p><code>help [name]</code>           查看命令的帮助</p>
<p><code>info</code>          查看信息</p>
<ul>
<li><code>info breakpoints</code> 查看断点信息</li>
</ul>
<p><strong>2、调试core文件</strong></p>
<p>编译没有问题，运行程序崩溃</p>
<p>1）先修改shell限制</p>
<img src="/gcc%E5%92%8Cgdb/image-20220401172548704.png" alt="image-20220401172548704" style="zoom:80%;">

<p><code>ulimit -c unlimited</code></p>
<p>2）更改<code>core dump</code>生成路径</p>
<p>core dump默认会生成在程序的工作目录，但是有些程序存在切换目录的情况，导致core dump生成的路径没有规律</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> /data/coredump/core.%e.%p&gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>

<ul>
<li>更改core文件生成路径，放在<code>/date/coredump</code>文件夹中（要先创建文件夹）</li>
<li><code>%e</code>表示程序名，<code>%p</code>表示进程id</li>
</ul>
<p>不能生成core文件，<a href="https://blog.csdn.net/qq_35621436/article/details/120870746">https://blog.csdn.net/qq_35621436/article/details/120870746</a></p>
<p><strong>3、调试正在运行的程序</strong></p>
<p>后台运行 <code>./test.out &amp;</code> 有输出的话：<code>nohup ./test.out &amp;</code></p>
<p>查看进程PID <code>ps -ef | grep 文件名</code></p>
<p><code>gdb -p 进程号</code> 可能需要root权限</p>
<p><a href="https://blog.csdn.net/chen1415886044/article/details/105094688?ops_request_misc=%7B%22request_id%22:%22164879780516780255231994%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164879780516780255231994&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105094688.142%5Ev5%5Epc_search_result_control_group&utm_term=gdb&spm=1018.2226.3001.4187">GDB调试指南(入门，看这篇够了)_程序猿编码的博客-CSDN博客_gdb调试</a></p>
<h3 id="makefile入门"><a href="#makefile入门" class="headerlink" title="makefile入门"></a>makefile入门</h3><p><a href="https://seisman.github.io/how-to-write-makefile/overview.html#">概述 — 跟我一起写Makefile 1.0 文档 (seisman.github.io)</a></p>
<p><a href="https://blog.csdn.net/whitefish520/article/details/103968609">(18条消息) 跟我一起写 Makefile（完整版）_FixCarMaster的博客-CSDN博客_跟我一起写makefile</a></p>
<p>安装<code>sudo apt install make</code> </p>
<p>1、简单使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标:依赖</span><br><span class="line">	命令</span><br></pre></td></tr></table></figure>

<p>伪目标使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.PHONY:</span><br><span class="line">伪目标:</span><br><span class="line">	命令</span><br></pre></td></tr></table></figure>

<p>示例：<code>clearAll</code> 和 <code>clear</code> 就是伪目标</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注释</span></span><br><span class="line"><span class="comment"># 文件名就是Makefile</span></span><br><span class="line"><span class="section">hello:hello.o</span></span><br><span class="line">        g++ hello.o -o hello</span><br><span class="line"></span><br><span class="line"><span class="section">hello.o:hello.s</span></span><br><span class="line">        g++ -c hello.s -o hello.o</span><br><span class="line"></span><br><span class="line"><span class="section">hello.s:hello.i</span></span><br><span class="line">        g++ -S hello.i -o hello.s</span><br><span class="line"></span><br><span class="line"><span class="section">hello.i:hello.cpp</span></span><br><span class="line">        g++ -E hello.cpp -o hello.i</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:</span></span><br><span class="line"><span class="section">clearAll:</span></span><br><span class="line">        rm hello.o hello.i hello.s hello</span><br><span class="line"></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">        rm hello.o hello.i hello.s</span><br></pre></td></tr></table></figure>

<p>使用Makefile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make hello</span><br><span class="line">g++ -E hello.cpp -o hello.i</span><br><span class="line">g++ -S hello.i -o hello.s</span><br><span class="line">g++ -c hello.s -o hello.o</span><br><span class="line">g++ hello.o -o hello</span><br><span class="line">$ make clearAll</span><br><span class="line">rm hello.o hello.i hello.s hello</span><br></pre></td></tr></table></figure>

<p>2、变量</p>
<ul>
<li>赋值 =     </li>
<li>追加 +=       </li>
<li>常量 := </li>
</ul>
<p>使用变量 <code>$(变量名)</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line">CC := g++</span><br><span class="line">target = hello</span><br><span class="line">reply = hello.o</span><br><span class="line">source = hello.cpp</span><br><span class="line">remove += <span class="variable">$(reply)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(reply)</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(reply)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(reply)</span>:<span class="variable">$(source)</span></span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$(source)</span> -o <span class="variable">$(reply)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:</span></span><br><span class="line"><span class="section">clearAll:</span></span><br><span class="line">        rm <span class="variable">$(remove)</span> hello</span><br><span class="line"></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">        rm <span class="variable">$(remove)</span></span><br></pre></td></tr></table></figure>



<p>3、通配符</p>
<p><code>%.c</code> <code>%.o</code> 任意的<code>.c</code>或<code>.o</code>文件   <code>*.c *.o</code> 所有的 <code>.c .o</code>文件</p>
<p><code>$^</code> 所有的依赖文件   <code>$@</code>所有的依赖文件    <code>$&lt;</code>第一个依赖文件</p>
<p>4、函数</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>git访问慢</title>
    <url>/git%E8%AE%BF%E9%97%AE%E6%85%A2/</url>
    <content><![CDATA[<p>git访问慢的解决方法</p>
<span id="more"></span>

<p>CDN，Content Distribute Network，可以直译成内容分发网络，CDN解决的是如何将数据快速可靠从源站传递到用户的问题。用户获取数据时，不需要直接从源站获取，通过CDN对于数据的分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的。</p>
<p>为什么访问速度慢、下载慢？</p>
<p>答：github的CDN被某墙屏了，由于网络代理商的原因，所以访问下载很慢。ping github.com 时，速度只有300多ms。</p>
<p>第一种：</p>
<p>绕过dns解析，在本地直接绑定host，该方法也可加速其他因为CDN被屏蔽导致访问慢的网站。</p>
<blockquote>
<p>去<a href="https://www.ipaddress.com/%E8%BE%93%E5%85%A5raw.githubusercontent.com%E6%9F%A5%E8%AF%A2%E5%88%B0%E7%9C%9F%E5%AE%9EIP%E5%9C%B0%E5%9D%80">https://www.ipaddress.com/输入raw.githubusercontent.com查询到真实IP地址</a>  xxx.xxx.xxx.xxx</p>
</blockquote>
<blockquote>
<p>Windows系统下，找到C:\Windows\System32\drivers\etc这个目录下的hosts文件</p>
<p>添加 xxx.xxx.xxx.xxx raw.githubusercontent.com 到hosts文件</p>
</blockquote>
<p>打开cmd</p>
<p>输入<code>ipconfig /flushdns</code></p>
<p>第二种：</p>
<p>使用浏览器插件<br>似乎只能加快下载速度，访问速度还是比较随缘</p>
<p>第三种：</p>
<p>使用github加速器  <a href="https://github.com/dotnetcore/FastGithub">dotnetcore/FastGithub: github加速神器，解决github打不开、用户头像无法加载、releases无法上传下载、git-clone、git-pull、git-push失败等问题</a></p>
<p>第四种：</p>
<p>梯子</p>
<p>第五种</p>
<p>找国内镜像文件</p>
<p><a href="https://hub.fastgit.org/">https://hub.fastgit.org/</a>    不要登录，小心被盗号</p>
<p>例如：将<a href="https://github.com/tesseract-ocr/tessdata/blob/master/chi_sim.traineddata">https://github.com/tesseract-ocr/tessdata/blob/master/chi_sim.traineddata</a> </p>
<p>的 <a href="https://github.com/">https://github.com/</a>  换成 <a href="https://hub.fastgit.org/">https://hub.fastgit.org/</a> </p>
<p>即：<a href="https://hub.fastgit.org/tesseract-ocr/tessdata/blob/master/chi_sim.traineddata">https://hub.fastgit.org/tesseract-ocr/tessdata/blob/master/chi_sim.traineddata</a> </p>
<p>————————————————<br>参考链接：<a href="https://blog.csdn.net/u013517229/article/details/81351885">https://blog.csdn.net/u013517229/article/details/81351885</a></p>
<p>控制面板-》网络和Internet-》网络和共享中心-》单击WiFi-》属性-》Internet协议4(TCP/IPV4)-》属性-》DNS服务器地址</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo个人博客</title>
    <url>/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>hexo和github搭建个人博客</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以下命令在cmd执行</span><br><span class="line">若报错：&#x27;git&#x27; 不是内部或外部命令，也不是可运行的程序</span><br><span class="line">改用git bash执行命令，或将git添加到环境变量，即git安装文件夹下的bin文件</span><br><span class="line"></span><br><span class="line">（查看hero官方文档教程https://hexo.io/zh-cn/docs/）</span><br><span class="line">1、下载nodejs</span><br><span class="line">	（最好不要下最新的nodejs，后面可能会出错，可以查看hero官方文档看对应版本）</span><br><span class="line">	也可以使用 nvs(Node Version Switcher) 或 nvm(Node Version Manager) 管理nodejs</span><br><span class="line">	查看版本</span><br><span class="line">	node -v</span><br><span class="line">	npm -v</span><br><span class="line">	</span><br><span class="line">2、npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">	-g 全局安装</span><br><span class="line">	从淘宝源下载</span><br><span class="line">	Windows若报错，</span><br><span class="line">		可试着修改nodejs所在文件夹的权限</span><br><span class="line">			属性-》安全—》编辑-》完全控制</span><br><span class="line">		或管理员运行cmd</span><br><span class="line">	输入cnpm查看</span><br><span class="line">	</span><br><span class="line">3、cnpm install -g hexo-cli</span><br><span class="line">	下载hexo</span><br><span class="line">	hexo -v 查看</span><br><span class="line">	</span><br><span class="line">4、安装git</span><br><span class="line">	将git添加到环境变量，即git安装文件夹下的bin文件</span><br><span class="line">	cmd输入 git --version</span><br><span class="line">	</span><br><span class="line">4、创建一个文件夹xxx，用来保存以后所有博客的内容</span><br><span class="line">	进入这个文件夹，右键，打开Git Bash Here，</span><br><span class="line">	执行hexo init</span><br><span class="line">	</span><br><span class="line">	也不先创建文件夹，使用 hexo init 文件夹名</span><br><span class="line">	报错：git clone failed. Copying data instead，需要安装git</span><br><span class="line">	</span><br><span class="line">	注：若安装报错，可以把这个文件夹，删了重建，再重新尝试</span><br><span class="line">	</span><br><span class="line">	http://localhost:4000不能访问的话</span><br><span class="line">	(有可能是其他软件占用了，</span><br><span class="line">	或者复制cmd显示的http://localhost:4000，不要手打)</span><br><span class="line">	或者 hexo s -p 5000	更换端口</span><br><span class="line">	</span><br><span class="line">	npm install hexo-cli -g</span><br><span class="line">	hexo init blog</span><br><span class="line">	cd blog</span><br><span class="line">	npm install</span><br><span class="line">	hexo server</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	初始化博客</span><br><span class="line">	&gt; hexo init 文件夹名称</span><br><span class="line">	新建文章</span><br><span class="line">	&gt; hexo new 文章名称</span><br><span class="line">	(或者)</span><br><span class="line">	&gt; hexo n 文章名称</span><br><span class="line">	在线预览</span><br><span class="line">	&gt; hexo server</span><br><span class="line">	(或者)</span><br><span class="line">	&gt; hexo s</span><br><span class="line">	</span><br><span class="line">5、在GitHub上新建一个，名称：&lt;你的 GitHub 用户名&gt;.github.io</span><br><span class="line">	- 在命令行使用 cnpm install --save hexo-deployer-git</span><br><span class="line">	</span><br><span class="line">	- 修改_config.yml文件，在文件末尾修改 #Deployment 部分</span><br><span class="line">		# Deployment</span><br><span class="line">		## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">		deploy:</span><br><span class="line">		  type: git</span><br><span class="line">		  repo: https://github.com/yanglinqi107/yanglinqi107.github.io #github 仓库链接</span><br><span class="line">		  # example, https://github.com/hexojs/hexojs.github.io</span><br><span class="line">		  branch: master</span><br><span class="line">	一键部署</span><br><span class="line">	&gt; hexo deploy</span><br><span class="line">	(或者)</span><br><span class="line">	&gt; hexo d</span><br><span class="line">	</span><br><span class="line">6、hexo配置主页</span><br><span class="line">	全局配置文件_config.yml中，找到Site部分，自行配置和修改，:后面要空一格</span><br><span class="line">	# Site</span><br><span class="line">	title: yang</span><br><span class="line">	subltitle: </span><br><span class="line">	description: </span><br><span class="line">	author: </span><br><span class="line">	language: zh-cn</span><br><span class="line">	timezone: &#x27;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==============================================================================</span><br><span class="line">报错：</span><br><span class="line">-------------------------------------</span><br><span class="line">(Use `node --trace-warnings ...` to show where the warning was created)</span><br><span class="line">(node:4344) Warning: Accessing non-existent property &#x27;cd&#x27; of module exports inside circular dependency</span><br><span class="line">(node:4344) Warning: Accessing non-existent property &#x27;chmod&#x27; of module exports inside circular dependency</span><br><span class="line">(node:4344) Warning: Accessing non-existent property &#x27;cp&#x27; of module exports inside circular dependency</span><br><span class="line">(node:4344) Warning: Accessing non-existent property &#x27;dirs&#x27; of module exports inside circular dependency</span><br><span class="line">(node:4344) Warning: Accessing non-existent property &#x27;pushd&#x27; of module exports inside circular dependency</span><br><span class="line">(node:4344) Warning: Accessing non-existent property &#x27;popd&#x27; of module exports inside circular dependency</span><br><span class="line">(node:4344) Warning: Accessing non-existent property &#x27;echo&#x27; of module exports inside circular dependency</span><br><span class="line">(node:4344) Warning: Accessing non-existent property &#x27;tempdir&#x27; of module exports inside circular dependency</span><br><span class="line"></span><br><span class="line">查看	node --trace-warnings queue.js </span><br><span class="line"></span><br><span class="line">降低node版本，可以直接使用nvm进行版本管理</span><br><span class="line">博本：https://blog.csdn.net/weixin_44349707/article/details/112307824</span><br><span class="line"></span><br><span class="line">报错：</span><br><span class="line">fatal: not a git repository (or any of the parent directories): .git</span><br><span class="line"></span><br><span class="line">没有初始化git本地管理仓库</span><br><span class="line">查看 git status</span><br><span class="line"></span><br><span class="line">创建仓库 git init</span><br><span class="line"></span><br><span class="line">报错：</span><br><span class="line">fatal: unable to access &#x27;https://github.com/yanglinqi107/yanglinqi107.github.io/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br><span class="line">造成这个错误很有可能是网络不稳定，连接超时导致的，</span><br><span class="line">如果再次尝试后依然报错，可以执行下面的命令。</span><br><span class="line"></span><br><span class="line">打开Git命令页面，执行git命令脚本：修改设置，解除ssl验证</span><br><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===============================================================================</span><br><span class="line">可以看博文：https://blog.csdn.net/jiunian_2761/article/details/97388534</span><br><span class="line"></span><br><span class="line">可以跳到后面的主题</span><br><span class="line"></span><br><span class="line">- 部署到gitee上</span><br><span class="line"></span><br><span class="line">	- 注册gitee</span><br><span class="line">	</span><br><span class="line">	- 创建仓库</span><br><span class="line">		- 仓库路径：xxxxxx.gitee.com</span><br><span class="line">		- 公开</span><br><span class="line">		- Readme初始化</span><br><span class="line">		</span><br><span class="line">	- 仓库页面-》克隆/下载 -》复制ssh</span><br><span class="line">	</span><br><span class="line">	- 修改 _config.yml 文件</span><br><span class="line">	</span><br><span class="line">	- 生成/添加 SSH 公钥</span><br><span class="line">		- 打开git bash窗口</span><br><span class="line">		- 输入 cd ~/.ssh</span><br><span class="line">			- 无ssh，显示 bash: cd: /c/Users/Administrator/.ssh: No such file or directory</span><br><span class="line">			- 有ssh，输入 ls 查看，显示 id_rsa id_rsa.pub known_hosts			</span><br><span class="line">			- 文件夹路径为 C:\Users\yourname\.ssh</span><br><span class="line">		- 创建 ssh</span><br><span class="line">		&#x27;&#x27;&#x27;</span><br><span class="line">		# 注意：该命令是在本地PC上执行</span><br><span class="line">		ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;  </span><br><span class="line">		# Generating public/private rsa key pair...</span><br><span class="line">		&#x27;&#x27;&#x27;</span><br><span class="line">		注意：这里的 xxxxx@xxxxx.com 只是生成的 sshkey 的名称，并不约束或要求具体命名为某个邮箱。</span><br><span class="line">		现网的大部分教程均讲解的使用邮箱生成，其一开始的初衷仅仅是为了便于辨识所以使用了邮箱</span><br><span class="line">		&#x27;&#x27;&#x27;</span><br><span class="line">		# 注意：该命令是在本地PC上执行</span><br><span class="line">		cat ~/.ssh/id_rsa.pub</span><br><span class="line">		# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc....</span><br><span class="line">		&#x27;&#x27;&#x27;</span><br><span class="line">		</span><br><span class="line">	- 将公钥添加到Gitee</span><br><span class="line">		进入gitee-》设置-》SSH公钥-》将ssh-rsa xxxxxxxxx添加创建</span><br><span class="line">		</span><br><span class="line">	- 验证公钥添加结果</span><br><span class="line">	&#x27;&#x27;&#x27;</span><br><span class="line">	# 注意：该命令是在本地PC上执行</span><br><span class="line">	ssh -T git@gitee.com</span><br><span class="line">	&#x27;&#x27;&#x27;</span><br><span class="line">	显示 Hi XXX! You&#x27;ve successfully authenticated, but Gitee.com does not provide shell access. 则证明添加成功</span><br><span class="line">	</span><br><span class="line">	- 在Gitee上开通/更新 Git Pages 服务</span><br><span class="line">		进入仓库-》服务-》Git Pages-》勾选强制使用https</span><br><span class="line">		</span><br><span class="line">	每次修改本地的 Hexo 工程目录之后，通过 hexo g命令即可将更新后的工程部署到 Gitee。</span><br><span class="line">	但是，这个时候你通过浏览器看到的 Hexo 博客页面并不会更新… 你需要再次执行更新Git Pages </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">也可以不修改，使用默认主题</span><br><span class="line"></span><br><span class="line">- 修改主题</span><br><span class="line">	git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">7、配置查看所有文章</span><br><span class="line">//执行命令</span><br><span class="line">npm i hexo-generator-json-content --save</span><br><span class="line"></span><br><span class="line">//在全局配置文件_config.yml进行配置，追加这一段</span><br><span class="line">jsonContent:</span><br><span class="line">  meta: false</span><br><span class="line">  pages: false</span><br><span class="line">  posts:</span><br><span class="line">    title: true</span><br><span class="line">    date: true</span><br><span class="line">    path: true</span><br><span class="line">    text: false</span><br><span class="line">    raw: false</span><br><span class="line">    content: false</span><br><span class="line">    slug: false</span><br><span class="line">    updated: false</span><br><span class="line">    comments: false</span><br><span class="line">    link: false</span><br><span class="line">    permalink: false</span><br><span class="line">    excerpt: false</span><br><span class="line">    categories: false</span><br><span class="line">    tags: true</span><br><span class="line"></span><br><span class="line">8、yilia菜单</span><br><span class="line"># 添加归档，分类的标签</span><br><span class="line">menu:</span><br><span class="line">  主页: /</span><br><span class="line">  归档: /archives/index.html</span><br><span class="line">  随笔: /tags/随笔/</span><br><span class="line">  python: /tags/python/</span><br><span class="line">  </span><br><span class="line">9、文章摘要</span><br><span class="line">	&lt;!-- more --&gt; 分隔文章</span><br><span class="line">	</span><br><span class="line">10、md能显示图片</span><br><span class="line">	修改hexo根目录下的_config.yml文件的以下部分，修改不是追加</span><br><span class="line">	post_asset_folder: true</span><br><span class="line"></span><br><span class="line">	# URL</span><br><span class="line">	## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">	url: http://example.com  #改成自己博客的url，不改好像也可以</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 经典算法--最大存水量问题</span><br><span class="line">date: 2018-02-01 17:44:18</span><br><span class="line">tags:</span><br><span class="line">    - 算法</span><br><span class="line">    - 最大存水量</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------	</span><br><span class="line">参考博客：https://blog.csdn.net/lynnbest/article/details/79845944</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫之OCR</title>
    <url>/python%E7%88%AC%E8%99%AB%E4%B9%8BOCR/</url>
    <content><![CDATA[<p>OCR的方法</p>
<span id="more"></span>

<h2 id="1、EasyOCR"><a href="#1、EasyOCR" class="headerlink" title="1、EasyOCR"></a>1、EasyOCR</h2><p>Python中有一个不错的OCR库-EasyOCR，在GitHub已有9700star。它可以在python中调用，用来识别图像中的文字，并输出为文本。</p>
<p><a href="https://github.com/JaidedAI/EasyOCR">https://github.com/JaidedAI/EasyOCR</a></p>
<p>EasyOCR支持超过80种语言的识别，包括英语、中文（简繁）、阿拉伯文、日文等，并且该库在不断更新中，未来会支持更多的语言。</p>
<h3 id="安装EasyOCR"><a href="#安装EasyOCR" class="headerlink" title="安装EasyOCR"></a>安装EasyOCR</h3><p>安装过程比较简单，使用pip或者conda安装。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install easyocr -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>如果用的PyPl源，安装起来可能会耽误些时间，建议大家用清华源安装，几十秒就能安装好。<br><img src="/python%E7%88%AC%E8%99%AB%E4%B9%8BOCR/ocr000001.png"></p>
<p>使用方法<br>EasyOCR的用法非常简单，分为三步:</p>
<ol>
<li>创建识别对象；</li>
<li>读取并识别图像；</li>
<li>导出文本。</li>
</ol>
<p>实例<br><img src="/python%E7%88%AC%E8%99%AB%E4%B9%8BOCR/ocr000002.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入easyocr</span></span><br><span class="line"><span class="keyword">import</span> easyocr</span><br><span class="line"><span class="comment"># 创建reader对象</span></span><br><span class="line">reader = easyocr.Reader([<span class="string">&#x27;ch_sim&#x27;</span>,<span class="string">&#x27;en&#x27;</span>]) </span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">result = reader.readtext(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>结果<br><img src="/python%E7%88%AC%E8%99%AB%E4%B9%8BOCR/ocr000003.png"></p>
<p>识别的结果包含在元组里，元组由三部分组成：边框坐标、文本、识别概率。</p>
<h3 id="关于语言"><a href="#关于语言" class="headerlink" title="关于语言"></a>关于语言</h3><p>这段代码有一段参数<code>[&#39;ch_sim&#39;,&#39;en&#39;]</code>，这是要识别的语言列表，因为路牌里有中文和英文，所以列表里添加了ch_sim（简体中文）、en（英文）。</p>
<p>可以一次传递多种语言，但并非所有语言都可以一起使用。英语与每种语言兼容，共享公共字符的语言通常相互兼容。</p>
<p>前文我们给出了EasyOCR支持的语言列表，并附有参数代号。<br>关于图像文件：</p>
<p>上面传入了相对路径’test.jpg’，还可以传递OpenCV图像对象（numpy数组）、图像字节文件、图像URL。</p>
<p>抽取文字部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">    word = i[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(word)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Tesseract-OCR"><a href="#Tesseract-OCR" class="headerlink" title="Tesseract-OCR"></a>Tesseract-OCR</h2><p>1、下载并安装<a href="https://digi.bib.uni-mannheim.de/tesseract/">Tesseract-OCR</a>软件，安装完成之后需要配置环境变量，配置完成之后通过CMD命令行验证是否配置成功，执行<code>tesseract -v</code>命令查看相应版本    </p>
<p>默认情况下Tesseract-OCR是不能识别中文的，需要加载相应的中文语言包，简体<a href="https://github.com/tesseractocr/tessdata/blob/master/chi_sim.traineddata">中文语言包</a>叫chi_sim.traineddata下载下来之后需要放置到${TESSERACT_HOME}/tessdata目录下，同时把语言包目录路径配置到环境变量当中</p>
<p>2、接下来我们主要实现Python与Tesseract-OCR交互实现程序化图片识别功能。首先我们需要安装Python 图片依赖包，本文中Python涉及到的依赖包主要有两个，一个是PIL(Python Imaging Library)，另外一个就是与Tesseract-OCR交互的依赖包pytesseract，通过<code>pip install package_name</code>安装相应的包。</p>
<p>3、例子</p>
<p>编写相应代码获取图片字符，首先是加载依赖包，读取图片，最终把从图片上读取出的字符写入一个文件保存起来，具体代码如下：<br>在这里插入图片描述</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_handle</span>():</span></span><br><span class="line">    image = image.<span class="built_in">open</span>(<span class="string">&quot;testchinesejpg&quot;</span>)</span><br><span class="line">    text = pytesseract.image_to_string(image,lang=chi sim<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    with open(&#x27;</span>output.txt<span class="string">&#x27;,&#x27;</span>w<span class="string">&#x27;) as f:</span></span><br><span class="line"><span class="string">        f.write(str(text))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ == &#x27;</span>__main__<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">    image_handle()</span></span><br></pre></td></tr></table></figure>
<p>————————————————</p>
<p>原文链接：<a href="https://blog.csdn.net/xiaxianba/article/details/89450855">https://blog.csdn.net/xiaxianba/article/details/89450855</a></p>
<p>其他链接：<a href="https://blog.csdn.net/weixin_43040873/article/details/109459687">https://blog.csdn.net/weixin_43040873/article/details/109459687</a></p>
<h2 id="使用OCR的API接口，如超级鹰、百度云OCR"><a href="#使用OCR的API接口，如超级鹰、百度云OCR" class="headerlink" title="使用OCR的API接口，如超级鹰、百度云OCR"></a>使用OCR的API接口，如超级鹰、百度云OCR</h2>]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫之协程</title>
    <url>/python%E7%88%AC%E8%99%AB%E4%B9%8Bjs%E9%80%86%E5%90%91/</url>
    <content><![CDATA[<p>js常见加密算法</p>
<span id="more"></span>

<p>爬虫的js加密处理+js算法改写分析</p>
<p>js中常见的加密算法剖析</p>
<ul>
<li><p>线性散列Md5算法</p>
</li>
<li><p>对称加密DES/AES算法</p>
</li>
<li><p>非对称加密算法RSA</p>
</li>
<li><p>base64伪加密</p>
</li>
<li><p>https证书秘钥加密</p>
</li>
</ul>
<p>可以处理的爬虫问题</p>
<ul>
<li><p>模拟登录中密码加密和其他请求参数加密处理</p>
</li>
<li><p>动态加载且加密数据的捕获和破解</p>
</li>
<li><p>重点：找寻到js算法加密和解密相关流程的编码于处理套路/技巧，大幅度提升处理相关问题的效率。</p>
</li>
</ul>
<p>js常见的加密方式</p>
<ul>
<li><p>加密在前端开发和爬虫中是经常遇见的。掌握了加密算法且可以将加密的密文进行解密破解的，也是你从一个编程小白到大神级别质的一个飞跃。且加密算法的熟练和剖析也是很有助于帮助我 们实现高效的js逆向。下述只把我们常用的加密方法进行总结。不去深究加密的具体实现方式。</p>
</li>
<li><p>常见的加密算法基本分为这几类，</p>
<ul>
<li>线性散列算法（签名算法）MD5</li>
<li>对称性加密算法 AES DES</li>
<li>对称性加密算法RSA</li>
</ul>
</li>
</ul>
<p>MD5加密</p>
<ul>
<li><p>MD5是一种被广泛使用的线性散列算法，可以产生出一个128位(16字节)的散列值（hash value),用于确保信息传输完整的一致性。且MD5加密之后产生的是一个固定长度（32位或16位）的数据</p>
</li>
<li><p>解密</p>
</li>
<li><p>常规讲MD5是不存在解密的。但是理论上MD5是可以进行反向暴力破解的。暴力破解的大致原理就是用很多不同的数据进行加密后跟已有的加密数据进行对比，由此来寻找规律。理论上只要数据量足够庞大MD5是可以被破解的。但是要注意，破解MD5是需要考虑破解的成本（时间和机器性能）。假设破解当前的MD5密码需要目前计算能力最优秀的计算机工作100年才能破解完成。那么当前的MD5密码就是安全的。</p>
</li>
<li><p>增加破解成本的方法(方法很多，这里只说我常用的)。</p>
<ul>
<li>使用一段无意义且随机的私匙进行MD5加密会生成一个加密串，我们暂且称之为串1</li>
<li>将要加密的的数据跟串1拼接，再进行一次MD5,这时会生成串2</li>
<li>将串2再次进行MD5加密，这时生成的串3就是我们加密后的数据</li>
</ul>
</li>
<li><p>我们在注册账号是的密码一般都是用到MD5加密</p>
</li>
<li><p>关键字 <code>md5()</code></p>
</li>
</ul>
<p>DES/AES加密</p>
<ul>
<li><p>DES全称为 Data Encryption Standard,即数据加密标准，是一种使用密钥加密的算法。该加密算法是一种对称加密方式，其加密运算、解密运算需要使用的是同样的密钥（一组字符串）即可。</p>
</li>
<li><p>现在用AES这个标准来替代原先的DES</p>
</li>
<li><p>AES和DES的区别：</p>
<ul>
<li><p>加密后密文长度的不同：</p>
<ul>
<li>DES加密后密文长度是8的整数倍</li>
<li>AES加密后密文长度是16的整数倍</li>
</ul>
</li>
<li><p>应用场景的不同</p>
<ul>
<li>企业级开发使用DES足够安全</li>
<li>如果要求高使用AES</li>
</ul>
</li>
<li><p>DES和AES切换只需要修改 CryptoJS.AES &lt;=&gt; CryptoJS.DES</p>
</li>
</ul>
</li>
<li><p>使用DES/AES进行数据交互时要求双方都拥有相同的私匙</p>
</li>
<li><p>破解方法</p>
<ul>
<li>暴力破解。</li>
<li>DES如果使用56位的密钥，则可能的密钥数量是2的56次方个。只要计算足够强大是可以被破解的</li>
</ul>
</li>
<li><p>DES算法的入口参数有三个：</p>
<p>​    Key、Data、Mode, padding</p>
<ul>
<li>Key为7个字节共56位，是DES算法的工作密钥；</li>
<li> Data为8个字节64位，是要被加密或被解密的数据；</li>
<li>Mode为DES的工作方式。</li>
<li>padding为填充模式，如果加密后密文长度如果达不到指定整数倍（8个字节、16个字节），填充对应字符，padding的赋值固定为CryptoJS.pad.Pkcs7即可</li>
</ul>
</li>
<li><p>关键字  <code>CryptoJS</code></p>
</li>
</ul>
<p>RSA加密</p>
<ul>
<li>RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。</li>
</ul>
<p>非对称加密算法：</p>
<ul>
<li><p>非对称加密算法需要两个密钥</p>
<ul>
<li>公开密钥( publickey简称公钥)</li>
<li>私有密钥( privtekey简称私钥)</li>
<li>公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>使用时都是使用公匙加密，使用私匙解密。公匙可以公开，私匙自己保留。</li>
<li>算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对 称加密解密的速度快。</li>
</ul>
</li>
<li><p>使用流程和场景介绍</p>
<ul>
<li>通过公匙加密，使用私匙解密。私匙是通过公匙计算生成的。假设ABC三方之间相互要进行加密通信。大家相互之间使用公匙进行信息加密，信息读取时使用各自对应的私匙进行信息解密</li>
</ul>
</li>
<li><p>用户输入的支付密码会通过RSA加密</p>
</li>
<li><p>公钥私钥生成方式：</p>
<ul>
<li>公私钥可以在线生成    <a href="http://web.chacuo.net/netrsakey.pair">http://web.chacuo.net/netrsakey.pair</a></li>
</ul>
</li>
<li><p>关键字  <code>setPuplicKey()  setPrivateKey()</code></p>
</li>
</ul>
<p>base64伪加密</p>
<ul>
<li><p>Base64是一种用64个字符来表示任意二进制数据的方法。base64是一种编码方式而不是加密算法。只是看上去像是加密而已。</p>
</li>
<li><p>Base64使用A–Z,a–z,0–9,+,/这64个字符实现对数据进行加密。</p>
</li>
<li><p>关键字       <code>Base64()</code></p>
</li>
</ul>
<p>拓展：https加密</p>
<ul>
<li><p>https是基于http和SSL/TLS实现的一个协议，他可以保证在网络上传输的数据都是加密的，从而保证数据安全。</p>
</li>
<li><p>接下来我们从http协议开始，提出想法井逐步进行分析，最终实现Https.</p>
</li>
</ul>
<p>1.http协议是不安全的。</p>
<ul>
<li>在https诞生之前，所有网站都使用http协议，而ht协议在数据传输的过程中都是明文，所以可能存在数据泄露和篡改。</li>
</ul>
<p>2.使用对称秘钥进行数据加密</p>
<ul>
<li>为了防止数据泄露和篡改，我们对数据进行加密，如：生成一个对称密码【DKUFHNAF897123F】，将对称秘钥分别交给浏览器和服务器端，他们之间传输的数据都使用对称秘钥进行加密和解密。</li>
</ul>
<p>请求和响应流程如下</p>
<ul>
<li><p>客户端使用对称秘钥对请求进行加密，并发送给服务端。</p>
</li>
<li><p>服务端接收到密文之后，使用对称秘钥对密文进行解密，然后处理请求。最后再使用对称秘钥把要返回的内容再次加密，返回给客户端。</p>
</li>
<li><p>客户端接收到密文之后，使用对称秘钥进行解密，并获取最终的响应内容。</p>
</li>
</ul>
<p>如此一来，数据传输都是密文，解决了明文传输数据的问题。但是，这么干有bug</p>
<ul>
<li><p>浏览器如何获取对称秘钥</p>
</li>
<li><p>每个客户端的对称秘钥相同，浏览器能拿到对称秘钥，那么黑客也可以拿到，所以，数据加密也就没有意义了</p>
</li>
</ul>
<p><img src="/python%E7%88%AC%E8%99%AB%E4%B9%8Bjs%E9%80%86%E5%90%91/image20211127174405.png"></p>
<p>3.动态对称秘钥和非对称秘钥</p>
<ul>
<li>为了解决对称秘钥动态性以及让客户端和服务端安全的获取对称秘钥，可以引入非对称秘钥机制。</li>
</ul>
<p><img src="/python%E7%88%AC%E8%99%AB%E4%B9%8Bjs%E9%80%86%E5%90%91/image20211127175123.png"></p>
<p>js调试工具</p>
<ul>
<li>发条js调试工具</li>
</ul>
<p>PyExecJs</p>
<ul>
<li><p>实现使用python执行js代码</p>
</li>
<li><p>环境安装：</p>
<ul>
<li>nodejs开发环境</li>
<li>pip install PyExecJs</li>
</ul>
</li>
</ul>
<p>js算法改写初探</p>
<ul>
<li><p>打断点</p>
</li>
<li><p>代码调试时，如果发现了相关变量的缺失，一般给其定义成空字典即可。</p>
</li>
</ul>
<p>注意：如果需要逆向的js函数时出现在一个闭包中，那么直接将闭包的整个代码块拷贝出进行调试即可</p>
<p>js混淆：</p>
<ul>
<li>将js核心的相关代码进行变相的加密，加密后的数据就是js混淆之后的结果。</li>
</ul>
<p>js反混淆：</p>
<ul>
<li><p>反混淆的线上工具（不理想）</p>
</li>
<li><p>浏览器自带的反混淆工具设置（推荐）</p>
<ul>
<li>开发者工具的sources-》settings-》sources-》第一项勾上</li>
<li>进行关键字的全局搜索-》VMxxxx（就是反混淆后的代码）</li>
</ul>
</li>
</ul>
<p>sessionid在抓包工具Application的Cookie中</p>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy框架</title>
    <url>/scrapy%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>scrapy框架的使用</p>
<span id="more"></span>

<h3 id="scrapy框架"><a href="#scrapy框架" class="headerlink" title="scrapy框架"></a>scrapy框架</h3><ul>
<li>什么是框架？<pre><code>  - 集成了很多功能，并且具有很强通用性的一个项目模板
</code></pre>
</li>
<li>如何学习框架？<ul>
<li>专门学习框架封装的各种功能的详细用法</li>
</ul>
</li>
<li>什么是scrapy？<ul>
<li>爬虫中封装好的一个明星框架。</li>
<li>功能：高性能的持久化存储，异步的数据下载，高性能的数据解析，分布式</li>
</ul>
</li>
</ul>
<h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><ul>
<li><code>pip install wheel</code></li>
<li>下载twisted，下载地址为<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted">http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted</a></li>
<li>安装twisted：<code>pip install Twisted‑17.1.0‑cp36‑cp36m‑win_amd64.whl</code></li>
<li><code>pip install pywin32</code></li>
<li><code>pip install scrapy</code></li>
<li>测试：在终端里录入scrapy指令，没有报错即表示安装成功！</li>
</ul>
<h3 id="scrapy框架基本使用"><a href="#scrapy框架基本使用" class="headerlink" title="scrapy框架基本使用"></a>scrapy框架基本使用</h3><h4 id="创建一个工程："><a href="#创建一个工程：" class="headerlink" title="创建一个工程："></a>创建一个工程：</h4><p><code> scrapy startproject xxxPro</code></p>
<ul>
<li><p>在spiders子目录中创建一个爬虫文件</p>
<ul>
<li><p>scrapy genspider 文件名 <a href="http://www.xxx.com/">www.xxx.com</a></p>
</li>
<li><p>执行工程</p>
<ul>
<li>修改settings.py文件中 ROBOTSTXT_OBEY = False</li>
<li>scrapy crawl 文件名</li>
<li>scrapy crawl 文件名 –nolog  # 不在打印日志信息（若有错，不会打印错误信息）</li>
<li>在settings.py文件添加 LOG_LEVEL = ‘ERROR’    # 打印错误信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="scrapy持久化存储"><a href="#scrapy持久化存储" class="headerlink" title="scrapy持久化存储"></a>scrapy持久化存储</h4><ul>
<li>基于终端指令：<ul>
<li>要求：只可以将parse方法的返回值存储到本地的文本文件中</li>
<li>注意：存储的文件类型只能是’json’, ‘jsonlines’, ‘jl’, ‘csv’, ‘xml’, ‘marshal’, ‘pickle’</li>
<li>指令：scrapy crawl xxx -o filePath</li>
</ul>
</li>
<li>基于管道<ul>
<li>编码流程：<ul>
<li>数据解析</li>
<li>在item类中定义相关的属性</li>
<li>将解析的数据封装存储到item类型的对象</li>
<li>将item类型的对象提交给管道进行持久化存储的操作</li>
<li>在管道类的process_item中要将其接收到的item对象中存储的数据进行持久化存储操作</li>
<li>在配置文件中开启管道</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>基于Spider的全站数据的爬取</p>
<ul>
<li>就是将网站中某版块下的全部页码对应的页面数据进行爬取</li>
<li>实现方式：<ul>
<li>将所有页码的URL添加到start_urls列表（不推荐）</li>
<li>自行手动请求发送（推荐）<ul>
<li>yield scrapy.Request(url,callback=self.parse)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="五大核心组件"><a href="#五大核心组件" class="headerlink" title="五大核心组件"></a>五大核心组件</h4><ul>
<li>引擎</li>
<li>Spider</li>
<li>下载器</li>
<li>管道</li>
<li>调度器</li>
</ul>
<p>请求传参</p>
<ul>
<li>使用场景：爬取解析的数据不在同一张页面中（深度爬取）</li>
<li>meta{} 传递给回调函数    使用response.meta[‘xx’]</li>
</ul>
<p>图片数据爬取之ImagesPipeline</p>
<ul>
<li>基于scrapy爬取字符串类型的数据和爬取图片类型的数据区别<ul>
<li>字符串：只需要基于xpath进行解析且提交管道进行持久化存储</li>
<li>图片：xpath解析出图片src的属性值。单独对图片的地址发起请求获取图片的二进制类型的数据</li>
</ul>
</li>
<li>ImagesPipeline:<ul>
<li>只需要将Img的src的属性值进行解析，提交到管道，管道就会对图片的src进行求求获取图片的二进制类型的数据，并进行持久化存储</li>
</ul>
</li>
<li>使用流程：<ul>
<li>数据解析（图片的地址）</li>
<li>将存储图片地址的item提交到指定的管道类</li>
<li>在管道文件中自定制一个基于ImagesPipeLine的一个管道类<ul>
<li>get_media_request</li>
<li>file_path</li>
<li>item_completed</li>
</ul>
</li>
<li>在配置文件中：<ul>
<li>指定图片存储的目录:IMAGES_STORE = ‘XXXX’</li>
<li>指定开启的管道：自定制的管道类</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>中间件</p>
<ul>
<li>下载中间件<ul>
<li>位置：引擎和下载器之间</li>
<li>作用：批量拦截到整个工程中所有的请求和响应</li>
<li>拦截请求：<ul>
<li>UA伪装：process_request</li>
<li>代理IP：process_exception    return request</li>
</ul>
</li>
<li>拦截响应<ul>
<li>篡改响应数据，响应对象 </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>CrawlSpider：Spider的一个子类</p>
<ul>
<li>全站数据爬取的方式<ul>
<li>基于Spider：手动请求</li>
<li>基于CrawlSpider</li>
</ul>
</li>
<li>CrawlSpider的使用<ul>
<li>创建工程  scrapy startproject xxxPro</li>
<li>创建爬虫文件 scrapy genspider -t crawl 文件名 <a href="http://www.xxx.com/">www.xxx.com</a></li>
<li>链接提取器LinkExtractor：根据指定规则（allow=r’正则表达式’）进行链接的提取</li>
<li>规则解析器Rule：将链接提取器提取到的链接进行指定规则（callback）的解析提取<ul>
<li>follow = True：可以将链接提取器 继续作用到 链接提取器提取到的链接所对应的页面中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="分布式爬虫"><a href="#分布式爬虫" class="headerlink" title="分布式爬虫"></a>分布式爬虫</h4><ul>
<li>概念：需要搭建一个分布式的机群，让其对一组资源进行分布式联合爬取</li>
<li>作用：提升爬取数据的效率    </li>
<li>如何实现分布式<ul>
<li>安装scrapy-redis组件<ul>
<li>给原生的scrapy提供共享的调度器和机群</li>
</ul>
</li>
<li>原生的scrapy不可以实现分布式爬虫，必须结合scrapy-redis组件<ul>
<li>调度器不可以被分布式机群共享</li>
<li>管道不可以被分布式机群共享</li>
</ul>
</li>
<li>实现流程<ul>
<li>创建工程</li>
<li>创建一个基于CrawlSpider的爬虫文件</li>
<li>修改创建的爬虫文件：<ul>
<li>导包：from scrapy_redis.spiders import RedisCrawlSpider</li>
<li>将start_url和allowed_domains注释</li>
<li>添加一个新属性：redis_Key = ‘xxx’ 可以被共享的调度器队列的名称</li>
<li>编写数据解析相关操作</li>
<li>将当前爬虫类的父类更改为RedisCrawlSpider</li>
</ul>
</li>
<li>修改配置文件settings<ul>
<li>指定使用可以被共享的管道  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">	&#x27;scrapy_redis.pipelines.RedisPipeline&#x27;:400</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>指定被共享的调度器  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加了一个去重容器类的配置，作用使用 Redist的set集合来存储请求的指纹数据，从而实现请求去重的持久化存储</span></span><br><span class="line">DUPEFILTER_CLASS = <span class="string">&quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span></span><br><span class="line"><span class="comment"># 使用crapy-redis组件自己的调度器</span></span><br><span class="line">SCHEDULER = <span class="string">&quot;scrapy_redis.scheduler.Scheduler&quot;</span></span><br><span class="line"><span class="comment"># 配置调度器是否要持久化，也就是当爬虫结東了，要不要清空Redis中请求队列和去重指纹的set。</span></span><br><span class="line">SCHEDULER_PERSIST = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li>配置redis服务器  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REDIS_HOST = <span class="string">&#x27;127.0.0.1&#x27;</span>	redis服务器的IP地址</span><br><span class="line">REDIS_PORT = <span class="number">6379</span>	</span><br><span class="line">REDIS_ENCODING = <span class="string">&#x27;UTF-8&#x27;</span></span><br><span class="line">REDIS_PARAMS = &#123;<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;xxxxxx&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>redis相关操作配置<ul>
<li>windows：redis.windows.conf<ul>
<li>将bind 127.0.0.1注释</li>
<li>关闭保护模式：protected-mode  yes改为no</li>
</ul>
</li>
<li>结合配置文件开启redis服务<ul>
<li>redis-server 配置文件</li>
<li>启动客户端：redis-cli</li>
</ul>
</li>
<li>执行工程：scrapy runspider xxx.py</li>
<li>向调度器的队列中放入一个起始url：<ul>
<li>调度器的队列在redis的客户端中    ： lpush 共享调度器名称 起始url</li>
</ul>
</li>
</ul>
</li>
<li>爬取的数据存储在redis数据库中</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>增量式爬虫：</p>
<ul>
<li>概念：监测网站数据更新的情况，只会爬取网站最新更新出来的数据。</li>
<li>核心：检测详情页的url之前有没有请求过</li>
</ul>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Win远程桌面RDP</title>
    <url>/win%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2RDP/</url>
    <content><![CDATA[<p>使用windows支持的RDP协议和远程桌面连接实现远程控制</p>
<p>官方网站：<a href="https://docs.microsoft.com/zh-cn/windows-server/remote/remote-desktop-services/welcome-to-rds">欢迎使用 Windows Server 2016 中的远程桌面服务 | Microsoft Docs</a> </p>
<p>参考链接：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1497640">远程桌面失败：你的凭据不工作 - 云+社区 - 腾讯云 (tencent.com)</a> </li>
<li><a href="https://blog.csdn.net/Khaoszhang/article/details/113818150">Windows服务器远程桌面连接RDP_雁無痕的博客-CSDN博客_windows远程桌面rdp</a> </li>
</ul>
<span id="more"></span>

<h3 id="前提：电脑有远程桌面服务"><a href="#前提：电脑有远程桌面服务" class="headerlink" title="前提：电脑有远程桌面服务"></a>前提：电脑有远程桌面服务</h3><p>win10家庭版没有远程桌面服务，需要下载额外的组件或安装专业版。</p>
<p><a href="http://www.xitongcheng.com/jiaocheng/win10_article_55870.html">2021专业版win10永久激活密钥大全(有效激活)－系统城 (xitongcheng.com)</a> </p>
<p>右键电脑-》属性可以看到windows的版本，可以选择<em>更改产品密钥或升级Windows</em>，使用上面链接里面的专业版密钥升级为Windows专业版或Windows11</p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509154545254.png" alt="image-20220509154545254" style="zoom:67%;">



<h3 id="第一步：开启远程桌面服务"><a href="#第一步：开启远程桌面服务" class="headerlink" title="第一步：开启远程桌面服务"></a>第一步：开启远程桌面服务</h3><p>设置-》系统-》远程桌面</p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509154949080.png" alt="image-20220509154949080" style="zoom:67%;">



<h3 id="第二步：设置用户"><a href="#第二步：设置用户" class="headerlink" title="第二步：设置用户"></a>第二步：设置用户</h3><p>点击上图的 <em>选择可远程访问这台电脑的用户</em></p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509155658475.png" alt="image-20220509155658475" style="zoom: 67%;">

<p>然后依次是   高级-》立即查找 -》选择用户</p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509160236870.png" alt="image-20220509160236870" style="zoom: 67%;">



<h3 id="第三步：关闭网络级身份验证"><a href="#第三步：关闭网络级身份验证" class="headerlink" title="第三步：关闭网络级身份验证"></a>第三步：关闭网络级身份验证</h3><p>点击第一张图的 <em>高级设置</em></p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509160539415.png" alt="image-20220509160539415" style="zoom:80%;">

<p>按下 <em>WIN+R</em> 键 输入 <code>gpedit.msc</code>     或       用win10带的搜索输入 <em>编辑组策略</em>     </p>
<p><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509160920964.png" alt="image-20220509160920964" style="zoom: 67%;"><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509161057896.png" alt="image-20220509161057896"></p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509161057896.png" alt="image-20220509160920964" style="zoom: 67%;">

<p>目的是打开<em>本地组策略编辑器</em></p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509161222496.png" alt="image-20220509161222496" style="zoom:67%;">

<p>计算机配置-》管理模块-》Windows组件-》远程桌面服务-》远程桌面会话主机-》安全</p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509161521370.png" alt="image-20220509161521370" style="zoom: 67%;">

<p>右键 <em>远程（RDP）连接要求使用指定的安全层</em>   点击 <em>编辑</em></p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509162004447.png" alt="image-20220509162004447" style="zoom: 80%;">



<h3 id="第四步，远程登录"><a href="#第四步，远程登录" class="headerlink" title="第四步，远程登录"></a>第四步，远程登录</h3><p>获取当前电脑ip</p>
<ul>
<li>打开cmd窗口：<em>win+R</em> 输入 <code>cmd</code></li>
<li>输入<code>ipconfig</code>命令，查看对应的网卡下的<strong>IPv4</strong>地址（如果是连接wifi的话，应该是 *无线局域网适配器 WLAN:*下的地址）</li>
</ul>
<p>换一台电脑：使用同一个局域网（大部分情况为同一个WIFI下）下的另一台电脑</p>
<p>打开自带的远程桌面连接进行连接，然后像打开自己电脑一样输入密码登录</p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509162358270.png" alt="image-20220509162358270" style="zoom:80%;">

<p>结果：</p>
<img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509163202191.png" alt="image-20220509163202191">



<h3 id="不关闭网络级身份验证"><a href="#不关闭网络级身份验证" class="headerlink" title="不关闭网络级身份验证"></a>不关闭网络级身份验证</h3><p>可以不进行第三步，但需要加别的设置</p>
<ul>
<li>打开<em>本地组策略编辑器</em></li>
<li>用户配置-》管理模块-》Windows组件-》远程桌面服务-》RD网关</li>
<li><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509164234688.png" alt="image-20220509164234688" style="zoom:67%;"></li>
<li>右键 <em>设置 RD 网关身份验证方法</em>  点击 <em>编辑</em></li>
<li><img src="https://cdn.jsdelivr.net/gh/yanglinqi107/Images/res/image-20220509164457882.png" alt="image-20220509164457882" style="zoom:65%;"></li>
</ul>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>修改status</title>
    <url>/%E4%BF%AE%E6%94%B9status/</url>
    <content><![CDATA[<p>mysql修改以下编码和全局变量的方法</p>
<p>Server characterset:    utf8mb4<br>Db     characterset:    utf8mb4<br>Client characterset:    utf8mb4<br>Conn.  characterset:    utf8mb4</p>
<span id="more"></span>



<p>查看状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; status;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*查看所有变量，不推荐，会跑一段时间*/</span><br><span class="line">mysql&gt; show [global] variables;</span><br><span class="line">/*查看想要的变量*/</span><br><span class="line">mysql&gt; show [global] variables like &quot;&quot;;</span><br><span class="line"></span><br><span class="line">/*例：查看编码的设置状态*/</span><br><span class="line">mysql&gt; show variables like &#x27;%character%&#x27;;</span><br></pre></td></tr></table></figure>



<p>修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set character_set_client=utf8;</span><br></pre></td></tr></table></figure>

<p>也可以在mysql安装目录下的<code>mysql.ini</code>中添加：若没有mysql.ini，可以直接创一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在[mysqld]段中添加或修改max_connections值：max_connections=512</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>函数和模块</title>
    <url>/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>Python的函数和自定义模块</p>
<span id="more"></span>

<p>一个函数只做一件事情, Python 编码规范建议一个函数的函数体不超过20行代码。如果超过了,说明这个函数做了不止一件事情,就应该把这个函数拆分为更小的函数。这也就暗示了在函数体里面也可以调用其他的函数。</p>
<p>Python函数的注意事项</p>
<p>(1)函数参数的类型决定了它的作用范围</p>
<p>函数外面的容器类作为参数传递到函数中以后,如果函数修改了这个容器里面的值,那么函数外面的容器也会受到影响。</p>
<p>(2)默认参数陷阱，这个问题涉及Python底层的实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default_para_trap</span>(<span class="params">para=[], value=<span class="number">0</span></span>):</span></span><br><span class="line">    para.append(value)</span><br><span class="line">    <span class="keyword">return</span> para</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数返回值:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(default_para_trap(value=<span class="number">100</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数返回值:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(default_para_trap(value=<span class="number">50</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># 函数返回值:[100]</span></span><br><span class="line"><span class="comment"># 函数返回值:[100, 50]</span></span><br></pre></td></tr></table></figure>



<p>函数格式</p>
<p>def 函数名(参数列表)：</p>
<p>​    函数体</p>
<p>函数参数说明：</p>
<p>不可改变类型变量为实参时，被调函数执行结束后，形参的值可能发生变化，但返回后，形参的值不会带到对应得实参。数据的单向传递。可改变类型变量，形参的变化会带到对应实参。数据的双向传递。</p>
<p>位置参数</p>
<p>默认参数</p>
<p> 函数定义时，参数列表可以包含默认参数。默认参数需放置在非默认参数后面，默认参数必须是可变对象。默认参数可以省略，省略时采用默认值。</p>
<p>例：<code>def testDefaultParms(stdno,name1,grade=&quot;2017&quot;):</code></p>
<p>关键字参数</p>
<p>关键字参数之间不存在先后顺序，*后面的参数被视为关键字参数。如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数不需要一个特殊分隔符*了</p>
<p>例：<code>def testKeyWordPrams(stdno,name1,grade=&quot;2017&quot;,*,city,zipcode):</code></p>
<p>可变参数</p>
<p>可变参数允许调用函数时传入的参数是可变的，可以是1个实参，2个实参或者多个实参，也可以是0个实参。可用包裹packing位置参数（简称*args参数），或包裹关键字参数（简称**kwargs参数）进行参数传递</p>
<p>包裹位置参数（元组可变参数）。调用函数时传入的相关参数会被args变量收集，根据传入参数的位置合并为一个元组tuple，args是元组类型</p>
<p>例：<code>def testVarParms1(*hobby):</code></p>
<p>包裹关键字传递（字典可变参数）。调用函数时传入的相关字典数据会被kwargs变量收集，根据传入参数的位置合并成一个字典dict，args是元组类型。</p>
<p>例：<code>def testVarParms2(**birthplace):</code></p>
<h3 id="解包裹参数"><a href="#解包裹参数" class="headerlink" title="解包裹参数"></a>解包裹参数</h3><p>*args和**kwargs形式也可以在函数调用的时候使用，称为解包裹unpacking</p>
<p>传递元组时，让元组的每个元素对应一个位置参数</p>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testUnpackingParms1</span>(<span class="params">basketball,music,reading</span>):</span></span><br><span class="line">	..........</span><br><span class="line">    </span><br><span class="line">hobby1=(<span class="string">&quot;篮球&quot;</span>,<span class="string">&quot;音乐&quot;</span>,<span class="string">&quot;看书&quot;</span>)</span><br><span class="line"></span><br><span class="line">x=testUNpackingParms1（*hobby1）</span><br></pre></td></tr></table></figure>
<p>传递词典字典时，让词典的每个键值对作为一个关键字参数传递给函数</p>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testUnpackingParms2</span>(<span class="params">province,city,zipcode</span>):</span></span><br><span class="line">	..........</span><br><span class="line"></span><br><span class="line">birthplace1=&#123;<span class="string">&quot;province&quot;</span>:<span class="string">&quot;湖北&quot;</span>,<span class="string">&quot;city&quot;</span>:<span class="string">&quot;孝感&quot;</span>,<span class="string">&quot;zipcode&quot;</span>:<span class="string">&quot;432100&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">x = testUnpackingParm2(**birthplace1)</span><br></pre></td></tr></table></figure>


<p>参数次序</p>
<p>位置参数、默认参数、包裹参数、包裹关键字   </p>
<hr>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>Python中只有模块（module）、类（class）、以及函数（def、lambda）才会有作用域的概念，</p>
<p>其他的代码块（如<code>if/elif/else  try/except  for/while</code>等）语句内定义的变量，外部可以访问</p>
<p>作用域的4中类型</p>
<ul>
<li><p>L（local）局部作用域：对定义在函数中的定义的变量，为局部变量。函数内部使用global关键字来声明变量的作用域为全局</p>
</li>
<li><p>E（enclosing）嵌套作用域：E是定义一个函数的上一层的父级函数的局部作用域，主要为实现Python的闭包</p>
</li>
<li><p>G（global）全局作用域：即在模块层次中定义的变量，每一个模块都是一个全局作用域。在模块文件顶层声明的变量具有全局作用域。模块的全局变量就是一个模块对象的属性。（仅限单个模块文件）</p>
</li>
<li><p>B（built-in）内置作用域：系统内固定模块例定义的变量，如预定义在builtin模块内的变量</p>
</li>
</ul>
<p>变量名LEGB法则：</p>
<blockquote>
<p>搜索变量名的优先级：局部作用域&gt;嵌套作用域&gt;全局作用域&gt;内置作用域</p>
<p>LEGB法则为：当在函数中使用为确定的变量名时，Python会按照优先级依次搜索4个作用域。</p>
</blockquote>
<p>不同作用域变量的修改</p>
<p>non-L变量相对L而言，默认只读而不能修改，否则会在L中引入一个同名的新变量。</p>
<p>注意：在L中对新变量的修改不会影响到non-L。希望在L中修改non-L中的变量时，可以使用global，nonlocal关键字。</p>
<p>局部变量和全局变量</p>
<h3 id="三个典型函数"><a href="#三个典型函数" class="headerlink" title="三个典型函数"></a>三个典型函数</h3><p>1、lambda表达式（lambda expression）是一个匿名函数，lambda表达式基于数学中的$λ$演算得名，直接对应于其中的lambda抽象（lambda abstraction）</p>
<p>Python用lambda关键字创造匿名函数</p>
<p><code>lambda [arg1[,arg2,...,argN]]:expression</code></p>
<p>参数时可选的，lambda可定义匿名函数，def定义函数必须有名字</p>
<p>lambda是表达式而不是语句，只可以包含一个表达式，该表达式的计算结果可以看作是函数的返回值，</p>
<p>不允许包含复合语句，但在表达式中可以调用其他函数</p>
<p>2、map()函数 是Python内置的高阶函数，使用格式为map(function,Itera)</p>
<p>第一个参数为某个函数，第二个为可迭代对象。作用是接收一个函数function和可迭代对象Itera，通过函数function依次作用在Itera的每个元素上，得到一个新的可迭代的map对象并返回。</p>
<p>3、reduce()函数</p>
<p>标准库functools中的函数reduce()可以将一个接收2个参数的函数以迭代累积的方式从左到右依次作用到一个序列或迭代器对象的所有元素上，并且允许指定一个初始值。</p>
<p><code>reduce(function, iterable[, initializer])</code></p>
<p>参数function必须有两个参数，initializer是可选的。</p>
<p>通过取出序列的头两个元素，将它们传入二元函数获得一个单一的值来实现。然后用这个值和下一个元素来获得又一个值，继续直到整个序列的内容都遍历完毕。</p>
<hr>
<p>函数递归：直接递归和间接递归</p>
<hr>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>使用内置函数dir()可以查看所有内置函数和内置对象：</p>
<p><code>dir(_builtins_)</code></p>
<p>使用<code>help</code>(函数名)可以查看某个函数的用法。</p>
<h3 id="常见内置函数"><a href="#常见内置函数" class="headerlink" title="常见内置函数"></a>常见内置函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abs()	delattr()	hash()	memoryview()	set()	all()</span><br><span class="line"></span><br><span class="line">dict()	help()	min()	serattr()		any()	dir()</span><br><span class="line"></span><br><span class="line">hex()	next()	slice()	ascii()		divmod()	id()</span><br><span class="line"></span><br><span class="line">object()	sorted()	bin()	enumerate()	input()	oct()</span><br><span class="line"></span><br><span class="line">staticmethod()	bool()	eval()	int()	open()	str()</span><br><span class="line"></span><br><span class="line">breakpoint()	exec()	isinstance()	ord()	sum()	bytearray()</span><br><span class="line"></span><br><span class="line">filter()	issubclass()	pow()	super()	bytes()	float()</span><br><span class="line"></span><br><span class="line">iter()	print()	tuple()	callable()	format()	len()</span><br><span class="line"></span><br><span class="line">property()	type()	chr()	frozenset()	list()	range()</span><br><span class="line"></span><br><span class="line">vars()	classmethod()	getattr()	locals()	repr()	zip()</span><br><span class="line"></span><br><span class="line">compile()	globals()	map()	reversed()	_import_()	complex()</span><br><span class="line"></span><br><span class="line">hasattr()	max()	round()</span><br></pre></td></tr></table></figure>



<h3 id="进制转换函数"><a href="#进制转换函数" class="headerlink" title="进制转换函数"></a>进制转换函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bin</span>(n)：将十进制数n转换为二进制数</span><br><span class="line"></span><br><span class="line"><span class="built_in">oct</span>(n)：将十进制数n转换为八进制数</span><br><span class="line"></span><br><span class="line"><span class="built_in">hex</span>(n)：将十进制数n转换为十六进制数</span><br><span class="line"></span><br><span class="line"><span class="built_in">chr</span>(n)：将十进制数n转换为ASCII中相应的字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">ord</span>(s)：将ASCII中相应的字符转换为十进制数</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>(s,base)：将字符串s表示的base(=<span class="number">2</span>,<span class="number">8</span>,<span class="number">16</span>)进制数组合转化为十进制</span><br></pre></td></tr></table></figure>

<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>math模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">abs</span>(x)：返回数字的绝对值</span><br><span class="line"></span><br><span class="line">ceil(x)：返回数字的上入整数</span><br><span class="line"></span><br><span class="line">cmp(x,y)：x,y比较，&lt;返回-<span class="number">1</span>，==返回<span class="number">0</span>，&gt;返回<span class="number">1</span></span><br><span class="line"></span><br><span class="line">exp(x)：返回e的x次幂（ex）</span><br><span class="line"></span><br><span class="line">fabs(x)：返回数字的绝对值</span><br><span class="line"></span><br><span class="line">floor(x)：返回数字的下取舍数</span><br><span class="line"></span><br><span class="line">log(x)：</span><br><span class="line"></span><br><span class="line">log10(x)：返回以<span class="number">10</span>为基数的x的对数</span><br><span class="line"></span><br><span class="line"><span class="built_in">max</span>(x1,x2,.....)：</span><br><span class="line"></span><br><span class="line"><span class="built_in">min</span>(x1,x2,.....)：</span><br><span class="line"></span><br><span class="line">modf(x)：返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示</span><br><span class="line"></span><br><span class="line"><span class="built_in">pow</span>(x,y)：x**y运算后的值</span><br><span class="line"></span><br><span class="line"><span class="built_in">round</span>(x[,n])：返回浮点数x的四舍五入值</span><br><span class="line"></span><br><span class="line">acos(x)：返回x的反余弦弧度值</span><br><span class="line"></span><br><span class="line">asin(x)：返回x的反正弦弧度值</span><br><span class="line"></span><br><span class="line">atan(x)：返回x的反正切弧度值</span><br><span class="line"></span><br><span class="line">atan2(y,x)：返回给定的X及Y坐标值的反正切值</span><br><span class="line"></span><br><span class="line">cos(x)：返回x的弧度的余弦值</span><br><span class="line"></span><br><span class="line">hypot(x,y)：返回欧几里得范数sqrt(x*x+y*y)</span><br><span class="line"></span><br><span class="line">sin(x)：返回x的弧度的正弦值</span><br><span class="line"></span><br><span class="line">tan(x)：返回x的弧度的正切值</span><br><span class="line"></span><br><span class="line">degrees(x)：将弧度转换为角度</span><br><span class="line"></span><br><span class="line">radians(x)：将角度转换为弧度</span><br><span class="line"></span><br><span class="line">常量</span><br><span class="line"></span><br><span class="line">pi：圆周率</span><br><span class="line"></span><br><span class="line">e：自然常数</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块是一组Python代码的集合，主要定义了一些公有函数和变量。使用者通过import命令引入模块，</p>
<p>使用其中的函数和变量。在Python中，一个.py文件就是一个模块（Module）。</p>
<p>模块的分类</p>
<p>1、自定义模块：用户自己编写的实现包含一些函数变量的.py文件</p>
<p>2、内置模块：Python自身提供的模块，如：sys、os、random等模块</p>
<p>3、开源模块：第三方提供的模块</p>
<p>模块的好处</p>
<p>1、提高代码的可维护性和开发效率</p>
<p>2、使用模块还可以避免函数名和变量名冲突</p>
<p>模块文件的管理</p>
<p>为避免模块名冲突，Python引入包（Package）来管理模块文件。包是一个有层次的文件目录结构，</p>
<p>它定义了由若干个模块、子包组成的Python应用程序执行环境。包是一个包含<code>_init_.py</code>文件的目录，</p>
<p>该目录下一定得有这个<code>_init_.py</code>文件和其他模块或子包</p>
<p>因此只要将模块放在不同的包，就可避免模块名冲突。</p>
<p>注意：包目录下必须有<code>_init_.py</code>文件，否则就被Python当普通目录。</p>
<p>模块的引用</p>
<p>1、import module_name</p>
<p>module_name为模块名</p>
<p>2、from module_name</p>
<p>from module_name import function_name</p>
<p>3、应用多个模板，模板之间用逗号</p>
<p>注意：在引入模板前要求配置好模块所在的目录。可以将该目录加入到PATHPYTHON环境变量，也</p>
<p>可以通过下列方式配置</p>
<h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><p>将一系列常用功能放在一个.py文件中。自定义模块应用一般包括以下几个步骤：</p>
<p>1、编辑并调试好模块文件，如mymath.py</p>
<p>2、规划模块文件存放的目录，如d:\myLearn\Python\lib</p>
<p>3、配置模块文件目录，即将模块文件目录加到PATHPYTHON环境变量或在某应用该模块的文件中引</p>
<p>用该模块前加入如下语句：</p>
<p>import sys    #引用系统内置模块sys</p>
<p>sys.append(“d:\myLearn\Python\lib”)</p>
<p>4、引用模块</p>
<p><code>import mymath</code>    #引用自定义模块mymath</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程</title>
    <url>/%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<br>

<span id="more"></span>

<p>Python这门语言在设计的时候，有一个<code>全局解释器锁（Global Interpreter Lock, GIL）</code>。</p>
<p>这导致Python的多线程都是<code>伪多线程，即本质上还是一个线程</code>，但是这个线程每个事情只做几毫秒，几毫秒以后就保存现场，换做其他事情，几毫秒后再做其他事情，一轮之后回到第一件事上，恢复现场再做几毫秒，继续换……<code>微观上的单线程</code>，在宏观上就像同时在做几件事。</p>
<p>这种机制在I/O（Input/Output，输入/输出）密集型的操作上影响不大，但是在CPU计算密集型的操作上面，由于只能使用CPU的一个核，就会对性能产生非常大的影响。所以涉及计算密集型的程序，就需要使用多进程，Python的多进程不受GIL的影响。</p>
<p>爬虫属于I/O密集型的程序，所以使用多线程可以大大提高爬取效率。</p>
<h3 id="多进程库"><a href="#多进程库" class="headerlink" title="多进程库"></a>多进程库</h3><p><code>multiprocessing</code>本身是Python的多进程库，用来处理与多进程相关的操作。</p>
<p>但是由于进程与进程之间不能直接共享内存和堆栈资源，而且启动新的进程开销也比线程大得多，因此使用多线程来爬取比使用多进程有更多的优势。</p>
<p><code>multiprocessing</code>下面有一个<code>dummy</code>模块，它可以让Python的线程使用<code>multiprocessing</code>的各种方法。</p>
<p><code>dummy</code>下面有一个<code>Pool</code>类，它用来实现线程池。</p>
<p>这个线程池有一个<code>map()</code>方法，可以让线程池里面的所有线程都“同时”执行一个函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_power2</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">return</span> num**num</span><br><span class="line">pool = Pool(<span class="number">3</span>)</span><br><span class="line">origin_num = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">result = pool.<span class="built_in">map</span>(calc_power2, origin_num)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;计算0-9的平方分别为：<span class="subst">&#123;result&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>程池的<code>map()</code>方法接收两个参数，第1个参数是函数名，第2个参数是一个列表。</p>
<p>第1个参数仅仅是函数的名字，是不能带括号的。</p>
<p>第2个参数是一个可迭代的对象，这个可迭代对象里面的每一个元素都会被函数<code>clac_power2()</code>接收来作为参数。除了列表以外，元组、集合或者字典都可以作为<code>map()</code>的第2个参数。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python常用模块</title>
    <url>/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>Python常用模块的常用方法，如：os，shutil，datetime，time，random，sys</p>
<span id="more"></span>

<p>Python的<code>os模块和shutil模块</code>下包含了大量进行文件I/O的函数和方法，使用这些函数能很方便的读取、写入文件。</p>
<p>os.path模块主要用于文件的属性获取，如exists()函数判断该目录是否存在，getsize()函数来获取文件大小，等等。</p>
<p>全局函数open()可打开文件，并采取多种方式来读取文本内容。</p>
<p>Python还提供了<code>tempfile</code>模块来创建临时文件和临时目录，tempfile模块下的高级API会自动管理临时文件的创建和删除；当程序不再使用临时文件和临时目录时，程序会自动删除临时文件和临时目录。</p>
<h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h3><p>Python os.path模块</p>
<p>os.path模块主要用于文件的属性获取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os模块的主要方法</span><br><span class="line">os.sep	取代操作系统特定的路径分隔符</span><br><span class="line">os.name	指示正在使用的工作平台。比如对于Windows，它是 <span class="string">&#x27;nt&#x27;</span> ，而对于 Linux/UNIX 用户，它是 <span class="string">&#x27;posix&#x27;</span></span><br><span class="line">os.getcwd() 得到当前工作目录，及当前Python脚本工作的目录路径</span><br><span class="line">os.linesep	给出当前平台的行终止符。例如，Windows使用 <span class="string">&#x27;\r\n&#x27;</span> ，Linux使用 <span class="string">&#x27;\n&#x27;</span>，而Mac使用 <span class="string">&#x27;\r&#x27;</span></span><br><span class="line">os.getenv()	读取环境变量</span><br><span class="line">os.putenv()	设置环境变量</span><br><span class="line">os.listdir()	返回指定目录下的所有文件和目录名</span><br><span class="line">os.walk(top, topdown=Ture, onerror=<span class="literal">None</span>, followlinks=<span class="literal">False</span>)  遍历文件夹下所有文件	</span><br><span class="line">os.remove(file)	删除一个文件</span><br><span class="line">os.stat(file)	获得文件属性</span><br><span class="line">os.chmod(file)	修改文件权限和时间戳</span><br><span class="line">os.mkdir(name)	创建目录</span><br><span class="line">os.makedirs（r“C:\Python\test”）	创建多级目录</span><br><span class="line">os.rmdir(path)		删除目录，必须是空的</span><br><span class="line">os.mknod(<span class="string">&quot;test.txt&quot;</span>)        创建文件，Windows不能用</span><br><span class="line">os.chdir(<span class="string">&quot;path&quot;</span>)	转换目录，换路径</span><br><span class="line">os.removedirs(path)	删除多个目录</span><br><span class="line">os.rename(<span class="string">&quot;oldname&quot;</span>,<span class="string">&quot;newname&quot;</span>)	重命名文件（目录），文件或目录都是使用这条命令</span><br><span class="line">os.system()	运行shell命令</span><br><span class="line">os.exit()	终止当前进程</span><br></pre></td></tr></table></figure>

<p>os.path模块常用方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.path.abspath(path)	返回path规范化的绝对路径</span><br><span class="line">os.path.split(path)	将path分割成目录和文件名二元组返回</span><br><span class="line">os.path.dirname(path)	返回path的目录，就是os.path.split(path)的第一个元素</span><br><span class="line">os.path.basename(path)		返回path最后的文件名。如果path以 / 或 \ 结尾，那么就会返回空值。即os.path.split(path)的第二个元素</span><br><span class="line">os.path.commonprefix(<span class="built_in">list</span>)	返回<span class="built_in">list</span>中，所有path共有的最长路径</span><br><span class="line">os.path.exists(path)	 如果path存在，返回TRUE；如果path不存在，返回<span class="literal">False</span></span><br><span class="line">os.path.isabs(path)		如果path是绝对路径，返回<span class="literal">True</span></span><br><span class="line">os.path.isfile(path)		如果path是一个存在的文件，返回<span class="literal">True</span>，否则返回<span class="literal">False</span></span><br><span class="line">os.path.isdir(path)		如果path是一个存在的目录，返回<span class="literal">True</span>，否则返回<span class="literal">False</span></span><br><span class="line">os.path.join(path1[,path2[,...]])	将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</span><br><span class="line">os.path.normacase(path)	在Linux和Mac平台上，该函数会原样返回path，在Windows平台上会将路径中的所有字符转换为小写，并将所有斜杠转换为反斜杠</span><br><span class="line">os.path.normpath(path)	规范化路径</span><br><span class="line">os.path.splitdrive(path)	返回（drivername,fpath）元组</span><br><span class="line">os.path.splitext(path)	分离文件名与扩展名；默认返回（fname,fextension）元组，可做分片操作</span><br><span class="line">os.path.getsize(path)	返回path的文件的大小（字节）</span><br><span class="line">os.path.getatime(path)	返回path所指向的文件或者目录的最后存取时间</span><br><span class="line">os.path.getmtime(path)	返回path所指向的文件或目录的最后修改时间</span><br></pre></td></tr></table></figure>

<h3 id="shutil模块"><a href="#shutil模块" class="headerlink" title="shutil模块"></a>shutil模块</h3><p>shutil模块的主要方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil.rmtree(path)						删除文件夹及其所有内容</span><br><span class="line">shutil.copyfile(<span class="string">&quot;oldfile&quot;</span>,<span class="string">&quot;newfile&quot;</span>)	复制文件，oldfile和newfile都只能是文件</span><br><span class="line">shutil.copy(<span class="string">&quot;oldfile&quot;</span>,<span class="string">&quot;newfile&quot;</span>)		oldfile只能是文件夹，newfile可以是文件，可以是目标目录</span><br><span class="line">shutil.copytree(<span class="string">&quot;olddir&quot;</span>,<span class="string">&quot;newdir&quot;</span>)	复制文件夹。olddir和newdir都只能是目录，且newdir必须不存在</span><br><span class="line">shutil.move(<span class="string">&quot;oldpos&quot;</span>,<span class="string">&quot;newpos&quot;</span>)		移动文件（目录）</span><br><span class="line">shutil.rmtree(<span class="string">&quot;dir&quot;</span>)				空目录，有内容的目录都可以删除</span><br></pre></td></tr></table></figure>



<h3 id="time-amp-datetime"><a href="#time-amp-datetime" class="headerlink" title="time&amp;datetime"></a>time&amp;datetime</h3><p>#导入模块：</p>
<p><code>import time,datetime</code></p>
<p>主要函数说明如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time.clock()：以浮点数计算秒数，返回程序运行的时间</span><br><span class="line"></span><br><span class="line">time.sleep(seconds)：程序休眠seconds再执行下面的语句</span><br><span class="line"></span><br><span class="line">time.time()：返回一个浮点型数据</span><br><span class="line"></span><br><span class="line">time.gmtime(时间戳)：把时间戳转成格林尼治时间，返回一个时间元组</span><br><span class="line"></span><br><span class="line">time.lobaltime(时间戳)：把时间戳转成本地时间，返回一个时间元组（如中国时区，加<span class="number">8</span>个小时）</span><br><span class="line"></span><br><span class="line">time.mktime(时间元组)：将时间元组转成时间戳，返回一个浮点数</span><br><span class="line"></span><br><span class="line">time.asctime(时间元组)：将时间元组转成一个字符串</span><br><span class="line"></span><br><span class="line">time.ctime(时间戳)：将时间戳转成一个字符串</span><br><span class="line"></span><br><span class="line">time.strftime(<span class="built_in">format</span>,时间元组)：将时间元组转成指定格式的字符串</span><br><span class="line"></span><br><span class="line">time.strptime(字符串,<span class="built_in">format</span>)：将指定格式的字符串转成时间元组</span><br><span class="line"></span><br><span class="line">datetime.datetime.now()：获取系统当前时间</span><br><span class="line"></span><br><span class="line">datetime.datetime(参数列表)：获取指定时间</span><br><span class="line"></span><br><span class="line">datetime.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)：将时间转换为字符串</span><br></pre></td></tr></table></figure>

<h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><p>#导入模块</p>
<p><code>import random</code></p>
<p>主要函数说明如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">random.choice(列表/元组/字符串)：在列表或者元组中随机挑选一个元素，若是字符串则随机挑选一个字符</span><br><span class="line"></span><br><span class="line">random.randrange([start,end),step)：返回一个从[start,end)并且步长为step的一个随机数。若start不写，默认为<span class="number">0</span>。多数情况下step不写，默认为<span class="number">1</span>，但是end一定要有</span><br><span class="line"></span><br><span class="line">random.random()：返回一个[<span class="number">0</span>,<span class="number">1</span>)的随机数，结果是一个浮点数</span><br><span class="line"></span><br><span class="line">num4=random.random()</span><br><span class="line"></span><br><span class="line">random.shuffle(列表)：将序列中所有的元素进行随机排序，直接操作序列“序列发生变化”，无返回值</span><br><span class="line"></span><br><span class="line">random.uniform(m,n)：随机产生一个[m,n]的浮点数</span><br><span class="line"></span><br><span class="line">random.randint(m,n)：随机产生一个[m,n]的整数</span><br></pre></td></tr></table></figure>

<h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>#导入模块：</p>
<p><code>import sys</code></p>
<p>主要函数说明如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.argv：命令行参数<span class="type">List</span>，第一个元素是程序本身的路径</span><br><span class="line"></span><br><span class="line">sys.exit(n)：退出程序，正常退出是exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">sys.version：获取Python解释程序的版本信息</span><br><span class="line"></span><br><span class="line">sys.path：返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</span><br><span class="line"></span><br><span class="line">sys.platform：返回操作系统平台名称</span><br><span class="line"></span><br><span class="line">sys.modules.keys()：返回所有已经导入的模块列表</span><br><span class="line"></span><br><span class="line">sys.exc_info()：获取当前正在处理的异常类，exc_type、exc_value、exc_traceback当前处理的异常详细信息</span><br><span class="line"></span><br><span class="line">sys.maxsize：最大的Int值</span><br><span class="line"></span><br><span class="line">sys.maxunicode：最大的Unicode值</span><br><span class="line"></span><br><span class="line">sys.modules：返回系统导入的模块字段，key是模块名，value是模块</span><br><span class="line"></span><br><span class="line">sys.stdout：标准输出</span><br><span class="line"></span><br><span class="line">sys.stdin：标准输入</span><br><span class="line"></span><br><span class="line">sys.stderr：错误输出</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库简介</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>学习自华为iLearnX官网</p>
<span id="more"></span>

<p>数据库技术</p>
<ul>
<li><p>数据 Data</p>
</li>
<li><p>数据库  DB  database </p>
</li>
<li><p>数据库系统 DBS  database system</p>
</li>
<li><p>数据库管理系统 DBMS  database manager system</p>
</li>
</ul>
<p>数据库系统</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220120213518021.png" alt="image-20220120213518021"></p>
<hr>
<p>数据库技术发展</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220120213736327.png" alt="image-20220120213736327"></p>
<hr>
<p>数据库的优势</p>
<p>整体数据的结构化</p>
<ul>
<li>数据面向整个系统而不是单个应用，被多个应用共享。</li>
</ul>
<p>数据的共享性高，冗余度低且易扩充。</p>
<p>数据独立性高</p>
<ul>
<li>物理独立性：应用程序与数据库中数据的物理存储是相互独立的。</li>
<li>逻辑独立性：应用程序与数据库的逻辑结构是相互独立的。</li>
</ul>
<p>统一管理和控制</p>
<ul>
<li>数据的安全性保护；</li>
<li>数据的完整性检查</li>
<li>并发控制；</li>
<li>数据库恢复。</li>
</ul>
<hr>
<p>数据模型</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220120214105066.png" alt="image-20220120214105066"></p>
<hr>
<p>结构化查询语言  Structured  Query Language</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220120214348535.png" alt="image-20220120214348535"></p>
<hr>
<p>关系型数据库ACID特性</p>
<p>原子性( Atomicity )</p>
<ul>
<li>事务是数据库的逻辑工作单位，事务中的操作，要么都做，要么都不做。</li>
</ul>
<p>一致性( Consistency )</p>
<ul>
<li>事务的执行结果必须是使数据库从一个一致性状态转到另一个一致性状态。</li>
</ul>
<p>隔离性（ Isolation )</p>
<ul>
<li>数据库中一个事务的执行不能被其他事务干扰。即一个事务的內部操作及使用的数据对其他事务是隔离的，并发执行的各个事务不能相互干扰。</li>
</ul>
<p>持久性( Durability )</p>
<ul>
<li>事务一旦提交，对数据库中数据的改变是永久的。提交后的操作或者故障不会对事务的操作结果产生任何影响</li>
</ul>
<hr>
<p>其他数据模型</p>
<p>面向对象数据模型( Object Oriented Data Model,OO模型)</p>
<ul>
<li>将语义数据模型和面向对象程序设计方法结合起来，用一系列面向对象核心概念构成模型基础。</li>
<li>由于面向对象数据库操作语言过于复杂，没有得到开发人员认可。</li>
</ul>
<p>XML数据模型</p>
<ul>
<li>随着互联网迅速发展，出现了大量的半结构化和非结构化数据源，XML成为网上交换数据的标准之一以及研究热点，相应地出现了半结构化数据的XML数据模型。</li>
<li>纯XML数据库基于XML节点树模型，可以支持XML数据管理，但是同样要解決传统关系型数据库所面临的各种问题</li>
</ul>
<p>RDF数据模型</p>
<ul>
<li>互联网的信息没有统一表达方式，W3C提出资源描述框架( Resource Description Framework,RDF)来描述和注解互联网资源；</li>
<li>RDF是描述互联网资源的标记语言，结构为(主语，谓词，宾语)主要用于语义网、知识库的基础数据模型，是当前知识图谱技术的基石。</li>
</ul>
<hr>
<p>NoSQL数据库</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220120215125191.png" alt="image-20220120215125191"></p>
<hr>
<p>关系型数据库主流应用场景</p>
<p>联机事务处理（OnLine Transaction Processing）</p>
<ul>
<li>OLTP是传统关系数据库的主要应用<ul>
<li>面向基本的，日常的事务处理，例如银行储蓄业务的存取交易，转账交易等</li>
</ul>
</li>
<li>特点<ul>
<li>大吞吐量：大量的短在线事务(插入、更新、删除)，非常快速的査询处理。</li>
<li>高并发，（准）实时响应。</li>
</ul>
</li>
<li>典型OLTP场景<ul>
<li>零售系统</li>
<li>金融交易系统</li>
<li>火车机票销售系统</li>
<li>秒杀活动</li>
</ul>
</li>
</ul>
<p>联机分析处理（OnLine Analytical Processing）</p>
<ul>
<li>OLAP<ul>
<li>联机分析处理的概念最早是E.F.Codd于1993年相对于OLTP系统而提出的。</li>
<li>是指对数据的查询和分析操作，通常对大量的历史数据査询和分析。涉及到的历史周期比较长，数据量大，在不同层级上的汇总，聚合操作使得事务处理操作比较复杂。</li>
</ul>
</li>
<li>特点<ul>
<li>主要面向侧重于复杂查询，回答一些“战略性”的问题。</li>
<li>数据处理方面聚焦于数据的聚合，汇总，分组计算，窗口计算等“分析型”数据加工和操作。</li>
<li>从多维度去使用和分析数据。</li>
</ul>
</li>
<li>典型的OLAP场景<ul>
<li>报表系统，CRM系统</li>
<li>金融风险预测预警系统、反洗钱系统</li>
<li>数据集市，数据仓库。</li>
</ul>
</li>
</ul>
<hr>
<p>数据库性能衡量指标</p>
<ul>
<li>TPC( Transaction Processing Performance Council,事务处理性能委员会)<ul>
<li>职责是制定商务应用基准测试标准( Benchmark)的规范、性能和价格度量，并管理测试结果的发布。</li>
<li>制定的是标准规范而不是代码，任何厂家依据规范最优地构造自己系统进行评测。</li>
<li>推出了很多基准测试标准，其中针对OLTP和OLAP分别有两个规范。</li>
</ul>
</li>
<li>TPC-C规范<ul>
<li>面向OLTP系统，主要包括两个指标<ul>
<li>流量指标：tpmc(tpm- transactions per minuet,即每分钟测试系统处理的事务数量)。</li>
<li>性价比指标： Price（测试系统价格）/tmpC.</li>
</ul>
</li>
</ul>
</li>
<li>TPC-H规范<ul>
<li>面向OLAP类系统<ul>
<li>流量指标：qphH- Query per hour,即每小时处理的复杂査询数量。</li>
<li>需要考虑测试数据集合大小，分为不同的测试数据集，指定了22个查询语句，可以根据产品微调</li>
<li>测试场景：数据加载， Powera能力测试和 Througputi则试。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库大作业</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A_107/</url>
    <content><![CDATA[<p>数据库大作业我负责的内容</p>
<span id="more"></span>

<h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><p>英雄联盟云顶之弈英雄数据，将英雄的详细数据作为此次实验所展示的信息</p>
<img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A_107/image-20211229205302299.png" alt="image-20211229205302299" style="zoom:80%;">

<img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A_107/image-20211229205359200.png" alt="image-20211229205359200" style="zoom:80%;">



<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>分析数据构造相应的的表</p>
<p>Cards数据库，依次保存英雄的 ==称号，图片，头像，技能名称，技能图片，技能类型，技能描述，英雄价格，英雄ID==</p>
<p>其中英雄ID是主码</p>
<h2 id="Cards"><a href="#Cards" class="headerlink" title="Cards"></a>Cards</h2><table>
<thead>
<tr>
<th>name<string></string></th>
<th>img</th>
<th>icon</th>
<th>skill_name<string></string></th>
<th>skill_img</th>
<th>skill_type<string></string></th>
<th>skill_desc<string></string></th>
<th>price<int></int></th>
<th>id<int></int></th>
</tr>
</thead>
<tbody><tr>
<td>卡牌大师 崔斯特</td>
<td></td>
<td></td>
<td>万能牌</td>
<td></td>
<td>主动</td>
<td>崔斯特沿锥形掷出3张牌，对沿途的每个敌人造成145 / 190 / 255魔法伤害。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>刀锋之影 泰隆</td>
<td></td>
<td></td>
<td>刀锋之末</td>
<td></td>
<td>被动</td>
<td>被动：泰隆对一名敌人进行的第一次攻击将使其流血，在 7 秒里持续造成共450 / 625 / 950魔法伤害。对相同目标的每第3次攻击会施加一层额外的流血效果。</td>
<td>2</td>
<td>91</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Fetters表存有英雄所拥有的羁绊信息，==一个英雄可以拥有多个羁绊，是一对多的关系，单独用一张表将其存起来==</p>
<h2 id="Fetters-羁绊"><a href="#Fetters-羁绊" class="headerlink" title="Fetters(羁绊)"></a>Fetters(羁绊)</h2><table>
<thead>
<tr>
<th>id&lt;int&gt;</th>
<th>fname&lt;string&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>辛迪加</td>
</tr>
<tr>
<td>4</td>
<td>黑魔法师</td>
</tr>
<tr>
<td>91</td>
<td>帝国</td>
</tr>
<tr>
<td>91</td>
<td>刺客</td>
</tr>
</tbody></table>
<p>Fetter 表存有羁绊的详细内容，依次是==羁绊名称，羁绊图标，羁绊描述，羁绊在不同情况下的描述==。</p>
<h2 id="Fetter"><a href="#Fetter" class="headerlink" title="Fetter"></a>Fetter</h2><table>
<thead>
<tr>
<th>fname<string></string></th>
<th>icon</th>
<th>descr<string></string></th>
<th>level<string></string></th>
</tr>
</thead>
<tbody><tr>
<td>帝国</td>
<td></td>
<td>在战斗环节开始时，上一回合造成了最多伤害的【帝国】英雄会变为【帝国统领】。【帝国统领】造成额外伤害。当【帝国统领】阵亡时，当前战斗环节中造成了最多伤害的【帝国】英雄会变为新的【帝国统领】。</td>
<td>3:” 75%额外伤害”$5:” 125%额外伤害，并且其他【帝国】英雄们造成75%额外伤害”</td>
</tr>
</tbody></table>
<p>Properties表存有英雄的各类属性信息，依次存有英雄的==ID，生命，护甲，魔抗，物攻，攻速，暴击率，攻击距离，初始法力值，法力值==等信息</p>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><table>
<thead>
<tr>
<th>数据项</th>
<th>数据类型</th>
<th>主码</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>Y</td>
</tr>
<tr>
<td>health</td>
<td>VARCHAR(20)</td>
<td></td>
</tr>
<tr>
<td>armor</td>
<td>VARCHAR(20)</td>
<td></td>
</tr>
<tr>
<td>magic_resist</td>
<td>VARCHAR(20)</td>
<td></td>
</tr>
<tr>
<td>material_attack</td>
<td>VARCHAR(20)</td>
<td></td>
</tr>
<tr>
<td>attack_speed</td>
<td>VARCHAR(20)</td>
<td></td>
</tr>
<tr>
<td>critical_strike_rate</td>
<td>VARCHAR(20)</td>
<td></td>
</tr>
<tr>
<td>attack_distance</td>
<td>VARCHAR(20)</td>
<td></td>
</tr>
<tr>
<td>initial_mana</td>
<td>VARCHAR(20)</td>
<td></td>
</tr>
<tr>
<td>mana</td>
<td>VARCHAR(20)</td>
<td></td>
</tr>
</tbody></table>
<p>Users表存有用户的==ID，密码，类型==，类型是管理员和普通用户</p>
<h2 id="Users"><a href="#Users" class="headerlink" title="Users"></a>Users</h2><table>
<thead>
<tr>
<th>id</th>
<th>pwd</th>
<th>privilege</th>
</tr>
</thead>
<tbody><tr>
<td>root</td>
<td>string</td>
<td>2</td>
</tr>
<tr>
<td>tomClancy</td>
<td>ubisoft</td>
<td>1</td>
</tr>
<tr>
<td>jackMa</td>
<td>123456</td>
<td>1</td>
</tr>
</tbody></table>
<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A_107/image-20211230115426092.png" alt="image-20211230115426092"></p>
<h2 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h2><p>将==Cards，Fetters，Properties==三张表通过英雄ID创建==表级参照完整性约束==，作用：删除英雄数据时，只需要根据ID删除Cards的数据，Fetters和Properties会自动删除相应ID的数据</p>
<h3 id="创建Cards"><a href="#创建Cards" class="headerlink" title="创建Cards"></a>创建Cards</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table Cards</span><br><span class="line">(</span><br><span class="line">name varchar(40),</span><br><span class="line">img varchar(100),</span><br><span class="line">icon varchar(100),</span><br><span class="line">skill_name varchar(20),</span><br><span class="line">skill_img varchar(100),</span><br><span class="line">skill_type varchar(10),</span><br><span class="line">skill_desc varchar(500),</span><br><span class="line">price tinyint,</span><br><span class="line">id int primary key not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="创建Fetters"><a href="#创建Fetters" class="headerlink" title="创建Fetters"></a>创建Fetters</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table fetters</span><br><span class="line">(</span><br><span class="line">id int,</span><br><span class="line">fname varchar(18),</span><br><span class="line">foreign key(id)</span><br><span class="line">references cards(id)</span><br><span class="line">on delete cascade</span><br><span class="line">on update cascade</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="创建Fetter"><a href="#创建Fetter" class="headerlink" title="创建Fetter"></a>创建Fetter</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> fetter</span><br><span class="line">(</span><br><span class="line">fname <span class="type">varchar</span>(<span class="number">18</span>) <span class="keyword">primary</span> key,</span><br><span class="line">icon <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">descr <span class="type">varchar</span>(<span class="number">500</span>),</span><br><span class="line">level <span class="type">varchar</span>(<span class="number">1000</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="创建Properties"><a href="#创建Properties" class="headerlink" title="创建Properties"></a>创建Properties</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> properties</span><br><span class="line">(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">health <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">armor <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">magic_resist <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">material_attack <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">attack_speed <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">critical_strike_rate <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">attack_distance <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">initial_mana <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">mana <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">foreign</span> key(id)</span><br><span class="line"><span class="keyword">references</span> cards(id)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> cascade</span><br><span class="line"><span class="keyword">on</span> update cascade</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="创建Users"><a href="#创建Users" class="headerlink" title="创建Users"></a>创建Users</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table users</span><br><span class="line">(</span><br><span class="line">id varchar(20),</span><br><span class="line">pwd varchar(20),</span><br><span class="line">privilege int    </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>==存储过程==</p>
<p>创建添加用户的存储过程，后端调用<code>procedure adduser</code>并传入参数，<code>adduser</code>会判断<code>user</code>表中用户名是否存在，若存在，置输出参数<code>result</code>值为0；若不存在，将用户数据插入Users表中，并返回<code>result</code>为1；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure addUser(in name varchar(20),in pwd varchar(20),in privilege int,out result int)</span><br><span class="line">begin</span><br><span class="line">declare e varchar(20);</span><br><span class="line">set e=&#x27;&#x27;;</span><br><span class="line">set result=1;</span><br><span class="line">select user_id into e</span><br><span class="line">from users</span><br><span class="line">where id=name;</span><br><span class="line">if e=name then</span><br><span class="line">set result=0;</span><br><span class="line">else insert into users values(name,pwd,privilege);</span><br><span class="line">end if;</span><br><span class="line">end$$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>



<h2 id="数据爬取"><a href="#数据爬取" class="headerlink" title="数据爬取"></a>数据爬取</h2><p>使用python爬取数据并存入数据库</p>
<img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A_107/image-20211229215916131.png" alt="image-20211229215916131" style="zoom: 80%;">



<p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A_107/image-20211229215957252.png" alt="image-20211229215957252"></p>
<img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A_107/image-20211229220055562.png" alt="image-20211229220055562" style="zoom:80%;">

<img src="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A_107/image-20211229220132910.png" alt="image-20211229220132910" style="zoom:80%;">

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python文件操作</title>
    <url>/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>Python对文件的操作</p>
<span id="more"></span>

<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>文件对象操作</p>
<p><code>open()</code>函数用于打开文件对象，<code>open(file,mode) </code>  </p>
<p>file必需，文件路径，mode可选，文件打开模式。</p>
<p>有 <code> r、rb、r+、rb+、w、wb、wb、w+、wb+、a、ab、a+、ab+</code></p>
<p>Python在处理文本对象时可采取字节模式和字符模式</p>
<p>文件对象像序列一样可遍历，因此程序完全可以使用for循环来遍历文件内容。也可使用<code>list(fp)</code>方法或<code>fp.readlines()</code>方法将文件内容存放到列表中。</p>
<p>with语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的清理操作，释放资源。比如文件使用后自动关闭、线程锁的自动获取和释放等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;d:/abc.txt&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> fp:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure>



<p>文件对象的<code>字节模式/b模式</code>（UTF-8编码为例）</p>
<table>
<thead>
<tr>
<th>文件对象</th>
<th>读操作</th>
<th>写操作</th>
<th>指针操作</th>
</tr>
</thead>
<tbody><tr>
<td>ASCII字节</td>
<td>返回bytes/字节类型的ASCII</td>
<td>写入bytes类型字节<br>例如：b”This is ASCII”</td>
<td>使用seek每次设置任意字节</td>
</tr>
<tr>
<td>中文字符串</td>
<td>返回bytes/字节类型的乱码<br>例如：\xe4\xbd\xa0，三组为一个中文，需解码显示<br>例如：’\xe4\xbd\xa0&#39;.decode(‘utf8’)</td>
<td>把字符串编码后才可写操作<br>例如：’内容’.encode(‘utf-8’)</td>
<td>使用seek每次设置3的倍数的字节</td>
</tr>
</tbody></table>
<p>文本对象的字本模式</p>
<table>
<thead>
<tr>
<th>文件对象</th>
<th>读操作</th>
<th>写操作</th>
<th>指针操作</th>
</tr>
</thead>
<tbody><tr>
<td>ASCII字节</td>
<td>返回可查看的字符串</td>
<td>写入字符串</td>
<td>使用seek每次设置任意字节</td>
</tr>
<tr>
<td>中文字符串</td>
<td>返回可查看的字符串</td>
<td>写入字符串</td>
<td>使用seek每次设置3的倍数的字节</td>
</tr>
</tbody></table>
<p>文件对象的主要方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">读</span><br><span class="line"></span><br><span class="line">fp.read(size)	size可选，读取文件中size个字符的内容，若size为负或不存在，读取全部内容；当文件大小是当前机器内容的两倍是，出错；若到了文件末尾，会显示空字符串</span><br><span class="line"></span><br><span class="line">fp.readline()	读取文件中单独一行。返回的每行结尾会自动夹换行符<span class="string">&#x27;\n&#x27;</span>，如果到了文件末尾，返回空字符串</span><br><span class="line"></span><br><span class="line">fp.readlines()	返回文件的所有行</span><br><span class="line"></span><br><span class="line">写</span><br><span class="line"></span><br><span class="line">fp.write(string)	将string写入文件中，返回值为写入的字符数</span><br><span class="line"></span><br><span class="line">其他方法</span><br><span class="line"></span><br><span class="line">fp.tell()	返回指针在文件中的位置，从文件开头开始计算的字符数</span><br><span class="line"></span><br><span class="line">fp.seek(offset, from_what)	改变指针在文件中的位置，from_what=<span class="number">0</span>或<span class="number">1</span>或<span class="number">2</span>，<span class="number">0</span>：文件开头 <span class="number">1</span>：当前位置 <span class="number">2</span>：文件结尾 </span><br><span class="line">							seek(x,<span class="number">0</span>) 从文件首字符移动x个字符</span><br><span class="line">    						seek(x,<span class="number">1</span>) 从当前位置往后移动x个字符</span><br><span class="line">        					seek(-x,<span class="number">2</span>) 从文件的结尾往前移动x个字符</span><br><span class="line">            </span><br><span class="line">fp.close() 关闭文件</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center">mode参数</th>
<th align="center">含义描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">只读</td>
</tr>
<tr>
<td align="center">rb</td>
<td align="center">只读</td>
</tr>
<tr>
<td align="center">r+</td>
<td align="center">只读，二进制格式</td>
</tr>
<tr>
<td align="center">rb+</td>
<td align="center">读写，二进制格式</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">写，文件不存在则新建，存在则删除原有内容</td>
</tr>
<tr>
<td align="center">wb</td>
<td align="center">写，二进制格式，文件不存在则新建，存在则删除原有内容</td>
</tr>
<tr>
<td align="center">w+</td>
<td align="center">读写，文件不存在则新建，存在则删除原有内容</td>
</tr>
<tr>
<td align="center">wb+</td>
<td align="center">读写，二进制格式，文件不存在则新建，存在则删除原有内容</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">追加，文件不存在则新建，存在则追加内容</td>
</tr>
<tr>
<td align="center">ab</td>
<td align="center">追加，二进制格式，文件不存在则新建，存在则追加内容</td>
</tr>
<tr>
<td align="center">a+</td>
<td align="center">读写，文件不存在则新建，存在则追加内容</td>
</tr>
<tr>
<td align="center">ab+</td>
<td align="center">读写，二进制格式，文件不存在则新建，存在则追加内容</td>
</tr>
</tbody></table>
<p><font color="#ff000">总结：r模式和w模式，打开文件，指针都在文件头，而a模式则在文件尾；w模式和a模式都能在文件不存在时新建文件</font></p>
<p>open()的详细格式为：</p>
<p><code>open(file,  mode=&quot;r&quot;,  buffering=None, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code></p>
<p>参数说明：</p>
<p>file：必需，文件路径（相对或绝对路径）</p>
<p>mode：可选，文件打开模式</p>
<p>buffering：设置缓冲</p>
<p>encoding：一般使用utf-8</p>
<p>errors：报错级别</p>
<p>newline：区分换行符</p>
<p>closefd：传入的file参数类型</p>
<p>opener：可以通过调用 <em>opener</em>方式，使用自定义的开启器。底层文件描述符是通过调用<em>opener</em>或者<em>file</em>、<em>flags</em>获得的。<em>opener</em>必须返回一个打开的文件描述。将os.open作为<em>opener</em>的结果，在功能上，类似于通过None。</p>
<h3 id="读CSV文件"><a href="#读CSV文件" class="headerlink" title="读CSV文件"></a>读CSV文件</h3><p>要读取CSV文件，首先需要导入Python的CSV模块：</p>
<p><code>import csv</code></p>
<p>由于CSV文件本质上是一个文本文件，所以需要先以文本文件的方式打开，再将文件对象传递给CSV模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;course.csv&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.DictReader(f)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">    	<span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>

<p>for循环得到的row是OrderedDict（有序字典），可以直接像普通字典那样使用</p>
<p><font color="#ff0000">特别注意：</font></p>
<p>读取文本内容的代码必须放在缩进内部进行，否则会导致报错。</p>
<p>这是因为f变量里面的值是一个生成器，生成器只有在被使用（更准确的说法是被迭代）的时候才会去读文本内容。但是退出with的缩进以后，文件就被Python关闭了，这个时候当然什么都读不了</p>
<p>列表推导式可以绕过这个限制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;course.csv&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    reader = [x <span class="keyword">for</span> x <span class="keyword">in</span> csv.DictReader(f)]</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>


<h3 id="写CSV文件"><a href="#写CSV文件" class="headerlink" title="写CSV文件"></a>写CSV文件</h3><p>Python可以把一个字典写成CSV文件，或者把一个包含字典的列表写成CSV文件。</p>
<p>Python写CSV文件比读CSV文件稍微复杂一点，因为要指定列名。</p>
<p>列名要和字典的Key一一对应。</p>
<p>Python写CSV文件时需要用到csv.DictWriter()这个类。它接收两个参数：</p>
<p>第1个参数是文件对象f；第2个参数名为fieldnames，值为字典的Key列表。</p>
<p>写入CSV文件的为列名的一行：</p>
<p><code>writer.writeheader()</code></p>
<p>将包含字典的列表全部写入到CSV文件中:</p>
<p><code>writer.writerows(包含字典的列表)</code></p>
<p>学入单个字典：</p>
<p><code>writer.writerow(字典)</code></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和运算</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>Python的数据类型及其运算</p>
<span id="more"></span>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>不可变数据类型：</p>
<ul>
<li><p>number（数字型）：int、bool、float、complex（复数型）</p>
</li>
<li><p>str（字符串型）</p>
</li>
<li><p>tuple（元组型）</p>
</li>
</ul>
</li>
<li><p>可变：</p>
<ul>
<li><p>list（列表型）</p>
</li>
<li><p>set（集合型）</p>
</li>
<li><p>dictionary（字典型）</p>
</li>
<li><p>int 整数型：</p>
</li>
<li><p>bool 逻辑型：</p>
</li>
<li><p>实数型：</p>
<ul>
<li>科学计数法：123e3或123E3，e或E之前必须有数字，后面的指数必须是整数</li>
</ul>
</li>
<li><p>复数型：3+4J，5+6j</p>
</li>
</ul>
</li>
</ul>
<p>字符串型：</p>
<pre><code>转义字符：\b    backspace     BS 退格

      \t    horizontal tab    HT Tab键

      \n    linefeed        LF 换行

      \f    form feed    FF 换页

      \r    carriage return     CR 回车

      \&quot;    double quote    双引号

      \&#39;    single quote    单引号

      \\    backslash        反斜杠

      \            续行符
</code></pre>
<p>元组型：（）和list列表类似，但元素不能修改</p>
<p>列表型：[]</p>
<p>集合型：{}，不能包好列表型、集合型、字典型。</p>
<p>字典型：</p>
<p>可变类型的数据：同一值赋值给不同变量或同一值多次赋值给同一变量，id值不同</p>
<p>不可变类型的数据：同一值赋值给不同变量，id相同；给变量的赋值发生变化，id改变</p>
<hr>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>(x,[,base])		x转为整数</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span>(x)			x转为浮点数</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span>(real[,imag])	创建一个复数</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span>(x)			将对象x转换为字符串</span><br><span class="line"></span><br><span class="line"><span class="built_in">repr</span>(x)			将对象x转换为表达式字符串</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="built_in">str</span>)			计算在字符串中有效Python表达式，返回一个对象</span><br><span class="line"></span><br><span class="line"><span class="built_in">tuple</span>(s)			将序列s转换为元组</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(s)			将序列s转换为列表</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(s)			转换为不可变集合</span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span>(d)			创建一个字典，d必须是一个序列(key,value)元组</span><br><span class="line"></span><br><span class="line"><span class="built_in">frozenset</span>(s)		转换为不可变集合</span><br><span class="line"></span><br><span class="line"><span class="built_in">chr</span>(x)			将x转换为字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">ord</span>(x)			将x转换为它的整数值</span><br><span class="line"></span><br><span class="line"><span class="built_in">hex</span>(x)			将x转换为十六进制字符串</span><br><span class="line"></span><br><span class="line"><span class="built_in">oct</span>(x) 			将转换为八进制字符串</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="算术运算符和算术表达式"><a href="#算术运算符和算术表达式" class="headerlink" title="算术运算符和算术表达式"></a>算术运算符和算术表达式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+	加法。</span><br><span class="line"></span><br><span class="line">-</span><br><span class="line"></span><br><span class="line">*	两个数相乘或是一个被重复若干次的字符串 <span class="string">&quot;hello&quot;</span>*<span class="number">2</span>结果为<span class="string">&quot;hellohello&quot;</span></span><br><span class="line"></span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">%</span><br><span class="line"></span><br><span class="line">**	b**a为b的a次方</span><br><span class="line"></span><br><span class="line">//	返回商的整数部分（向下取整）<span class="number">35</span>//<span class="number">15</span>=<span class="number">2</span>      -<span class="number">35</span>//<span class="number">15</span>=-<span class="number">3</span></span><br><span class="line"></span><br><span class="line">注：<span class="number">1</span>、+   列表、元组、字符串的连接</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span>、*   列表、元组、字符串三种有序序列与整数相乘，表示将序列赋值整数倍</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="关系运算符和关系表达式"><a href="#关系运算符和关系表达式" class="headerlink" title="关系运算符和关系表达式"></a>关系运算符和关系表达式</h3><p><code>&gt;   &gt;=   &lt;    &lt;=    ==    !=</code></p>
<pre><code>注：
Python关系运算符可以连用。具有惰性求值或者逻辑短路的特点，即从左向右运算中，有部分结果为False，终止运算

实数型数据之间比较是否相等是，不宜使用“x==y”，而应使用两个数之差的绝对值小于一个很小的数的形式判断
</code></pre>
<hr>
<h3 id="逻辑运算符和逻辑表达式"><a href="#逻辑运算符和逻辑表达式" class="headerlink" title="逻辑运算符和逻辑表达式"></a>逻辑运算符和逻辑表达式</h3><p><code>and   or     not</code></p>
<pre><code>注：Python逻辑运算符具有惰性求值或者逻辑短路的特点。
</code></pre>
<hr>
<h3 id="赋值运算符和赋值表达式"><a href="#赋值运算符和赋值表达式" class="headerlink" title="赋值运算符和赋值表达式"></a>赋值运算符和赋值表达式</h3><hr>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">与&amp;	op1 &amp; op2 </span><br><span class="line"></span><br><span class="line">位或|	op1 | op2</span><br><span class="line"></span><br><span class="line">位非~	~op1</span><br><span class="line"></span><br><span class="line">位异或^	op1 ^ op2</span><br><span class="line"></span><br><span class="line">左移&lt;&lt;	op1&lt;&lt;op2	op1左移op2位</span><br><span class="line"></span><br><span class="line">右移&gt;&gt;	op1&gt;&gt;op2	op1右移op2位</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">is</span>	判断是否引用自一个对象</span><br><span class="line"></span><br><span class="line"><span class="keyword">not</span> <span class="keyword">is</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(),[]</span><br><span class="line"></span><br><span class="line">x.attrbute（属性访问）</span><br><span class="line"></span><br><span class="line">**</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line"></span><br><span class="line">+,-（符号运算符）</span><br><span class="line"></span><br><span class="line">*,/,%,//</span><br><span class="line"></span><br><span class="line">+,-（加减法）</span><br><span class="line"></span><br><span class="line">&gt;&gt;,&lt;&lt;</span><br><span class="line"></span><br><span class="line">&amp;</span><br><span class="line"></span><br><span class="line">^</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">==,!=,&lt;=,&lt;,&gt;,&gt;=</span><br><span class="line"></span><br><span class="line">=,%=,/=,//=,-=,+=,*=,**=</span><br><span class="line"></span><br><span class="line"><span class="keyword">is</span>,<span class="keyword">is</span> <span class="keyword">not</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span>,<span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">not</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">lambda</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="条件控制语句"><a href="#条件控制语句" class="headerlink" title="条件控制语句"></a>条件控制语句</h3><p><code>if-else语句</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式:</span><br><span class="line"></span><br><span class="line">      语句块<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">      语句块<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><code>if-elif-else语句</code></p>
<hr>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p><code>while循环</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 表达式:</span><br><span class="line"></span><br><span class="line">    语句块<span class="keyword">while</span>    <span class="comment"># 后面else这部分一般不加</span></span><br><span class="line"><span class="keyword">else</span>:                   </span><br><span class="line">    语句块<span class="keyword">else</span></span><br></pre></td></tr></table></figure>

<p><code>for循环</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 序列:</span><br><span class="line">	</span><br><span class="line">    语句块<span class="keyword">for</span>   <span class="comment"># 后面else这部分一般不加</span></span><br><span class="line"><span class="keyword">else</span>:       </span><br><span class="line"></span><br><span class="line">	语句块<span class="keyword">else</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">说明：</span><br><span class="line"></span><br><span class="line"><span class="built_in">range</span>()函数可以生成数列，因此可以和<span class="keyword">for</span>循环配套使用。</span><br><span class="line"></span><br><span class="line"><span class="built_in">range</span>()函数的格式为：<span class="built_in">range</span>(start,end[,step])  </span><br><span class="line"></span><br><span class="line">生成一个初值为start，截止值为end，步长为step的数列，step省略是步长默认为<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)  范围[<span class="number">0</span>,<span class="number">5</span>) 运行<span class="number">5</span>次，从<span class="number">0</span>开始</span><br><span class="line"><span class="keyword">while</span>也可以搭配<span class="keyword">else</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><p><code>break语句</code></p>
<p><code>continue语句</code></p>
<p><code>return语句</code></p>
<hr>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">记为  s = <span class="string">&#x27;&#x27;</span>   或	s = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">Python没有字符类型，可以用单字符串代替</span><br><span class="line"></span><br><span class="line">字符串连接：+</span><br><span class="line"></span><br><span class="line">重复输出字符串：*运算</span><br><span class="line"></span><br><span class="line">s2 = s1 * n	将s1复制n次给s2</span><br><span class="line"></span><br><span class="line">成员运算符：<span class="keyword">in</span>运算</span><br><span class="line"></span><br><span class="line">s2 <span class="keyword">in</span> s1  判断s2是不是s1的子串，是为<span class="literal">True</span>，否为<span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p><code>索引</code>号规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python中，n个元素构成的有序序列（字符串、列表等）的索引号从左到右依次为0,1,2,……，n-1</span><br><span class="line"></span><br><span class="line">从右到左依次为-1，-2，……，-n</span><br><span class="line"></span><br><span class="line">正序列号 = 负索引号 + len（序列）</span><br></pre></td></tr></table></figure>

<p><code>切片</code>    截取有序序列的部分或全部元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">形式1：序列[index]		截取序列号为index的元素</span><br><span class="line"></span><br><span class="line">形式2：序列[start：end]</span><br><span class="line"></span><br><span class="line">    从左向右截取索引号start至索引号end之间的元素，但不包括end，省略start时默认为从最左边开始截取，省略end时截取到最右边。start和end为正负均可，一般要求start位于end左边，否则截取为空</span><br><span class="line"></span><br><span class="line">形式3：序列[start: end: step]</span><br><span class="line"></span><br><span class="line">    step&gt;0时，从左向右截取start至end之间的元素，但不包括end，省略start默认从最左边开始，省略</span><br><span class="line"></span><br><span class="line">end默认截取到最右边，start和end正负均可，一般要求start位于end左边，否则截取为空</span><br><span class="line"></span><br><span class="line">    step&lt;0时，从右向左截取start至end之间的元素，不包括end，省略start默认从最左边开始，省略</span><br><span class="line"></span><br><span class="line">    end默认截取到最右边，start和end正负均可，一般要求start位于end右边，否则截取为空</span><br></pre></td></tr></table></figure>

<p>字符串格式化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）%格式符方法	        %[(name)][flags][width].[precision]typecode</span><br><span class="line"></span><br><span class="line">（2）format方式	        [[fill]align][sign][#][0][width][,][.precision][type]</span><br></pre></td></tr></table></figure>

<p>字符串常见函数及方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.zfill(n) ： 字符串前面补<span class="number">0</span>，n为设置字符串长度</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、去掉空格和特殊符号</span><br><span class="line"></span><br><span class="line">s.strip()：去掉空格和换行符</span><br><span class="line"></span><br><span class="line">s.strip(<span class="string">&#x27;xx&#x27;</span>)：去掉某个字符串</span><br><span class="line"></span><br><span class="line">s.lstrip()：去掉左边的控分和换行符</span><br><span class="line"></span><br><span class="line">s.rstrip()：去掉右边的空格和换行符</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、字符串的搜索和替换</span><br><span class="line"></span><br><span class="line">s.count(<span class="string">&#x27;x&#x27;</span>)：查找某个字符在字符串里面出现的次数</span><br><span class="line"></span><br><span class="line">s.capitalize()：首字母大写</span><br><span class="line"></span><br><span class="line">s.center(n,<span class="string">&#x27;-&#x27;</span>)：把字符串放中间，两边用-对齐</span><br><span class="line"></span><br><span class="line">s.find(<span class="string">&#x27;x&#x27;</span>)：找到这个字符返回下标，多个时返回第一个；不存在的字符返回-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">s.index(<span class="string">&#x27;x&#x27;</span>)：找到这个字符返回下标，多个时返回第一个；不存在的字符报错</span><br><span class="line"></span><br><span class="line">s.replace(oldstr,newstr)字符串替换</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">format</span>()：字符串格式化</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、字符串的测试和替换函数</span><br><span class="line"></span><br><span class="line">s.startswith(prefix[,start[,end]])：是否以prefix开头</span><br><span class="line"></span><br><span class="line">s.endswith(suffix[,start[,end]])：以suffix结尾</span><br><span class="line"></span><br><span class="line">s.isalnum()：是否全是字母和数字，并至少有一个字符</span><br><span class="line"></span><br><span class="line">s.isalpha()：是否全是字母，并至少有一个字符</span><br><span class="line"></span><br><span class="line">s.isdigit()：是否全是数字，并至少有一个字符</span><br><span class="line"></span><br><span class="line">s.isspace()：是否全是空白字符，并至少有一个字符</span><br><span class="line"></span><br><span class="line">s.islower()：s中的字母是否全是小写</span><br><span class="line"></span><br><span class="line">s.isupper()：s中的字母是否全是大写</span><br><span class="line"></span><br><span class="line">s.istitle()：s是否是首字母大写的</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、字符串分割</span><br><span class="line"></span><br><span class="line">s.split()：默认是按照空格分割</span><br><span class="line"></span><br><span class="line">s.split(splitter)：按照splitter分割</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、字符串连接</span><br><span class="line"></span><br><span class="line">joiner.join(slit)：使用连接字符串joiner将slit中的元素连接成一个字符串，slit可以是字符串列表、字典（可迭代的对象）。</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>类型不能被连接</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、截取字符串（切片）</span><br><span class="line"></span><br><span class="line">s=<span class="string">&#x27;0123456789&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>:<span class="number">3</span>])：截取第一位到第三位的字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[:])：截取字符串的全部字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">6</span>:])：截取第七个字符到结尾</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[:-<span class="number">3</span>])：截取从头开始到倒数第三个字符之前</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">2</span>])：截取第三个字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">1</span>])：截取倒数第一个字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])：创造一个与原字符串顺序相反的字符串</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">3</span>:-<span class="number">1</span>])：截取倒数第三位与倒数第一位之前的字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">3</span>:])：截取倒数第三位到结尾</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[:-<span class="number">5</span>:-<span class="number">3</span>])：逆序截取</span><br></pre></td></tr></table></figure>

<p>string模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">string.ascii_uppercase：所有大写字母</span><br><span class="line"></span><br><span class="line">string.ascii_lowercase：所有小写字母</span><br><span class="line"></span><br><span class="line">string.ascii_letters：所有字母</span><br><span class="line"></span><br><span class="line">string.digits：所有数字</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="列表List"><a href="#列表List" class="headerlink" title="列表List []"></a>列表List []</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表创建：赋值创建，或调用函数<span class="built_in">list</span>()由字符串、元素、集合、字典等创建。列表可为空[]</span><br><span class="line"></span><br><span class="line">列表截取：与字符串类似，索引号，从左向右依次为：<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,...从右向左依次为：-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">3</span>,...</span><br><span class="line"></span><br><span class="line">列表运算（和字符串类似）：</span><br><span class="line"></span><br><span class="line">连接+，复制*，修改，判断某元素是否属于列表<span class="keyword">in</span>，个数<span class="built_in">len</span>()，最大值<span class="built_in">max</span>()，最小值<span class="built_in">min</span>()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="元组Tuple"><a href="#元组Tuple" class="headerlink" title="元组Tuple ()"></a>元组Tuple ()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元组创建：赋值创建，或调用函数<span class="built_in">tuple</span>()由列表、集合、字符串等创建。元组可为空()，可只有一个元素</span><br><span class="line"></span><br><span class="line">元素(<span class="number">10</span>,)，只有一个元素时，逗号不能少，否则会认为是数学上的(<span class="number">5</span>)。</span><br><span class="line"></span><br><span class="line">元组截取：与字符串类似，索引号，从左向右依次为：<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,...从右向左依次为：-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">3</span>,...</span><br><span class="line"></span><br><span class="line">元组运算：连接+，复制*，判断某元素是否属于元组<span class="keyword">in</span>，个数<span class="built_in">len</span>()，最大值<span class="built_in">max</span>()，最小值<span class="built_in">min</span>()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set    {}"></a>集合Set    {}</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合创建：赋值创建，或调用函数<span class="built_in">set</span>()由列表、元组、字符串等创建。空集合不能通过set1=&#123;&#125;形式创建，只能通过set1=<span class="built_in">set</span>()创建，set1=&#123;&#125;是空字典。</span><br><span class="line"></span><br><span class="line">集合添加和删除：s.add()添加元素，s.pop()随机删除一个元素，s.remove()和s.discard()删除指定元素</span><br><span class="line"></span><br><span class="line">s.remove在删除元素不存在时会报错(KeyError)，s.discard()在删除元素不在时不会报错</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="字典Dictionary"><a href="#字典Dictionary" class="headerlink" title="字典Dictionary    {}"></a>字典Dictionary    {}</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">无序的键(key):值(value)	通过键(key)存取，不是索引存取	</span><br><span class="line"></span><br><span class="line">键key必须使用不可变类型，键key的类型可以不同，键值不能相同</span><br><span class="line"></span><br><span class="line">值value的类型任意</span><br><span class="line"></span><br><span class="line">创建字典：赋值创建，或创建空字典再逐一添加元素</span><br><span class="line"></span><br><span class="line">访问字典里的值：字典对象[key]</span><br><span class="line"></span><br><span class="line">修改字典：增加、修改、删除键/值对</span><br><span class="line"></span><br><span class="line">删除字典：<span class="keyword">del</span>命令可删除单一的元素，可清空字典</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="栈stack-和-队列queue"><a href="#栈stack-和-队列queue" class="headerlink" title="栈stack 和 队列queue"></a>栈stack 和 队列queue</h3><p><code>collections</code>是Python内建的一个集合模块，里面封装了许多集合类，其中队列相关的集合只有一个deque。<code>deque</code>是双边队列(double-ended queue)，具有队列和栈的性质，在list的基础上增加了移动、旋转和增删等。</p>
<p>常用方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = collections.deque([])</span><br><span class="line"></span><br><span class="line">d.append(<span class="string">&#x27;a&#x27;</span>):在最右边添加一个元素</span><br><span class="line"></span><br><span class="line">d.appendleft(<span class="string">&#x27;b&#x27;</span>):在最左边添加一个元素</span><br><span class="line"></span><br><span class="line">d.extend([<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]):在最右边添加所有元素</span><br><span class="line"></span><br><span class="line">d.extendleft([<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>]):在最左边添加所有元素</span><br><span class="line"></span><br><span class="line">d.pop():将最右边的元素取出</span><br><span class="line"></span><br><span class="line">d.popleft():将最左边的元素取出</span><br><span class="line"></span><br><span class="line">d.rotate(-<span class="number">2</span>):向左旋转两个位置，正数向右旋转</span><br><span class="line"></span><br><span class="line">d.count(<span class="string">&#x27;a&#x27;</span>):队列中a的个数</span><br><span class="line"></span><br><span class="line">d.remove(<span class="string">&#x27;c&#x27;</span>):从队列中将c删除</span><br><span class="line"></span><br><span class="line">d.reverse():将队列倒序</span><br></pre></td></tr></table></figure>



<p>当要判断一个变量里面的 是不是 None 的时候,可以使用“ is ”这个关键字,也可以使用“==”。一般建议使用“ is ”关键字,因为速度会比”==＂稍微快一些。</p>
<p>字典<br>变量名[key]<br>变量名.get(key)<br>变量名.get(key, val) 在找不到key的情况下返回val<br>字典存储的数据是无序的</p>
<p>集合<br>无序，不能重复，可用于去重<br>集合最大的应用之一就是去重。例如,把一个带有重复元素的列表先转换为集合,再转换回列表,那么重复元素就只会保留一个。把列表转换为集合需要使用 setl )函数,把集合转换为列表使用 listl )函数<br>由于集合是无序的，去重的代价就是顺序会被打乱</p>
<p>4.使用字典实现多重条件控制<br>如果有多个 if ,写起来会很烦琐,例如下面这一段代码<br>if state == start :<br>    code =1<br> elif state == running:<br>    code =2<br> elif state == offline:<br>    code =3<br> elif state == unknown:<br>    code =4<br> else:<br>    code =5<br>使用“ if . elif . else .”会让代码显得冗长。如果使用字典改写,代码就会变得非常简洁:<br>state_dict = { ‘start’ :1, ‘running’ :2, ‘offline’:3, ‘unknown’:4}<br>code = state_dict.get(state ,5)<br>for循环输出字典</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论实验</title>
    <url>/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>AI基础之概率论的学习，学习自华为的iLearnX网站</p>
<span id="more"></span>

<h2 id="概率论介绍"><a href="#概率论介绍" class="headerlink" title="概率论介绍"></a>概率论介绍</h2><p>概率论是研究随机现象数量规律的数学分支。随机现象是相对于决定性现象而言的，在一定条件下必然发生某一结果的现象称为决定性现象。<br>概率论是用来描述不确定性的数学工具，很多据挖掘中的算法都是通过描述样本的概率相关信息或推断来构建模型</p>
<h3 id="均值实现"><a href="#均值实现" class="headerlink" title="均值实现"></a>均值实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy <span class="keyword">as</span> sp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值实现</span></span><br><span class="line">U = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部元素求均值</span></span><br><span class="line"><span class="built_in">print</span>(np.mean(U))</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># 4.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按列求均值，0代表列向量</span></span><br><span class="line"><span class="built_in">print</span>(np.mean(U, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># [2. 3. 4. 5. 6. 7.]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按行求均值，1代表行向量</span></span><br><span class="line"><span class="built_in">print</span>(np.mean(U, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># [3.5 5.5]</span></span><br></pre></td></tr></table></figure>

<h3 id="方差实现"><a href="#方差实现" class="headerlink" title="方差实现"></a>方差实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy <span class="keyword">as</span> sp</span><br><span class="line"><span class="comment"># 方差实现</span></span><br><span class="line">b = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">U = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line"><span class="comment"># 求方差</span></span><br><span class="line">np.var(b)</span><br><span class="line"><span class="comment"># 结果输出</span></span><br><span class="line"><span class="comment"># 3.6875</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个参数为1，表示按行求方差</span></span><br><span class="line">np.var(U, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 结果输出</span></span><br><span class="line"><span class="comment"># array([2.91666667, 2.91666667])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个参数为0，表示按行求方差</span></span><br><span class="line">np.var(U, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 结果输出</span></span><br><span class="line"><span class="comment"># array([1., 1., 1., 1., 1., 1.])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="标准差实现"><a href="#标准差实现" class="headerlink" title="标准差实现"></a>标准差实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy <span class="keyword">as</span> sp</span><br><span class="line"><span class="comment"># 标准差实现</span></span><br><span class="line">U = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line"><span class="comment"># 求标准差</span></span><br><span class="line">np.std(U)</span><br><span class="line"><span class="comment"># 结果输出</span></span><br><span class="line"><span class="comment"># 1.9790570145063195</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个参数为1，表示按行求标准差</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果输出</span></span><br><span class="line"><span class="comment"># array([1.70782513, 1.70782513])</span></span><br><span class="line">np.std(U, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 第二个参数为0，表示按行求标准差</span></span><br><span class="line">np.std(U, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 结果输出</span></span><br><span class="line"><span class="comment"># array([1., 1., 1., 1., 1., 1.])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="协方差实现"><a href="#协方差实现" class="headerlink" title="协方差实现"></a>协方差实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy <span class="keyword">as</span> sp</span><br><span class="line"><span class="comment"># 协方差实现</span></span><br><span class="line">b = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment"># 求协方差</span></span><br><span class="line">np.cov(b)</span><br><span class="line"><span class="comment"># 结果输出</span></span><br><span class="line"><span class="comment"># array(4.91666667)</span></span><br></pre></td></tr></table></figure>

<h3 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 相关系数</span></span><br><span class="line">vc=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">39</span>,<span class="number">0</span>,<span class="number">8</span>]</span><br><span class="line">vb=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">38</span>,<span class="number">0</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">np.corrcoef(vc,vb)</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br></pre></td></tr></table></figure>

<h3 id="二项分布的实现"><a href="#二项分布的实现" class="headerlink" title="二项分布的实现"></a>二项分布的实现</h3><p>服从二项分布的随机变量X表示在n次独立同分布的伯努利试验中成功的次数，其中每次试验的成功概率为p。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二项分布的实现</span></span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> binom,norm,beta,expon</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># n,p对应二项式公式中的事件成功次数及其概率</span></span><br><span class="line">binom_sim = binom.rvs(n=<span class="number">10</span>, p=<span class="number">0.3</span>,size=<span class="number">10000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Data:&#x27;</span>,binom_sim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Mean:%g&#x27;</span>%np.mean(binom_sim))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;SD:%g&#x27;</span>%np.std(binom_sim,ddof=<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 生成直方图，x指定每个bin(箱子)分布的数据，对应x轴，bins是总共有几条条状图，</span></span><br><span class="line"><span class="comment"># normed值密度，也就是每个条状图的占比比例，默认为1</span></span><br><span class="line">plt.hist(binom_sim,bins=<span class="number">10</span>,density=<span class="literal">True</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;density&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>Data: [4 5 1 ... 5 5 2]
Mean:3.0176
SD:1.42664
</code></pre>
<p><img src="/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%AE%9E%E9%AA%8C/output_5_1.png" alt="png"></p>
<h3 id="泊松分布实现"><a href="#泊松分布实现" class="headerlink" title="泊松分布实现"></a>泊松分布实现</h3><p>一个服从泊松分布的随机变量X,表示在具有比率参数$\lambda$的一段固定时间间隔内，事件发生的次数。参数$\lambda$告诉你该事件发生的比率。随机变量X的平均值和方差都是$\lambda$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生10000个符合lambda=2的泊松分布的数</span></span><br><span class="line">X = np.random.poisson(lam=<span class="number">2</span>,size=<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">a = plt.hist(X, bins=<span class="number">15</span>, density=<span class="literal">True</span>,<span class="built_in">range</span>=[<span class="number">0</span>,<span class="number">15</span>])</span><br><span class="line"><span class="comment"># 生成网络</span></span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%AE%9E%E9%AA%8C/output_7_0.png" alt="png"><br>​    </p>
<h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><p>正态分布是一种连续分布，其函数可以在实线上的任何地方取值。正态分布由两个参数描述：<br>分布的平均值μ标准差σ。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> norm</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">mu = <span class="number">0</span></span><br><span class="line">sigma = <span class="number">1</span></span><br><span class="line"><span class="comment"># 分布采样点</span></span><br><span class="line">x = np.arange(-<span class="number">5</span>,<span class="number">5</span>,<span class="number">0.1</span>)</span><br><span class="line"><span class="comment"># 生成符合mu,sigma的正态分布</span></span><br><span class="line">y = norm.pdf(x,mu,sigma)</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;density&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%AE%9E%E9%AA%8C/output_9_0.png" alt="png"></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="图像加噪声"><a href="#图像加噪声" class="headerlink" title="图像加噪声"></a>图像加噪声</h3><p>案例引入：比如在深度学习中，我们需要训练一个图像分类的模型，但是能拿到的图像不是很多，那有没有一种方法可以根据现有的图像生成一些新的图像出来呢？</p>
<p>增加的图像需要满足一些条件：图像本身的内容不能发生根本性的改变，比如图像能看出来是一只狗的话扩增出来的图像应该也是一只狗而不能成为只剩下一个毛茸茸的尾巴。最直接的方式就是在原始的图像上增加一些噪声，也就是使得图像变得粗糙同时保持图像原本要表述的信息。</p>
<p>给图像增加噪声，实现一下这个过程，该过程需要使用到 Python图像处理的模块 OpenCV，我们使用著名的Lena图作为原始图像。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图像加噪声</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">srcImage = cv2.imread(<span class="string">r&#x27;E:\Python\sources\lena.png&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(srcImage.shape)  <span class="comment"># 打印图像size</span></span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;Original image&#x27;</span>)  <span class="comment"># 图像显示窗口命令</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Original image&#x27;</span>, srcImage)  <span class="comment"># 显示图像</span></span><br><span class="line">k = cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 灰度处理原始图片</span></span><br><span class="line">grayImage = cv2.cvtColor(srcImage, cv2.COLOR_BGR2GRAY)  <span class="comment"># 灰度变换</span></span><br><span class="line"><span class="built_in">print</span>(grayImage.shape)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;grayimage&#x27;</span>, grayImage)</span><br><span class="line">k = cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 加入高斯噪声(均值mean,方差var,比例percent)</span></span><br><span class="line">image = np.array(grayImage / <span class="number">255</span>, dtype=<span class="built_in">float</span>)</span><br><span class="line">percent = <span class="number">0.01</span>  <span class="comment"># 图像加入噪声比例</span></span><br><span class="line">num = <span class="built_in">int</span>(percent * image.shape[<span class="number">0</span>] * image.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    temp1 = np.random.randint(image.shape[<span class="number">0</span>])</span><br><span class="line">    temp2 = np.random.randint(image.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    mean = <span class="number">0</span></span><br><span class="line">    var = <span class="number">0.04</span></span><br><span class="line">    noise = np.random.normal(mean, var**<span class="number">0.5</span>, <span class="number">1</span>)</span><br><span class="line">    image[temp1][temp2] += noise</span><br><span class="line">out = image</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> out.<span class="built_in">min</span>() &lt; <span class="number">0</span>:</span><br><span class="line">    low_clip = -<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    low_clip = <span class="number">0</span></span><br><span class="line">out = np.clip(out, low_clip, <span class="number">1</span>)</span><br><span class="line">gasuss_image = np.uint8(out * <span class="number">255</span>)</span><br><span class="line"><span class="built_in">print</span>(gasuss_image.shape)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;gasuss_image&#x27;</span>, gasuss_image)</span><br><span class="line">k = cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入泊松噪声(泊松参数scale,比例percent)</span></span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> expon</span><br><span class="line"></span><br><span class="line">image = np.array(grayImage, dtype=<span class="built_in">float</span>)</span><br><span class="line">percent = <span class="number">0.001</span>  <span class="comment"># 图像加入噪声比例</span></span><br><span class="line">num = <span class="built_in">int</span>(percent * image.shape[<span class="number">0</span>] * image.shape[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    temp1 = np.random.randint(image.shape[<span class="number">0</span>])</span><br><span class="line">    temp2 = np.random.randint(image.shape[<span class="number">1</span>])</span><br><span class="line">    scale = <span class="number">150</span></span><br><span class="line">    noise = np.random.poisson(scale, <span class="number">1</span>)</span><br><span class="line">    image[temp1][temp2] += noise</span><br><span class="line"></span><br><span class="line">out = image</span><br><span class="line"><span class="keyword">if</span> out.<span class="built_in">min</span>() &lt; <span class="number">0</span>:</span><br><span class="line">    low_clip = -<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    low_clip = <span class="number">0</span></span><br><span class="line">out = np.clip(out, low_clip, <span class="number">255</span>)</span><br><span class="line">expon_image = np.uint8(out)</span><br><span class="line"><span class="built_in">print</span>(expon_image.shape)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;expon.image&#x27;</span>, expon_image)</span><br><span class="line">k = cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<pre><code>(457, 563, 3)
</code></pre>
<p><img src="/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%AE%9E%E9%AA%8C/20211214223124.png"></p>
<p><img src="/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%AE%9E%E9%AA%8C/20211214223239.png"></p>
<p><img src="/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%AE%9E%E9%AA%8C/20211214223331.png"></p>
<p><img src="/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%AE%9E%E9%AA%8C/20211214223410.png"></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫库</title>
    <url>/%E7%88%AC%E8%99%AB%E5%BA%93/</url>
    <content><![CDATA[<p>requests，bs4，XPath</p>
<span id="more"></span>

<h2 id="Python的第三方库"><a href="#Python的第三方库" class="headerlink" title="Python的第三方库"></a>Python的第三方库</h2><p>在Python开发的过程中，常常需要将一些功能比较通用的代码抽离出来作为一个单独的模块，从而被多个工程调用。这种公共的模块称为Python的库（Library, Lib）。Python在发布时会自带一些由官方开发的常用的库，例如正则表达式“re”、时间“time”等。这些库称为“官方库”。而由非官方发布的库，则称为“第三方库”。</p>
<p>Python之所以如此强大，正是由于它拥有非常多的第三方库。使用第三方库，可以轻易实现各种各样的功能。以获取网页内容为例，Python其实自带了两个模块，分别是urllib和urllib2。使用这两个模块也可以获取网页内容。但是这两个模块使用起来非常麻烦。而requests这个第三方库，让获取网页内容变得极其简单。</p>
<p><font color="#FF0000">注意：</font></p>
<p><code>开发者自己写的.py文件的名字绝对不能和Python自带的模块或者已经安装的第三方库的名字相同，否则会产生问题</code>。例如本章内容涉及requests和正则表达式，那么读者在测试代码的时候绝对不能自行创建名为“requests.py”或者“re.py”的文件。一旦创建，代码必定报错。</p>
<h3 id="requests"><a href="#requests" class="headerlink" title="requests"></a><strong>requests</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">html = requests.get(<span class="string">&#x27;网址&#x27;</span>)  </span><br><span class="line">html_bytes = html.content   <span class="comment">#使用.content这个属性来显示bytes型网页的源代码</span></span><br><span class="line">html_str = html_bytes.decode() <span class="comment">#将bytes型的网页源代码解码为字符串型的源代码</span></span><br><span class="line">html_json = html.json()</span><br><span class="line">html_text = html.text</span><br></pre></td></tr></table></figure>

<p>之所以需要把bytes型的数据解码为字符串型的数据，是因为在bytes型的数据类型下，中文是无法正常显示的。</p>
<p>这个“解码”对应的英文为“decode”，因而我们需要使用.decode()这个方法。</p>
<p>这个方法的参数可以省略。在省略的时候，默认使用UTF-8编码格式来把bytes型解码为字符串型的源代码。</p>
<p>可能有一些中文网页，它的编码格式本身不是UTF-8，这就需要在括号里面写明目标编码格式的名字。</p>
<h3 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a><strong>XPath</strong></h3><p>XPath（XML Path）是一种查询语言，它能在XML（Extensible MarkupLanguage，可扩展标记语言）和HTML的树状结构中寻找结点。<br><br>安装一个第三方库：lxml</p>
<p>如果直接使用上面的命令来安装，10个人里面有7个人都会出问题。</p>
<p>因为lxml的底层是使用C语言实现的，所以计算机上面需要安装Virtual C++运行库。</p>
<p>但是即便安装好了Virtual C++运行库，还是有可能出问题。</p>
<p>所以需要换一种办法。请用浏览器打开：<a href="http://www.lfd.uci.edu/%EF%BD%9Egohlke/pythonlibs/#lxml">http://www.lfd.uci.edu/～gohlke/pythonlibs/#lxml</a> 根据自己计算机的Python版本下载对应的whl包。</p>
<p>例如对于64位的Python3.6，可以下载lxml-3.7.3-cp36-cp36m-win_amd64.whl。</p>
<p>下载完成以后，在存放这个whl包的文件夹中打开CMD，并执行以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install lxml-3.7.3-cp36-cp36m-vin_amd64.whl</span><br></pre></td></tr></table></figure>

<p>使用这种方法，若还未成功</p>
<p>把lxml-3.7.3-cp36-cp36m-win_amd64.whl这个文件的扩展名由.whl改为.zip，使用WinRAR或者7-Zip等解压缩工具来解压这个文件。</p>
<p>解压以后，会得到两个文件夹<br><br>把它们复制到Python安装文件夹下面Lib\site-packages文件夹中即可<br><br>打开Python的交互环境，输入<code>import lxml</code>，如果不报错，就表示安装成功</p>
<h3 id="BeautifulSoup4"><a href="#BeautifulSoup4" class="headerlink" title="BeautifulSoup4"></a><strong>BeautifulSoup4</strong></h3><p>Beautiful Soup4（BS4）是Python的一个第三方库，用来从HTML和XML中提取数据。</p>
<p>Beautiful Soup4在某些方面比XPath易懂，但是不如XPath简洁，而且由于它是使用Python开发的，因此速度比XPath慢。</p>
<p>使用pip安装Beautiful Soup4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure>
<p>打开python开发环境，输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure>

<p>解析源代码生成BeautifulSoup对象，使用以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(网页源代码,<span class="string">&#x27;解析器&#x27;</span>)</span><br><span class="line"><span class="comment"># 这里的“解析器”，可以使用html.parser：</span></span><br><span class="line">soup = BeautifulSoup(source, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"><span class="comment"># 如果安装了lxml，还可以使用 lxml：</span></span><br><span class="line">soup = BeautifulSoup(source, <span class="string">&#x27;lxml&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell编程题</title>
    <url>/%E7%89%9B%E5%AE%A2shell%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
    <content><![CDATA[<p>牛客上的shell编程题</p>
<span id="more"></span>

<h3 id="输出第5行的内容"><a href="#输出第5行的内容" class="headerlink" title="输出第5行的内容"></a>输出第5行的内容</h3><p><a href="https://www.nowcoder.com/practice/1d5978c6136d4252904757b4fa0c9296?tpId=195&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=SHELL%E7%AF%87&topicId=195&page=1&difficulty=&judgeStatus=&tags=&title=&gioEnter=menu">输出第5行的内容_牛客题霸_牛客网 (nowcoder.com)</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">lines=0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">&quot;lines++&quot;</span>  <span class="comment"># 可以改成 ((lines++))  速度变快了，但内存增多了</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$lines</span> == 5 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span> &lt; nowcoder.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">head -n 5 nowcoder.txt | tail -n 1</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;5,5p&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure>



<h3 id="统计所有进程占用内存大小的和"><a href="#统计所有进程占用内存大小的和" class="headerlink" title="统计所有进程占用内存大小的和"></a>统计所有进程占用内存大小的和</h3><p><a href="https://www.nowcoder.com/practice/fb24140bac154e5b99e44e0cee45dcaf?tpId=195&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=SHELL%E7%AF%87&topicId=195&page=1&difficulty=&judgeStatus=&tags=&title=&gioEnter=menu">统计所有进程占用内存大小的和_牛客题霸_牛客网 (nowcoder.com)</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">mem=0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> -a line  </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ((mem += line[5]))</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;line[5]&#125;</span></span><br><span class="line"><span class="keyword">done</span> &lt; nowcoder.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$mem</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read -a array_name 读入数组array_name，从下标0开始</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>百度文库爬虫之TXT</title>
    <url>/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E7%88%AC%E8%99%AB%E4%B9%8BTXT/</url>
    <content><![CDATA[<p>百度文库爬虫之TXT文件，保存为txt文件，对特殊的文件可以处理后保存为html文件</p>
<span id="more"></span>

<p>进入百度文库</p>
<p><img src="/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E7%88%AC%E8%99%AB%E4%B9%8BTXT/image-20220116140200284.png" alt="image-20220116140200284"></p>
<p>查看百度文库的爬虫协议：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://wenku.baidu.com/robots.txt</span><br></pre></td></tr></table></figure>



<p>使用下面给出的UA标识</p>
<p><img src="/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E7%88%AC%E8%99%AB%E4%B9%8BTXT/image-20220116140753775.png" alt="image-20220116140753775"></p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="built_in">input</span>(<span class="string">&quot;请输入TXT文件网址：&quot;</span>)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>:<span class="string">&quot;Googlebot&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(url = url, headers = headers)</span><br><span class="line"></span><br><span class="line">resp.encoding = <span class="string">&quot;gbk&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(resp.text)</span></span><br><span class="line"></span><br><span class="line">title = re.findall(<span class="string">r&#x27;&lt;span id=&quot;doc-tittle-0&quot;&gt;(.*?)&lt;/span&gt;&#x27;</span>, resp.text, re.S)[<span class="number">0</span>].strip()</span><br><span class="line"></span><br><span class="line">content = re.findall(<span class="string">r&#x27;&lt;div style=&quot;border:1px solid #C8DBD3;padding:20px;line-height:24px;&quot;&gt;(.*?)&lt;/div&gt;&#x27;</span>, resp.text, re.S)[<span class="number">0</span>].strip()</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(title)</span></span><br><span class="line"><span class="comment"># print(content)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;title&#125;</span>.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>, encoding = <span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(content)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;title&#125;</span>.txt文件保存成功！&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>上述代码对很多txt百度文库文件是OK的，</p>
<p>如：<a href="https://wenku.baidu.com/view/14d86f06dd36a32d7375818a.html">https://wenku.baidu.com/view/14d86f06dd36a32d7375818a.html</a></p>
<blockquote>
<p><img src="/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E7%88%AC%E8%99%AB%E4%B9%8BTXT/image-20220116153725378.png" alt="image-20220116153725378"></p>
<p><img src="/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E7%88%AC%E8%99%AB%E4%B9%8BTXT/image-20220116153851910.png" alt="image-20220116153851910"></p>
</blockquote>
<p><font color="#ff0000">但是对一些奇奇怪怪的文件就会出问题</font></p>
<p>如：<a href="https://wenku.baidu.com/view/9d0ed76fae45b307e87101f69e3143323968f5e4.html">c语言编写网络爬虫 - 百度文库 (baidu.com)</a></p>
<blockquote>
<p><img src="/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E7%88%AC%E8%99%AB%E4%B9%8BTXT/image-20220116154251168.png" alt="image-20220116154251168"></p>
</blockquote>
<p>文库中看到的是<code>#include&lt;cspider/spider.h&gt;</code> </p>
<p>而网页源代码显示地是<code>#include&amp;lt;cspider/spider.h&amp;gt;</code> &amp;lt 和 &amp;gt 在html中 是 &lt;&gt; </p>
<p>这种TXT文件就会出问题，导致保存至本地的TXT文件是<code>#include&amp;lt;cspider/spider.h&amp;gt;</code>而不是<code>#include&lt;cspider/spider.h&gt;</code></p>
<p>我的解决方法是保存为HTML文件</p>
<p>找到页面源代码</p>
<blockquote>
<p><img src="/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E7%88%AC%E8%99%AB%E4%B9%8BTXT/image-20220116210224061.png" alt="image-20220116210224061">》</p>
</blockquote>
<p>复制部分文本内容</p>
<blockquote>
<p><img src="/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E7%88%AC%E8%99%AB%E4%B9%8BTXT/image-20220116210926464.png" alt="image-20220116210926464">&gt;</p>
</blockquote>
<p>创建一个HTML文件，看是否能成功显示</p>
<blockquote>
<p><img src="/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E7%88%AC%E8%99%AB%E4%B9%8BTXT/image-20220116211233492.png" alt="image-20220116211233492"></p>
</blockquote>
<p>显示结果：</p>
<blockquote>
<p><img src="/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E7%88%AC%E8%99%AB%E4%B9%8BTXT/image-20220116211322921.png"></p>
</blockquote>
<p>使用HTML文件保存的方法可行。</p>
<p><strong>代码实现</strong></p>
<p>第一步：使用<code>selenium</code>获取网页源代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line">option = Options()</span><br><span class="line">option.binary_location=<span class="string">r&#x27;D:\Program Files\Google\Chrome\Application\chrome.exe&#x27;</span></span><br><span class="line">url = <span class="string">&quot;https://wenku.baidu.com/view/9d0ed76fae45b307e87101f69e3143323968f5e4.html&quot;</span></span><br><span class="line">driver = Chrome(options = option)</span><br><span class="line">driver.get(url)</span><br><span class="line">page = driver.page_source   <span class="comment"># 网页源代码</span></span><br><span class="line">driver.close()</span><br><span class="line"><span class="built_in">print</span>(page)</span><br></pre></td></tr></table></figure>

<p>输出的结果（部分）：</p>
<p><img src="/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E7%88%AC%E8%99%AB%E4%B9%8BTXT/image-20220116213711462.png" alt="image-20220116213711462"></p>
<p><img src="/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E7%88%AC%E8%99%AB%E4%B9%8BTXT/image-20220116213007883.png" alt="image-20220116213007883"></p>
<p>第二步：使用<code>BeautifulSoup</code>提取内容</p>
<p><code>&lt;h3 class=&quot;doc-title&quot;&gt;c语言编写网络爬虫&lt;/h3&gt;</code>提取出文件名</p>
<p>上图中<code>&lt;p class=&quot;p-txt&quot;&gt;文本内容&lt;/p&gt;</code>这类标签为文本内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(page, <span class="string">&quot;lxml&quot;</span>);</span><br><span class="line">title = soup.find(<span class="string">&quot;h3&quot;</span>,attrs=&#123;<span class="string">&quot;class&quot;</span>:<span class="string">&quot;doc-title&quot;</span>&#125;).text</span><br><span class="line"><span class="built_in">print</span>(title)</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> soup.find_all(<span class="string">&quot;p&quot;</span>, attrs=&#123;<span class="string">&quot;class&quot;</span>:<span class="string">&quot;p-txt&quot;</span>&#125;):</span><br><span class="line">    <span class="built_in">print</span>(p)</span><br></pre></td></tr></table></figure>



<p>第三步：保存至文件</p>
<p>最终代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变了谷歌浏览器的位置，需加上这几行</span></span><br><span class="line">option = Options()</span><br><span class="line">option.binary_location=<span class="string">r&#x27;D:\Program Files\Google\Chrome\Application\chrome.exe&#x27;</span></span><br><span class="line">option.add_argument(<span class="string">&quot;--headless&quot;</span>)   <span class="comment"># 让浏览器后台运行，不显示出来</span></span><br><span class="line"><span class="comment"># url = &quot;https://wenku.baidu.com/view/9d0ed76fae45b307e87101f69e3143323968f5e4.html&quot;</span></span><br><span class="line">url = <span class="built_in">input</span>(<span class="string">&quot;请输入TXT文件网址：&quot;</span>)</span><br><span class="line">driver = Chrome(options = option)</span><br><span class="line">driver.get(url)</span><br><span class="line">page = driver.page_source   <span class="comment"># 网页源代码</span></span><br><span class="line">driver.close()</span><br><span class="line"><span class="comment"># print(page)</span></span><br><span class="line"><span class="comment"># charset = re.findall(r&#x27;&lt;meta charset=&quot;(.*?)&quot;&gt;&#x27;, page)[0]</span></span><br><span class="line"><span class="comment"># print(charset)</span></span><br><span class="line">soup = BeautifulSoup(page, <span class="string">&quot;lxml&quot;</span>)</span><br><span class="line">title = soup.find(<span class="string">&quot;h3&quot;</span>,attrs=&#123;<span class="string">&quot;class&quot;</span>:<span class="string">&quot;doc-title&quot;</span>&#125;).text    <span class="comment"># 文件名</span></span><br><span class="line"><span class="comment"># print(title)</span></span><br><span class="line"><span class="comment"># for p in soup.find_all(&quot;p&quot;, attrs=&#123;&quot;class&quot;:&quot;p-txt&quot;&#125;):</span></span><br><span class="line"><span class="comment">#     print(p)      # p的类型是&lt;class &#x27;bs4.element.Tag&#x27;&gt;，写入文件需转换为str</span></span><br><span class="line">html_head = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html lang=&quot;zh&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;<span class="subst">&#123;title&#125;</span>&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;    </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">html_tail = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;E:\\Python\\爬虫_百度文库\\百度文库\\<span class="subst">&#123;title&#125;</span>.html&quot;</span>,<span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(html_head)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> soup.find_all(<span class="string">&quot;p&quot;</span>, attrs=&#123;<span class="string">&quot;class&quot;</span>:<span class="string">&quot;p-txt&quot;</span>&#125;):</span><br><span class="line">        f.write(<span class="string">&quot;   &quot;</span> + <span class="built_in">str</span>(p))</span><br><span class="line">    f.write(html_tail)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;title&#125;</span>.html文件保存完成&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p><img src="/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E7%88%AC%E8%99%AB%E4%B9%8BTXT/image-20220116214920584.png" alt="image-20220116214920584"></p>
<p><img src="/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E7%88%AC%E8%99%AB%E4%B9%8BTXT/image-20220116214956311.png" alt="image-20220116214956311"></p>
</blockquote>
<p>最开始的代码和最后的代码可以选择性使用。</p>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数实验</title>
    <url>/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>AI基础学习之线性代数的学习，学习自华为iLearnX网站</p>
<span id="more"></span>

<h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><p>numpy是款基于 Python的数值处理模块，在处理矩阵数据方面有很大的功能与优势。</p>
<p>因为线性代数的主要内容就是对矩阵的处理，所以本章节主要的内容都是基于 numpy进行展<br>开，另外也会涉及到方程组求解，所会用到<strong>数学科学库scipy</strong>.</p>
<ul>
<li>导入相应库</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy <span class="keyword">as</span> sp</span><br></pre></td></tr></table></figure>

<h3 id="reshape运算"><a href="#reshape运算" class="headerlink" title="reshape运算"></a>reshape运算</h3><p>在数学中并没有reshape运算，但是在 numpy运算库中是一个非常常用的运算，用来改变一个张量的维度数和个维度的大小，例如一个10x10的图片在保存时直接保存为一个包含100个元素的序列，在读取后就可以使用 reshape将其从1x100变换为10x10。示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个包含整数0-11的向量</span></span><br><span class="line">x= np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># [0 1 2 3 4 5 6 6 8 9 10 11]</span></span><br><span class="line"><span class="comment"># 查看数组大小</span></span><br><span class="line"><span class="built_in">print</span>(x.shape)</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># (12,)</span></span><br><span class="line"><span class="comment"># 将x转换成二维矩阵，其中矩阵的第一个维度为1</span></span><br><span class="line">x=x.reshape(<span class="number">1</span>,<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># (12,)</span></span><br><span class="line"><span class="comment"># 查看数组大小</span></span><br><span class="line"><span class="built_in">print</span>(x.shape)</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># （1,12）</span></span><br><span class="line"><span class="comment"># 将x转换为3x4的矩阵</span></span><br><span class="line">x = x.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[ 0  1  2  3]</span></span><br><span class="line"><span class="string"> [ 4  5  6  7]</span></span><br><span class="line"><span class="string"> [ 8  9 10 11]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="转置实现"><a href="#转置实现" class="headerlink" title="转置实现"></a>转置实现</h3><p>向量和矩阵的转置是交换行列顺序，而三维及以上张量的转置就需要指定转换的维度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成3x4的矩阵并转置</span></span><br><span class="line">A = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># 结果输出</span></span><br><span class="line"><span class="comment"># [[ 0  1  2  3]</span></span><br><span class="line"><span class="comment">#  [ 4  5  6  7]</span></span><br><span class="line"><span class="comment">#  [ 8  9 10 11]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.T)</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># [[ 0  4  8]</span></span><br><span class="line"><span class="comment">#  [ 1  5  9]</span></span><br><span class="line"><span class="comment">#  [ 2  6 10]</span></span><br><span class="line"><span class="comment">#  [ 3  7 11]]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="矩阵乘法实现"><a href="#矩阵乘法实现" class="headerlink" title="矩阵乘法实现"></a>矩阵乘法实现</h3><p>矩阵乘法：记两个矩阵分别为A和B，两个矩阵能够相乘的条件为第一个矩阵的列数等于第二个矩阵的行数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">B = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [2 3]</span></span><br><span class="line"><span class="comment">#  [4 5]]</span></span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># [[0 1 2]</span></span><br><span class="line"><span class="comment">#  [3 4 5]]</span></span><br><span class="line"><span class="comment"># 矩阵相乘</span></span><br><span class="line">C = np.matmul(A,B)</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># [[ 3  4  5]</span></span><br><span class="line"><span class="comment">#  [ 9 14 19]</span></span><br><span class="line"><span class="comment">#  [15 24 33]]</span></span><br></pre></td></tr></table></figure>

<h3 id="矩阵对应运算"><a href="#矩阵对应运算" class="headerlink" title="矩阵对应运算"></a>矩阵对应运算</h3><p>元素对应运算：针对形状相同矩阵的运算统称，包括元素对应相乘，相加等，即对两个矩阵相同位置的元素进行加减乘除的运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建矩阵</span></span><br><span class="line">A = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">B = np.arange(<span class="number">6</span>,<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵相乘</span></span><br><span class="line"><span class="built_in">print</span>(A*B)</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># [[ 0  7]</span></span><br><span class="line"><span class="comment">#  [16 27]</span></span><br><span class="line"><span class="comment">#  [40 55]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵相加</span></span><br><span class="line"><span class="built_in">print</span>(A+A)</span><br><span class="line"><span class="comment"># 结果输出</span></span><br><span class="line"><span class="comment"># [[ 0  2]</span></span><br><span class="line"><span class="comment">#  [ 4  6]</span></span><br><span class="line"><span class="comment">#  [ 8 10]]</span></span><br></pre></td></tr></table></figure>

<h3 id="逆矩阵实现"><a href="#逆矩阵实现" class="headerlink" title="逆矩阵实现"></a>逆矩阵实现</h3><p>只有方阵($n\times n$)才有逆矩阵，逆矩阵的实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [2 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求逆矩阵</span></span><br><span class="line">B = np.linalg.inv(A)</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># [[-1.5  0.5]</span></span><br><span class="line"><span class="comment">#  [ 1.   0. ]]</span></span><br><span class="line"><span class="comment"># 验证AB=I_n</span></span><br><span class="line"><span class="built_in">print</span>(np.matmul(A,B))</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># [[1. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 1.]]</span></span><br></pre></td></tr></table></figure>

<h3 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h3><p>求矩阵的特征值与特征向量并实现可视化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入相应的库</span></span><br><span class="line"><span class="keyword">from</span> scipy.linalg <span class="keyword">import</span> eig</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个2x2的矩阵</span></span><br><span class="line">A = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求A的特征值(evals)和特征向量(evecs)</span></span><br><span class="line">evals, evecs = eig(A)</span><br><span class="line">evecs = evecs[:, <span class="number">0</span>], evecs[:, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># print(evals, evecs)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.subplots() 返回一个Figure实例flg 和一个AxesSubplot实例ax。</span></span><br><span class="line"><span class="comment"># flg代表整个图像，ax代表坐标轴和画的图，作图：</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"><span class="comment"># 让坐标轴经过原点：</span></span><br><span class="line"><span class="keyword">for</span> spine <span class="keyword">in</span> [<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;bottom&#x27;</span>]:  <span class="comment"># 让在左下角的坐标轴经过原点</span></span><br><span class="line">    ax.spines[spine].set_position(<span class="string">&#x27;zero&#x27;</span>)</span><br><span class="line"><span class="comment"># 画出网格：</span></span><br><span class="line">ax.grid(alpha=<span class="number">0.4</span>)</span><br><span class="line"><span class="comment"># 设置坐标轴的范围</span></span><br><span class="line">xmin, xmax = -<span class="number">3</span>, <span class="number">3</span></span><br><span class="line">ymin, ymax = -<span class="number">3</span>, <span class="number">3</span></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(xmin, xmax), ylim=(ymin, ymax))</span><br><span class="line"><span class="comment"># 画出特征向量，用一个箭头指向要注释的地方，再写上一段画的行为，叫做annotate。</span></span><br><span class="line"><span class="comment"># text是输入内容；xy:箭头指向；xytext:文字所处的位置；arrowprops通过表明箭头的风格或种类：</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> evecs:</span><br><span class="line">    ax.annotate(text=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                xy=v,</span><br><span class="line">                xytext=(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                arrowprops=<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">                                shrink=<span class="number">0</span>,</span><br><span class="line">                                alpha=<span class="number">0.6</span>,</span><br><span class="line">                                width=<span class="number">0.5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出特征空间：</span></span><br><span class="line">x = np.linspace(xmin, xmax, <span class="number">3</span>)  <span class="comment"># 在指定的间隔内返回均匀间隔的数字</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> evecs:</span><br><span class="line">    a = v[<span class="number">1</span>] / v[<span class="number">0</span>]  <span class="comment"># 沿特征向量方向的单位向量</span></span><br><span class="line">    ax.plot(x, a * x, <span class="string">&#x27;r-&#x27;</span>, lw=<span class="number">0.4</span>)  <span class="comment"># 参数lw表示图像的粗细</span></span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 结果如图：</span></span><br><span class="line"><span class="comment"># 蓝箭头是向量的特征向量，红色直线表示特征空间</span></span><br></pre></td></tr></table></figure>
<p><img src="/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AE%9E%E9%AA%8C/Figure_1.png"></p>
<h3 id="求行列式"><a href="#求行列式" class="headerlink" title="求行列式"></a>求行列式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">E = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], </span><br><span class="line">     [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">     [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(np.linalg.det(E))</span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># 0.0</span></span><br></pre></td></tr></table></figure>

<h3 id="奇异值分解实现"><a href="#奇异值分解实现" class="headerlink" title="奇异值分解实现"></a>奇异值分解实现</h3><p>例：通过标题的关键词对海量的文章分类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">title_1 = [<span class="string">&#x27;dad&#x27;</span>,<span class="string">&#x27;dad&#x27;</span>,<span class="string">&#x27;stock&#x27;</span>]</span><br><span class="line">title_2 = [<span class="string">&#x27;books&#x27;</span>,<span class="string">&#x27;books&#x27;</span>,<span class="string">&#x27;value&#x27;</span>,<span class="string">&#x27;estate&#x27;</span>]</span><br><span class="line">title_3 = [<span class="string">&#x27;books&#x27;</span>,<span class="string">&#x27;decomposition&#x27;</span>]</span><br><span class="line">title_4 = [<span class="string">&#x27;stock&#x27;</span>]</span><br><span class="line">title_5 = [<span class="string">&#x27;dad&#x27;</span>]</span><br><span class="line">title_6 = [<span class="string">&#x27;value&#x27;</span>,<span class="string">&#x27;singular&#x27;</span>,<span class="string">&#x27;decomposition&#x27;</span>]</span><br><span class="line">title_7 = [<span class="string">&#x27;dad&#x27;</span>,<span class="string">&quot;singular&quot;</span>]</span><br><span class="line">title_8 = [<span class="string">&#x27;singular&#x27;</span>,<span class="string">&#x27;estate&#x27;</span>,<span class="string">&#x27;decomposition&#x27;</span>]</span><br><span class="line"></span><br><span class="line">words = [<span class="string">&#x27;books&#x27;</span>,<span class="string">&#x27;dad&#x27;</span>,<span class="string">&#x27;stock&#x27;</span>,<span class="string">&#x27;value&#x27;</span>,<span class="string">&#x27;singular&#x27;</span>,<span class="string">&#x27;estate&#x27;</span>,<span class="string">&#x27;decomposition&#x27;</span>]</span><br><span class="line"><span class="comment"># 设已知8个标题，7个关键字，记录每个关键字出现的次数，得矩阵X，</span></span><br><span class="line"><span class="comment"># X中每一行表示一个标题，每一列表示一个关键字，</span></span><br><span class="line"><span class="comment"># 矩阵中的每个元素表示一个关键字在一个标题中出现的次数</span></span><br><span class="line">X=np.array([[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]])</span><br><span class="line"><span class="comment"># 进行奇异值分解</span></span><br><span class="line">U,s,Vh = np.linalg.svd(X)</span><br><span class="line"><span class="comment"># 输出左奇异矩阵U及其shape:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;U=&#x27;</span>,U)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;U.shape&#x27;</span>,U.shape)</span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># U= [[-1.87135757e-01 -7.93624528e-01  2.45011855e-01 -2.05404352e-01</span></span><br><span class="line"><span class="comment">#   -7.77156117e-16 -4.95330978e-15 -2.57394431e-01 -4.08248290e-01]</span></span><br><span class="line"><span class="comment">#  [-6.92896814e-01  2.88368077e-01  5.67788037e-01  2.22142537e-01</span></span><br><span class="line"><span class="comment">#    2.54000254e-01  5.20956571e-15 -2.21623012e-02  0.00000000e+00]</span></span><br><span class="line"><span class="comment">#  [-3.53233681e-01  1.22606651e-01  3.49203461e-02 -4.51735990e-01</span></span><br><span class="line"><span class="comment">#   -7.62000762e-01 -1.04191314e-14  2.72513448e-01  5.55111512e-17]</span></span><br><span class="line"><span class="comment">#  [-2.61369658e-02 -1.33189110e-01  7.51079037e-02 -6.44727454e-01</span></span><br><span class="line"><span class="comment">#    5.08000508e-01 -1.58761893e-14  3.68146235e-01  4.08248290e-01]</span></span><br><span class="line"><span class="comment">#  [-8.04993957e-02 -3.30217709e-01  8.49519758e-02  2.19661551e-01</span></span><br><span class="line"><span class="comment">#   -2.54000254e-01  5.29989065e-15 -3.12770333e-01  8.16496581e-01]</span></span><br><span class="line"><span class="comment">#  [-3.95029694e-01  1.56123876e-02 -5.28290830e-01 -6.82340484e-02</span></span><br><span class="line"><span class="comment">#    1.27000127e-01 -7.07106781e-01 -2.09360158e-01  1.38777878e-16]</span></span><br><span class="line"><span class="comment">#  [-2.02089013e-01 -3.80395849e-01 -2.12899198e-01  4.80790894e-01</span></span><br><span class="line"><span class="comment">#    8.88178420e-16  1.15928216e-14  7.33466480e-01  1.66533454e-16]</span></span><br><span class="line"><span class="comment">#  [-3.95029694e-01  1.56123876e-02 -5.28290830e-01 -6.82340484e-02</span></span><br><span class="line"><span class="comment">#    1.27000127e-01  7.07106781e-01 -2.09360158e-01 -2.49800181e-16]]</span></span><br><span class="line"><span class="comment"># U.shape (8, 8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出奇异矩阵及其shape:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s=&#x27;</span>,s)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s.shape&#x27;</span>,s.shape)</span><br><span class="line"><span class="comment"># 结果结果：</span></span><br><span class="line"><span class="comment"># 按每个奇异值——对应一个左奇异向量和一个右奇异向量从大到小排列</span></span><br><span class="line"><span class="comment"># s= [2.85653844 2.63792139 2.06449303 1.14829917 1.         1.</span></span><br><span class="line"><span class="comment">#  0.54848559]</span></span><br><span class="line"><span class="comment"># s.shape (7,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出右奇异矩阵Vh及其shape:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Vh=&#x27;</span>,Vh)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Vh.shape&#x27;</span>,Vh.shape)</span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># Vh= [[-6.08788345e-01 -2.29949618e-01 -7.46612474e-02 -3.80854846e-01</span></span><br><span class="line"><span class="comment">#   -3.47325416e-01 -3.80854846e-01 -4.00237243e-01]</span></span><br><span class="line"><span class="comment">#  [ 2.65111314e-01 -8.71088358e-01 -3.51342402e-01  1.15234846e-01</span></span><br><span class="line"><span class="comment">#   -1.32365989e-01  1.15234846e-01  5.83153945e-02]</span></span><br><span class="line"><span class="comment">#  [ 5.66965547e-01  1.75382762e-01  1.55059743e-01  1.91316736e-02</span></span><br><span class="line"><span class="comment">#   -6.14911671e-01  1.91316736e-02 -4.94872736e-01]</span></span><br><span class="line"><span class="comment">#  [-6.48865369e-03  2.52237176e-01 -7.40339999e-01  1.34031699e-01</span></span><br><span class="line"><span class="comment">#    2.99854608e-01  1.34031699e-01 -5.12239408e-01]</span></span><br><span class="line"><span class="comment">#  [-2.54000254e-01 -2.54000254e-01  5.08000508e-01  3.81000381e-01</span></span><br><span class="line"><span class="comment">#    2.54000254e-01  3.81000381e-01 -5.08000508e-01]</span></span><br><span class="line"><span class="comment">#  [ 0.00000000e+00  7.25520445e-15 -2.07821168e-14 -7.07106781e-01</span></span><br><span class="line"><span class="comment">#    8.03741866e-15  7.07106781e-01 -1.37929454e-14]</span></span><br><span class="line"><span class="comment">#  [ 4.16034348e-01 -1.71550021e-01  2.01922906e-01 -4.22112199e-01</span></span><br><span class="line"><span class="comment">#    5.73845817e-01 -4.22112199e-01 -2.66564648e-01]]</span></span><br><span class="line"><span class="comment"># Vh.shape (7, 7)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 规定坐标轴的范围</span></span><br><span class="line">plt.axis([-<span class="number">0.8</span>,<span class="number">0.8</span>,-<span class="number">0.8</span>,<span class="number">0.8</span>])</span><br><span class="line"><span class="comment"># 原每个关键字由1*8的向量表示，先降维成1*2的向量以便进行可视化</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words)):</span><br><span class="line">    plt.text(U[i,<span class="number">0</span>],U[i,<span class="number">1</span>],words[i])</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 图像如下：</span></span><br><span class="line"><span class="comment"># 图解：将到2维可视化后，我们可以将关键词聚类，如 singular, value和 decomposition三个词距离比较近可以被划分为一组，而 stock和 estate经常同时出现。</span></span><br><span class="line"><span class="comment"># 在得到了词的向量表示后，我们就可以根据选取一种向量距离（例如：欧式距离、曼哈顿距离等）计算的方式来计算词间的相似度从而可以再根据一些策略（例如：词对相似度的和、均值 等）得到文章标题之间的相似度；</span></span><br><span class="line"><span class="comment"># 之后我们就可以通过文章标题的相似度来近似表示文章内容的相似度从而完成对文章的聚类。</span></span><br></pre></td></tr></table></figure>
<p><img src="/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AE%9E%E9%AA%8C/Figure_2.png"></p>
<h3 id="奇异值分解应用-图像压缩"><a href="#奇异值分解应用-图像压缩" class="headerlink" title="奇异值分解应用-图像压缩"></a>奇异值分解应用-图像压缩</h3><pre><code>一副灰度图像可以看作一个矩阵，对这样矩阵进行奇异值分解，奇异值矩阵的奇异值是按照从大到小的顺序排列的。对应奇异值大的奇异向量所保存的信息量越大，而奇异值大小一般都衰减得比较快。因比前K个奇异值及其对应的奇异向量就包含了图像的大部分信息。所以前K项奇异值及其奇异向量来组成的图像可以达到基本和原图一样的清晰度，但是数据量却大大减少了。这样就可以达到图像数据压缩的效果。
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取并保存灰度图像</span></span><br><span class="line">img = imread(<span class="string">&#x27;E:\\Python\\sources\\lena.png&#x27;</span>)[:,:,<span class="number">0</span>]</span><br><span class="line">plt.gray()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出灰度图</span></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.imshow(img) <span class="comment"># 负责处理图片不会显示</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;./lena_gray&#x27;</span>)</span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"><span class="comment"># 输出结果：图片1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取并打印图像的长宽</span></span><br><span class="line">m,n = img.shape</span><br><span class="line"><span class="built_in">print</span>(np.shape(img))</span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># (457, 563)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对图像矩阵进行奇异值分解</span></span><br><span class="line">U,sigma,V = np.linalg.svd(img)</span><br><span class="line"><span class="comment"># 打印奇异值大小</span></span><br><span class="line"><span class="built_in">print</span>(np.shape(sigma))</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># (457,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将奇异值整理成一个对角矩阵</span></span><br><span class="line">sigma = resize(sigma,[m,<span class="number">1</span>])*eye(m,n)</span><br><span class="line"><span class="comment"># 取前K个奇异值及其奇异向量用于压缩图像</span></span><br><span class="line">k = <span class="number">100</span></span><br><span class="line"><span class="comment"># 用前K个奇异值及其奇异向量构造新图像</span></span><br><span class="line">img1 = np.dot(U[:,<span class="number">0</span>:k],np.dot(sigma[<span class="number">0</span>:k,<span class="number">0</span>:k],V[<span class="number">0</span>:k,:]))</span><br><span class="line">plt.figure(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 打印压缩后的效果图：图片2</span></span><br><span class="line">plt.imshow(img1)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AE%9E%E9%AA%8C/lena_gray.png#pic_left" title="图1"><br><img src="/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AE%9E%E9%AA%8C/lena_gray2.png#pic_right" title="图2"></p>
<h3 id="线性方程组求解"><a href="#线性方程组求解" class="headerlink" title="线性方程组求解"></a>线性方程组求解</h3><p>求解线性方程组比较简单，只需要用到一个函数<code>(scipy.linglg.solve)</code>就可以了。<br>案例引入：有三种价格未知的水果，苹果、香蕉、葡萄。已知，李雷购买10斤苹果、2斤香蕉、5斤葡萄花费了10元，韩梅梅购买4斤苹果、4斤香蕉、2斤葡萄花费了8元，汤姆购买2斤苹果、2斤香蕉、2斤葡萄花费了5元；问，苹果、香蕉、葡萄分别多少钱一斤？</p>
<p>根据已知条件，可以构建如下多元方程组，其中$x_1、x_2、x_3$分别是苹果、香蕉、葡萄的价格，目的是求解$x_1、x_2、x_3$的值.</p>
<p>$10x_1+2x_2+5x_3=10<br>\4x_1+4x_2+2x_3=8\<br>2x_1+2x_2+2x_3=5$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.linalg <span class="keyword">import</span> solve</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">10</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]])</span><br><span class="line">b = np.array([<span class="number">10</span>,<span class="number">8</span>,<span class="number">5</span>])</span><br><span class="line">x = solve(a,b)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果输出：</span></span><br><span class="line"><span class="comment"># [0.25 1.25 1.  ]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>语法分析实验</title>
    <url>/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>编译原理语法分析实验的分析</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSTTK const</span><br><span class="line">INTTK int</span><br><span class="line">IDENFR const1</span><br><span class="line">ASSIGN =</span><br><span class="line">INTCON 1</span><br><span class="line">&lt;无符号整数&gt;</span><br><span class="line">&lt;整数&gt;</span><br><span class="line">COMMA ,</span><br><span class="line">IDENFR const2</span><br><span class="line">ASSIGN =</span><br><span class="line">MINU -</span><br><span class="line">INTCON 100</span><br><span class="line">&lt;无符号整数&gt;</span><br><span class="line">&lt;整数&gt;</span><br><span class="line">&lt;常量定义&gt;</span><br><span class="line">SEMICN ;</span><br><span class="line">CONSTTK const</span><br><span class="line">CHARTK char</span><br><span class="line">IDENFR const3</span><br><span class="line">ASSIGN =</span><br><span class="line">CHARCON _</span><br><span class="line">&lt;常量定义&gt;</span><br><span class="line">SEMICN ;</span><br><span class="line">&lt;常量说明&gt;</span><br><span class="line">INTTK int</span><br><span class="line">IDENFR change1</span><br><span class="line">&lt;变量定义&gt;</span><br><span class="line">SEMICN ;</span><br><span class="line">CHARTK char</span><br><span class="line">IDENFR change3</span><br><span class="line">&lt;变量定义&gt;</span><br><span class="line">SEMICN ;</span><br><span class="line">&lt;变量说明&gt;</span><br><span class="line">INTTK int</span><br><span class="line">IDENFR gets1</span><br><span class="line">&lt;声明头部&gt;</span><br><span class="line">LPARENT (</span><br><span class="line">INTTK int</span><br><span class="line">IDENFR var1</span><br><span class="line">COMMA ,</span><br><span class="line">INTTK int</span><br><span class="line">IDENFR var2</span><br><span class="line">&lt;参数表&gt;</span><br><span class="line">RPARENT )</span><br><span class="line">LBRACE &#123;</span><br><span class="line">IDENFR change1</span><br><span class="line">ASSIGN =</span><br><span class="line">IDENFR var1</span><br><span class="line">&lt;因子&gt;</span><br><span class="line">&lt;项&gt;</span><br><span class="line">PLUS +</span><br><span class="line">IDENFR var2</span><br><span class="line">&lt;因子&gt;</span><br><span class="line">&lt;项&gt;</span><br><span class="line">&lt;表达式&gt;</span><br><span class="line">&lt;赋值语句&gt;</span><br><span class="line">SEMICN ;</span><br><span class="line">&lt;语句&gt;</span><br><span class="line">RETURNTK return</span><br><span class="line">LPARENT (</span><br><span class="line">IDENFR change1</span><br><span class="line">&lt;因子&gt;</span><br><span class="line">&lt;项&gt;</span><br><span class="line">&lt;表达式&gt;</span><br><span class="line">RPARENT )</span><br><span class="line">&lt;返回语句&gt;</span><br><span class="line">SEMICN ;</span><br><span class="line">&lt;语句&gt;</span><br><span class="line">&lt;语句列&gt;</span><br><span class="line">&lt;复合语句&gt;</span><br><span class="line">RBRACE &#125;</span><br><span class="line">&lt;有返回值函数定义&gt;</span><br><span class="line">VOIDTK void</span><br><span class="line">MAINTK main</span><br><span class="line">LPARENT (</span><br><span class="line">RPARENT )</span><br><span class="line">LBRACE &#123;</span><br><span class="line">PRINTFTK printf</span><br><span class="line">LPARENT (</span><br><span class="line">STRCON Hello World</span><br><span class="line">&lt;字符串&gt;</span><br><span class="line">RPARENT )</span><br><span class="line">&lt;写语句&gt;</span><br><span class="line">SEMICN ;</span><br><span class="line">&lt;语句&gt;</span><br><span class="line">PRINTFTK printf</span><br><span class="line">LPARENT (</span><br><span class="line">IDENFR gets1</span><br><span class="line">LPARENT (</span><br><span class="line">INTCON 10</span><br><span class="line">&lt;无符号整数&gt;</span><br><span class="line">&lt;整数&gt;</span><br><span class="line">&lt;因子&gt;</span><br><span class="line">&lt;项&gt;</span><br><span class="line">&lt;表达式&gt;</span><br><span class="line">COMMA ,</span><br><span class="line">INTCON 20</span><br><span class="line">&lt;无符号整数&gt;</span><br><span class="line">&lt;整数&gt;</span><br><span class="line">&lt;因子&gt;</span><br><span class="line">&lt;项&gt;</span><br><span class="line">&lt;表达式&gt;</span><br><span class="line">&lt;值参数表&gt;</span><br><span class="line">RPARENT )</span><br><span class="line">&lt;有返回值函数调用语句&gt;</span><br><span class="line">&lt;因子&gt;</span><br><span class="line">&lt;项&gt;</span><br><span class="line">&lt;表达式&gt;</span><br><span class="line">RPARENT )</span><br><span class="line">&lt;写语句&gt;</span><br><span class="line">SEMICN ;</span><br><span class="line">&lt;语句&gt;</span><br><span class="line">&lt;语句列&gt;</span><br><span class="line">&lt;复合语句&gt;</span><br><span class="line">RBRACE &#125;</span><br><span class="line">&lt;主函数&gt;</span><br><span class="line">&lt;程序&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> const1 = <span class="number">1</span>, const2 = <span class="number">-100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> const3 = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> change1;</span><br><span class="line"><span class="keyword">char</span> change3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gets1</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">int</span> var2)</span></span>&#123;</span><br><span class="line">	change1 = var1 + var2;</span><br><span class="line">	<span class="keyword">return</span> (change1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="built_in">gets1</span>(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">＜加法运算符＞ ::= +｜-</span><br><span class="line">＜乘法运算符＞  ::= *｜/</span><br><span class="line">＜关系运算符＞  ::=  &lt;｜&lt;=｜&gt;｜&gt;=｜!=｜==</span><br><span class="line">＜字母＞   ::= ＿｜a｜．．．｜z｜A｜．．．｜Z</span><br><span class="line">＜数字＞   ::= ０｜＜非零数字＞</span><br><span class="line">＜非零数字＞  ::= １｜．．．｜９</span><br><span class="line">＜字符＞    ::=  <span class="string">&#x27;＜加法运算符＞&#x27;</span>｜<span class="string">&#x27;＜乘法运算符＞&#x27;</span>｜<span class="string">&#x27;＜字母＞&#x27;</span>｜<span class="string">&#x27;＜数字＞&#x27;</span></span><br><span class="line"><span class="comment">//＜字符串＞   ::=  &quot;｛十进制编码为32,33,35-126的ASCII字符｝&quot;</span></span><br><span class="line"><span class="comment">//＜程序＞    ::= ［＜常量说明＞］［＜变量说明＞］&#123;＜有返回值函数定义＞|＜无返回值函数定义＞&#125;＜主函数＞</span></span><br><span class="line"><span class="comment">//＜常量说明＞ ::=  const＜常量定义＞;&#123; const＜常量定义＞;&#125;</span></span><br><span class="line"><span class="comment">//＜常量定义＞   ::=   int＜标识符＞＝＜整数＞&#123;,＜标识符＞＝＜整数＞&#125;| char＜标识符＞＝＜字符＞&#123;,＜标识符＞＝＜字符＞&#125;</span></span><br><span class="line"><span class="comment">//＜无符号整数＞  ::= ＜非零数字＞｛＜数字＞｝| 0</span></span><br><span class="line"><span class="comment">//＜整数＞        ::= ［＋｜－］＜无符号整数＞</span></span><br><span class="line">＜标识符＞    ::=  ＜字母＞｛＜字母＞｜＜数字＞｝</span><br><span class="line"><span class="comment">//＜声明头部＞   ::=  int＜标识符＞ |char＜标识符＞</span></span><br><span class="line"><span class="comment">//＜变量说明＞  ::= ＜变量定义＞;&#123;＜变量定义＞;&#125;</span></span><br><span class="line"><span class="comment">//＜变量定义＞  ::= ＜类型标识符＞(＜标识符＞|＜标识符＞&#x27;[&#x27;＜无符号整数＞&#x27;]&#x27;)&#123;,(＜标识符＞|＜标识符＞&#x27;[&#x27;＜无符号整数＞&#x27;]&#x27; )&#125;//＜无符号整数＞表示数组元素的个数，其值需大于0</span></span><br><span class="line">＜类型标识符＞      ::=  <span class="keyword">int</span> | <span class="keyword">char</span></span><br><span class="line"><span class="comment">//＜有返回值函数定义＞  ::=  ＜声明头部＞&#x27;(&#x27;＜参数表＞&#x27;)&#x27; &#x27;&#123;&#x27;＜复合语句＞&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="comment">//＜无返回值函数定义＞  ::= void＜标识符＞&#x27;(&#x27;＜参数表＞&#x27;)&#x27;&#x27;&#123;&#x27;＜复合语句＞&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="comment">//＜复合语句＞   ::=  ［＜常量说明＞］［＜变量说明＞］＜语句列＞</span></span><br><span class="line"><span class="comment">//＜参数表＞    ::=  ＜类型标识符＞＜标识符＞&#123;,＜类型标识符＞＜标识符＞&#125;| ＜空＞</span></span><br><span class="line"><span class="comment">//＜主函数＞    ::= void main‘(’‘)’ ‘&#123;’＜复合语句＞‘&#125;’</span></span><br><span class="line"><span class="comment">//＜表达式＞    ::= ［＋｜－］＜项＞&#123;＜加法运算符＞＜项＞&#125;   //[+|-]只作用于第一个&lt;项&gt;</span></span><br><span class="line"><span class="comment">//＜项＞     ::= ＜因子＞&#123;＜乘法运算符＞＜因子＞&#125;</span></span><br><span class="line"><span class="comment">//＜因子＞    ::= ＜标识符＞｜＜标识符＞&#x27;[&#x27;＜表达式＞&#x27;]&#x27;|&#x27;(&#x27;＜表达式＞&#x27;)&#x27;｜＜整数＞|＜字符＞｜＜有返回值函数调用语句＞  </span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//＜语句＞    ::= ＜条件语句＞｜＜循环语句＞| &#x27;&#123;&#x27;＜语句列＞&#x27;&#125;&#x27;| ＜有返回值函数调用语句＞;  |＜无返回值函数调用语句＞;｜＜赋值语句＞;｜＜读语句＞;｜＜写语句＞;｜＜空＞;|＜返回语句＞;</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//＜赋值语句＞   ::=  ＜标识符＞＝＜表达式＞|＜标识符＞&#x27;[&#x27;＜表达式＞&#x27;]&#x27;=＜表达式＞</span></span><br><span class="line"><span class="comment">//＜条件语句＞  ::= if &#x27;(&#x27;＜条件＞&#x27;)&#x27;＜语句＞［else＜语句＞］</span></span><br><span class="line"><span class="comment">//＜条件＞    ::=  ＜表达式＞＜关系运算符＞＜表达式＞ //整型表达式之间才能进行关系运算｜＜表达式＞    //表达式为整型，其值为0条件为假，值不为0时条件为真                                </span></span><br><span class="line"><span class="comment">//＜循环语句＞   ::=  while &#x27;(&#x27;＜条件＞&#x27;)&#x27;＜语句＞| do＜语句＞while &#x27;(&#x27;＜条件＞&#x27;)&#x27; |for&#x27;(&#x27;＜标识符＞＝＜表达式＞;＜条件＞;＜标识符＞＝＜标识符＞(+|-)＜步长＞&#x27;)&#x27;＜语句＞</span></span><br><span class="line"><span class="comment">//＜步长＞::= ＜无符号整数＞  </span></span><br><span class="line"><span class="comment">//＜有返回值函数调用语句＞ ::= ＜标识符＞&#x27;(&#x27;＜值参数表＞&#x27;)&#x27;</span></span><br><span class="line"><span class="comment">//＜无返回值函数调用语句＞ ::= ＜标识符＞&#x27;(&#x27;＜值参数表＞&#x27;)&#x27;</span></span><br><span class="line"><span class="comment">//＜值参数表＞   ::= ＜表达式＞&#123;,＜表达式＞&#125;｜＜空＞</span></span><br><span class="line"><span class="comment">//＜语句列＞   ::= ｛＜语句＞｝</span></span><br><span class="line"><span class="comment">//＜读语句＞    ::=  scanf &#x27;(&#x27;＜标识符＞&#123;,＜标识符＞&#125;&#x27;)&#x27;</span></span><br><span class="line"><span class="comment">//＜写语句＞    ::= printf &#x27;(&#x27; ＜字符串＞,＜表达式＞ &#x27;)&#x27;| printf &#x27;(&#x27;＜字符串＞ &#x27;)&#x27;| printf &#x27;(&#x27;＜表达式＞&#x27;)&#x27;</span></span><br><span class="line"><span class="comment">//＜返回语句＞   ::=  return[&#x27;(&#x27;＜表达式＞&#x27;)&#x27;]   </span></span><br></pre></td></tr></table></figure>

<p><img src="/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20220102113306597.png" alt="image-20220102113306597"></p>
<p><img src="/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20220102113327972.png" alt="image-20220102113327972"></p>
<p><img src="/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20220102113353001.png" alt="image-20220102113353001"></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>通讯录管理系统</title>
    <url>/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>学习自黑马程序员&amp;传智教育，文档资料有修改</p>
<span id="more"></span>

<h1 id="通讯录管理系统"><a href="#通讯录管理系统" class="headerlink" title="通讯录管理系统"></a>通讯录管理系统</h1><h2 id="1、系统需求"><a href="#1、系统需求" class="headerlink" title="1、系统需求"></a>1、系统需求</h2><p>通讯录是一个可以记录亲人、好友信息的工具。</p>
<p>本教程主要利用C++来实现一个通讯录管理系统</p>
<p>系统中需要实现的功能如下：</p>
<ul>
<li>添加联系人：向通讯录中添加新人，信息包括（姓名、性别、年龄、联系电话、家庭住址）最多记录1000人</li>
<li>显示联系人：显示通讯录中所有联系人信息</li>
<li>删除联系人：按照姓名进行删除指定联系人</li>
<li>查找联系人：按照姓名查看指定联系人信息</li>
<li>修改联系人：按照姓名重新修改指定联系人</li>
<li>清空联系人：清空通讯录中所有信息</li>
<li>退出通讯录：退出当前使用的通讯录</li>
</ul>
<h2 id="2、创建项目"><a href="#2、创建项目" class="headerlink" title="2、创建项目"></a>2、创建项目</h2><p>创建项目步骤如下：</p>
<ul>
<li>创建新项目</li>
<li>添加文件</li>
</ul>
<h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><p>打开vs2017后，点击创建新项目，创建新的C++项目</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544151401138.png" alt="1544151401138"></p>
<p>填写项目名称，选择项目路径</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544151579620.png" alt="1544151579620"></p>
<h3 id="2-2添加文件"><a href="#2-2添加文件" class="headerlink" title="2.2添加文件"></a>2.2添加文件</h3><p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544161551746.png" alt="1544161551746"></p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544161648175.png" alt="1544161648175"></p>
<p>添加成功后，效果如图：</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544162344057.png" alt="1544162344057"></p>
<p>至此，项目已创建完毕</p>
<h2 id="3、菜单功能"><a href="#3、菜单功能" class="headerlink" title="3、菜单功能"></a>3、菜单功能</h2><p><strong>功能描述：</strong> 用户选择功能的界面</p>
<p>菜单界面效果如下图：</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544149559893.png" alt="1544149559893"></p>
<p><strong>步骤：</strong></p>
<ul>
<li>封装函数显示该界面  如 <code>void showMenu()</code></li>
<li>在main函数中调用封装好的函数</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;***************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  1、添加联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  2、显示联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  3、删除联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  4、查找联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  5、修改联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  6、清空联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  0、退出通讯录  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;***************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">showMenu</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="4、退出功能"><a href="#4、退出功能" class="headerlink" title="4、退出功能"></a>4、退出功能</h2><p>功能描述：退出通讯录系统</p>
<p>思路：根据用户不同的选择，进入不同的功能，可以选择switch分支结构，将整个架构进行搭建</p>
<p>当用户选择0时候，执行退出，选择其他先不做操作，也不会退出程序</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">showMenu</span>();</span><br><span class="line"></span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (select)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//添加联系人</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//显示联系人</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//删除联系人</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:  <span class="comment">//查找联系人</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:  <span class="comment">//修改联系人</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:  <span class="comment">//清空联系人</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//退出通讯录</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;欢迎下次使用&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>效果图：</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544163868043.png" alt="1544163868043"></p>
<h2 id="5、添加联系人"><a href="#5、添加联系人" class="headerlink" title="5、添加联系人"></a>5、添加联系人</h2><p>功能描述：</p>
<p>实现添加联系人功能，联系人上限为1000人，联系人信息包括（姓名、性别、年龄、联系电话、家庭住址）</p>
<p>添加联系人实现步骤：</p>
<ul>
<li>设计联系人结构体</li>
<li>设计通讯录结构体</li>
<li>main函数中创建通讯录</li>
<li>封装添加联系人函数</li>
<li>测试添加联系人功能</li>
</ul>
<h3 id="5-1-设计联系人结构体"><a href="#5-1-设计联系人结构体" class="headerlink" title="5.1 设计联系人结构体"></a>5.1 设计联系人结构体</h3><p>联系人信息包括：姓名、性别、年龄、联系电话、家庭住址</p>
<p>设计如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  <span class="comment">//string头文件</span></span></span><br><span class="line"><span class="comment">//联系人结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	string m_Name; <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> m_Sex; <span class="comment">//性别：1男 2女</span></span><br><span class="line">	<span class="keyword">int</span> m_Age; <span class="comment">//年龄</span></span><br><span class="line">	string m_Phone; <span class="comment">//电话</span></span><br><span class="line">	string m_Addr; <span class="comment">//住址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-设计通讯录结构体"><a href="#5-2-设计通讯录结构体" class="headerlink" title="5.2 设计通讯录结构体"></a>5.2 设计通讯录结构体</h3><p>设计时候可以在通讯录结构体中，维护一个容量为1000的存放联系人的数组，并记录当前通讯录中联系人数量</p>
<p>设计如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000 <span class="comment">//最大人数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通讯录结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Addressbooks</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">personArray</span>[<span class="title">MAX</span>];</span> <span class="comment">//通讯录中保存的联系人数组</span></span><br><span class="line">	<span class="keyword">int</span> m_Size; <span class="comment">//通讯录中人员个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5-3-main函数中创建通讯录"><a href="#5-3-main函数中创建通讯录" class="headerlink" title="5.3 main函数中创建通讯录"></a>5.3 main函数中创建通讯录</h3><p>添加联系人函数封装好后，在main函数中创建一个通讯录变量，这个就是我们需要一直维护的通讯录</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mian函数起始位置添加：</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建通讯录</span></span><br><span class="line">	Addressbooks abs;</span><br><span class="line">	<span class="comment">//初始化通讯录中人数</span></span><br><span class="line">	abs.m_Size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>





<h3 id="5-4-封装添加联系人函数"><a href="#5-4-封装添加联系人函数" class="headerlink" title="5.4 封装添加联系人函数"></a>5.4 封装添加联系人函数</h3><p>思路：添加联系人前先判断通讯录是否已满，如果满了就不再添加，未满情况将新联系人信息逐个加入到通讯录</p>
<p>添加联系人代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、添加联系人信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(Addressbooks *abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//判断电话本是否满了</span></span><br><span class="line">	<span class="keyword">if</span> (abs-&gt;m_Size == MAX)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;通讯录已满，无法添加&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//姓名</span></span><br><span class="line">		string name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入姓名：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; name;</span><br><span class="line">		abs-&gt;personArray[abs-&gt;m_Size].m_Name = name;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入性别：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1 -- 男&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;2 -- 女&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//性别</span></span><br><span class="line">		<span class="keyword">int</span> sex = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; sex;</span><br><span class="line">			<span class="keyword">if</span> (sex == <span class="number">1</span> || sex == <span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				abs-&gt;personArray[abs-&gt;m_Size].m_Sex = sex;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//年龄</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入年龄：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; age;</span><br><span class="line">		abs-&gt;personArray[abs-&gt;m_Size].m_Age = age;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//联系电话</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入联系电话：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string phone = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		cin &gt;&gt; phone;</span><br><span class="line">		abs-&gt;personArray[abs-&gt;m_Size].m_Phone = phone;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//家庭住址</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入家庭住址：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string address;</span><br><span class="line">		cin &gt;&gt; address;</span><br><span class="line">		abs-&gt;personArray[abs-&gt;m_Size].m_Addr = address;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新通讯录人数</span></span><br><span class="line">		abs-&gt;m_Size++;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;添加成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="5-5-测试添加联系人功能"><a href="#5-5-测试添加联系人功能" class="headerlink" title="5.5 测试添加联系人功能"></a>5.5 测试添加联系人功能</h3><p>选择界面中，如果玩家选择了1，代表添加联系人，我们可以测试下该功能</p>
<p>在switch case 语句中，case1里添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//添加联系人</span></span><br><span class="line">	<span class="built_in">addPerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p>测试效果如图：</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544165554002.png" alt="1544165554002"></p>
<h2 id="6、显示联系人"><a href="#6、显示联系人" class="headerlink" title="6、显示联系人"></a>6、显示联系人</h2><p>功能描述：显示通讯录中已有的联系人信息</p>
<p>显示联系人实现步骤：</p>
<ul>
<li>封装显示联系人函数</li>
<li>测试显示联系人功能</li>
</ul>
<h3 id="6-1-封装显示联系人函数"><a href="#6-1-封装显示联系人函数" class="headerlink" title="6.1 封装显示联系人函数"></a>6.1 封装显示联系人函数</h3><p>思路：判断如果当前通讯录中没有人员，就提示记录为空，人数大于0，显示通讯录中信息</p>
<p>显示联系人代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2、显示所有联系人信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (abs-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;当前记录为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; abs-&gt;m_Size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; abs-&gt;personArray[i].m_Name &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;性别：&quot;</span> &lt;&lt; (abs-&gt;personArray[i].m_Sex == <span class="number">1</span> ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>) &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; abs-&gt;personArray[i].m_Age &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;电话：&quot;</span> &lt;&lt; abs-&gt;personArray[i].m_Phone &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;住址：&quot;</span> &lt;&lt; abs-&gt;personArray[i].m_Addr &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="6-2-测试显示联系人功能"><a href="#6-2-测试显示联系人功能" class="headerlink" title="6.2 测试显示联系人功能"></a>6.2 测试显示联系人功能</h3><p>在switch case语句中，case 2 里添加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//显示联系人</span></span><br><span class="line">	<span class="built_in">showPerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p>测试效果如图：</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544166401582.png" alt="1544166401582"></p>
<h2 id="7、删除联系人"><a href="#7、删除联系人" class="headerlink" title="7、删除联系人"></a>7、删除联系人</h2><p>功能描述：按照姓名进行删除指定联系人</p>
<p>删除联系人实现步骤：</p>
<ul>
<li>封装检测联系人是否存在</li>
<li>封装删除联系人函数</li>
<li>测试删除联系人功能</li>
</ul>
<h3 id="7-1-封装检测联系人是否存在"><a href="#7-1-封装检测联系人是否存在" class="headerlink" title="7.1  封装检测联系人是否存在"></a>7.1  封装检测联系人是否存在</h3><p>设计思路：</p>
<p>删除联系人前，我们需要先判断用户输入的联系人是否存在，如果存在删除，不存在提示用户没有要删除的联系人</p>
<p>因此我们可以把检测联系人是否存在封装成一个函数中，如果存在，返回联系人在通讯录中的位置，不存在返回-1</p>
<p>检测联系人是否存在代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否存在查询的人员，存在返回在数组中索引位置，不存在返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isExist</span><span class="params">(Addressbooks * abs, string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; abs-&gt;m_Size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (abs-&gt;personArray[i].m_Name == name)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-2-封装删除联系人函数"><a href="#7-2-封装删除联系人函数" class="headerlink" title="7.2 封装删除联系人函数"></a>7.2 封装删除联系人函数</h3><p>根据用户输入的联系人判断该通讯录中是否有此人</p>
<p>查找到进行删除，并提示删除成功</p>
<p>查不到提示查无此人。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3、删除指定联系人信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入您要删除的联系人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	string name;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">isExist</span>(abs, name);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = ret; i &lt; abs-&gt;m_Size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			abs-&gt;personArray[i] = abs-&gt;personArray[i + <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">         abs-&gt;m_Size--;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;删除成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-3-测试删除联系人功能"><a href="#7-3-测试删除联系人功能" class="headerlink" title="7.3 测试删除联系人功能"></a>7.3 测试删除联系人功能</h3><p>在switch case 语句中，case3里添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//删除联系人</span></span><br><span class="line">	<span class="built_in">deletePerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>测试效果如图：</p>
<p>存在情况：</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544167951559.png" alt="1544167951559"></p>
<p>不存在情况：</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544168010831.png" alt="1544168010831"></p>
<h2 id="8、查找联系人"><a href="#8、查找联系人" class="headerlink" title="8、查找联系人"></a>8、查找联系人</h2><p>功能描述：按照姓名查看指定联系人信息</p>
<p>查找联系人实现步骤</p>
<ul>
<li>封装查找联系人函数</li>
<li>测试查找指定联系人</li>
</ul>
<h3 id="8-1-封装查找联系人函数"><a href="#8-1-封装查找联系人函数" class="headerlink" title="8.1 封装查找联系人函数"></a>8.1 封装查找联系人函数</h3><p>实现思路：判断用户指定的联系人是否存在，如果存在显示信息，不存在则提示查无此人。</p>
<p>查找联系人代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4、查找指定联系人信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入您要查找的联系人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	string name;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">isExist</span>(abs, name);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; abs-&gt;personArray[ret].m_Name &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;性别：&quot;</span> &lt;&lt; abs-&gt;personArray[ret].m_Sex &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; abs-&gt;personArray[ret].m_Age &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;电话：&quot;</span> &lt;&lt; abs-&gt;personArray[ret].m_Phone &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;住址：&quot;</span> &lt;&lt; abs-&gt;personArray[ret].m_Addr &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-2-测试查找指定联系人"><a href="#8-2-测试查找指定联系人" class="headerlink" title="8.2 测试查找指定联系人"></a>8.2 测试查找指定联系人</h3><p>在switch case 语句中，case4里添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">4</span>:  <span class="comment">//查找联系人</span></span><br><span class="line">	<span class="built_in">findPerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p>测试效果如图</p>
<p>存在情况：</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544170057646.png" alt="1544170057646"></p>
<p>不存在情况：</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544170254021.png" alt="1544170254021"></p>
<h2 id="9、修改联系人"><a href="#9、修改联系人" class="headerlink" title="9、修改联系人"></a>9、修改联系人</h2><p>功能描述：按照姓名重新修改指定联系人</p>
<p>修改联系人实现步骤</p>
<ul>
<li>封装修改联系人函数</li>
<li>测试修改联系人功能</li>
</ul>
<h3 id="9-1-封装修改联系人函数"><a href="#9-1-封装修改联系人函数" class="headerlink" title="9.1 封装修改联系人函数"></a>9.1 封装修改联系人函数</h3><p>实现思路：查找用户输入的联系人，如果查找成功进行修改操作，查找失败提示查无此人</p>
<p>修改联系人代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5、修改指定联系人信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyPerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入您要修改的联系人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	string name;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">isExist</span>(abs, name);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//姓名</span></span><br><span class="line">		string name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入姓名：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; name;</span><br><span class="line">		abs-&gt;personArray[ret].m_Name = name;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入性别：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1 -- 男&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;2 -- 女&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//性别</span></span><br><span class="line">		<span class="keyword">int</span> sex = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; sex;</span><br><span class="line">			<span class="keyword">if</span> (sex == <span class="number">1</span> || sex == <span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				abs-&gt;personArray[ret].m_Sex = sex;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//年龄</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入年龄：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; age;</span><br><span class="line">		abs-&gt;personArray[ret].m_Age = age;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//联系电话</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入联系电话：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string phone = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		cin &gt;&gt; phone;</span><br><span class="line">		abs-&gt;personArray[ret].m_Phone = phone;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//家庭住址</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入家庭住址：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string address;</span><br><span class="line">		cin &gt;&gt; address;</span><br><span class="line">		abs-&gt;personArray[ret].m_Addr = address;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;修改成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="9-2-测试修改联系人功能"><a href="#9-2-测试修改联系人功能" class="headerlink" title="9.2 测试修改联系人功能"></a>9.2 测试修改联系人功能</h3><p>在switch case 语句中，case 5里添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">5</span>:  <span class="comment">//修改联系人</span></span><br><span class="line">	<span class="built_in">modifyPerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p>测试效果如图：</p>
<p>查不到指定联系人情况：</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544172265676.png" alt="1544172265676"></p>
<p>查找到联系人，并修改成功：</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544172164141.png" alt="1544172164141"></p>
<p>再次查看通讯录，确认修改完毕</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544172228627.png" alt="1544172228627"></p>
<h2 id="10、清空联系人"><a href="#10、清空联系人" class="headerlink" title="10、清空联系人"></a>10、清空联系人</h2><p>功能描述：清空通讯录中所有信息</p>
<p>清空联系人实现步骤</p>
<ul>
<li>封装清空联系人函数</li>
<li>测试清空联系人</li>
</ul>
<h3 id="10-1-封装清空联系人函数"><a href="#10-1-封装清空联系人函数" class="headerlink" title="10.1 封装清空联系人函数"></a>10.1 封装清空联系人函数</h3><p>实现思路： 将通讯录所有联系人信息清除掉，只要将通讯录记录的联系人数量置为0，做逻辑清空即可。</p>
<p>清空联系人代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6、清空所有联系人</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanPerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	abs-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通讯录已清空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-2-测试清空联系人"><a href="#10-2-测试清空联系人" class="headerlink" title="10.2  测试清空联系人"></a>10.2  测试清空联系人</h3><p>在switch case 语句中，case 6 里添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">6</span>:  <span class="comment">//清空联系人</span></span><br><span class="line">	<span class="built_in">cleanPerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p>测试效果如图：</p>
<p>清空通讯录</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544172909693.png" alt="1544172909693"></p>
<p>再次查看信息，显示记录为空</p>
<p><img src="/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544172943653.png" alt="1544172943653"></p>
<p><strong>至此，通讯录管理系统完成！</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>bs4解析</title>
    <url>/03%20bs4%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>bs4 全名 BeautifulSoup，是编写 python 爬虫常用库之一，主要用来解析 html 标签。</p>
<span id="more"></span>

<p>一点点HTML基础知识</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;标签 属性=&quot;值&quot; 属性=&quot;值&quot;&gt;</span><br><span class="line">	被标记的内容</span><br><span class="line">&lt;/标签&gt;</span><br></pre></td></tr></table></figure>

<p>安装bs4（清华源）</p>
<p>方法1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install bs4 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>方法2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 需要将pip源设置为国内源，阿里源、豆瓣源、网易源等</span><br><span class="line">   - windows</span><br><span class="line">    （1）打开文件资源管理器(文件夹地址栏中)</span><br><span class="line">    （2）地址栏上面输入 %appdata%</span><br><span class="line">    （3）在这里面新建一个文件夹  pip</span><br><span class="line">    （4）在pip文件夹里面新建一个文件叫做  pip.ini ,内容写如下即可</span><br><span class="line">        [global]</span><br><span class="line">        timeout = 6000</span><br><span class="line">        index-url = https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">        trusted-host = mirrors.aliyun.com</span><br><span class="line">   - linux</span><br><span class="line">    （1）cd ~</span><br><span class="line">    （2）mkdir ~/.pip</span><br><span class="line">    （3）vi ~/.pip/pip.conf</span><br><span class="line">    （4）编辑内容，和windows一模一样</span><br><span class="line">- 需要安装：pip install bs4</span><br><span class="line">     bs4在使用时候需要一个第三方库，把这个库也安装一下</span><br><span class="line">     pip install lxml  </span><br></pre></td></tr></table></figure>



<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用流程：       </span><br><span class="line">    - 导包：from bs4 import BeautifulSoup</span><br><span class="line">    - 使用方式：可以将一个html文档，转化为BeautifulSoup对象，然后通过对象的方法或者属性去查找指定的节点内容</span><br><span class="line">        （1）转化本地文件：</span><br><span class="line">             - soup = BeautifulSoup(open(&#x27;本地文件&#x27;), &#x27;lxml&#x27;)</span><br><span class="line">        （2）转化网络文件：</span><br><span class="line">             - soup = BeautifulSoup(&#x27;字符串类型或者字节类型&#x27;, &#x27;lxml&#x27;)</span><br><span class="line">        （3）打印soup对象显示内容为html文件中的内容</span><br><span class="line">基础巩固：</span><br><span class="line">    （1）根据标签名查找</span><br><span class="line">        - soup.a   只能找到第一个符合要求的标签</span><br><span class="line">    （2）获取属性</span><br><span class="line">        - soup.a.attrs  获取a所有的属性和属性值，返回一个字典</span><br><span class="line">        - soup.a.attrs[&#x27;href&#x27;]   获取href属性</span><br><span class="line">        - soup.a[&#x27;href&#x27;]   也可简写为这种形式</span><br><span class="line">    （3）获取内容</span><br><span class="line">        - soup.a.string</span><br><span class="line">        - soup.a.text</span><br><span class="line">        - soup.a.get_text()</span><br><span class="line">       【注意】如果标签还有标签，那么string获取到的结果为None，而其它两个，可以获取文本内容</span><br><span class="line">    （4）find：找到第一个符合要求的标签</span><br><span class="line">        - soup.find(&#x27;a&#x27;)  找到第一个符合要求的</span><br><span class="line">        - soup.find(&#x27;a&#x27;, title=&quot;xxx&quot;)</span><br><span class="line">        - soup.find(&#x27;a&#x27;, alt=&quot;xxx&quot;)</span><br><span class="line">        - soup.find(&#x27;a&#x27;, class_=&quot;xxx&quot;)</span><br><span class="line">        - soup.find(&#x27;a&#x27;, id=&quot;xxx&quot;)</span><br><span class="line">    （5）find_all：找到所有符合要求的标签</span><br><span class="line">        - soup.find_all(&#x27;a&#x27;)</span><br><span class="line">        - soup.find_all([&#x27;a&#x27;,&#x27;b&#x27;]) 找到所有的a和b标签</span><br><span class="line">        - soup.find_all(&#x27;a&#x27;, limit=2)  限制前两个</span><br><span class="line">    （6）根据选择器选择指定的内容</span><br><span class="line">               select:soup.select(&#x27;#feng&#x27;)</span><br><span class="line">        - 常见的选择器：标签选择器(a)、类选择器(.)、id选择器(#)、层级选择器</span><br><span class="line">            - 层级选择器：</span><br><span class="line">                div .dudu #lala .meme .xixi  下面好多级</span><br><span class="line">                div &gt; p &gt; a &gt; .lala          只能是下面一级</span><br><span class="line">        【注意】select选择器返回永远是列表，需要通过下标提取指定的对象</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment">#需求：爬取三国演义小说所有的章节标题和章节内容http://www.shicimingju.com/book/sanguoyanyi.html</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#对首页的页面数据进行爬取</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>:</span><br><span class="line">        <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    url = <span class="string">&#x27;http://www.shicimingju.com/book/sanguoyanyi.html&#x27;</span></span><br><span class="line">    page_text = requests.get(url=url, headers=headers).text</span><br><span class="line"></span><br><span class="line">    <span class="comment">#在首页中解析出章节的标题和详情页的url</span></span><br><span class="line">    <span class="comment">#1.实例化BeautifulSoup对象，需要将页面源码数据加载到该对象中</span></span><br><span class="line">    soup = BeautifulSoup(page_text, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    <span class="comment">#解析章节标题和详情页的url</span></span><br><span class="line">    li_list = soup.select(<span class="string">&#x27;.book-mulu &gt; ul &gt; li&#x27;</span>)</span><br><span class="line">    fp = <span class="built_in">open</span>(<span class="string">&#x27;./sanguo.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">        title = li.a.string</span><br><span class="line">        detail_url = <span class="string">&#x27;http://www.shicimingju.com&#x27;</span> + li.a[<span class="string">&#x27;href&#x27;</span>]</span><br><span class="line">        <span class="comment">#对详情页发起请求，解析出章节内容</span></span><br><span class="line">        detail_page_text = requests.get(url=detail_url, headers=headers).text</span><br><span class="line">        <span class="comment">#解析出详情页中相关的章节内容</span></span><br><span class="line">        detail_soup = BeautifulSoup(detail_page_text, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">        div_tag = detail_soup.find(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;chapter_content&#x27;</span>)</span><br><span class="line">        <span class="comment">#解析到了章节的内容</span></span><br><span class="line">        content = div_tag.text</span><br><span class="line">        fp.write(title + <span class="string">&#x27;:&#x27;</span> + content + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(title, <span class="string">&#x27;爬取成功！！！&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h3><p><a href="https://www.cnblogs.com/gl1573/p/9480022.html">【Python 库】bs4的使用 - 丹枫无迹 - 博客园 (cnblogs.com)</a></p>
<p><strong>一、初始化</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(<span class="string">&quot;&lt;html&gt;A Html Text&lt;/html&gt;&quot;</span>, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line">第一个参数是要解析的html文本，第二个参数是解析器</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>解析器</th>
<th>使用方法</th>
<th>优势</th>
</tr>
</thead>
<tbody><tr>
<td>Python标准库</td>
<td>BeautifulSoup(html, “html.parser”)</td>
<td>1、Python的内置标准库<br>2、执行速度适中<br>3、文档容错能力强</td>
</tr>
<tr>
<td>lxml HTML</td>
<td>BeautifulSoup(html, “lxml”)</td>
<td>1、速度快<br>2、文档容错能力强</td>
</tr>
<tr>
<td>lxml XML</td>
<td>BeautifulSoup(html, [“lxml”, “xml”])<br>BeautifulSoup(html, “xml”)</td>
<td>1、速度快<br>2、唯一支持XML的解析器</td>
</tr>
<tr>
<td>html5lib</td>
<td>BeautifulSoup(html, “html5lib”)</td>
<td>1、最好的容错性<br>2、以浏览器的方式解析文档<br>3、生成HTML5格式的文档</td>
</tr>
</tbody></table>
<p>格式化输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.prettify()  <span class="comment"># prettify 有括号和没括号都可以</span></span><br></pre></td></tr></table></figure>

<p><strong>二、对象</strong></p>
<p>　　Beautfiful Soup将复杂HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种：tag，NavigableString，BeautifulSoup，Comment。</p>
<p><strong>1、tag</strong></p>
<p>　　Tag对象与 xml 或 html 原生文档中的 tag 相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">&#x27;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">tag = soup.b</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>(tag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;class &#x27;bs4.element.Tag&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>　　如果不存在，则返回 None，如果存在多个，则返回第一个。</p>
<p><strong>Name</strong></p>
<p>　　每个 tag 都有自己的名字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tag.name </span><br><span class="line"><span class="comment"># &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>


<p><strong>Attributes</strong></p>
<p>　　tag 的属性是一个字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tag[<span class="string">&#x27;class&#x27;</span>]</span><br><span class="line"><span class="comment"># &#x27;boldest&#x27;</span></span><br><span class="line"></span><br><span class="line">tag.attrs</span><br><span class="line"><span class="comment"># &#123;&#x27;class&#x27;: &#x27;boldest&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>(tag.attrs)</span><br><span class="line"><span class="comment"># &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>多值属性</strong></p>
<p>　　最常见的多值属性是class，多值属性的返回 list。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">&#x27;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.p[<span class="string">&#x27;class&#x27;</span>])  <span class="comment"># [&#x27;body&#x27;, &#x27;strikeout&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.p.attrs)     <span class="comment"># &#123;&#x27;class&#x27;: [&#x27;body&#x27;, &#x27;strikeout&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>

<p>　　如果某个属性看起来好像有多个值,但在任何版本的HTML定义中都没有被定义为多值属性，那么Beautiful Soup会将这个属性作为字符串返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">&#x27;&lt;p id=&quot;my id&quot;&gt;&lt;/p&gt;&#x27;</span>, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup.p[<span class="string">&#x27;id&#x27;</span>])    <span class="comment"># &#x27;my id&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>Text</strong></p>
<p>　　text 属性返回 tag 的所有字符串连成的字符串。</p>
<p><strong>其他方法</strong></p>
<p>　　<code>tag.has_attr(&#39;id&#39;)</code>   # 返回 tag 是否包含 id 属性</p>
<p>　　当然，以上代码还可以写成 ‘id’ in tag.attrs，之前说过，tag 的属性是一个字典。顺便提一下，has_key是老旧遗留的api，为了支持2.2之前的代码留下的。Python3已经删除了该函数。</p>
<p><strong>2、NavigableString</strong></p>
<p>　　字符串常被包含在 tag 内，Beautiful Soup 用 NavigableString 类来包装 tag 中的字符串。但是字符串中不能包含其他 tag。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">&#x27;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s = soup.b.string</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s)        <span class="comment"># Extremely bold</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s))  <span class="comment"># &lt;class &#x27;bs4.element.NavigableString&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3、BeautifulSoup</strong></p>
<p>　　BeautifulSoup 对象表示的是一个文档的全部内容。大部分时候，可以把它当作 Tag 对象。但是 BeautifulSoup 对象并不是真正的 HTM L或 XML 的 tag，它没有attribute属性，name 属性是一个值为“[document]”的特殊属性。</p>
<p><strong>4、Comment</strong></p>
<p>　　Comment 一般表示文档的注释部分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">&#x27;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s = soup.b.string</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s)        <span class="comment"># Extremely bold</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s))  <span class="comment"># &lt;class &#x27;bs4.element.NavigableString&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>三、遍历</strong> </p>
<p><strong>1、子节点</strong></p>
<p><strong>contents</strong> <strong>属性</strong></p>
<p>　　contents 属性返回所有子节点的列表，包括 NavigableString 类型节点。如果节点当中有换行符，会被当做是 NavigableString 类型节点而作为一个子节点。</p>
<p>　　NavigableString 类型节点没有 contents 属性，因为没有子节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">&quot;&quot;&quot;&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;span&gt;test&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">element = soup.div.contents</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(element)          <span class="comment"># [&#x27;\n&#x27;, &lt;span&gt;test&lt;/span&gt;, &#x27;\n&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>children</strong> <strong>属性</strong></p>
<p>　　children 属性跟 contents 属性基本一样，只不过返回的不是子节点列表，而是子节点的可迭代对象。</p>
<p><strong>descendants</strong> <strong>属性</strong></p>
<p>　　descendants 属性返回 tag 的所有子孙节点。</p>
<p><strong>string</strong> <strong>属性</strong></p>
<p>　　如果 tag 只有一个 NavigableString 类型子节点，那么这个 tag 可以使用 .string 得到子节点。</p>
<p>　　如果一个 tag 仅有一个子节点，那么这个 tag 也可以使用 .string 方法，输出结果与当前唯一子节点的 .string 结果相同。</p>
<p>　　如果 tag 包含了多个子节点，tag 就无法确定 .string 方法应该调用哪个子节点的内容, .string 的输出结果是 None。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">&quot;&quot;&quot;&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;&lt;span&gt;&lt;b&gt;test&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">element = soup.p.string</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(element)          <span class="comment"># test</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(element))    <span class="comment"># &lt;class &#x27;bs4.element.NavigableString&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>　　特别注意，为了清楚显示，一般我们会将 html 节点换行缩进显示，而在BeautifulSoup 中会被认为是一个 NavigableString 类型子节点，导致出错。上例中，如果改成 element = soup.div.string 就会出错。</p>
<p><strong>strings</strong> <strong>和 stripped_strings 属性</strong></p>
<p>　　如果 tag 中包含多个字符串，可以用 strings 属性来获取。如果返回结果中要去除空行，则可以用 stripped_strings 属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">&quot;&quot;&quot;&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;      &lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;test 1&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;test 2&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"></span><br><span class="line">element = soup.div.stripped_strings</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(element))          <span class="comment"># [&#x27;test 1&#x27;, &#x27;test 2&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>2、父节点</strong></p>
<p><strong>parent</strong> <strong>属性</strong></p>
<p>　　parent 属性返回某个元素（tag、NavigableString）的父节点，文档的顶层节点的父节点是 BeautifulSoup 对象，BeautifulSoup 对象的父节点是 None。</p>
<p><strong>parents</strong> <strong>属性</strong></p>
<p>　　parent 属性递归得到元素的所有父辈节点，包括 BeautifulSoup 对象。</p>
<p><strong>3、兄弟节点</strong></p>
<p><strong>next_sibling</strong> <strong>和 previous_sibling</strong></p>
<p>　　next_sibling 返回后一个兄弟节点，previous_sibling 返回前一个兄弟节点。直接看个例子，注意别被换行缩进搅了局。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">&quot;&quot;&quot;&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;test 1&lt;/p&gt;&lt;b&gt;test 2&lt;/b&gt;&lt;h&gt;test 3&lt;/h&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.b.next_sibling)      <span class="comment"># &lt;h&gt;test 3&lt;/h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.b.previous_sibling)  <span class="comment"># &lt;p&gt;test 1&lt;/p&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.h.next_sibling)      <span class="comment"># None</span></span><br></pre></td></tr></table></figure>

<p><strong>next_siblings</strong> <strong>和 previous_siblings</strong></p>
<p>　　next_siblings 返回后面的兄弟节点</p>
<p>　　previous_siblings　　返回前面的兄弟节点</p>
<p><strong>4、回退和前进</strong></p>
<p>　　把html解析看成依次解析标签的一连串事件，BeautifulSoup 提供了重现解析器初始化过程的方法。</p>
<p>　　next_element 属性指向解析过程中下一个被解析的对象（tag 或 NavigableString）。</p>
<p>　　previous_element 属性指向解析过程中前一个被解析的对象。</p>
<p>　　另外还有next_elements 和 previous_elements 属性，不赘述了。</p>
<p><strong>四、搜索</strong></p>
<p><strong>1、过滤器</strong></p>
<p>　　介绍 find_all() 方法前，先介绍一下过滤器的类型，这些过滤器贯穿整个搜索的API。过滤器可以被用在tag的name中，节点的属性中，字符串中或他们的混合中。</p>
<p>示例使用的 html 文档如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">    &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">    &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">    &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>字符串</strong></p>
<p>查找所有的<b>标签</b></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="string">&#x27;b&#x27;</span>)  <span class="comment"># [&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;]</span></span><br></pre></td></tr></table></figure>
<p><strong>正则表达式</strong></p>
<p>传入正则表达式作为参数，返回满足正则表达式的标签。下面例子中找出所有以b开头的标签。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(re.<span class="built_in">compile</span>(<span class="string">&quot;^b&quot;</span>))  <span class="comment"># [&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;]</span></span><br></pre></td></tr></table></figure>
<p><strong>列表</strong></p>
<p>传入列表参数，将返回与列表中任一元素匹配的内容。下面例子中找出所有<a>标签和<b>标签。</b></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>])</span><br></pre></td></tr></table></figure>

<p><strong>True</strong></p>
<p>True可以匹配任何值，下面的代码查找到所有的tag，但是不会返回字符串节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><strong>方法</strong></p>
<p>如果没有合适过滤器，那么还可以自定义一个方法，方法只接受一个元素参数，如果这个方法返回True表示当前元素匹配被找到。下面示例返回所有包含 class 属性但不包含 id 属性的标签。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_class_but_no_id</span>(<span class="params">tag</span>):</span></span><br><span class="line">    <span class="keyword">return</span> tag.has_attr(<span class="string">&#x27;class&#x27;</span>) <span class="keyword">and</span> <span class="keyword">not</span> tag.has_attr(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.find_all(has_class_but_no_id))</span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&lt;p <span class="class"><span class="keyword">class</span>=&quot;<span class="title">title</span>&quot;&gt;&lt;<span class="title">b</span>&gt;<span class="title">The</span> <span class="title">Dormouse</span>&#x27;<span class="title">s</span> <span class="title">story</span>&lt;/<span class="title">b</span>&gt;&lt;/<span class="title">p</span>&gt;, &lt;<span class="title">p</span> <span class="title">class</span>=&quot;<span class="title">story</span>&quot;&gt;<span class="title">Once</span> <span class="title">upon</span> <span class="title">a</span> <span class="title">time</span> <span class="title">there</span> <span class="title">were</span> <span class="title">three</span> <span class="title">little</span> <span class="title">sisters</span>; <span class="title">and</span> <span class="title">their</span> <span class="title">names</span> <span class="title">were</span></span></span><br><span class="line"><span class="class">    &lt;<span class="title">a</span> <span class="title">class</span>=&quot;<span class="title">sister</span>&quot; <span class="title">href</span>=&quot;<span class="title">http</span>:</span>//example.com/elsie<span class="string">&quot; id=&quot;</span>link1<span class="string">&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">    &lt;a class=&quot;</span>siste<span class="string">r&quot; href=&quot;</span>http://example.com/lacie<span class="string">&quot; id=&quot;</span>link2<span class="string">&quot;&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">    &lt;a class=&quot;</span>siste<span class="string">r&quot; href=&quot;</span>http://example.com/tillie<span class="string">&quot; id=&quot;</span>link3<span class="string">&quot;&gt;Tillie&lt;/a&gt;&lt;/p&gt;]</span></span><br></pre></td></tr></table></figure>

<p>这个结果乍一看不对，<a>标签含有 id 属性，其实返回的 list 中只有2个元素，都是<p>标签，<a>标签是<p>标签的子节点。</p>
<p><strong>2、find 和 find_all</strong></p>
<p>　　搜索当前 tag 的所有 tag 子节点，并判断是否符合过滤器的条件</p>
<p>语法：</p>
<p>　　find(name=None, attrs={}, recursive=True, text=None, **kwargs)</p>
<p>　　find_all(name=None, attrs={}, recursive=True, text=None, limit=None, **kwargs)</p>
<p>参数：</p>
<p>　　name：查找所有名字为 name 的 tag，字符串对象会被自动忽略掉。上面过滤器示例中的参数都是 name 参数。当然，其他参数中也可以使用过滤器。</p>
<p>　　attrs：按属性名和值查找。传入字典，key 为属性名，value 为属性值。</p>
<p>　　recursive：是否递归遍历所有子孙节点，默认 True。</p>
<p>　　text：用于搜索字符串，会找到 .string 方法与 text 参数值相符的tag，通常配合正则表达式使用。也就是说，虽然参数名是 text，但实际上搜索的是 string 属性。</p>
<p>　　limit：限定返回列表的最大个数。</p>
<p>　　kwargs：如果一个指定名字的参数不是搜索内置的参数名，搜索时会把该参数当作 tag 的属性来搜索。这里注意，如果要按 class 属性搜索，因为 class 是 python 的保留字，需要写作 class_。</p>
<p>　　Tag 的有些属性在搜索中不能作为 kwargs 参数使用，比如 html5 中的 data-* 属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_soup = BeautifulSoup(<span class="string">&#x27;&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data_soup.find_all(data-foo=<span class="string">&quot;value&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># SyntaxError: keyword can&#x27;t be an expression</span></span><br></pre></td></tr></table></figure>

<p>　　但是可以通过 attrs 参数传递：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_soup = BeautifulSoup(<span class="string">&#x27;&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data_soup.find_all(attrs=&#123;<span class="string">&quot;data-foo&quot;</span>: <span class="string">&quot;value&quot;</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;]</span></span><br></pre></td></tr></table></figure>

<p>　　而按 class_ 查找时，只要一个CSS类名满足即可，如果写了多个CSS名称，那么顺序必须一致，而且不能跳跃。以下示例中，前三个可以查找到元素，后两个不可以。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">css_soup = BeautifulSoup(<span class="string">&#x27;&lt;p class=&quot;body bold strikeout&quot;&gt;&lt;/p&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(css_soup.find_all(<span class="string">&quot;p&quot;</span>, class_=<span class="string">&quot;strikeout&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(css_soup.find_all(<span class="string">&quot;p&quot;</span>, class_=<span class="string">&quot;body&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(css_soup.find_all(<span class="string">&quot;p&quot;</span>, class_=<span class="string">&quot;body bold strikeout&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(css_soup.find_all(<span class="string">&quot;p&quot;</span>, class_=<span class="string">&quot;body strikeout&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(css_soup.find_all(<span class="string">&quot;p&quot;</span>, class_=<span class="string">&quot;strikeout body&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># []</span></span><br></pre></td></tr></table></figure>

<p><strong>3、像调用find_all()一样调用tag</strong></p>
<p>　　find_all() 几乎是 BeautifulSoup 中最常用的搜索方法，所以我们定义了它的简写方法。BeautifulSoup 对象和 tag 对象可以被当作一个方法来使用，这个方法的执行结果与调用这个对象的 find_all() 方法相同，下面两行代码是等价的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">soup(<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>4、其他搜索方法</strong></p>
<p>find_parents()　　　　　 返回所有祖先节点</p>
<p>find_parent()　　　　　　返回直接父节点</p>
<p>find_next_siblings()　　 返回后面所有的兄弟节点</p>
<p>find_next_sibling()　　 返回后面的第一个兄弟节点</p>
<p>find_previous_siblings() 返回前面所有的兄弟节点</p>
<p>find_previous_sibling()　返回前面第一个兄弟节点</p>
<p>find_all_next()　　　　 返回节点后所有符合条件的节点</p>
<p>find_next()　　　　　　 返回节点后第一个符合条件的节点</p>
<p>find_all_previous()　　 返回节点前所有符合条件的节点</p>
<p>find_previous()　　　　 返回节点前所有符合条件的节点</p>
<p><strong>五、CSS选择器</strong></p>
<p>BeautifulSoup支持大部分的CSS选择器，这里直接用代码来演示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string"> &lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;标题&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;div name=&quot;divlink&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;</span></span><br><span class="line"><span class="string">   &lt;a href=&quot;http://example.com/1&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;链接1&lt;/a&gt;</span></span><br><span class="line"><span class="string">   &lt;a href=&quot;http://example.com/2&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;链接2&lt;/a&gt;</span></span><br><span class="line"><span class="string">   &lt;a href=&quot;http://example.com/3&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;链接3&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string"> &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;div name=&#x27;dv2&#x27;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过tag查找</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;title&#x27;</span>))             <span class="comment"># [&lt;title&gt;标题&lt;/title&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过tag逐层查找</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&quot;html head title&quot;</span>))   <span class="comment"># [&lt;title&gt;标题&lt;/title&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过class查找</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;.sister&#x27;</span>))</span><br><span class="line"><span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/1&quot; id=&quot;link1&quot;&gt;链接1&lt;/a&gt;,</span></span><br><span class="line"><span class="comment"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/2&quot; id=&quot;link2&quot;&gt;链接2&lt;/a&gt;,</span></span><br><span class="line"><span class="comment"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/3&quot; id=&quot;link3&quot;&gt;链接3&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过id查找</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;#link1, #link2&#x27;</span>))</span><br><span class="line"><span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/1&quot; id=&quot;link1&quot;&gt;链接1&lt;/a&gt;,</span></span><br><span class="line"><span class="comment"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/2&quot; id=&quot;link2&quot;&gt;链接2&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合查找</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;p #link1&#x27;</span>))　　　　<span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/1&quot; id=&quot;link1&quot;&gt;链接1&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找直接子标签</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&quot;head &gt; title&quot;</span>))　 <span class="comment"># [&lt;title&gt;标题&lt;/title&gt;]</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&quot;p &gt; #link1&quot;</span>))　　 <span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/1&quot; id=&quot;link1&quot;&gt;链接1&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&quot;p &gt; a:nth-of-type(2)&quot;</span>))　　<span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/2&quot; id=&quot;link2&quot;&gt;链接2&lt;/a&gt;]</span></span><br><span class="line"><span class="comment"># nth-of-type 是CSS选择器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找兄弟节点（向后查找）</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&quot;#link1 ~ .sister&quot;</span>))</span><br><span class="line"><span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/2&quot; id=&quot;link2&quot;&gt;链接2&lt;/a&gt;,</span></span><br><span class="line"><span class="comment"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/3&quot; id=&quot;link3&quot;&gt;链接3&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&quot;#link1 + .sister&quot;</span>))</span><br><span class="line"><span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/2&quot; id=&quot;link2&quot;&gt;链接2&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过属性查找</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;a[href=&quot;http://example.com/1&quot;]&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ^ 以XX开头</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;a[href^=&quot;http://example.com/&quot;]&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># * 包含</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;a[href*=&quot;.com/&quot;]&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找包含指定属性的标签</span></span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;[name]&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找第一个元素</span></span><br><span class="line"><span class="built_in">print</span>(soup.select_one(<span class="string">&quot;.sister&quot;</span>))</span><br></pre></td></tr></table></figure>

</a></p></a></p>]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>线程和进程</title>
    <url>/08%20selenium%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>selenium本身是一个自动化测试工具，缺点是慢，优点是获取动态请求的数据比较容易。</p>
<span id="more"></span>

<h3 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h3><p>安装<code>selenium</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>



<p>下载浏览器驱动：（chrome浏览器）<a href="https://npm.taobao.org/mirrors/chromedriver">ChromeDriver Mirror (taobao.org)</a></p>
<p>如果是其他浏览器，则下载对应的驱动</p>
<p>1、查看浏览器内核版本</p>
<p>![image-20220119114803419](08 selenium模块/image-20220119114803419.png)</p>
<p>2、查看网站对应的版本，如果没有刚好对应的，向前查找最近的版本</p>
<p>![image-20220119115053658](08 selenium模块/image-20220119115053658.png)</p>
<p>3、下载操作系统对应的压缩包</p>
<p>![image-20220119115001266](08 selenium模块/image-20220119115001266.png)4、解压后将 <code>chromedriver.exe</code> 文件放在已添加到环境变量的路径下，比如<code>python</code>环境所在的文件夹</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>selenium引入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.创建浏览器对象</span></span><br><span class="line">web = Chrome()</span><br><span class="line"><span class="comment"># 2.打开一个网址</span></span><br><span class="line">web.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(web.title)  <span class="comment"># 输出：百度一下，你就知道</span></span><br><span class="line"><span class="comment"># 关闭浏览器</span></span><br><span class="line">web.close() <span class="comment"># 或 web.quit() </span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">bro = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">bro.get(<span class="string">&#x27;https://www.taobao.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标签定位</span></span><br><span class="line">search_input = bro.find_element_by_id(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line"><span class="comment"># 标签交互</span></span><br><span class="line">search_input.send_keys(<span class="string">&#x27;Iphone&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一组js程序</span></span><br><span class="line">bro.execute_script(<span class="string">&#x27;window.scrollTo(0, document.body.scrollHeight)&#x27;</span>)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 点击搜索按钮</span></span><br><span class="line">btn = bro.find_element_by_css_selector(<span class="string">&#x27;.btn-search&#x27;</span>)</span><br><span class="line">btn.click()</span><br><span class="line">bro.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 回退</span></span><br><span class="line">bro.back()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 前进</span></span><br><span class="line">bro.forward()</span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line">bro.quit()</span><br></pre></td></tr></table></figure>



<p>selenium的定位元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">web = Chrome()</span><br><span class="line"></span><br><span class="line">web.get(<span class="string">&quot;http://lagou.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到某个元素. 点击它</span></span><br><span class="line">el = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;changeCityBox&quot;]/ul/li[1]/a&#x27;</span>)</span><br><span class="line">el.click()  <span class="comment"># 点击事件</span></span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)  <span class="comment"># 让浏览器缓一会儿</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到输入框. 输入python  =&gt;  输入回车/点击搜索按钮</span></span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;search_input&quot;]&#x27;</span>).send_keys(<span class="string">&quot;python&quot;</span>, Keys.ENTER)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找存放数据的位置. 进行数据提取</span></span><br><span class="line"><span class="comment"># 找到页面中存放数据的所有的li</span></span><br><span class="line">li_list = web.find_elements_by_xpath(<span class="string">&#x27;//*[@id=&quot;s_position_list&quot;]/ul/li&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">    job_name = li.find_element_by_tag_name(<span class="string">&quot;h3&quot;</span>).text</span><br><span class="line">    job_price = li.find_element_by_xpath(<span class="string">&quot;./div/div/div[2]/div/span&quot;</span>).text</span><br><span class="line">    company_name = li.find_element_by_xpath(<span class="string">&#x27;./div/div[2]/div/a&#x27;</span>).text</span><br><span class="line">    <span class="built_in">print</span>(company_name, job_name, job_price)</span><br></pre></td></tr></table></figure>



<p>动作链和处理iframe</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="comment"># 导入动作链对应的类</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">bro = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">bro.get(<span class="string">&#x27;https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果定位的标签是存在于iframe标签之中的则必须通过如下操作在进行标签定位</span></span><br><span class="line">iframe = bro.find_element_by_id(<span class="string">&quot;iframeResult&quot;</span>)</span><br><span class="line">bro.switch_to.frame(iframe)  <span class="comment"># 切换浏览器标签定位的作用域</span></span><br><span class="line">div = bro.find_element_by_id(<span class="string">&#x27;draggable&#x27;</span>)  <span class="comment"># 定位元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动作链</span></span><br><span class="line">action = ActionChains(bro)</span><br><span class="line"><span class="comment"># 点击长按指定的标签</span></span><br><span class="line">action.click_and_hold(div)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    <span class="comment"># perform()立即执行动作链操作</span></span><br><span class="line">    <span class="comment"># move_by_offset(x,y):x水平方向 y竖直方向</span></span><br><span class="line">    action.move_by_offset(<span class="number">20</span>, <span class="number">0</span>).perform()</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放动作链</span></span><br><span class="line">action.release()</span><br><span class="line">bro.switch_to.default_content()  <span class="comment"># 切换回原页面</span></span><br><span class="line">bro.find_element_by_xpath(<span class="string">&quot;/html/body/header/div/div[2]/form/input&quot;</span>).send_keys(<span class="string">&quot;python&quot;</span>)</span><br><span class="line">bro.quit()</span><br></pre></td></tr></table></figure>



<p>窗口间切换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">web = Chrome()</span><br><span class="line"></span><br><span class="line">web.get(<span class="string">&quot;http://lagou.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;cboxClose&quot;]&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;search_input&quot;]&#x27;</span>).send_keys(</span><br><span class="line">    <span class="string">&quot;python&quot;</span>, Keys.ENTER)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">web.find_element_by_xpath(</span><br><span class="line">    <span class="string">&#x27;//*[@id=&quot;jobList&quot;]/div[1]/div[1]/div[1]/div[1]/div[1]/a&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如何进入到进窗口中进行提取</span></span><br><span class="line"><span class="comment"># 注意, 在selenium的眼中. 新窗口默认是不切换过来的.</span></span><br><span class="line">web.switch_to.window(web.window_handles[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在新窗口中提取内容</span></span><br><span class="line">job_detail = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;job_detail&quot;]/dd[2]/div&#x27;</span>).text</span><br><span class="line"><span class="built_in">print</span>(job_detail)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关掉子窗口</span></span><br><span class="line">web.close()</span><br><span class="line"><span class="comment"># 变更selenium的窗口视角. 回到原来的窗口中</span></span><br><span class="line">web.switch_to.window(web.window_handles[<span class="number">0</span>])</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    web.find_element_by_xpath(</span><br><span class="line">        <span class="string">&#x27;//*[@id=&quot;jobList&quot;]/div[1]/div[1]/div[1]/div[1]/div[1]/a&#x27;</span>).text)</span><br></pre></td></tr></table></figure>



<p>无头浏览器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">opt = Options()</span><br><span class="line">opt.add_argument(<span class="string">&quot;--headless&quot;</span>)</span><br><span class="line">opt.add_argument(<span class="string">&quot;--disbale-gpu&quot;</span>)</span><br><span class="line"></span><br><span class="line">web = Chrome(options=opt)  <span class="comment"># 把参数配置设置到浏览器中</span></span><br><span class="line">web.get(<span class="string">&quot;https://www.endata.com.cn/BoxOffice/BO/Year/index.html&quot;</span>)</span><br><span class="line">sleep(<span class="number">1</span>) <span class="comment"># 等待一秒</span></span><br><span class="line"><span class="built_in">print</span>(web.page_source) <span class="comment"># 拿到页面代码Elements(经过数据加载以及js执行之后的结果的html内容)</span></span><br></pre></td></tr></table></figure>



<p>规避检测</p>
<p>浏览器抓包工具的控制台，输入<code>window.navigator.webdriver</code>，正常浏览器显示<code>false</code>，自动化打开的浏览器显示<code>true</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line">option = Options()</span><br><span class="line"><span class="comment"># option.add_experimental_option(&#x27;excludeSwitches&#x27;, [&#x27;enable-automation&#x27;]) # 这个</span></span><br><span class="line">option.add_argument(<span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>)  <span class="comment"># 或者这个，二选一</span></span><br><span class="line"></span><br><span class="line">web = Chrome(options=option)</span><br></pre></td></tr></table></figure>



<p>注意：</p>
<p>1、谷歌浏览器装在D盘，程序报错没找到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line"><span class="comment"># 谷歌浏览器不是默认装在C盘，需加上这几行</span></span><br><span class="line">option = Options()</span><br><span class="line">option.binary_location=<span class="string">r&#x27;D:\Program Files\Google\Chrome\Application\chrome.exe&#x27;</span></span><br><span class="line"><span class="comment"># 创建一个浏览器对象</span></span><br><span class="line">driver = Chrome(options=option)</span><br></pre></td></tr></table></figure>

<p>2、浏览器加载需要时间，有时候浏览器没加载完成程序执行到下一步没找到元素会报错，可以加上 <code>sleep()</code>等几秒</p>
<p>3、浏览器最大化    <code>bro.maximize_window()</code></p>
<p>示例：模拟12306登录（已不适用）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> chaojiying <span class="keyword">import</span> Chaojiying_Client</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化超级鹰</span></span><br><span class="line">chaojiying = Chaojiying_Client(<span class="string">&#x27;18614075987&#x27;</span>, <span class="string">&#x27;6035945&#x27;</span>, <span class="string">&#x27;914467&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你的程序被识别到了怎么办?</span></span><br><span class="line"><span class="comment"># 1.chrome的版本号如果小于88  在你启动浏览器的时候(此时没有加载任何网页内容), 向页面嵌入js代码. 去掉webdriver</span></span><br><span class="line"><span class="comment"># web = Chrome()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># web.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, &#123;</span></span><br><span class="line"><span class="comment">#   &quot;source&quot;: &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#    navigator.webdriver = undefined</span></span><br><span class="line"><span class="comment">#     Object.defineProperty(navigator, &#x27;webdriver&#x27;, &#123;</span></span><br><span class="line"><span class="comment">#       get: () =&gt; undefined</span></span><br><span class="line"><span class="comment">#     &#125;)</span></span><br><span class="line"><span class="comment">#   &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># &#125;)</span></span><br><span class="line"><span class="comment"># web.get(xxxxxxx)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.chrome的版本大于等于88</span></span><br><span class="line">option = Options()</span><br><span class="line"><span class="comment"># option.add_experimental_option(&#x27;excludeSwitches&#x27;, [&#x27;enable-automation&#x27;])</span></span><br><span class="line">option.add_argument(<span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>)</span><br><span class="line"></span><br><span class="line">web = Chrome(options=option)</span><br><span class="line"></span><br><span class="line">web.get(<span class="string">&quot;https://kyfw.12306.cn/otn/resources/login.html&quot;</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;/html/body/div[2]/div[2]/ul/li[2]/a&#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先处理验证码</span></span><br><span class="line">verify_img_element = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;J-loginImg&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用超级鹰去识别验证码</span></span><br><span class="line">dic = chaojiying.PostPic(verify_img_element.screenshot_as_png, <span class="number">9004</span>)</span><br><span class="line">result = dic[<span class="string">&#x27;pic_str&#x27;</span>]  <span class="comment"># x1,y1|x2,y2|x3,y3</span></span><br><span class="line">rs_list = result.split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> rs <span class="keyword">in</span> rs_list:  <span class="comment"># x1,y1</span></span><br><span class="line">    p_temp = rs.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    x = <span class="built_in">int</span>(p_temp[<span class="number">0</span>])</span><br><span class="line">    y = <span class="built_in">int</span>(p_temp[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 要让鼠标移动到某一个位置. 然后进行点击</span></span><br><span class="line">    <span class="comment"># 醒了 -&gt; 掀开被子 -&gt; 坐起来 -&gt; 穿鞋子  -&gt; 穿衣服  -&gt; 开始执行动作</span></span><br><span class="line">    ActionChains(web).move_to_element_with_offset(verify_img_element, x, y).click().perform()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 输入用户名和密码</span></span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;J-userName&quot;]&#x27;</span>).send_keys(<span class="string">&quot;123456789&quot;</span>)</span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;J-password&quot;]&#x27;</span>).send_keys(<span class="string">&quot;12346789&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 点击登录</span></span><br><span class="line">web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;J-login&quot;]&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拖拽</span></span><br><span class="line">btn = web.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;nc_1_n1z&quot;]&#x27;</span>)</span><br><span class="line">ActionChains(web).drag_and_drop_by_offset(btn, <span class="number">300</span>, <span class="number">0</span>).perform()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="详细教程"><a href="#详细教程" class="headerlink" title="详细教程"></a>详细教程</h3><p><a href="http://www.selenium.org.cn/1598.html">轻松自动化—selenium-webdriver(python) (一) | selenium中文网</a></p>
<h4 id="Selenium提供了8种定位方式"><a href="#Selenium提供了8种定位方式" class="headerlink" title="Selenium提供了8种定位方式:"></a>Selenium提供了8种定位方式:</h4><ol>
<li>id</li>
<li>name</li>
<li>class name</li>
<li>tag name</li>
<li>link text</li>
<li>partial link text</li>
<li>xpath</li>
<li>css selector</li>
</ol>
<p>2.定位元素的8种方式</p>
<table>
<thead>
<tr>
<th><strong>定位一个元素</strong></th>
<th><strong>定位多个元素</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>find_element_by_id</td>
<td>find_elements_by_id</td>
<td>通过元素id定位</td>
</tr>
<tr>
<td>find_element_by_name</td>
<td>find_elements_by_name</td>
<td>通过元素name定位</td>
</tr>
<tr>
<td>find_element_by_xpath</td>
<td>find_elements_by_xpath</td>
<td>通过xpath表达式定位</td>
</tr>
<tr>
<td>find_element_by_link_text</td>
<td>find_elements_by_link_tex</td>
<td>通过完整超链接定位</td>
</tr>
<tr>
<td>find_element_by_partial_link_text</td>
<td>find_elements_by_partial_link_text</td>
<td>通过部分链接定位</td>
</tr>
<tr>
<td>find_element_by_tag_name</td>
<td>find_elements_by_tag_name</td>
<td>通过标签定位</td>
</tr>
<tr>
<td>find_element_by_class_name</td>
<td>find_elements_by_class_name</td>
<td>通过类名进行定位</td>
</tr>
<tr>
<td>find_elements_by_css_selector</td>
<td>find_elements_by_css_selector</td>
<td>通过css选择器进行定位</td>
</tr>
</tbody></table>
<p>3.实例演示</p>
<p>假如我们有一个Web页面，通过前端工具（如，Firebug）查看到一个元素的属性是这样的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">link</span>=<span class="string">&quot;#0000cc&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;result_logo&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span> <span class="attr">onmousedown</span>=<span class="string">&quot;return c(&#123;&#x27;fm&#x27;:&#x27;tab&#x27;,&#x27;tab&#x27;:&#x27;logo&#x27;&#125;)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fm&quot;</span> <span class="attr">name</span>=<span class="string">&quot;f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/s&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;soutu-btn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;kw&quot;</span> <span class="attr">class</span>=<span class="string">&quot;s_ipt&quot;</span> <span class="attr">name</span>=<span class="string">&quot;wd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;255&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>通过id定位:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_id(<span class="string">&quot;kw&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过name定位:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_name(<span class="string">&quot;wd&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过class name定位:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_class_name(<span class="string">&quot;s_ipt&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过tag name定位:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_tag_name(<span class="string">&quot;input&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过xpath定位，xpath定位有N种写法，这里列几个常用写法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//*[@id=&#x27;kw&#x27;]&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//*[@name=&#x27;wd&#x27;]&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//input[@class=&#x27;s_ipt&#x27;]&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;/html/body/form/span/input&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//span[@class=&#x27;soutu-btn&#x27;]/input&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//form[@id=&#x27;form&#x27;]/span/input&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//input[@id=&#x27;kw&#x27; and @name=&#x27;wd&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过css定位，css定位有N种写法，这里列几个常用写法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;#kw&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;[name=wd]&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;.s_ipt&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;html &gt; body &gt; form &gt; span &gt; input&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;span.soutu-btn&gt; input#kw&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;form#form &gt; span &gt; input&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>接下来，我们的页面上有一组文本链接。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;mnav&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://news.baidu.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tj_trnews&quot;</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;mnav&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://www.hao123.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tj_trhao123&quot;</span>&gt;</span>hao123<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过link text定位:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_link_text(<span class="string">&quot;新闻&quot;</span>)</span><br><span class="line">dr.find_element_by_link_text(<span class="string">&quot;hao123&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过partial link text定位:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_partial_link_text(<span class="string">&quot;新&quot;</span>)</span><br><span class="line">dr.find_element_by_partial_link_text(<span class="string">&quot;hao&quot;</span>)</span><br><span class="line">dr.find_element_by_partial_link_text(<span class="string">&quot;123&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Selenium-webdriver模块"><a href="#Selenium-webdriver模块" class="headerlink" title="Selenium.webdriver模块"></a>Selenium.webdriver模块</h4><h5 id="1-控制浏览器操作的一些方法"><a href="#1-控制浏览器操作的一些方法" class="headerlink" title="1.控制浏览器操作的一些方法"></a>1.控制浏览器操作的一些方法</h5><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>set_window_size()</td>
<td>设置浏览器的大小</td>
</tr>
<tr>
<td>back()</td>
<td>控制浏览器后退</td>
</tr>
<tr>
<td>forward()</td>
<td>控制浏览器前进</td>
</tr>
<tr>
<td>refresh()</td>
<td>刷新当前页面</td>
</tr>
<tr>
<td>clear()</td>
<td>清除文本</td>
</tr>
<tr>
<td>send_keys (value)</td>
<td>模拟按键输入</td>
</tr>
<tr>
<td>click()</td>
<td>单击元素</td>
</tr>
<tr>
<td>submit()</td>
<td>用于提交表单</td>
</tr>
<tr>
<td>get_attribute(name)</td>
<td>获取元素属性值</td>
</tr>
<tr>
<td>is_displayed()</td>
<td>设置该元素是否用户可见</td>
</tr>
<tr>
<td>size</td>
<td>返回元素的尺寸</td>
</tr>
<tr>
<td>text</td>
<td>获取元素的文本</td>
</tr>
</tbody></table>
<h5 id="2-鼠标事件"><a href="#2-鼠标事件" class="headerlink" title="2.鼠标事件"></a>2.鼠标事件</h5><p>在 WebDriver 中， 将这些关于鼠标操作的方法封装在 ActionChains 类提供。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ActionChains(driver)</td>
<td>构造ActionChains对象</td>
</tr>
<tr>
<td>context_click()</td>
<td>执行鼠标悬停操作</td>
</tr>
<tr>
<td>move_to_element(above)</td>
<td>右击</td>
</tr>
<tr>
<td>double_click()</td>
<td>双击</td>
</tr>
<tr>
<td>drag_and_drop()</td>
<td>拖动</td>
</tr>
<tr>
<td>move_to_element(above)</td>
<td>执行鼠标悬停操作</td>
</tr>
<tr>
<td>context_click()</td>
<td>用于模拟鼠标右键操作， 在调用时需要指定元素定位</td>
</tr>
<tr>
<td>perform()</td>
<td>执行所有 ActionChains 中存储的行为，可以理解成是对整个操作的提交动作</td>
</tr>
</tbody></table>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment">#1.引入 ActionChains 类</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建Chrome浏览器对象，这会在电脑上在打开一个浏览器窗口</span></span><br><span class="line">driver = webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.定位到要悬停的元素</span></span><br><span class="line">element= driver.find_element_by_link_text(<span class="string">&quot;设置&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.对定位到的元素执行鼠标悬停操作</span></span><br><span class="line">ActionChains(driver).move_to_element(element).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment">#找到链接</span></span><br><span class="line">elem1=driver.find_element_by_link_text(<span class="string">&quot;搜索设置&quot;</span>)</span><br><span class="line">elem1.click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过元素选择器找到id=sh_2,并点击设置</span></span><br><span class="line">elem2=driver.find_element_by_id(<span class="string">&quot;sh_1&quot;</span>)</span><br><span class="line">elem2.click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存设置</span></span><br><span class="line">elem3=driver.find_element_by_class_name(<span class="string">&quot;prefpanelgo&quot;</span>)</span><br><span class="line">elem3.click()</span><br></pre></td></tr></table></figure>

<h5 id="3-键盘事件"><a href="#3-键盘事件" class="headerlink" title="3.键盘事件"></a>3.键盘事件</h5><p>Selenium中的Key模块为我们提供了模拟键盘按键的方法，那就是send_keys()方法。它不仅可以模拟键盘输入，也可以模拟键盘的操作。</p>
<p>常用的键盘操作如下：</p>
<table>
<thead>
<tr>
<th><strong>模拟键盘按键</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>send_keys(Keys.BACK_SPACE)</td>
<td>删除键（BackSpace）</td>
</tr>
<tr>
<td>send_keys(Keys.SPACE)</td>
<td>空格键(Space)</td>
</tr>
<tr>
<td>send_keys(Keys.TAB)</td>
<td>制表键(Tab)</td>
</tr>
<tr>
<td>send_keys(Keys.ESCAPE)</td>
<td>回退键（Esc）</td>
</tr>
<tr>
<td>send_keys(Keys.ENTER)</td>
<td>回车键（Enter）</td>
</tr>
</tbody></table>
<p>组合键的使用</p>
<table>
<thead>
<tr>
<th><strong>模拟键盘按键</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>send_keys(Keys.CONTROL,‘a’)</td>
<td>全选（Ctrl+A）</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘c’)</td>
<td>复制（Ctrl+C）</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘x’)</td>
<td>剪切（Ctrl+X）</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘v’)</td>
<td>粘贴（Ctrl+V）</td>
</tr>
<tr>
<td>send_keys(Keys.F1…Fn)</td>
<td>键盘 F1…Fn</td>
</tr>
</tbody></table>
<h5 id="4-获取断言信息"><a href="#4-获取断言信息" class="headerlink" title="4.获取断言信息"></a>4.获取断言信息</h5><p>不管是在做功能测试还是自动化测试，最后一步需要拿实际结果与预期进行比较。这个比较的称之为断言。通过我们获取title 、URL和text等信息进行断言。</p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>用于获得当前页面的标题</td>
</tr>
<tr>
<td>current_url</td>
<td>用户获得当前页面的URL</td>
</tr>
<tr>
<td>text</td>
<td>获取搜索条目的文本信息</td>
</tr>
</tbody></table>
<h5 id="5-设置元素等待"><a href="#5-设置元素等待" class="headerlink" title="5.设置元素等待"></a>5.设置元素等待</h5><h5 id="6-定位一组元素"><a href="#6-定位一组元素" class="headerlink" title="6.定位一组元素"></a>6.定位一组元素</h5><p>定位一组元素的方法与定位单个元素的方法类似，唯一的区别是在单词element后面多了一个s表示复数。</p>
<h5 id="7-多表单切换"><a href="#7-多表单切换" class="headerlink" title="7.多表单切换"></a>7.多表单切换</h5><p>在Web应用中经常会遇到frame/iframe表单嵌套页面的应用，WebDriver只能在一个页面上对元素识别与定位，对于frame/iframe表单内嵌页面上的元素无法直接定位。这时就需要通过switch_to.frame()方法将当前定位的主体切换为frame/iframe表单的内嵌页面中。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>switch_to.frame()</td>
<td>将当前定位的主体切换为frame/iframe表单的内嵌页面中</td>
</tr>
<tr>
<td>switch_to.default_content()</td>
<td>跳回最外层的页面</td>
</tr>
</tbody></table>
<p>switch_to.frame() 默认可以直接取表单的id 或name属性。如果iframe没有可用的id和name属性，则可以通过下面的方式进行定位。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="comment">#先通过xpth定位到iframe</span></span><br><span class="line">xf = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;x-URS-iframe&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#再将定位对象传给switch_to.frame()方法</span></span><br><span class="line">driver.switch_to.frame(xf)</span><br><span class="line">……</span><br><span class="line">driver.switch_to.parent_frame()</span><br></pre></td></tr></table></figure>

<h5 id="8-多窗口切换"><a href="#8-多窗口切换" class="headerlink" title="8.多窗口切换"></a>8.多窗口切换</h5><p>在页面操作过程中有时候点击某个链接会弹出新的窗口，这时就需要主机切换到新打开的窗口上进行操作。WebDriver提供了switch_to.window()方法，可以实现在不同的窗口之间切换。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>current_window_handle</td>
<td>获得当前窗口句柄</td>
</tr>
<tr>
<td>window_handles</td>
<td>返回所有窗口的句柄到当前会话</td>
</tr>
<tr>
<td>switch_to.window()</td>
<td>用于切换到相应的窗口，与上一节的switch_to.frame()类似，前者用于不同窗口的切换，后者用于不同表单之间的切换。</td>
</tr>
</tbody></table>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.获得百度搜索窗口句柄</span></span><br><span class="line">sreach_windows = driver.current_window_handle</span><br><span class="line"></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&#x27;登录&#x27;</span>).click()</span><br><span class="line">driver.find_element_by_link_text(<span class="string">&quot;立即注册&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.获得当前所有打开的窗口的句柄</span></span><br><span class="line">all_handles = driver.window_handles</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.进入注册窗口</span></span><br><span class="line"><span class="keyword">for</span> handle <span class="keyword">in</span> all_handles:</span><br><span class="line">    <span class="keyword">if</span> handle != sreach_windows:</span><br><span class="line">        driver.switch_to.window(handle)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;跳转到注册窗口&#x27;</span>)</span><br><span class="line">        driver.find_element_by_name(<span class="string">&quot;account&quot;</span>).send_keys(<span class="string">&#x27;123456789&#x27;</span>)</span><br><span class="line">        driver.find_element_by_name(<span class="string">&#x27;password&#x27;</span>).send_keys(<span class="string">&#x27;123456789&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h5 id="9-警告框处理"><a href="#9-警告框处理" class="headerlink" title="9.警告框处理"></a>9.警告框处理</h5><p>在WebDriver中处理JavaScript所生成的alert、confirm以及prompt十分简单，具体做法是使用 switch_to.alert 方法定位到 alert/confirm/prompt，然后使用text/accept/dismiss/ send_keys等方法进行操作。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>返回 alert/confirm/prompt 中的文字信息</td>
</tr>
<tr>
<td>accept()</td>
<td>接受现有警告框</td>
</tr>
<tr>
<td>dismiss()</td>
<td>解散现有警告框</td>
</tr>
<tr>
<td>send_keys(keysToSend)</td>
<td>发送文本至警告框。keysToSend：将文本发送至警告框。</td>
</tr>
</tbody></table>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 鼠标悬停至“设置”链接</span></span><br><span class="line">link = driver.find_element_by_link_text(<span class="string">&#x27;设置&#x27;</span>)</span><br><span class="line">ActionChains(driver).move_to_element(link).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开搜索设置</span></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&quot;搜索设置&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#在此处设置等待2s否则可能报错</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 保存设置</span></span><br><span class="line">driver.find_element_by_class_name(<span class="string">&quot;prefpanelgo&quot;</span>).click()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受警告框</span></span><br><span class="line">driver.switch_to.alert.accept()</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h5 id="10-下拉框选择操作"><a href="#10-下拉框选择操作" class="headerlink" title="10.下拉框选择操作"></a>10.下拉框选择操作</h5><p>导入选择下拉框Select类，使用该类处理下拉框操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br></pre></td></tr></table></figure>

<p>Select类的方法</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>select_by_value(“选择值”)</td>
<td>select标签的value属性的值</td>
</tr>
<tr>
<td>select_by_index(“索引值”)</td>
<td>下拉框的索引</td>
</tr>
<tr>
<td>select_by_visible_testx(“文本值”)</td>
<td>下拉框的文本值</td>
</tr>
</tbody></table>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.鼠标悬停至“设置”链接</span></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&#x27;设置&#x27;</span>).click()</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#2.打开搜索设置</span></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&quot;搜索设置&quot;</span>).click()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.搜索结果显示条数</span></span><br><span class="line">sel = driver.find_element_by_xpath(<span class="string">&quot;//select[@id=&#x27;nr&#x27;]&quot;</span>)</span><br><span class="line">Select(sel).select_by_value(<span class="string">&#x27;50&#x27;</span>)  <span class="comment"># 显示50条</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h5 id="11-文件上传"><a href="#11-文件上传" class="headerlink" title="11.文件上传"></a>11.文件上传</h5><p>对于通过input标签实现的上传功能，可以将其看作是一个输入框，即通过send_keys()指定本地文件路径的方式实现文件上传。</p>
<p>通过send_keys()方法来实现文件上传:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">file_path = <span class="string">&#x27;file:///&#x27;</span> + os.path.abspath(<span class="string">&#x27;upfile.html&#x27;</span>)</span><br><span class="line">driver.get(file_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定位上传按钮，添加本地文件</span></span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;file&quot;</span>).send_keys(<span class="string">&#x27;D:\\upload_file.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h5 id="12-cookie操作"><a href="#12-cookie操作" class="headerlink" title="12.cookie操作"></a>12.cookie操作</h5><p>有时候我们需要验证浏览器中cookie是否正确，因为基于真实cookie的测试是无法通过白盒和集成测试进行的。WebDriver提供了操作Cookie的相关方法，可以读取、添加和删除cookie信息。</p>
<p>WebDriver操作cookie的方法:</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>get_cookies()</td>
<td>获得所有cookie信息</td>
</tr>
<tr>
<td>get_cookie(name)</td>
<td>返回字典的key为“name”的cookie信息</td>
</tr>
<tr>
<td>add_cookie(cookie_dict)</td>
<td>添加cookie。“cookie_dict”指字典对象，必须有name 和value 值</td>
</tr>
<tr>
<td>delete_cookie(name,optionsString)</td>
<td>删除cookie信息。“name”是要删除的cookie的名称，“optionsString”是该cookie的选项，目前支持的选项包括“路径”，“域”</td>
</tr>
<tr>
<td>delete_all_cookies()</td>
<td>删除所有cookie信息</td>
</tr>
</tbody></table>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">browser = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">browser.get(<span class="string">&quot;http://www.youdao.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.打印cookie信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打印cookie信息为：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.添加cookie信息</span></span><br><span class="line"><span class="built_in">dict</span>=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&quot;name&quot;</span>,<span class="string">&#x27;value&#x27;</span>:<span class="string">&#x27;Kaina&#x27;</span>&#125;</span><br><span class="line">browser.add_cookie(<span class="built_in">dict</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;添加cookie信息为：&#x27;</span>)</span><br><span class="line"><span class="comment">#3.遍历打印cookie信息</span></span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> browser.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s----%s\n&#x27;</span> %(cookie[<span class="string">&#x27;name&#x27;</span>],cookie[<span class="string">&#x27;value&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#4.删除一个cookie</span></span><br><span class="line">browser.delete_cookie(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;删除一个cookie&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> browser.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s----%s\n&#x27;</span> %(cookie[<span class="string">&#x27;name&#x27;</span>],cookie[<span class="string">&#x27;value&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;删除所有cookie后：&#x27;</span>)</span><br><span class="line"><span class="comment">#5.删除所有cookie,无需传递参数</span></span><br><span class="line">browser.delete_all_cookies()</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> browser.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s----%s\n&#x27;</span> %(cookie[<span class="string">&#x27;name&#x27;</span>],cookie[<span class="string">&#x27;value&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<h5 id="13-调用JavaScript代码"><a href="#13-调用JavaScript代码" class="headerlink" title="13.调用JavaScript代码"></a>13.调用JavaScript代码</h5><p>虽然WebDriver提供了操作浏览器的前进和后退方法，但对于浏览器滚动条并没有提供相应的操作方法。在这种情况下，就可以借助JavaScript来控制浏览器的滚动条。WebDriver提供了execute_script()方法来执行JavaScript代码。</p>
<p>用于调整浏览器滚动条位置的JavaScript代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="built_in">window</span>.scrollTo(左边距,上边距); --&gt;</span><br><span class="line"><span class="built_in">window</span>.scrollTo(<span class="number">0</span>,<span class="number">450</span>);</span><br></pre></td></tr></table></figure>

<p>window.scrollTo()方法用于设置浏览器窗口滚动条的水平和垂直位置。方法的第一个参数表示水平的左间距，第二个参数表示垂直的上边距。其代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.访问百度</span></span><br><span class="line">driver=webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.搜索</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;kw&quot;</span>).send_keys(<span class="string">&quot;selenium&quot;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;su&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.休眠2s目的是获得服务器的响应内容，如果不使用休眠可能报错</span></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.通过javascript设置浏览器窗口的滚动条位置</span></span><br><span class="line">js=<span class="string">&quot;window.scrollTo(100,450);&quot;</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>

<p>通过浏览器打开百度进行搜索，并且提前通过set_window_size()方法将浏览器窗口设置为固定宽高显示，目的是让窗口出现水平和垂直滚动条。然后通过execute_script()方法执行JavaScripts代码来移动滚动条的位置。</p>
<p>滚动条上下左右滚动代码演示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver=webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.set_window_size(<span class="number">400</span>,<span class="number">400</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.搜索</span></span><br><span class="line"><span class="comment"># driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)</span></span><br><span class="line"><span class="comment"># driver.find_element_by_id(&quot;su&quot;).click()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.休眠2s目的是获得服务器的响应内容，如果不使用休眠可能报错</span></span><br><span class="line">sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#4 滚动左右滚动条---向右</span></span><br><span class="line">js2 = <span class="string">&quot;var q=document.documentElement.scrollLeft=10000&quot;</span></span><br><span class="line">driver.execute_script(js2)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5 滚动左右滚动条---向左</span></span><br><span class="line">js3 = <span class="string">&quot;var q=document.documentElement.scrollLeft=0&quot;</span></span><br><span class="line">driver.execute_script(js3)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#6 拖动到滚动条底部---向下</span></span><br><span class="line">js = <span class="string">&quot;var q=document.documentElement.scrollTop=10000&quot;</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#7 拖动到滚动条底部---向上</span></span><br><span class="line">js = <span class="string">&quot;var q=document.documentElement.scrollTop=0&quot;</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>

<h5 id="14-窗口截图"><a href="#14-窗口截图" class="headerlink" title="14.窗口截图"></a>14.窗口截图</h5><p>自动化用例是由程序去执行的，因此有时候打印的错误信息并不十分明确。如果在脚本执行出错的时候能对当前窗口截图保存，那么通过图片就可以非常直观地看出出错的原因。WebDriver提供了截图函数get_screenshot_as_file()来截取当前窗口。</p>
<p>截屏方法：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>get_screenshot_as_file(self, filename)</td>
<td>用于截取当前窗口，并把图片保存到本地</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver =webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>).send_keys(<span class="string">&#x27;selenium&#x27;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;su&#x27;</span>).click()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.截取当前窗口，并指定截图图片的保存位置</span></span><br><span class="line">driver.get_screenshot_as_file(<span class="string">&quot;D:\\baidu_img.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<p>15.关闭浏览器</p>
<p>在前面的例子中我们一直使用quit()方法，其含义为退出相关的驱动程序和关闭所有窗口。除此之外，WebDriver还提供了close()方法，用来关闭当前窗口。例多窗口的处理，在用例执行的过程中打开了多个窗口，我们想要关闭其中的某个窗口，这时就要用到close()方法进行关闭了。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>close()</td>
<td>关闭单个窗口</td>
</tr>
<tr>
<td>quit()</td>
<td>关闭所有窗口</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能数学概览</title>
    <url>/AI%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>AI基础学习，学习自华为iLearnX网站</p>
<span id="more"></span>

<h2 id="数学与人工智能概览"><a href="#数学与人工智能概览" class="headerlink" title="数学与人工智能概览"></a>数学与人工智能概览</h2><pre><code>线性代数：描述深度学习算法的基础也是核心。它通过矩阵表示法来实现深度学习方法。待处理的非结构化数据转都换成离散的矩阵或向量形式。比如一张图像可以表示为按顺序排列的像素数组形式，声音数据可以表示为向量形式、神经网络就是无数的矩阵运算和非线性变换的结合。

概率论与统计学：研究数据分布与如何处理数据。深度学习算法所做的绝大多数事情就是预测，预测源于不确定性，而概率论与统计就是讨论不确定性的学科

微积分：数学分析的基础
</code></pre>
<hr>
<h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><p>线性代数与人工智能</p>
<ul>
<li>神经网络中的所有参数都被存储在矩阵中；线性代数使矩阵运算变得更加快捷简便，尤其是在GPU上训练模型时，因为GPU可以并行地以向量和矩阵运算</li>
<li>图像在计算中被表示为按序排列的像素数组</li>
<li>视游戏使用庞大的矩阵来产生令人炫目的游戏体验</li>
</ul>
<hr>
<h3 id="矩阵的概念及矩阵运算"><a href="#矩阵的概念及矩阵运算" class="headerlink" title="矩阵的概念及矩阵运算"></a>矩阵的概念及矩阵运算</h3><ul>
<li><p>标量（Scalar)：一个数，如：x=3</p>
</li>
<li><p>向量（Vector)：有序排列的列数，如：</p>
</li>
</ul>
<p>$$<br>\left[<br>\begin{matrix}<br>x_1\<br>x_2\<br>x_3\<br>.\<br>.\<br>x_n<br>\end{matrix}<br>\right]<br>$$</p>
<ul>
<li>矩阵（Matirx)：由 $m \times n$ 个数排成 m 行 n 列的数表，行列数一样的称为方阵。</li>
</ul>
<p>表示方式有：$A_{m\times n}$ 或 $A=(a_{ij})_{m\times n}$</p>
<p>$$<br>\left[<br>\begin{matrix}<br>x_{11} &amp; x_{12} &amp; x_{13} &amp;…&amp; x_{1n}\<br>x_{21} &amp; x_{22} &amp; x_{23} &amp;…&amp; x_{2n}\<br>x_{31} &amp; x_{32} &amp; x_{33} &amp;…&amp; x_{3n}\<br>. &amp; . &amp; . &amp; … &amp; .\<br>. &amp; . &amp; . &amp; … &amp; .\<br>x_{m1} &amp; x_{m2} &amp; x_{m3} &amp;…&amp; x_{mn}\<br>\end{matrix}<br>\right]<br>$$</p>
<p><code>张量(Tensor)</code>是深度学习中的一个重要概念，是 Tensorflow、 Pytorchs等很多深度学习框架重要组成部分。深度学习中的很多运算与模型优化过程都是基于tensor完成。</p>
<p>张量定义：一个多维数组</p>
<p>零阶张量：标量；一阶张量：向量；二阶张量：矩阵</p>
<h4 id="矩阵加法"><a href="#矩阵加法" class="headerlink" title="矩阵加法"></a>矩阵加法</h4><p>行、列数相同的矩阵对应元素($c_{ij}=a_{ij}+b_{ij}$)相加，$A_{m\times n}+B_{m\times n}$ 等到新的矩阵 ${C_{m\times n}}$</p>
<h4 id="标量和矩阵乘法"><a href="#标量和矩阵乘法" class="headerlink" title="标量和矩阵乘法"></a>标量和矩阵乘法</h4><p>$k\cdot A_{m\times n}=(ka_{ij})_{m\times n}$</p>
<h4 id="矩阵乘法："><a href="#矩阵乘法：" class="headerlink" title="矩阵乘法："></a>矩阵乘法：</h4><p>$A=(a_{ij})<em>{m\times n}$  &ensp;  $B=(b</em>{ij})_{n\times p}$</p>
<p>$C=AB=(c_{ij})_{m\times p}$</p>
<p>$c_{ij}=a_{i}b_{j}=\sum\limits_{k\in [1,m]}a_{ik}b_{kj}$</p>
<p>注：A的列数和B的行数必须相等</p>
<p><img src="/AI%E5%9F%BA%E7%A1%80/20211213153201.png"></p>
<h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>对向量的旋转，缩放，映射</p>
<ul>
<li>反射（镜像变换）</li>
<li>相似变换</li>
<li>旋转变换</li>
</ul>
<p>定义：设$V_n$ ，$U_m$分別是n维和m维的线性空间，T是一个从$V_n$到$U_m$的映射，如果映射满足：</p>
<p>(1)任一元素$\alpha_1$,$\alpha_2$∈$V_n$(从而$\alpha_1+\alpha_2\in V_n$),有</p>
<p>&ensp;&ensp;&ensp;$T(\alpha_1+\alpha_2)=T(\alpha_1)+T(\alpha_2)$</p>
<p>(2)任一元素$\alpha \in V_n$,$\lambda \in R$(从而$\lambda\alpha \in V_n$),有</p>
<p>&ensp;&ensp;&ensp;$T(\lambda\alpha)=\lambda T(\alpha)$</p>
<p>那么，T就称为从$V_n$到$U_m$的线性映射，或称为线性变换。</p>
<p>可以将线性代数看作是讨论空间变換与向量运动的科学，而空间变換与向量运动都是由线性变換实现的</p>
<p>线性变换的应用：线性变换在深度学习中最直观的应用为通过矩阵乘法对图像或语音数据集进行增强。如将图像沿着某个方向平移、对图像进行旋转或缩放等以产生新的图像</p>
<h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><ul>
<li><p>转置矩阵：把矩阵$A=(a_{ij})_{s\times n}$的行与列相互交换产生的矩阵称为A的转置，记作$A^T$或A’。<br><img src="/AI%E5%9F%BA%E7%A1%80/20211213160945.png"></p>
</li>
<li><p>单位矩阵：所有沿主对角线的元素都是1，而其他位置的所有元素都是0的矩阵。任意矩阵与单位矩阵相乘，都不会改变。</p>
<p>  <img src="/AI%E5%9F%BA%E7%A1%80/20211213161039.png"></p>
</li>
<li><p>逆矩阵：方阵A的逆矩阵记作$A^{-1}$，其满足$A^{-1}A=I_{n}$</p>
<ul>
<li>逆矩阵在深度学习中的应用：牛顿法优化神经网络。</li>
<li>在深度学习中，经常需要球逆矩阵，但是由于求逆矩阵的计算开销巨大，因此通常会将矩阵转换成其它特殊矩阵的形式以避免或简化矩阵求逆。</li>
</ul>
</li>
<li><p>正交矩阵：设n阶方阵$A=(a_{ij})_{n\times n}$满足$AA^{T}=A^{T}A=I_n$，则称A为正交矩阵，即$A^{-1}=A^T$</p>
<ul>
<li><p>正交矩阵的行向量之间与列向量之间都是两两正交（向量点积为0）的单位向量</p>
</li>
<li><p>n阶正交矩阵可以看作n为空间中任意互相垂直（正交）坐标基。</p>
</li>
<li><p>向量乘以一个正交矩阵：可以看作是对向量只进行旋转，而没有伸缩和空间映射作用</p>
</li>
<li><p>正交矩阵的应用：</p>
<ul>
<li>RNN中防止梯度消失和维度爆炸的方法：正交初始化。</li>
<li>对于正交矩阵，可以将求逆矩阵的过程转化为求矩阵转置，大大减小了计算量</li>
<li>矩阵分解</li>
</ul>
</li>
</ul>
</li>
<li><p>对角矩阵：主对角线之外的元素皆为0的矩阵。常写为$diag(\lambda_1,\lambda_2,…,\lambda_n)$，即<br><img src="/AI%E5%9F%BA%E7%A1%80/20211213163557.png"></p>
<ul>
<li><p>对角矩阵的和、差、积、方幂为主对角线上元素的和、差、积、方幂</p>
</li>
<li><p>对角矩阵的逆矩阵为：</p>
<p>  <img src="/AI%E5%9F%BA%E7%A1%80/20211213163840.png"></p>
</li>
<li><p>对对角矩阵进行乘法操作或逆矩阵求解（仅方阵）十分高效、计算量小。因此在机器学习中，我们将某些矩阵限制为对角矩阵以降低计算开销。</p>
</li>
</ul>
</li>
<li><p>对称矩阵：</p>
<ul>
<li><p>设方阵$A=(a_{ij})<em>{n\times n}$，满足$A^T=A$，即$a</em>{ij}=a_{ji}$，则称A为对称矩阵<br><img src="/AI%E5%9F%BA%E7%A1%80/20211213164018.png"></p>
</li>
<li><p>协方差矩阵，距离矩阵</p>
</li>
</ul>
</li>
<li><p>行列式</p>
<ul>
<li><p>行列式是一个将方阵映射到一个标量的函数，记作det(A)或|A|。行列式可以看作是矩阵有向面积或体积的推广。或者说是在n维欧几里得空间中，行列式描述了一个线性变换对“体积”所造成的影响。</p>
</li>
<li><p>行列式的意义</p>
<ul>
<li><p>行列式等于矩阵特征值的乘积。</p>
</li>
<li><p>行列式的绝对值可以用来衡量矩阵参与矩阵乘法后空间扩大或缩小了多少</p>
<ul>
<li>如正交矩阵的行列式大小都为1或-1。即用正交矩阵进行线性变换后的矩阵在空间中的有向面积或体积保持不变</li>
</ul>
</li>
<li><p>行列式的正负表示空间的定向。</p>
</li>
</ul>
</li>
<li><p>行列式的应用：求矩阵特征值，求解线性方程等</p>
</li>
</ul>
</li>
</ul>
<h3 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h3><h4 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h4><ul>
<li>定义：设A是数域$K$上的$n$阶方阵，如果K中有非零列向量$\alpha$使得$A\alpha=\lambda \alpha$,且$\lambda \in K$,则称$\lambda$是A的一个特征值，称<br>$\alpha$是A的属于特征值$\lambda$的一个特征向量。</li>
<li>一个矩阵对应着一种线性变换，通过矩阵乘法实现对向量的旋转、压缩和映射。如果矩阵作用于某一个向量或某些向量使这些向量只发生伸缩变换，而不产生旋转及投影的效果，那么这些向量就称为这个矩阵的特征向量，伸缩的比例就是特征值。</li>
</ul>
<p>特征值与特征向量的计算</p>
<ul>
<li><p>怎样求矩阵A的特征值与特征向量：$$A\alpha=\lambda \alpha \ \Leftrightarrow A\alpha-\lambda\alpha=0 \ \Leftrightarrow(A-\lambda I)\alpha=0 \ \stackrel{\alpha \neq 0}{\Leftrightarrow} |A-\lambda I|=0 $$ $$ \Leftrightarrow \left[ \begin{matrix}<br>a_{11}-\lambda &amp; a_{12} &amp; \cdots &amp; a_{1n} \  a_{21} &amp; a_{22}-\lambda &amp; \cdots &amp; a_{2n} \  \vdots &amp; \vdots &amp; \ddots &amp; \vdots  \   a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}-\lambda \ \end{matrix} \right] = 0 $$</p>
<p>  其中，$|A-\lambda I|=0$称为矩阵A的特征方程，$\lambda$为特征方程的解，即特征根,将特征根代入$A\alpha=\lambda \alpha$即可求得特征向量a。</p>
</li>
<li><p>特征值与特征向量的计算过程涉及到求解行列式，由此也可看出只有方阵才能求解其特征值与特征向量。</p>
</li>
</ul>
<h4 id="特征分解"><a href="#特征分解" class="headerlink" title="特征分解"></a>特征分解</h4><ul>
<li>设<strong>方阵A</strong>有$n$个线性无关的特征向量$\alpha_1,\alpha_2,…,\alpha_n$相对应的特征值为$\lambda_1,\lambda_2,…,\lambda_n$,则$A$的特征分解为：$$A=Pdiag(\lambda)P^{-1}$$<br>其中$P={\alpha_1,\alpha_2,…,\alpha_n},\lambda={\lambda_1,\lambda_2,…,\lambda_n}$。</li>
<li>把矩阵分解为一组特征向量和特征值，是使甲最广的矩阵分解方法之一</li>
<li>从<strong>线性空间</strong>的角度看，特征值越大，则矩阵在对应的特征向量上的方差越大，信息量越多</li>
<li>在<strong>最优化</strong>中，矩阵特征值的大小与函数值的变化快慢有关，在最大特征值所对应的特征方向上函数值变化最大，也就是该方向上的方向导数最大。</li>
<li>应用：用于降维的PCA(Principle Component Analysis)、最优化问题、用于处理模型过拟合的正则化。</li>
</ul>
<h4 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h4><ul>
<li><p>奇异值分解：将矩阵分解为奇异向量和奇异值。可以将矩阵$A=(a_{ij})_{m\times n}$分解为三个矩阵的乘积：$$A=U \Sigma V^T$$</p>
<p>  其中$U=(b_{ij})<em>{m\times m}$，$\Sigma$=$(c</em>{ij})<em>{m\times n}，V^T=(d</em>{ij})_{n\times n}$。矩阵$U和V$都为正交矩阵，矩阵$U$的列向量称为左奇异向量，矩阵$V$的列向量称为右奇异向量，$\Sigma$为对角矩阵（不一定为方阵），$\Sigma$对角线上的元素称为矩阵$A$的奇异值,奇异值按从大到小的顺序排列。</p>
</li>
<li><p>奇异值分解的应用：PCA，数据压缩（以图像压缩为代表）算法，特征提取、数字水印和LSA(latent semantic analysis,潜在语义分析)。</p>
</li>
<li><p>奇异值分解可以理解为在原空间内找到一组正交基$v_i$通过矩阵乘法将这组正交基映射到像空间中，其中奇异值对应伸缩系数。</p>
</li>
<li><p>奇异值分解将矩阵原本混合在一起的旋转、缩放和投影的三种作用效果分解出来了。<br><img src="/AI%E5%9F%BA%E7%A1%80/20211215150657.png"></p>
</li>
<li><p>奇异值分解应用实例-图像压缩</p>
<ul>
<li>奇异值分解：$$A=U \Epsilon V^T$$  $$A=[\vec u_1 \quad \vec u_2 \quad \cdots \quad \vec u_m] \left( \begin{matrix} \sigma_1 &amp; \cdots &amp; 0 \ \vdots &amp; \ddots &amp; \vdots \ 0 &amp; \cdots &amp; \sigma_1 \end{matrix} \right)   \left[  \begin{matrix}  \vec v_1^T  \ \vec v_2^T \ \vdots  \ \vec v_1^T   \end{matrix}  \right]  $$   $$A=u_1\sigma_1 \vec v_1^T + u_2\sigma_2 \vec v_2^T + \cdots  + u_n\sigma_n \vec v_n^T $$</li>
</ul>
</li>
<li><p>将上式中的A看作一个m*n个像素组成的图像矩阵，式中奇异值矩阵中的奇异值按从大到小排列数值越大，说明其对应的奇异向量越重要；值越小，则不是重要组成部分可以舍去。若只取前k项即能基本看清图像，则可以达到图像压缩的效果。</p>
</li>
</ul>
<h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><p>概率论是研究不确定的学科。</p>
<p>概率论是现有许多人工智能算法的基础。现阶段的很多人工智能算法都是数据驱动的，且目的大多为了做预测或是作出更好的決策。如</p>
<pre><code>机器翻译中，如何检测你输入的语言种类。一种简单的方法就是把你输入的词或句子进行分解计算各语言模型的概率，然后概率最高的是最后确定的语言模型

 用神经网络进行图像分类，网络的输出是衡量分类结果可信程度的概率值，即分类的置信度，我们选择置信度最高的作为图像分类结果

混合高斯模型、隐马尔科夫模型等传统语音处理模型都是以概率论为基础的
</code></pre>
<h3 id="随机变量及其分布"><a href="#随机变量及其分布" class="headerlink" title="随机变量及其分布"></a>随机变量及其分布</h3><ul>
<li><p>随机试验</p>
<ul>
<li>可以在相同的条件下重复进行。</li>
<li>每次试验的可能结果不止一个，并且能事先明确试验的所有可能结果。</li>
<li>进行一次试验之前不能确定哪一个结果会出现。</li>
</ul>
</li>
<li><p>样本点：一个随机试验所有可能结果的集合是样本空间，而随机试验中的每个可能结果称为样本点    </p>
</li>
<li><p>随机事件：随机试验的某些样本点组成的集合，常用大写字母表示</p>
</li>
<li><p>随机变量：本质是一个函数，是从样本空间的子集到实数的映射，将事件转換成一个数值。一些随机试验的结果可能不是数，因此很难进行描述和研究，比如S=(正面，反面)。因此将随机试验的每一个结果与实数对应起来，从而引入了随机变量的概念。随机变量用大写字母表示，其取值用小写字母表示。</p>
<pre><code>  按照随机变量的可能取值，可分为：
  离散随机变量：随机变量的全部可能取到的值是有限个或可列无限多个。如：某年某地的出生人数
  连续随机变量：随机变量的全部可能取到的值有无限个，或数值无法一列举。如：奶牛每天挤出奶的量可能是一个区间中的任意值
</code></pre>
</li>
<li><p>分布律</p>
<ul>
<li><p>对于离散随机变量，我们通常分布律来描述其取值规律。</p>
</li>
<li><p>分布律，又叫概率质量函数(Probability Mass Function, PMF):设离散型随机变量X的所有可能取值为$x_k$(k=1,2,…),X取各个可能值的概率，即事件{$X=x_k$}的概率，为 $$f_X(x_k)=P{X=x_k}=p_k，k=1,2,…$$</p>
<p>  $p_k$满足：</p>
<p>  (1)、$p_k\geq 0,k=1,2,…$</p>
<p>  (2)、$\sum^\infty_{k=1}p_k=1$</p>
</li>
</ul>
</li>
<li><p>特殊离散分布-伯努利分布</p>
<ul>
<li><p>伯努利分布（0-1分布，两点分布，a-b分布）：设随机变量X只可能取0与1两个值，它的分布律是：$p{X=k}=p^k(1-p)^{1-k}, k=0,1 (0&lt;p&lt;1)$</p>
<table>
<thead>
<tr>
<th>X</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>$p_k$</td>
<td>$1-p$</td>
<td>$p$</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$E(X)=p,Var(x)=p(1-p)$</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>伯努利分布主要用于二分类句题，可以用伯努利朴素贝叶斯进行文本分类或垃圾邮件分类。伯努利模型中每个特征的取值为1和0,即某个单词在文档中是否出现过，或是否为垃圾邮件。</p>
</li>
<li><p>为防止模型过拟合，常会用dropout方法随机丢弃神经元，每个神经元都被建模为伯努利随机变量被抛弃的概率为$p$,成功输出的比例为$1-p$</p>
</li>
</ul>
</li>
<li><p>特殊离散分布-二项分布</p>
<ul>
<li>二项分布是重复n次伯努利试验满足的分布。</li>
<li>若用X表示n重伯努利试验中事件A发生的次数，则n次试验中事件A发生k次的概率为$$P(X=k)=C_n ^k p^k (1-p)^{n-k},k=0,1,2,…,n$$</li>
<li>此时称X服从参数为n，p的二项分布，记为X~B(n,p)。其中$$E(X)=np,Var(x)=np(1-p)$$</li>
<li>二项分布在NLP中使用得非常广泛，例如估计文本中含有“的”字的句子所占百分比，或者确定一个动词在语言中常被用于及物动词还是非及物动词</li>
<li>如在 Dropout方法中，对于某一层的n个神经元在每个训练步骤中可以被看作是n个伯努利实验的集合，即被丢弃的神经元总数服从参数为$n，p$的二项分布</li>
</ul>
</li>
<li><p>特殊离散分布-泊松分布</p>
<ul>
<li>泊松分布：若随机变量所有可能的取值为0,1,2,…,而取每个值的概率为：$$P{X=k}=\frac{\lambda_k e^{-\lambda}}{k!},~~~k=0,1,2,…$$记为：$X$~$P(\lambda)$。$E(X)=\lambda，D(X)=\lambda$。参数$\lambda$是单位时间或单位面积内随机事件的平均发生率。</li>
<li>泊松分布，是二项分布当n很大p很小时的近似计算。</li>
<li>泊松分布用于描述单位时间内随机事件发生的次数。如一段时间内某一客服电话受到的服务请求的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA序列的变异数等。</li>
<li>图像处理中，图像会因为观点显示仪器测量造成的不确定性而出现服从泊松分布的泊松噪声，我们经常会给图像加泊松噪声用于图像的数据增强</li>
</ul>
</li>
<li><p>分布函数</p>
<ul>
<li>分布函数，又叫累计分布函数(Cumulative Distribution Function,CDF)：设$X$是一个随机变量，x是任意实数，函数$F(x)$称为X的分布函数，$$F(x)=P{X≤x},-∞&lt;x&lt;∞$$</li>
<li>分布函数$F(x)$的意义：如果将X看成是数轴上的随机点的坐标，那么分布函数$F(x)$在$x$处的函数值就表示$X$落在区间$(-\infty,x]$上的概率，即随机变量$x$小于等于$x$的概率。<img src="/AI%E5%9F%BA%E7%A1%80/20211213181418.png"></li>
</ul>
</li>
<li><p>连续型随机变量与概率密度函数</p>
<ul>
<li>对于连续随机变量$X$的分布函数$F(X)$，存在非负函数$f(x)$，使对于任意实数$x$有$$F(X)=\int^x _{-\infty} f(t)dt$$则称函数$f(x)$称为$X$的概率密度函数<br>(Probability Density Function,PDF)，简称概率密度。</li>
</ul>
</li>
<li><p>特殊分布-正态分布</p>
<ul>
<li><p>若连续型随机变量$X$的概率密度函数为$$f(x)=\frac{1}{\sqrt {2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}},\quad\quad -\infty&lt;x&lt;\infty$$其中$\mu,\sigma$为常数，则称$X$服从参数为$\mu,\sigma$的正态分布或高斯分布，记为$X$<del>$N(\mu,\sigma^2)$。当$\mu=0,\sigma=1$时称随机变量$X$服从标准正态分布，记为$X$</del>$N(0,1)$。</p>
</li>
<li><p>在自然现象和社会现象中，大量随机变量都服从或近似服从正态分布。高斯分布是机器学习中最常用的分布，如：</p>
<ul>
<li>图像处理中，我们可以给图像添加高斯噪声用于图像增强等任务。也可以用高斯滤波器去除噪声并平滑图像。还可以用混合高斯模型进行图像的前景目标检测。</li>
<li>在传统语音识別模型GMM-HMM(高斯混合模型-隐马尔科夫)中，高斯混合模型就是由多个高斯分布混合起来的模型。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="随机向量及其分布"><a href="#随机向量及其分布" class="headerlink" title="随机向量及其分布"></a>随机向量及其分布</h3><p>在实际应用中，经常需要对所考虑的问题用多个变量来描述。我们把多个随机变量放在一起组成向量，称为多维随机变量或者随机向量。</p>
<p><strong>定义：</strong>如果$X_1(\omega),X_2(\omega),…,X_n(\omega)$是定义在同一个样本空间$\Omega={\omega}$上的n个随机变量，则称$$X(\omega)=(X_1(\omega),X_2(\omega),…,X_n(\omega))$$<br>为<strong>n维(或n元)随机变量或随机向量</strong>。</p>
<p>如我们通过人脸判断人的年龄，可能需要结合多个特征（随机变量），如脸形、脸部纹理、面部斑点、皮肤松弛度、发际线等，将这些特征结合映射为一个实数，即年龄。</p>
<ul>
<li><p>联合分布函数</p>
<p>  对应随机变量的分布函数，随机向量有对应的联合分布函数</p>
<ul>
<li>定义：对任意的n个实数$x_1,x_2,…,x_n$,则n个事件${X_1\leq x_1},{X_2\leq x_2},…,{X_n\leq x_n}$同时发生的概率为$$F(x_1,x_2,…,x_n)=P(X_1≤x_1,X_2≤x_2,…,X_n≤x_n)$$<br>称为n维随机变量的联合分布函数。</li>
<li>二维联合分布函数：$F(x,y)=P(X≤x,Y\leq y)$,表示随机点(X,Y)落在以(x,y)为顶点的左下方无穷矩形区域的概率。<br>  <img src="/AI%E5%9F%BA%E7%A1%80/20211213211713.png"></li>
</ul>
</li>
<li><p>联合概率密度</p>
<p>  对应一维随机变量的概率密度函数，随机向量有对应的联合概率密度。</p>
<p>  定义：如果存在二元非负函数$p(x,y)$,使得二维随机变量$(X,Y)$的分布函数可表示为$$F(x,y)=\int_{-\infty} ^{x} \int_{-\infty}^y p(u,v)dudv$$<br>  则称$(X,Y)$为二维连续随机变量，称$p(u,v)$为$(X,Y)$的联合概率密度。</p>
</li>
</ul>
<h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><ul>
<li><p>条件概率、贝叶斯公式(1)</p>
<p>  已知原因求解事件发生的概率通常被叫做<strong>条件概率也叫后验概率：</strong>$$P(Y|X)=\frac{P(YX)}{P(X)}$$</p>
<ul>
<li>我们经常需要在已知事件发生的情况下计算$P(X|Y)$,即事件已经发生了，再分析原因。<br>此时若还知道先验概率$P(X)$,我们就可以用<strong>贝叶斯公式</strong>来计算$$P(X|Y)=\frac{P(XY)}{P(Y)}=\frac{P(Y|X)P(X)}{P(Y)}$$</li>
</ul>
</li>
<li><p>条件概率、贝叶斯公式(2)</p>
<p>  假设$X$是由相互独立的事件组成的概率空间${X_1,X_2,…,X_n}$,则$P(Y)$可以用<strong>全概率公式</strong>展开：$P(Y)=P(Y|X_1)P(X_1)+P(Y|X_2)P(X_2)+…+P(Y|X_n)P(X_n)$,此时<strong>贝叶斯公式</strong>可表示为：$$P(X_i|Y)=\frac{P(Y|X_i)}{\sum_{i=1}^nP(Y|X_i)P(X_i)}$$</p>
<ul>
<li>贝叶斯公式应用：中文分词、统计机器翻译、深度贝叶斯网络等。</li>
</ul>
</li>
<li><p>期望、方差</p>
<p>  数学期望(或均值，亦简称期望)：是试验中每次可能结果的概率乘以其结果的总和，是<br>  概率分布最基本的数学特征之ー。它反映随机变量平均取值的大小。</p>
<p>  对于离散型随机变量：$E(X)=\sum_{k=1} ^\infty x_k p_k，k=1,2,…$</p>
<p>  对于连续型随机变量：$E(X)=\int_{-\infty}^\infty xf(x)dx$</p>
<p>  方差：是衡量随机变量或一组数据离散程度的度量，即随机变量和其数学期望之间的偏离程度。$$D(X)=Var(X)=E{[X-E(X)]^2}$$</p>
<p>  另外，$\sqrt{D(X)}$，记为$\sigma(X)$,称为标准差或均方差。$X^*=\frac{X-E(X)}{\sigma(X)}$称为$X$的标准化变量。</p>
</li>
<li><p>协方差、相关系数、协方差矩阵</p>
<ul>
<li><strong>协方差</strong>：在某种意义上给出了两个随机变量线性相关性的强度。<br>$$Cov(X,Y)=E[(XーE(X))(Y-E(Y))]$$</li>
<li><strong>相关系数</strong>又叫线性相关系数，用来度量两个变量间的线性关系。<br>$$\rho_{XY}=\frac{Cov(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}$$</li>
<li>随机变量$(X1,X2)$的协方差矩阵：<br>$$<br>\left[<br>\begin{matrix}<br>c_{11} &amp; c_{12} &amp; \ldots &amp; c_{1n} \<br>c_{21} &amp; c_{21} &amp; \ldots &amp; c_{2n} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>c_{n1} &amp; c_{n2} &amp; \ldots &amp; c_{nn} \<br>\end{matrix}<br>\right]<br>$$</li>
<li>其中，$c_{ij}=Cov(X_i,X_j)=E{[X_i-E(X_i)][X_j-E(X_j)]},i,j=1,2,…,n$ 协方差矩阵对角线上的元素分别是$X_1,X_2$的方差，其余元素为$X_1,X_2$的协方差。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="最优化问题"><a href="#最优化问题" class="headerlink" title="最优化问题"></a>最优化问题</h2><p>最优化问题：指的是改变$x$以最小化或最大化某个函数$f(x)$的任务。可以表示为：$$min(max)f(x) \quad\quad\quad 目标函数的极小(极大)$$ $$s.t. \quad g_i(x) \geq 0,i=1,2,…,m, \quad\quad\quad不等式约束$$ $$h_j(x)=0,j=1,2,…,p, \quad\quad\quad 等式约束$$</p>
<p>其中$x=(x_1,x_2,…,x_n)^T\in R^n$，我们将$f(x)$称为目标函数或准则；当对其进行最小化时，也把它称为代价函数、损失函数、误差函数。</p>
<p>如果除目标函数以外，对参与优化的各变量没有其他约束，则称为无约束最优化问题。反之，称为有约束最优化问题。</p>
<h3 id="最优化问题分类"><a href="#最优化问题分类" class="headerlink" title="最优化问题分类"></a>最优化问题分类</h3><ul>
<li><p><strong>无约束最有化</strong>可以写为：$$minf(x)$$</p>
</li>
<li><p><strong>约束优化</strong>：是优化问题的分支。实际生活中大多都是带约束条件的，我们希望在$x$的某些集合$s$中找$f(x)$的最大值或最小值。集合$s$内的点称为<strong>可行点</strong>。</p>
</li>
<li><p><strong>等式约束最优化</strong>可以写为$$minf(x)$$ $$s.t. \quad g_i(x) \geq 0,i=1,2,…,n$$</p>
</li>
<li><p><strong>不等式约束最优化</strong>可以写为$$min(max)f(x)$$ $$s.t. \quad g_i(x) \geq 0,i=1,2,…,n $$ $$h_j(x)=0,j=1,2,…,m $$</p>
</li>
</ul>
<br>

<h3 id="最优化问题求解"><a href="#最优化问题求解" class="headerlink" title="最优化问题求解"></a>最优化问题求解</h3><ul>
<li><strong>无约束优化求解</strong>：主要有解析法和直接法。<ul>
<li>直接法通常用于当目标函数表达式十分复杂或写不出具体表达式时的情況。通过数值计算，经过一系列迭代过程产生点列，在其中搜索最优点。</li>
<li>解析法，即间接法，是根据无约束最优化问题的目标函数的解析表达式给出一种求最优解的方法，主要有梯度下降法、牛顿法、拟牛顿去、共轭方向法和共轭梯度法等。</li>
</ul>
</li>
<li><strong>约束最优化求解</strong>：解决约束最优化问题最常用的方法是引用拉格朗日乘子（等式约束）或者KKT(Kuhn-Kuhn- Tucker)条件（不等式约束）将含有n个变量和k个约束条件的约束优化问题转化为含有(n+k)个变量的无约束优化问题进行求解</li>
<li>在此我们重点讨论在深度学习最常用的无约東优化求解方法，即梯度下降算法。</li>
</ul>
<br>

<h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>凸函数：对于$\lambda \in (0,1)$，任意$x_1,x_2\in R$，都有$$f(\lambda x_1+(1-\lambda)x_2)\leq \lambda f(x_1)+(1-\lambda)f(x_2)$$则称$f(x)$是一个凸函数。凸函数的极值点出现在驻点处。</p>
<ul>
<li>优化的过程是逐渐调整模型或函数参数使其输出的预测值与真实值越来越接近的过程</li>
<li>损失函数通常是用来描绘模型的预测值与真实值的一致程度</li>
<li>优化的目标是寻找损失函数最小（大）值的过程</li>
<li>若只优化一个变量，损失函数是一元的。若优化的变量有两个以上，则损失函数是二元及以上的。</li>
</ul>
<br>

<p>一元函数的极值问题：</p>
<ul>
<li>函数极值存在于$f’(x)=0$的点处。</li>
<li>$f’(x)=0$的点称为临界点或驻点。</li>
<li>函数的极值点一点是驻点，反之未必。</li>
</ul>
<p>推广至多维函数的情形，用偏导数描述函数相对于各自变量的变化程度。</p>
<br>

<p>如何从初始位置到函数极值点？</p>
<ul>
<li>每一步都朝着函数值下降最快的方向移动一段距离<ul>
<li>函数下降（上升）最快的方向：函数值变化率最大的方向。<ul>
<li>导数：函数沿坐标轴正方向的变化率。</li>
<li>方向导数：函数沿着任意方向的变化率（多个）</li>
<li>最大方向导数：梯度。梯度方向即函数值变化率最大的方向，也就是我们需要沿着梯度方向寻找函数极值</li>
</ul>
</li>
<li>一段距离：步长，由经验获取的，可以在尝试过程中不断调整</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><p>正梯度向量指向上坡，负梯度向量指向下坡。我们在负梯度方向上移动可以最快地减小函数值，这被称为最速下降法( method of steepest descent)或梯度下降( gradient descent).</p>
</li>
<li><p>在梯度下降法中，每一步更新的方式为$$x’=x-\varepsilon \nabla_xf(x)$$</p>
</li>
<li><p>其中$\varepsilon$为学习率( (learning rate),是一个确定步长的正标量</p>
</li>
<li><p>迭代在梯度为零或趋近于零的时候收敛</p>
</li>
</ul>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>代码优化</title>
    <url>/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>编译原理    第八部分</p>
<span id="more"></span> 

<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>所谓优化，实质上是对程序进行各种等价变换，使得从变换后的程序出发，能够生成更有效的目标代码。</p>
<p>所谓有效，无非从时间和空间两个因素来考虑，即使得变换之后的程序运行速度更快、占用存储空间更少，这两个因素需要均衡考虑</p>
<p> 目标代码生成是编译的最后一个阶段。目标代码生成器把语法分析后或优化后的中间代码变换成目标代码。</p>
<p>目标代码（object code）指计算机科学中编译器或汇编器处理源代码后所生成的代码，它一般由机器代码或接近于机器语言的代码组成。</p>
<p>优化的分类；</p>
<ul>
<li>常用的代码优化技术</li>
<li>局部优化</li>
<li>循环优化</li>
<li>目标代码生成技术</li>
</ul>
<p>代码优化的分类</p>
<p>根据代码优化是否涉及具体的计算机来划分，代码优化可分为两大类</p>
<blockquote>
<p>一类是与机器有关的优化，这类优化一般在目标代码上进行，需要依赖于具体的机器。具体的有对寄存器优化、多处理机的优化、特殊指令的优化等</p>
<p>另一类是与机器无关的优化，在中间代码上进行</p>
</blockquote>
<p>据代码优化所涉及的程序范围，又可分为局部优化、循环优化和全局优化三个不同的级别</p>
<blockquote>
<p>局部优化指的是在只有一个入口、一个出口的基本程序块上进行的优化</p>
<p>循环优化是对循环中的代码进行的优化，在一个程序运行时，相当多的一部分时间会花在循环上，因此，基于循环的优化非常重要。</p>
<p>全局优化是在整个程序范围内进行的优化</p>
</blockquote>
<p>代码优化的目的是为了产生效率更高的代码。编译程序中的代码优化阶段提供的对代码的各种变换必须遵循一定的原则。</p>
<ul>
<li>等价原则。经过优化后不应改变程序运行的结果。</li>
<li>有效原则。使优化后所产生的目标代码运行时间较短，占用的存储空间较小。</li>
<li>合算原则。应尽可能以较低的代价取得较好的优化效果。</li>
</ul>
<h3 id="常用的代码优化技术"><a href="#常用的代码优化技术" class="headerlink" title="常用的代码优化技术"></a>常用的代码优化技术</h3><h4 id="删除公共子表达式-删除多余运算"><a href="#删除公共子表达式-删除多余运算" class="headerlink" title="删除公共子表达式(删除多余运算)"></a>删除公共子表达式(删除多余运算)</h4><blockquote>
<p>如果一个表达式E在前面已经计算过，并且在这之后E中变量的值没有改变，则称E为公共子表达式，是指在一个基本程序块内计算结果相同的子表达式。 </p>
<p>对相同的子表达式只在第一次出现时计算并且仅计算一次，其结果暂存入Ti，而不必重复计算，这样既节约了空间，又节省了时间。这种优化称为删除公共子表达式，也称为删除多余运算</p>
</blockquote>
<h4 id="代码外提"><a href="#代码外提" class="headerlink" title="代码外提"></a>代码外提</h4><blockquote>
<p>代码外提是指将循环中的不变运算提到循环体前面</p>
<p>处在循环体内的不变运算，不论循环体重复执行多少次都不影响其计算结果，这样的运算只会浪费代码执行时间</p>
<p>因此将这类运算提到循环体外并不影响程序运行结果，还可加快代码执行速度</p>
</blockquote>
<h4 id="强度削弱"><a href="#强度削弱" class="headerlink" title="强度削弱"></a>强度削弱</h4><blockquote>
<p>强度削弱是指用执行效率较高的操作等价地替换原操作</p>
<p>对于非算术运算可削弱强度，如尽量使用寄存器，少访问内存（或外存）等</p>
<p>对中间代码级的运算尽可能降低运算级别</p>
</blockquote>
<h4 id="变换循环控制条件-删除归纳变量"><a href="#变换循环控制条件-删除归纳变量" class="headerlink" title="变换循环控制条件(删除归纳变量)"></a>变换循环控制条件(删除归纳变量)</h4><blockquote>
<p>for循环中，控制变量i的作用域是本循环体。如果在循环体内存在一个变量（或临时变量）T与循环控制变量i保持线性关系，同时在循环的后面不引用i，而删去i又不影响程序结果，则可由T取代i的控制循环次数的作用。从循环中删除i，这种方法称为变换循环控制条件，或者称为删除归纳变量。</p>
</blockquote>
<h4 id="合并已知变量"><a href="#合并已知变量" class="headerlink" title="合并已知变量"></a>合并已知变量</h4><blockquote>
<p>已知量是指常数或在编译时就能确定其值的变量</p>
<p>合并已知量是指在编译时就将源程序中关于已知量的表达式之值先行算出，不必生成计算该表达式的代码</p>
</blockquote>
<h4 id="复写传播"><a href="#复写传播" class="headerlink" title="复写传播"></a>复写传播</h4><blockquote>
<p>复写传播是指尽量不引用那些在程序中仅仅只传递信息而不改变其值，也不影响其运行结果的变量。</p>
</blockquote>
<h4 id="删除无用赋值"><a href="#删除无用赋值" class="headerlink" title="删除无用赋值"></a>删除无用赋值</h4><blockquote>
<p>变量的最后一次引用到下次引用之前的最近一次赋值期间，可视为无用变量</p>
<p>在变量的无用期内，对它的任何赋值均可删除。对于那些被赋值后从未被引用的变量，对其进行赋值操作也是无用赋值，可删除</p>
<p>删除无用赋值语句可以减少程序中的无用的变量，还可以使代码更简洁</p>
</blockquote>
<p>示例：</p>
<blockquote>
<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104133404127.png" alt="image-20220104133404127" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104133417988.png" alt="image-20220104133417988" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104133430613.png" alt="image-20220104133430613" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104133648459.png" alt="image-20220104133648459" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104133702331.png" alt="image-20220104133702331" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104133716009.png" alt="image-20220104133716009" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104133735682.png" alt="image-20220104133735682" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104133747933.png" alt="image-20220104133747933" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104133758525.png" alt="image-20220104133758525" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104133808627.png" alt="image-20220104133808627" style="zoom:80%;">
</blockquote>
<h3 id="局部优化"><a href="#局部优化" class="headerlink" title="局部优化"></a>局部优化</h3><p>局部优化（local）是指基本块内的优化。 </p>
<p>对于给定的程序，我们可以把它划分为一系列的基本块。在各个基本块的范围内，分别进行优化。局限在基本块范围内的优化称为基本块内的优化，或者称为局部优化。</p>
<h4 id="基本块"><a href="#基本块" class="headerlink" title="基本块"></a>基本块</h4><p>所谓基本块，是指程序中一顺序执行的语句序列，其中只有一个入口语句和一个出口语句。执行时只能从其入口语句进入，从其出口语句退出，不存在跳转和分叉汇合的情况。</p>
<h4 id="基本块的划分"><a href="#基本块的划分" class="headerlink" title="基本块的划分"></a>基本块的划分</h4><p>第一步：确定四元式程序（中间代码）中各个基本块的人口语句</p>
<blockquote>
<p>所谓入口语句，严格地说来就是下述语句之一：</p>
<ul>
<li><p>程序的第一个语句； </p>
</li>
<li><p>能够由条件转移语句或无条件转移语句转移到的目标语句；</p>
</li>
<li><p>紧跟在条件转移语句后面的语句。 </p>
</li>
</ul>
</blockquote>
<p>第二步：对每一入口语句，构造其所属的基本块</p>
<blockquote>
<p>下述条件之一：</p>
<ul>
<li><p>由该入口语句到下一入口语句(不包括下一入口语句) 之间的所有语句序列组成一个基本块；</p>
</li>
<li><p>由该入口语句到一转移语句(包括该转移语句)之间的所有语句序列组成一个基本块；</p>
</li>
<li><p>由该入口语句到一停语句(包括该停语句)之间的所有语句序列组成的一个基本块。</p>
</li>
</ul>
</blockquote>
<p>第三步：凡未被纳入某一基本块的语句，都是程序中控制流程无法达到的语句，因而也是不会被执行到的语句，我们可以把它们删除</p>
<h4 id="基本块的变换"><a href="#基本块的变换" class="headerlink" title="基本块的变换"></a>基本块的变换</h4><ul>
<li>删除公共子表达式</li>
<li>删除无用赋值</li>
<li>重新命名临时变量</li>
<li>交换语句次序</li>
</ul>
<h4 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h4><blockquote>
<p>DAG（Directed Acyclic Graph）即无环有向图，它是有向图中的一种，通常用来对基本块进行优化。</p>
<p>这种有向图是一种其结点带有下述标记或附加信息的DAG：</p>
<p>1．图的叶结点(即没有后继的结点)以一标识符(变量名)或常数作为标记，表示该结点代表该变量或常数的值。如果叶结点用来代表某变量A的地址，则用addr(A)作为该结点的标记。通常把叶结点上作为标记的标识符加上下标0，以表示它是该变量的初值。</p>
<p>2．图的内部结点（即有后继的结点）以一运算符作为标记，表示该节点代表应用该运算符对其后继结点所代表的值进行运算的结果。</p>
<p>3．图中各个结点可能附加一个或多个标识符，表示这些变量具有该结点所代表的值。</p>
</blockquote>
<h4 id="基本块的DAG表示"><a href="#基本块的DAG表示" class="headerlink" title="基本块的DAG表示"></a>基本块的DAG表示</h4><blockquote>
<p>一个基本块，可用一个DAG来表示。可以利用DAG来描述四元式，如图所示，列出了各种四元式以及相对应的DAG的结点形式。图中为结点编号，结点下面的符号（运算符，标识符或常数）是各结点的标记，各结点右边的标识符是结点的附加标识符。</p>
<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104134903322.png" alt="image-20220104134903322" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104134922630.png" alt="image-20220104134922630" style="zoom:80%;">

<p>​      <img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104134947474.png" alt="image-20220104134947474" style="zoom:80%;"></p>
<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104135005681.png" alt="image-20220104135005681" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104135023462.png" alt="image-20220104135023462" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104135052507.png" alt="image-20220104135052507" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104135144564.png" alt="image-20220104135144564" style="zoom:80%;">
</blockquote>
<h4 id="基本块的DAG构造算法"><a href="#基本块的DAG构造算法" class="headerlink" title="基本块的DAG构造算法"></a>基本块的DAG构造算法</h4><blockquote>
<p>假设DAG各结点信息将用某种适当的数据结构来存放。并设有一个标识符（包括常数）A与结点NODE(A)的对应表，即用大写字母――A，B等表示四元式中的变量名或常数。NODE(A)是描述这种对应关系的一个函数，即用NODE(A)表示A在DAG中的相应结点，它的值可以是一个结点的编号n或者无定义。NODE(A)＝n代表DAG中存在一个结点n，A是其上的标记或附加标识符</p>
</blockquote>
<h4 id="四元式分类"><a href="#四元式分类" class="headerlink" title="四元式分类"></a>四元式分类</h4><blockquote>
<p>把各种形式的四元式按其对应结点的后继个数分为四类。其中：</p>
<p>0型四元式：有0个后继结点，如四元式(0)；</p>
<p>1型四元式：有1个后继结点，如四元式(1) ；</p>
<p>2型四元式：有2个后继结点，如四元式(2) 、 (3) 和(4) ；</p>
<p>3型四元式：有3个后继结点，如四元式(5)</p>
</blockquote>
<h4 id="仅含0，1，2型四元式的基本块的DAG构造算法如下："><a href="#仅含0，1，2型四元式的基本块的DAG构造算法如下：" class="headerlink" title="仅含0，1，2型四元式的基本块的DAG构造算法如下："></a>仅含0，1，2型四元式的基本块的DAG构造算法如下：</h4><blockquote>
<p>初始时，DAG为空。</p>
<p>对基本块中的每一条四元式，依次执行以下步骤：</p>
<p>1.如果NODE(B)无定义，则构造一标记为B的叶结点并定义NODE(B)为这个结点；</p>
<ul>
<li>如果当前四元式是0型，则记NODE(B)的值为n，转4。</li>
<li>如果当前四元式是1型，则转2.(1)</li>
<li>如果当前四元式是2型，则(ⅰ)如果NODE(C)无定义，则构造一标记为C的叶结点并定义NODE(C)为这个结点，(ⅱ)转2.(2)。</li>
</ul>
<p>2.</p>
<ul>
<li>(1)如果NODE(B)是标记为常数的叶结点，则转2. (3)，否则转3.(1)。</li>
<li>(2)如果NODE(B)和NODE(C)都是标记为常数的叶结点，则转2.(4)，否则转3.(2)。</li>
<li>(3)执行op B(即合并已知量)，令得到的新常数为P。如果NODE(B)是处理当前四元式时新构造出来的结点，则删除它。如果NODE(P)无定义，则构造一用P做标记的叶结点n。置NODE(P)=n，转4.。</li>
<li>(4)执行B op C(即合并已知量)，令得到的新常数为P。如果NODE(B)或NODE(C)是处理当前四元式时新构造出来的结点，则删除它。如果NODE(P)无定义，则构造一用P做标记的叶结点n。置NODE(P)＝n，转4.。</li>
</ul>
<p>3.</p>
<ul>
<li>(1)检查DAG中是否已有一结点，其唯一后继为NODE(B)，且标记为op(即找公共子表达式)。如果没有，则构造该结点n，否则就把已有的结点作为它的结点并设该结点为n，转4.。</li>
<li>(2)检查DAG中是否已有一结点，其左后继为NODE(B)，右后继为NODE(C)，且标记为op(即找公共子表达式)。如果没有，则构造该结点n，否则就把已有的结点作为它的结点并设该结点为n。转4.。</li>
</ul>
<p>4.</p>
<p>如果NODE(A)无定义，则把A附加在结点n上并令NODE(A)＝n；否则先把A从NODE(A)结点上的附加标识符集中删除(注意，如果NODE(A)是叶结点，则其标记A不删除)，把A附加到新结点n上并令NODE(A)＝n。转处理下一四元式。</p>
</blockquote>
<h4 id="基本块的应用"><a href="#基本块的应用" class="headerlink" title="基本块的应用"></a>基本块的应用</h4><blockquote>
<p>将四元式表示成相应的DAG后，可以利用DAG来进行优化。</p>
<p>利用基本块来进行优化的主要思想是：<br>    首先将一个基本块中的每一个四元式依次表示成对应的DAG，再将这些DAG合成对于一个较大的DAG，即为该基本块的DAG。然后按照构造DAG结点的顺序重写四元式序列，就可以得到经过“合并已知量”、“删除无用赋值”、“删除公共子表达式”的等价的基本块，即为优化后的基本块。</p>
</blockquote>
<p>示例：</p>
<blockquote>
<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104140038651.png" alt="image-20220104140038651" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104140057414.png" alt="image-20220104140057414" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104140116874.png" alt="image-20220104140116874" style="zoom:80%;">
</blockquote>
<h3 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h3><p>在程序设计语言中，循环是必不可少的控制结构之一。所谓循环，粗略地说，就是程序中那些可能反复执行的代码序列。因为循环中的代码要反复执行，因而为了提高目标代码的效率必须着重考虑循环的代码优化。</p>
<p>循环优化是指在循环体中进行的专项优化，是提高程序运行效率的主要途径。因为在一个执行n次的循环体内进行一项优化，从运行效率上来说，相当于进行了n项优化。</p>
<p>为了进行循环优化，首先必须找出程序中的循环，为找出程序中的循环，就需要对程序的控制流程进行分析。我们将使用程序的控制流程图对所讨论的循环给出定义，并介绍怎样从程序的控制流程图中找出程序的循环。</p>
<p>对循环中的代码段，可以进行代码外提、强度削弱和删除归纳变量等优化。</p>
<h4 id="程序流图"><a href="#程序流图" class="headerlink" title="程序流图"></a>程序流图</h4><p>一个控制流程图就是具有唯一首结点的有向图。</p>
<p>所谓首结点，就是从它开始到控制流程图中任何结点都有一条通路的结点。</p>
<p>一个控制流程图表示成一个三元组G＝(N，E，n0)，其中，N代表图中所有结点集，E代表图中所有有向边集，n0代表首结点。以下把控制流程图简称为流图。</p>
<p>一个程序可用一个流图来表示。流图中的有限结点集N就是程序的基本块集，流图中的结点就是程序中的基本块。流图的首结点就是包含程序第一个语句的基本块。 </p>
<p>程序流图中的有向边集E是这样构成的：</p>
<blockquote>
<p>假设流图中结点i和结点j分别对应于程序的基本块i和基本块j，则当下述条件1.或2.有一个成立时，从结点i有一有向边引向结点j：</p>
<p>1.基本块j在程序中的位置紧跟在基本块i之后，并且基本块i的出口语句不是无条件转移语句goto(s)或停语句。</p>
<p>2．基本块i的出口语句是goto(s)或if…goto(s)，并且(s)是基本块j的入口语句。</p>
</blockquote>
<p>示例：</p>
<blockquote>
<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104140500726.png" alt="image-20220104140500726" style="zoom:80%;">

<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104140517652.png" alt="image-20220104140517652" style="zoom:80%;">
</blockquote>
<p>循环的定义</p>
<blockquote>
<p>在流图中,称具有下列性质的结点序列为一个循环：</p>
<ul>
<li>它们是强连通的。即其中任意两个结点之间，必有一条通路，而且该通路上各结点都属于该结点序列。如果序列只包含一个结点，则必有一有向边从该结点引到其自身。</li>
<li>它们中间有且只有一个是入口结点。所谓入口结点，是指序列中具有下述性质的结点：从序列外某结点，有一有向边引到它，或者它就是程序流图的首结点。</li>
</ul>
<p>循环就是流图中具有唯一入口结点的强连通子图，从循环外要进入循环，必须首先经过循环的入口结点。</p>
<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104140747535.png" alt="image-20220104140747535" style="zoom:80%;">
</blockquote>
<p>循环的查找 </p>
<blockquote>
<p>为了查找循环，需对程序流图中各结点的控制关系进行分析，即利用控制点（dominator）查找循环</p>
</blockquote>
<p>循环优化方法</p>
<ul>
<li>代码外提</li>
<li>删除归纳变量</li>
<li>强度削弱</li>
</ul>
<p>代码外提</p>
<blockquote>
<p>减少循环中程序代码数目的一个重要办法是代码外提。这种变换把循环不变运算，即运算产生的结果不受循环执行次数影响的表达式，放到循环的前面</p>
<p>实行代码外提时，在循环的入口结点前面建立一个新结点(基本块)，称之为循环的前置结点。循环的前置结点以循环的入口结点为其唯一后继，原来流图中从循环外引到循环入口结点的有向边，改成引到循环前置结点</p>
</blockquote>
<p>强度削弱</p>
<blockquote>
<p>强度削弱是指把程序中执行时间较长的运算替换为执行时间较短的运算。例如把循环中的乘法运算用递归加法运算来实现</p>
</blockquote>
<p>删除归纳变量</p>
<blockquote>
<p>【基本归纳变量】如果循环中对变量I只有唯一的形如 I＝I土C的赋值，且其中C为循环不变量，则称I为循环中的基本归纳变量。</p>
<p>【归纳变量】如果I是循环中一基本归纳变量， J在循环中的定值总是可以化归为I的同一线性函数，也即 J ＝C1*I土C2，其中C1和C2都是循环不变量，则称J为归纳变量，并称它与I同族。一个基本归纳变量也是一归纳变量</p>
<p>删除归纳变量是在强度削弱之后进行的</p>
</blockquote>
<h2 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h2><p>代码生成要考虑的主要问题</p>
<blockquote>
<ul>
<li>充分利用寄存器：<br>  在基本块内或在全局内基本块中全局寄存器分配：不把寄存器平均分配给各个变量使用，而是从可用的寄存器中分出几个，固定分配给几个变量单独使用。<br>  标准：以各变量在循环内需要访问主存单元的次数为标准。</li>
<li>选择计算机指令系统</li>
<li>选择计算次序</li>
</ul>
</blockquote>
<p>目标代码的三种形式</p>
<ul>
<li>地址代真的机器代码</li>
<li>待装配的机器代码模块</li>
<li>汇编语言（宏汇编）</li>
</ul>
<p>机器指令形式(op source ,destination)</p>
<blockquote>
<p>ADD s,d    //d+s ? d<br>SUB  s,d     //d-s ? d<br>MOV s,d     //s ? d</p>
</blockquote>
<img src="/8%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/image-20220104141958647.png" alt="image-20220104141958647" style="zoom:80%;">

]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>ASCII表</title>
    <url>/ASCII/</url>
    <content><![CDATA[<p>ASCII码表</p>
<span id="more"></span>



<p><img src="/ASCII/www.51wendang.jpg"></p>
<table>
<thead>
<tr>
<th><strong>二进制</strong></th>
<th>**十进制        **</th>
<th><strong>十六进制</strong></th>
<th><strong>字符/缩写</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>00000000</td>
<td>0</td>
<td>00</td>
<td>NUL (NULL)</td>
<td>空字符</td>
</tr>
<tr>
<td>00000001</td>
<td>1</td>
<td>01</td>
<td>SOH (Start Of Headling)</td>
<td>标题开始</td>
</tr>
<tr>
<td>00000010</td>
<td>2</td>
<td>02</td>
<td>STX (Start Of Text)</td>
<td>正文开始</td>
</tr>
<tr>
<td>00000011</td>
<td>3</td>
<td>03</td>
<td>ETX (End Of Text)</td>
<td>正文结束</td>
</tr>
<tr>
<td>00000100</td>
<td>4</td>
<td>04</td>
<td>EOT (End Of Transmission)</td>
<td>传输结束</td>
</tr>
<tr>
<td>00000101</td>
<td>5</td>
<td>05</td>
<td>ENQ (Enquiry)</td>
<td>请求</td>
</tr>
<tr>
<td>00000110</td>
<td>6</td>
<td>06</td>
<td>ACK (Acknowledge)</td>
<td>回应/响应/收到通知</td>
</tr>
<tr>
<td>00000111</td>
<td>7</td>
<td>07</td>
<td>BEL (Bell)</td>
<td>响铃</td>
</tr>
<tr>
<td>00001000</td>
<td>8</td>
<td>08</td>
<td>BS (Backspace)</td>
<td>退格</td>
</tr>
<tr>
<td>00001001</td>
<td>9</td>
<td>09</td>
<td>HT (Horizontal Tab)</td>
<td>水平制表符</td>
</tr>
<tr>
<td>00001010</td>
<td>10</td>
<td>0A</td>
<td>LF/NL(Line Feed/New Line)</td>
<td>换行键</td>
</tr>
<tr>
<td>00001011</td>
<td>11</td>
<td>0B</td>
<td>VT (Vertical Tab)</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>00001100</td>
<td>12</td>
<td>0C</td>
<td>FF/NP (Form Feed/New Page)</td>
<td>换页键</td>
</tr>
<tr>
<td>00001101</td>
<td>13</td>
<td>0D</td>
<td>CR (Carriage Return)</td>
<td>回车键</td>
</tr>
<tr>
<td>00001110</td>
<td>14</td>
<td>0E</td>
<td>SO (Shift Out)</td>
<td>不用切换</td>
</tr>
<tr>
<td>00001111</td>
<td>15</td>
<td>0F</td>
<td>SI (Shift In)</td>
<td>启用切换</td>
</tr>
<tr>
<td>00010000</td>
<td>16</td>
<td>10</td>
<td>DLE (Data Link Escape)</td>
<td>数据链路转义</td>
</tr>
<tr>
<td>00010001</td>
<td>17</td>
<td>11</td>
<td>DC1/XON (Device Control 1/Transmission On)</td>
<td>设备控制1/传输开始</td>
</tr>
<tr>
<td>00010010</td>
<td>18</td>
<td>12</td>
<td>DC2 (Device Control 2)</td>
<td>设备控制2</td>
</tr>
<tr>
<td>00010011</td>
<td>19</td>
<td>13</td>
<td>DC3/XOFF (Device Control 3/Transmission Off)</td>
<td>设备控制3/传输中断</td>
</tr>
<tr>
<td>00010100</td>
<td>20</td>
<td>14</td>
<td>DC4 (Device Control 4)</td>
<td>设备控制4</td>
</tr>
<tr>
<td>00010101</td>
<td>21</td>
<td>15</td>
<td>NAK (Negative Acknowledge)</td>
<td>无响应/非正常响应/拒绝接收</td>
</tr>
<tr>
<td>00010110</td>
<td>22</td>
<td>16</td>
<td>SYN (Synchronous Idle)</td>
<td>同步空闲</td>
</tr>
<tr>
<td>00010111</td>
<td>23</td>
<td>17</td>
<td>ETB (End of Transmission Block)</td>
<td>传输块结束/块传输终止</td>
</tr>
<tr>
<td>00011000</td>
<td>24</td>
<td>18</td>
<td>CAN (Cancel)</td>
<td>取消</td>
</tr>
<tr>
<td>00011001</td>
<td>25</td>
<td>19</td>
<td>EM (End of Medium)</td>
<td>已到介质末端/介质存储已满/介质中断</td>
</tr>
<tr>
<td>00011010</td>
<td>26</td>
<td>1A</td>
<td>SUB (Substitute)</td>
<td>替补/替换</td>
</tr>
<tr>
<td>00011011</td>
<td>27</td>
<td>1B</td>
<td>ESC (Escape)</td>
<td>逃离/取消</td>
</tr>
<tr>
<td>00011100</td>
<td>28</td>
<td>1C</td>
<td>FS (File Separator)</td>
<td>文件分割符</td>
</tr>
<tr>
<td>00011101</td>
<td>29</td>
<td>1D</td>
<td>GS (Group Separator)</td>
<td>组分隔符/分组符</td>
</tr>
<tr>
<td>00011110</td>
<td>30</td>
<td>1E</td>
<td>RS (Record Separator)</td>
<td>记录分离符</td>
</tr>
<tr>
<td>00011111</td>
<td>31</td>
<td>1F</td>
<td>US (Unit Separator)</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>00100000</td>
<td>32</td>
<td>20</td>
<td>(Space)</td>
<td>空格</td>
</tr>
<tr>
<td>00100001</td>
<td>33</td>
<td>21</td>
<td>!</td>
<td></td>
</tr>
<tr>
<td>00100010</td>
<td>34</td>
<td>22</td>
<td>“</td>
<td></td>
</tr>
<tr>
<td>00100011</td>
<td>35</td>
<td>23</td>
<td>#</td>
<td></td>
</tr>
<tr>
<td>00100100</td>
<td>36</td>
<td>24</td>
<td>$</td>
<td></td>
</tr>
<tr>
<td>00100101</td>
<td>37</td>
<td>25</td>
<td>%</td>
<td></td>
</tr>
<tr>
<td>00100110</td>
<td>38</td>
<td>26</td>
<td>&amp;</td>
<td></td>
</tr>
<tr>
<td>00100111</td>
<td>39</td>
<td>27</td>
<td>‘</td>
<td></td>
</tr>
<tr>
<td>00101000</td>
<td>40</td>
<td>28</td>
<td>(</td>
<td></td>
</tr>
<tr>
<td>00101001</td>
<td>41</td>
<td>29</td>
<td>)</td>
<td></td>
</tr>
<tr>
<td>00101010</td>
<td>42</td>
<td>2A</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td>00101011</td>
<td>43</td>
<td>2B</td>
<td>+</td>
<td></td>
</tr>
<tr>
<td>00101100</td>
<td>44</td>
<td>2C</td>
<td>,</td>
<td></td>
</tr>
<tr>
<td>00101101</td>
<td>45</td>
<td>2D</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>00101110</td>
<td>46</td>
<td>2E</td>
<td>.</td>
<td></td>
</tr>
<tr>
<td>00101111</td>
<td>47</td>
<td>2F</td>
<td>/</td>
<td></td>
</tr>
<tr>
<td>00110000</td>
<td>48</td>
<td>30</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>00110001</td>
<td>49</td>
<td>31</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>00110010</td>
<td>50</td>
<td>32</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>00110011</td>
<td>51</td>
<td>33</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>00110100</td>
<td>52</td>
<td>34</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>00110101</td>
<td>53</td>
<td>35</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>00110110</td>
<td>54</td>
<td>36</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>00110111</td>
<td>55</td>
<td>37</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>00111000</td>
<td>56</td>
<td>38</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>00111001</td>
<td>57</td>
<td>39</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>00111010</td>
<td>58</td>
<td>3A</td>
<td>:</td>
<td></td>
</tr>
<tr>
<td>00111011</td>
<td>59</td>
<td>3B</td>
<td>;</td>
<td></td>
</tr>
<tr>
<td>00111100</td>
<td>60</td>
<td>3C</td>
<td>&lt;</td>
<td></td>
</tr>
<tr>
<td>00111101</td>
<td>61</td>
<td>3D</td>
<td>=</td>
<td></td>
</tr>
<tr>
<td>00111110</td>
<td>62</td>
<td>3E</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>00111111</td>
<td>63</td>
<td>3F</td>
<td>?</td>
<td></td>
</tr>
<tr>
<td>01000000</td>
<td>64</td>
<td>40</td>
<td>@</td>
<td></td>
</tr>
<tr>
<td>01000001</td>
<td>65</td>
<td>41</td>
<td>A</td>
<td></td>
</tr>
<tr>
<td>01000010</td>
<td>66</td>
<td>42</td>
<td>B</td>
<td></td>
</tr>
<tr>
<td>01000011</td>
<td>67</td>
<td>43</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td>01000100</td>
<td>68</td>
<td>44</td>
<td>D</td>
<td></td>
</tr>
<tr>
<td>01000101</td>
<td>69</td>
<td>45</td>
<td>E</td>
<td></td>
</tr>
<tr>
<td>01000110</td>
<td>70</td>
<td>46</td>
<td>F</td>
<td></td>
</tr>
<tr>
<td>01000111</td>
<td>71</td>
<td>47</td>
<td>G</td>
<td></td>
</tr>
<tr>
<td>01001000</td>
<td>72</td>
<td>48</td>
<td>H</td>
<td></td>
</tr>
<tr>
<td>01001001</td>
<td>73</td>
<td>49</td>
<td>I</td>
<td></td>
</tr>
<tr>
<td>01001010</td>
<td>74</td>
<td>4A</td>
<td>J</td>
<td></td>
</tr>
<tr>
<td>01001011</td>
<td>75</td>
<td>4B</td>
<td>K</td>
<td></td>
</tr>
<tr>
<td>01001100</td>
<td>76</td>
<td>4C</td>
<td>L</td>
<td></td>
</tr>
<tr>
<td>01001101</td>
<td>77</td>
<td>4D</td>
<td>M</td>
<td></td>
</tr>
<tr>
<td>01001110</td>
<td>78</td>
<td>4E</td>
<td>N</td>
<td></td>
</tr>
<tr>
<td>01001111</td>
<td>79</td>
<td>4F</td>
<td>O</td>
<td></td>
</tr>
<tr>
<td>01010000</td>
<td>80</td>
<td>50</td>
<td>P</td>
<td></td>
</tr>
<tr>
<td>01010001</td>
<td>81</td>
<td>51</td>
<td>Q</td>
<td></td>
</tr>
<tr>
<td>01010010</td>
<td>82</td>
<td>52</td>
<td>R</td>
<td></td>
</tr>
<tr>
<td>01010011</td>
<td>83</td>
<td>53</td>
<td>S</td>
<td></td>
</tr>
<tr>
<td>01010100</td>
<td>84</td>
<td>54</td>
<td>T</td>
<td></td>
</tr>
<tr>
<td>01010101</td>
<td>85</td>
<td>55</td>
<td>U</td>
<td></td>
</tr>
<tr>
<td>01010110</td>
<td>86</td>
<td>56</td>
<td>V</td>
<td></td>
</tr>
<tr>
<td>01010111</td>
<td>87</td>
<td>57</td>
<td>W</td>
<td></td>
</tr>
<tr>
<td>01011000</td>
<td>88</td>
<td>58</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>01011001</td>
<td>89</td>
<td>59</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>01011010</td>
<td>90</td>
<td>5A</td>
<td>Z</td>
<td></td>
</tr>
<tr>
<td>01011011</td>
<td>91</td>
<td>5B</td>
<td>[</td>
<td></td>
</tr>
<tr>
<td>01011100</td>
<td>92</td>
<td>5C</td>
<td>\</td>
<td></td>
</tr>
<tr>
<td>01011101</td>
<td>93</td>
<td>5D</td>
<td>]</td>
<td></td>
</tr>
<tr>
<td>01011110</td>
<td>94</td>
<td>5E</td>
<td>^</td>
<td></td>
</tr>
<tr>
<td>01011111</td>
<td>95</td>
<td>5F</td>
<td>_</td>
<td></td>
</tr>
<tr>
<td>01100000</td>
<td>96</td>
<td>60</td>
<td>`</td>
<td></td>
</tr>
<tr>
<td>01100001</td>
<td>97</td>
<td>61</td>
<td>a</td>
<td></td>
</tr>
<tr>
<td>01100010</td>
<td>98</td>
<td>62</td>
<td>b</td>
<td></td>
</tr>
<tr>
<td>01100011</td>
<td>99</td>
<td>63</td>
<td>c</td>
<td></td>
</tr>
<tr>
<td>01100100</td>
<td>100</td>
<td>64</td>
<td>d</td>
<td></td>
</tr>
<tr>
<td>01100101</td>
<td>101</td>
<td>65</td>
<td>e</td>
<td></td>
</tr>
<tr>
<td>01100110</td>
<td>102</td>
<td>66</td>
<td>f</td>
<td></td>
</tr>
<tr>
<td>01100111</td>
<td>103</td>
<td>67</td>
<td>g</td>
<td></td>
</tr>
<tr>
<td>01101000</td>
<td>104</td>
<td>68</td>
<td>h</td>
<td></td>
</tr>
<tr>
<td>01101001</td>
<td>105</td>
<td>69</td>
<td>i</td>
<td></td>
</tr>
<tr>
<td>01101010</td>
<td>106</td>
<td>6A</td>
<td>j</td>
<td></td>
</tr>
<tr>
<td>01101011</td>
<td>107</td>
<td>6B</td>
<td>k</td>
<td></td>
</tr>
<tr>
<td>01101100</td>
<td>108</td>
<td>6C</td>
<td>l</td>
<td></td>
</tr>
<tr>
<td>01101101</td>
<td>109</td>
<td>6D</td>
<td>m</td>
<td></td>
</tr>
<tr>
<td>01101110</td>
<td>110</td>
<td>6E</td>
<td>n</td>
<td></td>
</tr>
<tr>
<td>01101111</td>
<td>111</td>
<td>6F</td>
<td>o</td>
<td></td>
</tr>
<tr>
<td>01110000</td>
<td>112</td>
<td>70</td>
<td>p</td>
<td></td>
</tr>
<tr>
<td>01110001</td>
<td>113</td>
<td>71</td>
<td>q</td>
<td></td>
</tr>
<tr>
<td>01110010</td>
<td>114</td>
<td>72</td>
<td>r</td>
<td></td>
</tr>
<tr>
<td>01110011</td>
<td>115</td>
<td>73</td>
<td>s</td>
<td></td>
</tr>
<tr>
<td>01110100</td>
<td>116</td>
<td>74</td>
<td>t</td>
<td></td>
</tr>
<tr>
<td>01110101</td>
<td>117</td>
<td>75</td>
<td>u</td>
<td></td>
</tr>
<tr>
<td>01110110</td>
<td>118</td>
<td>76</td>
<td>v</td>
<td></td>
</tr>
<tr>
<td>01110111</td>
<td>119</td>
<td>77</td>
<td>w</td>
<td></td>
</tr>
<tr>
<td>01111000</td>
<td>120</td>
<td>78</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>01111001</td>
<td>121</td>
<td>79</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>01111010</td>
<td>122</td>
<td>7A</td>
<td>z</td>
<td></td>
</tr>
<tr>
<td>01111011</td>
<td>123</td>
<td>7B</td>
<td>{</td>
<td></td>
</tr>
<tr>
<td>01111100</td>
<td>124</td>
<td>7C</td>
<td>|</td>
<td></td>
</tr>
<tr>
<td>01111101</td>
<td>125</td>
<td>7D</td>
<td>}</td>
<td></td>
</tr>
<tr>
<td>01111110</td>
<td>126</td>
<td>7E</td>
<td>~</td>
<td></td>
</tr>
<tr>
<td>01111111</td>
<td>127</td>
<td>7F</td>
<td>DEL (Delete)</td>
<td>删除</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>ASCII</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell</title>
    <url>/Bash/</url>
    <content><![CDATA[<p>学习资料来自菜鸟教程，有增减，<a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程 | 菜鸟教程 (runoob.com)</a></p>
<span id="more"></span>

<h3 id="Shell脚本运行"><a href="#Shell脚本运行" class="headerlink" title="Shell脚本运行"></a>Shell脚本运行</h3><p>1、<strong>作为可执行程序</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod +x ./test.sh  <span class="comment">#使脚本具有执行权限</span></span><br><span class="line">./test.sh  <span class="comment">#执行脚本</span></span><br></pre></td></tr></table></figure>

<p>注意，一定要写成 <strong>./test.sh</strong>，而不是 <strong>test.sh</strong>，告诉系统就在当前目录找而不是去 PATH 里寻找。</p>
<p>2、<strong>作为解释器参数</strong></p>
<p>直接运行解释器，参数就是shell脚本的文件名，如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/bin/sh test.sh</span><br></pre></td></tr></table></figure>



<h3 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h3><p>定义变量时，变量名不加美元符号（$）<code>your_name=&quot;runoob.com&quot;</code> </p>
<ul>
<li>变量名和等号之间不能有空格</li>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头</li>
</ul>
<h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><p>使用一个定义过的变量，只要在变量名前面加美元符号</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">&quot;qinjx&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br><span class="line">your_name=<span class="string">&quot;yang&quot;</span> <span class="comment"># 赋值的时候不能写$your_name 使用变量的时候才加$</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></span><br></pre></td></tr></table></figure>

<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> skill <span class="keyword">in</span> Ada Coffe Action Java; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;I am good at <span class="variable">$&#123;skill&#125;</span>Script&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h4 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h4><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">myUrl=<span class="string">&quot;https://www.google.com&quot;</span></span><br><span class="line"><span class="built_in">readonly</span> myUrl</span><br><span class="line">myUrl=<span class="string">&quot;https://www.runoob.com&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/bin/sh: NAME: This variable is <span class="built_in">read</span> only.</span><br></pre></td></tr></table></figure>

<h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p><code>unset variable_name</code> （unset 命令不能删除只读变量）</p>
<h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><ul>
<li><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>
<li><strong>2) 环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
<li><strong>3) shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ul>
<h3 id="Shell字符串"><a href="#Shell字符串" class="headerlink" title="Shell字符串"></a>Shell字符串</h3><p>字符串可以用单引号，也可以用双引号，也可以不用引号</p>
<h4 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">str=<span class="string">&#x27;this is a string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>单引号字符串的限制：</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li>
</ul>
<h4 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">&quot;runoob&quot;</span></span><br><span class="line">str=<span class="string">&quot;Hello, I know you are \&quot;<span class="variable">$your_name</span>\&quot;! \n&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="variable">$str</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Hello, I know you are <span class="string">&quot;runoob&quot;</span>! </span><br></pre></td></tr></table></figure>

<p>双引号的优点：</p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
<h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">string=<span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span>  <span class="comment"># 输出 4</span></span><br></pre></td></tr></table></figure>

<h4 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">string=<span class="string">&quot;runoob is a great site&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:1:4&#125;</span>  <span class="comment"># 输出 unoo</span></span><br></pre></td></tr></table></figure>

<h4 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h4><p>查找字符 i 或 o 的位置（哪个字符先出现就计算哪个）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">string=<span class="string">&quot;runoob is a great site&quot;</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">&quot;<span class="variable">$string</span>&quot;</span> io`  <span class="comment"># 输出 4</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 以上脚本中 <strong>`</strong> 是反引号，而不是单引号 <strong>‘</strong></p>
<h3 id="Shell注释"><a href="#Shell注释" class="headerlink" title="Shell注释"></a>Shell注释</h3><p>以 <strong>#</strong> 开头的行就是注释，会被解释器忽略</p>
<p><strong>多行注释</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">:&lt;&lt;<span class="string">&#x27;</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></table></figure>



<h3 id="Shell传递参数"><a href="#Shell传递参数" class="headerlink" title="Shell传递参数"></a>Shell传递参数</h3><p>脚本内获取参数的格式为：**$n<strong>。</strong>n** 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……，**$0** 为执行的文件名（包含文件路径）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Shell 传递参数实例！&quot;</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;执行的文件名：<span class="variable">$0</span>&quot;</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;第一个参数为：<span class="variable">$1</span>&quot;</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;第二个参数为：<span class="variable">$2</span>&quot;</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;第三个参数为：<span class="variable">$3</span>&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">执行的文件名：./test.sh</span><br><span class="line">第一个参数为：1</span><br><span class="line">第二个参数为：2</span><br><span class="line">第三个参数为：3</span><br></pre></td></tr></table></figure>

<p><strong>其他特殊字符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$#	传递到脚本的参数个数</span><br><span class="line">$*	以一个单字符串显示所有向脚本传递的参数。如&quot;$*&quot;用&quot;括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。</span><br><span class="line">$$	脚本运行的当前进程ID号</span><br><span class="line">$!	后台运行的最后一个进程的ID号</span><br><span class="line">$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。如&quot;$@&quot;用&quot;括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。</span><br><span class="line">$-	显示Shell使用的当前选项，与set命令功能相同。</span><br><span class="line">$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</span><br></pre></td></tr></table></figure>

<p>$* 与 $@ 区别：</p>
<ul>
<li>相同点：都是引用所有参数。</li>
<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li>
</ul>
<h3 id="Shell数组"><a href="#Shell数组" class="headerlink" title="Shell数组"></a>Shell数组</h3><p>bash支持一维数组（<strong>不支持多维数组</strong>），并且没有限定数组的大小。</p>
<h4 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h4><p>在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">array_name=(value1 value2 value3)</span><br><span class="line"></span><br><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>单独定义：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></table></figure>

<p><strong>可以不使用连续的下标</strong>，而且下标的范围没有限制。</p>
<h4 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h4><p>获取数组长度的方法与获取字符串长度的方法相同</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取得数组元素的个数</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[@]&#125;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[*]&#125;</span></span><br><span class="line"><span class="comment"># 取得数组单个元素的长度</span></span><br><span class="line">lengthn=<span class="variable">$&#123;#array_name[n]&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=(1 2 3 5 7 183 37)</span><br><span class="line">length=<span class="variable">$&#123;#a[*]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$length</span>   <span class="comment"># 输出7</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[1]&#125;</span>   <span class="comment"># 输出2</span></span><br><span class="line">a[10]=8			<span class="comment"># 增加一个元素，不按连续下标</span></span><br><span class="line">length=<span class="variable">$&#123;#a[@]&#125;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$length</span>	 <span class="comment"># 输出8</span></span><br><span class="line">singleLength=<span class="variable">$&#123;#a[5]&#125;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$singleLength</span>  <span class="comment"># 输出3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[10]&#125;</span>		<span class="comment"># 输出8</span></span><br></pre></td></tr></table></figure>



<h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p>
<p><strong>expr</strong> 是一款表达式计算工具，使用它能完成表达式的求值操作。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">val=`expr 2 + 2`  <span class="comment"># 反引号不是单引号 注意空格</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;两数之和为 : <span class="variable">$val</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p><code>a=10,b=20</code> </p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">加法</td>
<td align="left"><code>expr $a + $b</code> 结果为 30。</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">减法</td>
<td align="left"><code>expr $a - $b</code> 结果为 -10。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘法</td>
<td align="left"><code>expr $a \* $b</code> 结果为  200。</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">除法</td>
<td align="left"><code>expr $b / $a</code> 结果为 2。</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取余</td>
<td align="left"><code>expr $b % $a</code> 结果为 0。</td>
</tr>
<tr>
<td align="left">=</td>
<td align="left">赋值</td>
<td align="left"><code>a=$b</code> 把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td align="left">==</td>
<td align="left">相等。用于比较<strong>两个数字</strong>，相同则返回 true。</td>
<td align="left"><code>[ $a == $b ]</code> 返回 false。</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">不相等。用于比较<strong>两个数字</strong>，不相同则返回 true。</td>
<td align="left"><code>[ $a != $b ]</code> 返回 true。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>条件表达式要放在方括号之间，并且要有空格，例如: <strong><code>[$a==$b]</code></strong> 是错误的，必须写成 <strong><code>[ $a == $b ]</code></strong></p>
<p>乘号(*)前边必须加反斜杠()才能实现乘法运算；</p>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>关系运算符<strong>只支持数字，不支持字符串，除非字符串的值是数字</strong>。</p>
<p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-eq</td>
<td align="left">检测两个数是否相等，相等返回 true。</td>
<td align="left"><code>[ $a -eq $b ]</code> 返回 false。</td>
</tr>
<tr>
<td align="left">-ne</td>
<td align="left">检测两个数是否不相等，不相等返回 true。</td>
<td align="left"><code>[ $a -ne $b ]</code> 返回 true。</td>
</tr>
<tr>
<td align="left">-gt</td>
<td align="left">检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td align="left"><code>[ $a -gt $b ]</code> 返回 false。</td>
</tr>
<tr>
<td align="left">-lt</td>
<td align="left">检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td align="left"><code>[ $a -lt $b ]</code> 返回 true。</td>
</tr>
<tr>
<td align="left">-ge</td>
<td align="left">检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td align="left"><code>[ $a -ge $b ]</code> 返回 false。</td>
</tr>
<tr>
<td align="left">-le</td>
<td align="left">检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td align="left"><code>[ $a -le $b ]</code> 返回 true。</td>
</tr>
</tbody></table>
<h4 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">!</td>
<td align="left">非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td align="left"><code>[ ! false ]</code> 返回 true。</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">或运算，有一个表达式为 true 则返回 true。</td>
<td align="left"><code>[ $a -lt 20 -o $b -gt 100 ]</code> 返回 true。</td>
</tr>
<tr>
<td align="left">-a</td>
<td align="left">与运算，两个表达式都为 true 才返回 true。</td>
<td align="left"><code>[ $a -lt 20 -a $b -gt 100 ]</code> 返回 false。</td>
</tr>
</tbody></table>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">逻辑的 AND</td>
<td align="left"><code>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</code> 返回 false</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">逻辑的 OR</td>
<td align="left">`[[ $a -lt 100</td>
</tr>
</tbody></table>
<h4 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h4><p>假定变量 a 为 “abc”，变量 b 为 “efg”：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">检测两个字符串是否相等，相等返回 true。</td>
<td align="left"><code>[ $a = $b ]</code> 返回 false。</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">检测两个字符串是否不相等，不相等返回 true。</td>
<td align="left"><code>[ $a != $b ]</code> 返回 true。</td>
</tr>
<tr>
<td align="left">-z</td>
<td align="left">检测字符串长度是否为0，为0返回 true。</td>
<td align="left"><code>[ -z $a ]</code> 返回 false。</td>
</tr>
<tr>
<td align="left">-n</td>
<td align="left">检测字符串长度是否不为 0，不为 0 返回 true。</td>
<td align="left"><code>[ -n &quot;$a&quot; ]</code> 返回 true。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">检测字符串是否为空，不为空返回 true。</td>
<td align="left"><code>[ $a ]</code> 返回 true。</td>
</tr>
</tbody></table>
<h4 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h4><table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-b file</td>
<td align="left">检测文件是否是块设备文件，如果是，则返回 true。</td>
<td align="left">[ -b $file ] 返回 false</td>
</tr>
<tr>
<td align="left">-c file</td>
<td align="left">检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td align="left">[ -c $file ] 返回 false</td>
</tr>
<tr>
<td align="left">-d file</td>
<td align="left">检测文件是否是目录，如果是，则返回 true。</td>
<td align="left">[ -d $file ] 返回 false</td>
</tr>
<tr>
<td align="left">-f file</td>
<td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td align="left">[ -f $file ] 返回 true</td>
</tr>
<tr>
<td align="left">-g file</td>
<td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
<td align="left">[ -g $file ] 返回 false</td>
</tr>
<tr>
<td align="left">-k file</td>
<td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
<td align="left">[ -k $file ] 返回 false</td>
</tr>
<tr>
<td align="left">-p file</td>
<td align="left">检测文件是否是有名管道，如果是，则返回 true。</td>
<td align="left">[ -p $file ] 返回 false</td>
</tr>
<tr>
<td align="left">-u file</td>
<td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td align="left">[ -u $file ] 返回 false</td>
</tr>
<tr>
<td align="left">-r file</td>
<td align="left">检测文件是否可读，如果是，则返回 true。</td>
<td align="left">[ -r $file ] 返回 true</td>
</tr>
<tr>
<td align="left">-w file</td>
<td align="left">检测文件是否可写，如果是，则返回 true。</td>
<td align="left">[ -w $file ] 返回 true</td>
</tr>
<tr>
<td align="left">-x file</td>
<td align="left">检测文件是否可执行，如果是，则返回 true。</td>
<td align="left">[ -x $file ] 返回 true</td>
</tr>
<tr>
<td align="left">-s file</td>
<td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>
<td align="left">[ -s $file ] 返回 true</td>
</tr>
<tr>
<td align="left">-e file</td>
<td align="left">检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td align="left">[ -e $file ] 返回 true</td>
</tr>
</tbody></table>
<p>其他检查符：</p>
<ul>
<li><strong>-S</strong>: 判断某文件是否 socket。</li>
<li><strong>-L</strong>: 检测文件是否存在并且是一个符号链接。</li>
</ul>
<h3 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h3><p>用于字符串的输出。命令格式：<code>echo string</code></p>
<p><strong>显示普通字符串:</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;It is a test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> It is a <span class="built_in">test</span> <span class="comment"># 这里双引号省略效果一样</span></span><br></pre></td></tr></table></figure>

<p><strong>显示转义字符</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\&quot;It is a test\&quot;&quot;</span>  <span class="comment"># 双引号也可以省略</span></span><br><span class="line"><span class="comment"># 输出结果：&quot;It is a test&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>显示变量</strong></p>
<p><code>read</code> 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;value_name&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">read</span> name </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$name</span> It is a test&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OK                     #标准输入</span><br><span class="line">OK It is a test        #输出</span><br></pre></td></tr></table></figure>

<p><strong>显示换行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;OK! \n&quot;</span> <span class="comment"># -e 开启转义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;It is a test&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OK!</span><br><span class="line"></span><br><span class="line">It is a test</span><br></pre></td></tr></table></figure>

<p><strong>显示不换行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;OK! \c&quot;</span> <span class="comment"># -e 开启转义 \c 不换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;It is a test&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OK! It is a test</span><br></pre></td></tr></table></figure>

<p><strong>显示结果定向至文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;It is a test&quot;</span> &gt; myfile  <span class="comment"># 文件不存在则创建文件，存在则情况再写入 两个 &gt;&gt; 是追加</span></span><br></pre></td></tr></table></figure>

<p><strong>原样输出字符串</strong>：使用单引号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$name\&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$name\&quot;</span><br></pre></td></tr></table></figure>

<p><strong>显示命令执行结果</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> `date`</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022年 03月 19日 星期六 17:52:04 CST  </span><br></pre></td></tr></table></figure>



<h3 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h3><p>printf 命令模仿 C 程序库（library）里的 printf() 程序</p>
<p>printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。</p>
<p>printf 使用引用文本或空格分隔的参数，外面可以在 <strong>printf</strong> 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认的 printf 不会像 <strong>echo</strong> 自动添加换行符，我们可以手动添加<strong>\n</strong>。</p>
<p>printf 命令的语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>  format-string  [arguments...]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li><strong>format-string:</strong> 为格式控制字符串</li>
<li><strong>arguments:</strong> 为参数列表。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4s\n&quot;</span> 姓名 性别 体重kg   <span class="comment"># 双引号也可以</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%-10s %-8s %-4.2f\n&#x27;</span> 郭靖 男 66.1234  <span class="comment"># 单引号也可以</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> <span class="string">&quot;杨过&quot;</span> 男 48.6555  <span class="comment"># 要输出的字符串可以用引号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-6s\n&quot;</span> 郭芙 女 47.9876   <span class="comment"># 将47.9876做字符串输出</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">姓名     性别   体重kg</span><br><span class="line">郭靖     男      66.12</span><br><span class="line">杨过     男      48.66   # 四舍五入</span><br><span class="line">郭芙     女      47.9876</span><br></pre></td></tr></table></figure>

<p><strong>%s %c %d %f</strong> 都是格式替代符，<strong>％s</strong> 输出一个字符串，<strong>％d</strong> 整型输出，<strong>％c</strong> 输出一个字符，<strong>％f</strong> 输出实数，以小数形式输出。</p>
<p><strong>%-10s</strong> 指一个宽度为 10 个字符（**-** 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p>
<p><strong>%-4.2f</strong> 指格式化为小数，其中 <strong>.2</strong> 指保留2位小数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%s\n&quot;</span> abc def </span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%s %s %s\n&quot;</span> a b c d e f h i j</span><br><span class="line"><span class="comment"># 如果没有arguments，那么 %s 用NULL代替，%d用0代替</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%s and %d\n&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">def</span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">h i j</span><br><span class="line"> and 0</span><br></pre></td></tr></table></figure>

<p><strong>转义序列</strong></p>
<table>
<thead>
<tr>
<th align="left">序列</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\a</td>
<td align="left">警告字符，通常为ASCII的BEL字符</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">后退</td>
</tr>
<tr>
<td align="left">\c</td>
<td align="left">抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页（formfeed）</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车（Carriage return）</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">水平制表符</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">垂直制表符</td>
</tr>
<tr>
<td align="left">\\</td>
<td align="left">一个字面上的反斜杠字符</td>
</tr>
<tr>
<td align="left">\ddd</td>
<td align="left">表示1到3位数八进制值的字符。仅在格式字符串中有效</td>
</tr>
<tr>
<td align="left">\0ddd</td>
<td align="left">表示1到3位的八进制值字符</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yang@Ubuntu18:~$ <span class="built_in">printf</span> <span class="string">&quot;a string, no processing:&lt;%b&gt;\n&quot;</span> <span class="string">&quot;A\nB&quot;</span></span><br><span class="line">a string, no processing:&lt;A</span><br><span class="line">B&gt;</span><br></pre></td></tr></table></figure>

<p><strong>%b</strong>：开启转义字符</p>
<h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3><p> test 命令用于检查某个条件是否成立，它可以进行<strong>数值、字符和文件</strong>三个方面的测试</p>
<h4 id="数值测试"><a href="#数值测试" class="headerlink" title="数值测试"></a>数值测试</h4><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-eq</td>
<td align="left">等于则为真</td>
</tr>
<tr>
<td align="left">-ne</td>
<td align="left">不等于则为真</td>
</tr>
<tr>
<td align="left">-gt</td>
<td align="left">大于则为真</td>
</tr>
<tr>
<td align="left">-ge</td>
<td align="left">大于等于则为真</td>
</tr>
<tr>
<td align="left">-lt</td>
<td align="left">小于则为真</td>
</tr>
<tr>
<td align="left">-le</td>
<td align="left">小于等于则为真</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">n1=10</span><br><span class="line">n2=10</span><br><span class="line">n3=20</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$n1</span> == <span class="variable">$n2</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;相等&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$n2</span> != <span class="variable">$n3</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;不等&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> $[n1+n2] -eq $[n3]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&#x27;相等&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;不等&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相等</span><br><span class="line">不等</span><br><span class="line">相等</span><br></pre></td></tr></table></figure>



<h4 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h4><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">等于则为真</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">不相等则为真</td>
</tr>
<tr>
<td align="left">-z 字符串</td>
<td align="left">字符串的长度为零则为真</td>
</tr>
<tr>
<td align="left">-n 字符串</td>
<td align="left">字符串的长度不为零则为真</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">n1=<span class="string">&quot;cainiaojiaocheng&quot;</span></span><br><span class="line">n2=<span class="string">&quot;cainaojiaocheng&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$n1</span> == <span class="variable">$n2</span>; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;字符串相等&quot;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span> -n <span class="variable">$n1</span>; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;n1=<span class="variable">$n1</span>,长度不为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n1=cainiaojiaocheng,长度不为空</span><br></pre></td></tr></table></figure>

<h4 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h4><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-e 文件名</td>
<td align="left">如果文件存在则为真</td>
</tr>
<tr>
<td align="left">-r 文件名</td>
<td align="left">如果文件存在且可读则为真</td>
</tr>
<tr>
<td align="left">-w 文件名</td>
<td align="left">如果文件存在且可写则为真</td>
</tr>
<tr>
<td align="left">-x 文件名</td>
<td align="left">如果文件存在且可执行则为真</td>
</tr>
<tr>
<td align="left">-s 文件名</td>
<td align="left">如果文件存在且至少有一个字符则为真</td>
</tr>
<tr>
<td align="left">-d 文件名</td>
<td align="left">如果文件存在且为目录则为真</td>
</tr>
<tr>
<td align="left">-f 文件名</td>
<td align="left">如果文件存在且为普通文件则为真</td>
</tr>
<tr>
<td align="left">-c 文件名</td>
<td align="left">如果文件存在且为字符型特殊文件则为真</td>
</tr>
<tr>
<td align="left">-b 文件名</td>
<td align="left">如果文件存在且为块特殊文件则为真</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> /bin</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -e ./bash</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;文件已存在!&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;文件不存在!&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /bin</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -e ./notFile -o -e ./bash</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;至少有一个文件存在!&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;两个文件都不存在&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件已存在</span><br><span class="line">至少有一个文件存在!</span><br></pre></td></tr></table></figure>



<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	....</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">elif</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>写成一行（适用于终端命令提示符）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi</span><br></pre></td></tr></table></figure>

<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> 1 23 3 5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">23</span><br><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>写成一行（适用于终端命令提示符）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for str in a bc c d; do echo $str; done;</span><br></pre></td></tr></table></figure>

<p>搭配括号扩展使用<code>&#123;&#125;</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> &#123;1..10..3&#125;; <span class="keyword">do</span> <span class="comment"># 从1到10，逐增3</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> alph <span class="keyword">in</span> &#123;a..z&#125;; <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$alph</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 一行行输出26个英文字母</span></span><br></pre></td></tr></table></figure>

<p><code>&#123;&#125;</code>也可以枚举</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> &#123;2,a,4,fe,35&#125;; <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>



<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>while 循环用于不断执行一系列命令，也用于从输入文件中读取数据。其语法格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">int=1</span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$int</span>&lt;5 ))  <span class="comment"># 一定要两个括号</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$int</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">&quot;int++&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>



<h4 id="until"><a href="#until" class="headerlink" title="until"></a>until</h4><p>until 循环执行一系列命令直至条件为 true 时停止。</p>
<p>until 循环与 while 循环<strong>在处理方式上刚好相反</strong>。</p>
<p>一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</p>
<p>until 语法格式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">until condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=0</span><br><span class="line">until [ ! <span class="variable">$a</span> -lt 10 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">   a=`expr <span class="variable">$a</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>



<h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p><strong>case … esac</strong> 为多选择语句，与其他语言中的 switch … case 语句类似，是一种多分支选择结构，每个 case 分支用右圆括号开始，用两个分号 <strong>;;</strong> 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记</p>
<p>可以用 case 语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。</p>
<p><strong>case … esac</strong> 语法格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 值 <span class="keyword">in</span></span><br><span class="line">模式1)</span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line">    ;;</span><br><span class="line">模式2)</span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>无一匹配模式，使用星号 <code>*</code>（类似<code>default</code>）捕获该值，再执行后面的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;输入1到4之间的数字：&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你输入的数字为：&quot;</span></span><br><span class="line"><span class="built_in">read</span> aNum</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">	1) <span class="built_in">echo</span> <span class="string">&quot;你选择了1&quot;</span>;;</span><br><span class="line">	2) <span class="built_in">echo</span> <span class="string">&quot;你选择了2&quot;</span>;;</span><br><span class="line">	3) <span class="built_in">echo</span> <span class="string">&quot;你选择了3&quot;</span>;;</span><br><span class="line">	4) <span class="built_in">echo</span> <span class="string">&quot;你选择了4&quot;</span>;;</span><br><span class="line">	*) <span class="built_in">echo</span> <span class="string">&quot;你没有输入1到4之间的数字&quot;</span>;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入 1 到 4 之间的数字:</span><br><span class="line">你输入的数字为:</span><br><span class="line">3</span><br><span class="line">你选择了 3</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">site=<span class="string">&quot;runoob&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$site</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">   <span class="string">&quot;runoob&quot;</span>) <span class="built_in">echo</span> <span class="string">&quot;菜鸟教程&quot;</span></span><br><span class="line">   ;;</span><br><span class="line">   <span class="string">&quot;google&quot;</span>) <span class="built_in">echo</span> <span class="string">&quot;Google 搜索&quot;</span></span><br><span class="line">   ;;</span><br><span class="line">   <span class="string">&quot;taobao&quot;</span>) <span class="built_in">echo</span> <span class="string">&quot;淘宝网&quot;</span></span><br><span class="line">   ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">菜鸟教程</span><br></pre></td></tr></table></figure>



<h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( ; ; ))</span><br></pre></td></tr></table></figure>



<h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>break命令允许跳出当前所在循环，类似C/C++的break，但break后面加数字可以跳出外层循环，例<code>break 2</code>，跳出当前循环的外层循环</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">&quot;输入 1 到 5 之间的数字:&quot;</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">&quot;你输入的数字为 <span class="variable">$aNum</span>!&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入 1 到 5 之间的数字:3</span><br><span class="line">你输入的数字为 3!</span><br><span class="line">输入 1 到 5 之间的数字:7</span><br><span class="line">你输入的数字不是 1 到 5 之间的! 游戏结束</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> (( var=1 ; <span class="variable">$var</span>&lt;4 ; var=$[ <span class="variable">$var</span>+1 ] ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;外层循环：var=&quot;</span> <span class="variable">$var</span></span><br><span class="line">        <span class="keyword">for</span> (( i=1 ; <span class="variable">$i</span>&lt;4 ; i++ ))</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;内层循环：i=&quot;</span> <span class="variable">$i</span></span><br><span class="line">                <span class="keyword">if</span> [ <span class="variable">$i</span> == 2 ]; <span class="keyword">then</span></span><br><span class="line">                        <span class="built_in">echo</span> <span class="string">&quot;内层循环结束&quot;</span></span><br><span class="line">                        <span class="built_in">break</span> 2; <span class="comment"># break 或 break 1 跳出的是当前循环</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外层循环：var= 1</span><br><span class="line">内层循环：i= 1</span><br><span class="line">内层循环：i= 2</span><br><span class="line">内层循环结束</span><br></pre></td></tr></table></figure>



<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">&quot;输入 1 到 5 之间的数字: &quot;</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">&quot;你输入的数字为 <span class="variable">$aNum</span>!&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;你输入的数字不是 1 到 5 之间的!&quot;</span></span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;游戏结束&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 <strong>echo “游戏结束”</strong> 永远不会被执行。</p>
<h3 id><a href="#" class="headerlink" title="[]"></a>[]</h3><p><code>[]</code> 内执行基本的算术运算，如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=5nan</span><br><span class="line">b=6</span><br><span class="line">result=$[a+b] <span class="comment"># 注意等号两边不能有空格</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;result 为： <span class="variable">$result</span>&quot;</span></span><br><span class="line">result=$[6+12] <span class="comment"># 注意等号两边不能有空格</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;result 为： <span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result 为： 11</span><br><span class="line">result 为： 18</span><br></pre></td></tr></table></figure>



<h3 id="Shell函数"><a href="#Shell函数" class="headerlink" title="Shell函数"></a>Shell函数</h3><p>shell中函数的定义格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li>
<li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;第一个参数为 <span class="variable">$1</span> !&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;第二个参数为 <span class="variable">$2</span> !&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$10</span> !&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;第十个参数为 <span class="variable">$&#123;10&#125;</span> !&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;第十一个参数为 <span class="variable">$&#123;11&#125;</span> !&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;参数总数有 <span class="variable">$#</span> 个!&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;作为一个字符串输出所有参数 $* !&quot;</span></span><br><span class="line">        <span class="built_in">return</span> $[ <span class="variable">$1</span>+<span class="variable">$2</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func 1 2 3 4 5 6 7 8 9 10 11</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;函数的返回值：$?&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个参数为 1 !</span><br><span class="line">第二个参数为 2 !</span><br><span class="line">第十个参数为 10 !</span><br><span class="line">第十个参数为 10 !</span><br><span class="line">第十一个参数为 11 !</span><br><span class="line">参数总数有 11 个!</span><br><span class="line">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 10 11 !</span><br><span class="line">函数的返回值：3</span><br></pre></td></tr></table></figure>

<p>注意，$10 不能获取第十个参数，获取第十个参数需要​${10}。当n&gt;=10时，需要使用​${n}来获取参数。</p>
<p>shell的0表示true，其它代表false</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World !&quot;</span> | grep -e Hello</span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World !&quot;</span> | grep -e Bye</span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">echo</span> <span class="string">&quot;Hello World !&quot;</span> | grep -e Hello</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">echo</span> <span class="string">&quot;Hello World !&quot;</span> | grep -e Bye</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">demoFun1</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">demoFun2</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> 12</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> demoFun1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> demoFun2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World !</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">Hello World !</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>



<h3 id="输入-输出重定向"><a href="#输入-输出重定向" class="headerlink" title="输入/输出重定向"></a>输入/输出重定向</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">command &gt; file</td>
<td align="left">将输出重定向到 file。</td>
</tr>
<tr>
<td align="left">command &lt; file</td>
<td align="left">将输入重定向到 file。</td>
</tr>
<tr>
<td align="left">command &gt;&gt; file</td>
<td align="left">将输出以追加的方式重定向到 file。</td>
</tr>
<tr>
<td align="left">n &gt; file</td>
<td align="left">将文件描述符为 n 的文件重定向到 file。</td>
</tr>
<tr>
<td align="left">n &gt;&gt; file</td>
<td align="left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td>
</tr>
<tr>
<td align="left">n &gt;&amp; m</td>
<td align="left">将输出文件 m 和 n 合并。</td>
</tr>
<tr>
<td align="left">n &lt;&amp; m</td>
<td align="left">将输入文件 m 和 n 合并。</td>
</tr>
<tr>
<td align="left">&lt;&lt; tag</td>
<td align="left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>
</tr>
</tbody></table>
<p><em>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yang@Ubuntu18:~$ who &gt; users</span><br><span class="line">yang@Ubuntu18:~$ cat users</span><br><span class="line">yang     tty2         2022-03-19 17:14</span><br><span class="line">yang     pts/2        2022-03-20 10:22 (10.132.6.192)</span><br><span class="line">yang@Ubuntu18:~$ wc -l &lt; users</span><br><span class="line">2</span><br><span class="line">yang@Ubuntu18:~$ <span class="built_in">read</span> val &lt; users</span><br><span class="line">yang@Ubuntu18:~$ <span class="built_in">echo</span> <span class="variable">$val</span></span><br><span class="line">yang tty2 2022-03-19 17:14</span><br><span class="line">yang@Ubuntu18:~$</span><br></pre></td></tr></table></figure>

<p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>
<ul>
<li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li>
<li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li>
<li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li>
</ul>
<p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<p>如果希望 stderr 重定向到 file，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command 2&gt;file</span><br></pre></td></tr></table></figure>

<p>如果希望 stderr 追加到 file 文件末尾，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command 2&gt;&gt;file</span><br></pre></td></tr></table></figure>

<p><strong>2</strong> 表示标准错误文件(stderr)。</p>
<p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command &gt; file 2&gt;&amp;1</span><br><span class="line">或者</span><br><span class="line">command &gt;&gt; file 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>如果希望对 stdin 和 stdout 都重定向，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command &lt; file1 &gt;file2</span><br></pre></td></tr></table></figure>

<p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p>
<h3 id="Here-Document"><a href="#Here-Document" class="headerlink" title="Here Document"></a>Here Document</h3><p>Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。</p>
<p>它的基本的形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command &lt;&lt; delimiter</span><br><span class="line">    document</span><br><span class="line">delimiter</span><br></pre></td></tr></table></figure>

<p>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p>
<blockquote>
<p>注意：</p>
<ul>
<li>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</li>
<li>开始的delimiter前后的空格会被忽略掉。</li>
</ul>
</blockquote>
<p>在命令行中通过 <strong>wc -l</strong> 命令计算 Here Document 的行数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wc -l &lt;&lt; EOF</span><br><span class="line">    欢迎来到</span><br><span class="line">    菜鸟教程</span><br><span class="line">    www.runoob.com</span><br><span class="line">EOF</span><br><span class="line">3          # 输出结果为 3 行</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>我们也可以将 Here Document 用在脚本中，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF</span><br><span class="line">欢迎来到</span><br><span class="line">菜鸟教程</span><br><span class="line">www.runoob.com</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>执行以上脚本，输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">欢迎来到</span><br><span class="line">菜鸟教程</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure>

<h3 id="dev-null-文件"><a href="#dev-null-文件" class="headerlink" title="/dev/null 文件"></a>/dev/null 文件</h3><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ command &gt; /dev/null</span><br></pre></td></tr></table></figure>

<p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p>
<p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ command &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
<p>这里的 <strong>2</strong> 和 <strong>&gt;</strong> 之间不可以有空格，<strong>2&gt;</strong> 是一体的时候才表示错误输出。</p>
</blockquote>
<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。</p>
<p>Shell 文件包含的语法格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. filename   <span class="comment"># 注意点号(.)和文件名中间有一空格</span></span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> filename</span><br></pre></td></tr></table></figure>

<p>例：创建两个shell脚本文件</p>
<p><code>include.sh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">url=<span class="string">&quot;http://www.runoob.com&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>testInclude.sh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#. ./include.sh </span></span><br><span class="line"><span class="built_in">source</span> ./include.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;菜鸟教程官网地址：<span class="variable">$url</span>&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">菜鸟教程官网地址：http://www.runoob.com</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基本的输入输出</title>
    <url>/C++%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>C++的输入输出</p>
<span id="more"></span>

<h2 id="C-基本的输入输出"><a href="#C-基本的输入输出" class="headerlink" title="C++ 基本的输入输出"></a><strong>C++</strong> <strong>基本的输入输出</strong></h2><p>C++ 标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。</p>
<p>C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做<strong>输入操作</strong>。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做<strong>输出操作</strong>。</p>
<p><strong>I/O 库头文件</strong></p>
<p>下列的头文件在 C++ 编程中很重要。</p>
<table>
<thead>
<tr>
<th><strong>头文件</strong></th>
<th><strong>函数和描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&lt;iostream&gt;</td>
<td>该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td>
</tr>
<tr>
<td>&lt;iomanip&gt;</td>
<td>该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I/O 有用的服务。</td>
</tr>
<tr>
<td>&lt;fstream&gt;</td>
<td>该文件为用户控制的文件处理声明服务。</td>
</tr>
</tbody></table>
<h3 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a><strong>标准输出流（cout）</strong></h3><p>预定义的对象 <strong>cout</strong> 是 <strong>iostream</strong> 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。<strong>cout</strong> 是与流插入运算符 &lt;&lt; 结合使用的。</p>
<p>C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</p>
<p>流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，<strong>endl</strong> 用于在行末添加一个换行符。</p>
<h3 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a><strong>标准输入流（cin）</strong></h3><p>预定义的对象 <strong>cin</strong> 是 <strong>iostream</strong> 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。<strong>cin</strong> 是与流提取运算符 &gt;&gt; 结合使用的。</p>
<p>C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。</p>
<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用。</p>
<h3 id="标准错误流（cerr）"><a href="#标准错误流（cerr）" class="headerlink" title="标准错误流（cerr）"></a><strong>标准错误流（cerr）</strong></h3><p>预定义的对象 <strong>cerr</strong> 是 <strong>iostream</strong> 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 <strong>cerr</strong> 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p>
<p><strong>cerr</strong> 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<p><strong>实例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[] = <span class="string">&quot;Unable to read....&quot;</span>;</span><br><span class="line"> </span><br><span class="line">   cerr &lt;&lt; <span class="string">&quot;Error message : &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error message : Unable to read....</span></span><br></pre></td></tr></table></figure>

<h3 id="标准日志流（clog）"><a href="#标准日志流（clog）" class="headerlink" title="标准日志流（clog）"></a><strong>标准日志流（clog）</strong></h3><p>预定义的对象 <strong>clog</strong> 是 <strong>iostream</strong> 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 <strong>clog</strong> 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。</p>
<p><strong>clog</strong> 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<p><strong>实例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[] = <span class="string">&quot;Unable to read....&quot;</span>;</span><br><span class="line"> </span><br><span class="line">   cerr &lt;&lt; <span class="string">&quot;Error message : &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error message : Unable to read....</span></span><br></pre></td></tr></table></figure>

<p>通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p>
<hr>
<h2 id="输出流中的函数"><a href="#输出流中的函数" class="headerlink" title="输出流中的函数"></a>输出流中的函数</h2><h3 id="输入输出流中的函数示例："><a href="#输入输出流中的函数示例：" class="headerlink" title="输入输出流中的函数示例："></a>输入输出流中的函数示例：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">setiosflags</span>(ios::left|ios::showpoint);  <span class="comment">// 设左对齐，以一般实数方式显示</span></span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">5</span>);       <span class="comment">// 设置除小数点外有五位有效数字 </span></span><br><span class="line">    cout&lt;&lt;<span class="number">123.456789</span>&lt;&lt;endl;</span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);          <span class="comment">// 设置显示域宽10 </span></span><br><span class="line">    cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);          <span class="comment">// 在显示区域空白处用*填充</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">resetiosflags</span>(ios::left);  <span class="comment">// 清除状态左对齐</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">setiosflags</span>(ios::right);   <span class="comment">// 设置右对齐</span></span><br><span class="line">    cout&lt;&lt;<span class="number">123.456789</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">setiosflags</span>(ios::left|ios::fixed);    <span class="comment">// 设左对齐，以固定小数位显示</span></span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">3</span>);    <span class="comment">// 设置实数显示三位小数</span></span><br><span class="line">    cout&lt;&lt;<span class="number">999.123456</span>&lt;&lt;endl; </span><br><span class="line">    cout&lt;&lt;<span class="built_in">resetiosflags</span>(ios::left|ios::fixed);  <span class="comment">//清除状态左对齐和定点格式</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">setiosflags</span>(ios::left|ios::scientific);    <span class="comment">//设置左对齐，以科学技术法显示 </span></span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">3</span>);   <span class="comment">//设置保留三位小数</span></span><br><span class="line">    cout&lt;&lt;<span class="number">123.45678</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试输出结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">123.46</span></span><br><span class="line">****<span class="number">123.46</span></span><br><span class="line"><span class="number">999.123</span></span><br><span class="line"><span class="number">1.235e+02</span></span><br></pre></td></tr></table></figure>

<p>其中 cout.setf 跟 setiosflags 一样，cout.precision 跟 setprecision 一样，cout.unsetf 跟 resetiosflags 一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setiosflags(ios::fixed) 固定的浮点显示 </span><br><span class="line">setiosflags(ios::scientific) 指数表示 </span><br><span class="line">setiosflags(ios::left) 左对齐 </span><br><span class="line">setiosflags(ios::right) 右对齐 </span><br><span class="line">setiosflags(ios::skipws) 忽略前导空白 </span><br><span class="line">setiosflags(ios::uppercase) 16进制数大写输出 </span><br><span class="line">setiosflags(ios::lowercase) 16进制小写输出 </span><br><span class="line">setiosflags(ios::showpoint) 强制显示小数点 </span><br><span class="line">setiosflags(ios::showpos) 强制显示符号 </span><br></pre></td></tr></table></figure>

<h3 id="cout-setf-常见的标志："><a href="#cout-setf-常见的标志：" class="headerlink" title="cout.setf 常见的标志："></a>cout.setf 常见的标志：</h3><table>
<thead>
<tr>
<th><strong>标志</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolalpha</td>
<td>可以使用单词”true”和”false”进行输入/输出的布尔值.</td>
</tr>
<tr>
<td>oct</td>
<td>用八进制格式显示数值.</td>
</tr>
<tr>
<td>dec</td>
<td>用十进制格式显示数值.</td>
</tr>
<tr>
<td>hex</td>
<td>用十六进制格式显示数值.</td>
</tr>
<tr>
<td>left</td>
<td>输出调整为左对齐.</td>
</tr>
<tr>
<td>right</td>
<td>输出调整为右对齐.</td>
</tr>
<tr>
<td>scientific</td>
<td>用科学记数法显示浮点数.</td>
</tr>
<tr>
<td>fixed</td>
<td>用正常的记数方法显示浮点数(与科学计数法相对应).</td>
</tr>
<tr>
<td>showbase</td>
<td>输出时显示所有数值的基数.</td>
</tr>
<tr>
<td>showpoint</td>
<td>显示小数点和额外的零，即使不需要.</td>
</tr>
<tr>
<td>showpos</td>
<td>在非负数值前面显示”＋（正号）”.</td>
</tr>
<tr>
<td>skipws</td>
<td>当从一个流进行读取时，跳过空白字符(spaces, tabs, newlines).</td>
</tr>
<tr>
<td>unitbuf</td>
<td>在每次插入以后，清空缓冲区.</td>
</tr>
<tr>
<td>internal</td>
<td>将填充字符回到符号和数值之间.</td>
</tr>
<tr>
<td>uppercase</td>
<td>以大写的形式显示科学记数法中的”e”和十六进制格式的”x”.</td>
</tr>
</tbody></table>
<h3 id="iostream-中定义的操作符："><a href="#iostream-中定义的操作符：" class="headerlink" title="iostream 中定义的操作符："></a>iostream 中定义的操作符：</h3><table>
<thead>
<tr>
<th><strong>操作符</strong></th>
<th><strong>描述</strong></th>
<th><strong>输入</strong></th>
<th><strong>输出</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolalpha</td>
<td>启用boolalpha标志</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>dec</td>
<td>启用dec标志</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>endl</td>
<td>输出换行标示，并清空缓冲区</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>ends</td>
<td>输出空字符</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>fixed</td>
<td>启用fixed标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>flush</td>
<td>清空流</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>hex</td>
<td>启用 hex 标志</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>internal</td>
<td>启用 internal 标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>left</td>
<td>启用 left 标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>noboolalpha</td>
<td>关闭boolalpha 标志</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>noshowbase</td>
<td>关闭showbase 标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>noshowpoint</td>
<td>关闭showpoint 标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>noshowpos</td>
<td>关闭showpos 标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>noskipws</td>
<td>关闭skipws 标志</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>nounitbuf</td>
<td>关闭unitbuf 标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>nouppercase</td>
<td>关闭uppercase 标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>oct</td>
<td>启用 oct 标志</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>right</td>
<td>启用 right 标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>scientific</td>
<td>启用 scientific 标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>showbase</td>
<td>启用 showbase 标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>showpoint</td>
<td>启用 showpoint 标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>showpos</td>
<td>启用 showpos 标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>skipws</td>
<td>启用 skipws 标志</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>unitbuf</td>
<td>启用 unitbuf 标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>uppercase</td>
<td>启用 uppercase 标志</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>ws</td>
<td>跳过所有前导空白字符</td>
<td>√</td>
<td></td>
</tr>
</tbody></table>
<h3 id="iomanip-中定义的操作符："><a href="#iomanip-中定义的操作符：" class="headerlink" title="iomanip 中定义的操作符："></a>iomanip 中定义的操作符：</h3><table>
<thead>
<tr>
<th><strong>操作符</strong></th>
<th><strong>描述</strong></th>
<th><strong>输入</strong></th>
<th><strong>输出</strong></th>
</tr>
</thead>
<tbody><tr>
<td>resetiosflags(long f)</td>
<td>关闭被指定为f的标志</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>setbase(int base)</td>
<td>设置数值的基本数为base</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>setfill(int ch)</td>
<td>设置填充字符为ch</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>setiosflags(long f)</td>
<td>启用指定为f的标志</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>setprecision(int p)</td>
<td>设置数值的精度(四舍五入)</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>setw(int w)</td>
<td>设置域宽度为w</td>
<td></td>
<td>√</td>
</tr>
</tbody></table>
<hr>
<p><strong>C++输入多个字符，中间用一个字符隔开</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;a;cin.<span class="built_in">get</span>();</span><br><span class="line">cin&gt;&gt;b;cin.<span class="built_in">get</span>();</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">输入 <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> 或者 <span class="number">1</span>a2b3都可以</span><br></pre></td></tr></table></figure>

<p>来自 <a href="https://www.runoob.com/cplusplus/cpp-basic-input-output.html">C++ 基本的输入输出 | 菜鸟教程 (runoob.com)</a></p>
<h2 id="cin详细介绍"><a href="#cin详细介绍" class="headerlink" title="cin详细介绍"></a><strong>cin详细介绍</strong></h2><p>在理解cin功能时，不得不提标准输入缓冲区。当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键(\r)会被转换为一个换行符\n，这个换行符\n也会被存储在cin的缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了123456这个字符串，然后敲一下回车键（\r）将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是7 ，而不是6。</p>
<p>cin读取数据也是从缓冲区中获取数据，缓冲区为空时，cin的成员函数会阻塞等待数据的到来，一旦缓冲区中有数据，就触发cin的成员函数去读取数据。</p>
<p>cin连续读入数据时，以==空格(32)，tab(9)，或换行符(10)==作为分隔符。</p>
<ul>
<li><strong>cin&gt;&gt;等价于cin.operator&gt;&gt;()</strong></li>
<li><strong>cin.get()</strong></li>
<li><strong>cin.getline()</strong></li>
</ul>
<p><strong>noskipws</strong>不忽略空白符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a, b;</span><br><span class="line">	cin&gt;&gt;noskipws&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;a:&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;b:&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入&quot;a b&quot;+回车</span><br><span class="line">输出b的值为空格，而不是&#x27;b&#x27;</span><br><span class="line">a:a</span><br><span class="line">b: </span><br><span class="line"></span><br><span class="line">输入a+回车</span><br><span class="line">输出b为回车</span><br><span class="line">a:a</span><br><span class="line">b:</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="cin-get的用法"><a href="#cin-get的用法" class="headerlink" title="cin.get的用法"></a>cin.get的用法</h3><p><strong>函数原型：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cin.<span class="built_in">get</span>();</span><br><span class="line">istream&amp; cin.<span class="built_in">get</span>(<span class="keyword">char</span>&amp; var);</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span> <span class="params">( <span class="keyword">char</span>* s, streamsize n)</span></span>; <span class="comment">// 默认换行符结束，n 表示目标空间大小</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span> <span class="params">( <span class="keyword">char</span>* s, streamsize n, <span class="keyword">char</span> delim)</span></span>; <span class="comment">// 指定结束符</span></span><br></pre></td></tr></table></figure>

<p>其中<strong>streamsize</strong>在VC++中被定义为<strong>long long</strong>型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">get</span> <span class="params">( streambuf&amp; sb)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span> <span class="params">( streambuf&amp; sb, <span class="keyword">char</span> delim )</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="cin-get读取一个字符"><a href="#cin-get读取一个字符" class="headerlink" title="cin.get读取一个字符"></a><strong>cin.get读取一个字符</strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a, b;</span><br><span class="line">    a=cin.<span class="built_in">get</span>();</span><br><span class="line">    cin.<span class="built_in">get</span>(b);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a:&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;b:&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c)。</p>
<h4 id="cin-get读取一行"><a href="#cin-get读取一行" class="headerlink" title="cin.get读取一行"></a><strong>cin.get读取一行</strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> array[<span class="number">20</span>]=&#123;<span class="literal">NULL</span>&#125;; </span><br><span class="line">    cin.<span class="built_in">get</span>(array,<span class="number">20</span>);</span><br><span class="line">    cin.<span class="built_in">get</span>(a);</span><br><span class="line">    cout&lt;&lt;array&lt;&lt;&quot; &quot;&lt;&lt;(<span class="keyword">int</span>)a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：只能读入C风格的字符串char *，不能是C++风格字符串string。</p>
<h3 id="cin-getline读取一行"><a href="#cin-getline读取一行" class="headerlink" title="cin.getline读取一行"></a><strong>cin.getline</strong>读取一行</h3><p><strong>函数原型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span>* s, streamsize count)</span></span>; <span class="comment">//默认以换行符结束</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span>* s, streamsize count, <span class="keyword">char</span> delim)</span></span>; <span class="comment">// 指定结束符</span></span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//C风格</span></span><br><span class="line">    <span class="keyword">char</span> array[<span class="number">20</span>]=&#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    cin.<span class="built_in">getline</span>(array,<span class="number">20</span>); <span class="comment">//或者指定结束符，使用下面一行</span></span><br><span class="line">    <span class="comment">//cin.getline(array,20,&#x27;\n&#x27;);</span></span><br><span class="line">    cout&lt;&lt;array&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：cin.getline与cin.get的区别是，cin.getline不会将结束符或者换行符残留在输入缓冲区中。</p>
<h3 id="cin的条件状态"><a href="#cin的条件状态" class="headerlink" title="cin的条件状态"></a><strong>cin的条件状态</strong></h3><p>使用cin读取键盘输入时，难免发生错误，一旦出错，cin将设置条件状态(condition state)。条件状态标识符号为:<br>goodbit:无错误<br>eofbit:已到达文件尾<br>failbit:非致命的输入/输出错误，可挽回<br>badbit:致命的输入/输出错误,无法挽回<br>若在输入输出类里.需要加ios::标识符号。与这些条件状态对应的就是设置、读取和判断条件状态的流对象的成员函数。他们主要有：<br>s.eof()：若流s的eofbit置位，则返回true；<br>s.fail()：若流s的failbit置位，则返回true；<br>s.bad()：若流s的badbit置位，则返回true；<br>s.good()：若流s的goodbit置位，则返回true；<br>s.clear(flags)：清空状态标志位，并将给定的标志位flags置为1，返回void。<br>s.setstate(flags)：根据给定的flags条件状态标志位，将流s中对应的条件状态位置为1，返回void。<br>s.rdstate()：返回流s的当前条件状态，返回值类型为strm::iostate。strm::iostate 机器相关的整形名,由各个iostream类定义,用于定义条件状态。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch, str[<span class="number">20</span>]; </span><br><span class="line">    cin.<span class="built_in">getline</span>(str, <span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;flag1:&quot;</span>&lt;&lt;cin.<span class="built_in">good</span>()&lt;&lt;endl;    <span class="comment">// 查看goodbit状态，即是否有异常</span></span><br><span class="line">    cin.<span class="built_in">clear</span>();                         <span class="comment">// 清除错误标志</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;flag1:&quot;</span>&lt;&lt;cin.<span class="built_in">good</span>()&lt;&lt;endl;    <span class="comment">// 清除标志后再查看异常状态</span></span><br><span class="line">    cin&gt;&gt;ch; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str:&quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ch :&quot;</span>&lt;&lt;ch&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\C++projects\命令行&gt;基本输入输出测试.exe</span><br><span class="line">12345</span><br><span class="line">flag1:0</span><br><span class="line">flag1:1</span><br><span class="line">str:1234</span><br><span class="line">ch :5</span><br><span class="line">请按任意键继续. . .</span><br><span class="line"></span><br><span class="line">E:\C++projects\命令行&gt;</span><br></pre></td></tr></table></figure>

<p>可以看出，因输入缓冲区未读取完造成输入异常，通过clear()可以清除输入流对象cin的异常状态。，不影响后面的cin&gt;&gt;ch从输入缓冲区读取数据。因为cin.getline读取之后，输入缓冲区中残留的字符串是：5[换行]，所以cin&gt;&gt;ch将5读取并存入ch，打印输入并输出5。</p>
<p>如果将clear()注释，cin&gt;&gt;ch;将读取失败，ch为空。</p>
<p>cin.clear()等同于cin.clear(ios::goodbit);因为cin.clear()的默认参数是ios::goodbit，所以不需显示传递，故而你最常看到的就是：cin.clear()。</p>
<h3 id="cin清空输入缓冲区"><a href="#cin清空输入缓冲区" class="headerlink" title="cin清空输入缓冲区"></a><strong>cin清空输入缓冲区</strong></h3><p>从上文中可以看出，上一次的输入操作很有可能是输入缓冲区中残留数据，影响下一次的输入。那么如何解决这个问题呢？自然而然，我们想到了在进行输入时，对输入缓冲区进行清空和状态条件的复位。条件状态的复位使用clear()，清空输入缓冲区应该使用：</p>
<p>函数原型：<code>istream &amp;ignore( streamsize num=1, int delim=EOF );</code></p>
<p>函数作用：跳过输入流中n个字符，或在遇到指定的终止字符时提前结束（此时跳过包括终止字符在内的若干字符）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">20</span>]=&#123;<span class="literal">NULL</span>&#125;,str2[<span class="number">20</span>]=&#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    cin.<span class="built_in">getline</span>(str1,<span class="number">5</span>);</span><br><span class="line">    cin.<span class="built_in">clear</span>();  <span class="comment">// 清除错误标志   </span></span><br><span class="line">    cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(),<span class="string">&#x27;\n&#x27;</span>); <span class="comment">//清除缓冲区的当前行</span></span><br><span class="line">    cin.<span class="built_in">getline</span>(str2,<span class="number">20</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str1:&quot;</span>&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str2:&quot;</span>&lt;&lt;str2&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\C++projects\命令行&gt;基本输入输出测试.exe</span><br><span class="line">12345</span><br><span class="line">sgjeij</span><br><span class="line">str1:1234</span><br><span class="line">str2:sgjeij</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>程序中使用cin.ignore清空了输入缓冲区的当前行，使上次的输入残留下的数据没有影响到下一次的输入，这就是ignore()函数的主要作用。其中，numeric_limits::max()不过是头文件定义的流使用的最大值，你也可以用一个足够大的整数代替它。</p>
<p>如果想清空输入缓冲区，去掉换行符，使用：<code>cin.ignore(numeric_limits&lt; std::streamsize&gt;::max());</code> 清除cin里所有内容。</p>
<p><code>cin.ignore();</code> 当输入缓冲区没有数据时，也会阻塞等待数据的到来。</p>
<h2 id="其它标准输入读取一行"><a href="#其它标准输入读取一行" class="headerlink" title="其它标准输入读取一行"></a>其它标准输入读取一行</h2><h3 id="getline读取一行"><a href="#getline读取一行" class="headerlink" title="getline读取一行"></a><strong>getline读取一行</strong></h3><p>C++中定义了一个在std名字空间的全局函数getline，因为这个getline函数的参数使用了string字符串，所以声明在了&lt;string&gt;头文件中了。</p>
<p>getline利用cin可以从标准输入设备键盘读取一行，当遇到如下三种情况会结束读操作：1）到文件结束，2）遇到函数的定界符，3）输入达到最大限度。</p>
<p><strong>函数原型</strong> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">( istream&amp; is, string&amp; str)</span></span>;<span class="comment">//默认以换行符结束</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">( istream&amp; is, string&amp; str, <span class="keyword">char</span> delim)</span></span>; <span class="comment">// 指定结束符</span></span><br></pre></td></tr></table></figure>

<p><strong>示例</strong> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,str);</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\C++projects\命令行&gt;基本输入输出测试.exe</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> ：</p>
<p>getline遇到结束符时，会将结束符一并读入指定的string中，再将结束符替换为空字符。因此，进行从键盘读取一行字符时，建议使用getline，较为安全。但是，最好还是要进行标准输入的安全检查，提高程序容错能力。</p>
<p>getline不会忽略分隔符，若键盘缓冲区存在分隔符，会读入，字符串为空。</p>
<p>cin.getline()类似，但是cin.getline()属于istream流，而getline()属于string流，是不一样的两个函数。</p>
<h3 id="gets读取一行"><a href="#gets读取一行" class="headerlink" title="gets读取一行"></a>gets读取一行</h3><p>gets是C中的库函数，在&lt;stdio.h&gt;声明，C++是&lt;cstdio&gt;库，从标准输入设备读字符串，可以无限读取，不会判断上限，以回车结束或者EOF时停止读取，所以程序员应该确保buffer的空间足够大，以便在执行读操作时不发生溢出。<br>函数原型：<code>char *gets( char *buffer );</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> array[<span class="number">20</span>]=&#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">gets</span>(array);</span><br><span class="line">    cout&lt;&lt;array&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    <span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来自 ： <a href="https://blog.csdn.net/qq_17368865/article/details/79769332">(14条消息) C++中cin的详细用法_独行Freedom的博客-CSDN博客_cin的用法</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>翻金币游戏</title>
    <url>/CoinFlip/</url>
    <content><![CDATA[<p>学习自黑马程序员的QT项目之翻金币</p>
<span id="more"></span>

<h2 id="CoinFlip"><a href="#CoinFlip" class="headerlink" title="CoinFlip"></a>CoinFlip</h2><h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><h4 id="mainscene-h"><a href="#mainscene-h" class="headerlink" title="mainscene.h"></a>mainscene.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINSCENE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINSCENE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chooselevelscene.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainScene</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainScene</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainScene</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">MainScene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写paintEvent事件 或背景图</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainScene *ui;</span><br><span class="line">    ChooseLevelScene *chooseLevelScene = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINSCENE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="mainscene-cpp"><a href="#mainscene-cpp" class="headerlink" title="mainscene.cpp"></a>mainscene.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mainscene.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ui_mainscene.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mypushbutton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSound&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainScene::<span class="built_in">MainScene</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainScene)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置主场景</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置窗口标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;翻金币&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置固定大小</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">320</span>, <span class="number">588</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置窗体左上角图标</span></span><br><span class="line">    <span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/res/Coin0001.png&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;actionQuit, &amp;QAction::triggered, [=]()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备点击开始按钮的音效</span></span><br><span class="line">    QSound *startSound = <span class="keyword">new</span> <span class="built_in">QSound</span>(<span class="string">&quot;:/res/TapButtonSound.wav&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始按钮</span></span><br><span class="line">    MyPushButton *startBtn = <span class="keyword">new</span> <span class="built_in">MyPushButton</span>(<span class="string">&quot;:/res/MenuSceneStartButton.png&quot;</span>);</span><br><span class="line">    startBtn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);  <span class="comment">//设定父亲</span></span><br><span class="line">    startBtn-&gt;<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;<span class="built_in">width</span>() * <span class="number">0.5</span> - startBtn-&gt;<span class="built_in">width</span>() * <span class="number">0.5</span>, <span class="keyword">this</span>-&gt;<span class="built_in">height</span>() * <span class="number">0.7</span>); <span class="comment">//设置按钮位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;chooseLevelScene = <span class="keyword">new</span> <span class="built_in">ChooseLevelScene</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按钮点击后 按钮跳到</span></span><br><span class="line">    <span class="built_in">connect</span>(startBtn, &amp;QPushButton::clicked, [=]()&#123;</span><br><span class="line">        startSound-&gt;<span class="built_in">play</span>(); <span class="comment">//播放音效</span></span><br><span class="line">        startBtn-&gt;<span class="built_in">zoomDown</span>(); <span class="comment">//向下跳</span></span><br><span class="line">        startBtn-&gt;<span class="built_in">zoomUp</span>();     <span class="comment">//向上跳</span></span><br><span class="line">        <span class="comment">//延时进入选择关卡</span></span><br><span class="line">        QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">        timer-&gt;<span class="built_in">start</span>(<span class="number">500</span>);</span><br><span class="line">        <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, [=]()&#123;</span><br><span class="line">            <span class="comment">//设置场景的出现位置和切换的窗口位置一致</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;chooseLevelScene-&gt;<span class="built_in">setGeometry</span>(<span class="keyword">this</span>-&gt;<span class="built_in">geometry</span>());</span><br><span class="line">            <span class="keyword">this</span>-&gt;chooseLevelScene-&gt;<span class="built_in">show</span>();</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//5.3版本不支持</span></span><br><span class="line"><span class="comment">//        QTimer::singleShot(500, this, [=]()&#123;</span></span><br><span class="line"><span class="comment">//            this-&gt;hide();</span></span><br><span class="line"><span class="comment">//            this-&gt;chooseLevelScene-&gt;show();</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听选择关卡的返回按钮的信号</span></span><br><span class="line">    <span class="built_in">connect</span>(chooseLevelScene, &amp;ChooseLevelScene::chooseSceneBack, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        chooseLevelScene-&gt;<span class="built_in">hide</span>();   <span class="comment">//将选择关卡场景 隐藏</span></span><br><span class="line">        <span class="comment">//设置场景的出现位置和切换的窗口位置一致</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(chooseLevelScene-&gt;<span class="built_in">geometry</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();               <span class="comment">//显示主场景</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainScene::~<span class="built_in">MainScene</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写paintEvent事件 或背景图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainScene::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建画家</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pix</span><span class="params">(<span class="string">&quot;:/res/PlayLevelSceneBg.png&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//设置起点0，0 和 图片的长高 使其铺满屏幕</span></span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">height</span>(), pix);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画背景上的图标</span></span><br><span class="line">    pix.<span class="built_in">load</span>(<span class="string">&quot;:/res/Title.png&quot;</span>);</span><br><span class="line">    <span class="comment">//图片长宽各缩一半</span></span><br><span class="line">    pix = pix.<span class="built_in">scaled</span>(pix.<span class="built_in">width</span>() * <span class="number">0.5</span>, pix.<span class="built_in">height</span>() * <span class="number">0.5</span>);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">10</span>, <span class="number">30</span>, pix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="选择关卡界面"><a href="#选择关卡界面" class="headerlink" title="选择关卡界面"></a>选择关卡界面</h3><h4 id="chooselevelscene-h"><a href="#chooselevelscene-h" class="headerlink" title="chooselevelscene.h"></a>chooselevelscene.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CHOOSELEVELSCENE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHOOSELEVELSCENE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;playscene.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChooseLevelScene</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ChooseLevelScene</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写绘图事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *)</span></span>;</span><br><span class="line"></span><br><span class="line">    PlayScene *playScene;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">//写一个自定义信号，告诉主场景 点击了返回</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chooseSceneBack</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CHOOSELEVELSCENE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="chooselevelscene-cpp"><a href="#chooselevelscene-cpp" class="headerlink" title="chooselevelscene.cpp"></a>chooselevelscene.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;chooselevelscene.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenu&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mypushbutton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSound&gt;</span></span></span><br><span class="line"></span><br><span class="line">ChooseLevelScene::<span class="built_in">ChooseLevelScene</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">320</span>, <span class="number">588</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;选择关卡场景&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/res/Coin0001.png&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建菜单栏</span></span><br><span class="line">    QMenuBar *menuBar = <span class="keyword">new</span> <span class="built_in">QMenuBar</span>();</span><br><span class="line">    <span class="built_in">setMenuBar</span>(menuBar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建开始菜单</span></span><br><span class="line">    QMenu *startMenu = menuBar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    <span class="comment">//退出</span></span><br><span class="line">    QAction *quitAction = startMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">    <span class="built_in">connect</span>(quitAction, &amp;QAction::triggered, [=]()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择关卡的音效</span></span><br><span class="line">    QSound *chooseSound = <span class="keyword">new</span> <span class="built_in">QSound</span>(<span class="string">&quot;:/res/TapButtonSound.wav&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//返回按钮的音效</span></span><br><span class="line">    QSound *backSound = <span class="keyword">new</span> <span class="built_in">QSound</span>(<span class="string">&quot;:/res/BackButtonSound.wav&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回按钮</span></span><br><span class="line">    MyPushButton *backBtn = <span class="keyword">new</span> <span class="built_in">MyPushButton</span>(<span class="string">&quot;:/res/BackButton.png&quot;</span>, <span class="string">&quot;:/res/BackButtonSelected.png&quot;</span>);</span><br><span class="line">    backBtn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    backBtn-&gt;<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;<span class="built_in">width</span>() - backBtn-&gt;<span class="built_in">width</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">height</span>() - backBtn-&gt;<span class="built_in">height</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点击返回</span></span><br><span class="line">    <span class="built_in">connect</span>(backBtn, &amp;QPushButton::clicked, [=]()&#123;</span><br><span class="line">        <span class="comment">//qDebug() &lt;&lt; &quot;点击了返回按钮&quot;;</span></span><br><span class="line">        <span class="comment">//播放返回按钮的音效</span></span><br><span class="line">        backSound-&gt;<span class="built_in">play</span>();</span><br><span class="line">        <span class="comment">//告诉主场景 返回 主场景监听ChooseLevelScene的返回按钮</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        emit <span class="built_in">chooseSceneBack</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建选择关卡的按钮</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        MyPushButton * menuBtn = <span class="keyword">new</span> <span class="built_in">MyPushButton</span>(<span class="string">&quot;:/res/LevelIcon.png&quot;</span>);</span><br><span class="line">        menuBtn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">        menuBtn-&gt;<span class="built_in">move</span>(<span class="number">25</span> + i % <span class="number">4</span> * <span class="number">70</span>, <span class="number">130</span> + i / <span class="number">4</span> * <span class="number">70</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//点击按钮，进入游戏界面</span></span><br><span class="line">        <span class="built_in">connect</span>(menuBtn, &amp;QPushButton::clicked, [=]()&#123;</span><br><span class="line">            <span class="comment">//播放选择关卡的音效</span></span><br><span class="line">            chooseSound-&gt;<span class="built_in">play</span>();</span><br><span class="line">            <span class="comment">//qDebug() &lt;&lt; &quot;这是第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;关&quot;;</span></span><br><span class="line">            playScene = <span class="keyword">new</span> <span class="built_in">PlayScene</span>(i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">            <span class="comment">//设置场景的出现位置和切换的窗口位置一致</span></span><br><span class="line">            playScene-&gt;<span class="built_in">setGeometry</span>(<span class="keyword">this</span>-&gt;<span class="built_in">geometry</span>());</span><br><span class="line">            playScene-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">connect</span>(playScene, &amp;PlayScene::playSceneBack, [=]()&#123;</span><br><span class="line">                <span class="comment">//设置场景的出现位置和切换的窗口位置一致</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="keyword">this</span>-&gt;<span class="built_in">geometry</span>());</span><br><span class="line">                <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">                <span class="keyword">delete</span> playScene;</span><br><span class="line">                playScene = <span class="literal">NULL</span>;</span><br><span class="line">                backSound-&gt;<span class="built_in">play</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(menuBtn);</span><br><span class="line">        label-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(i + <span class="number">1</span>));</span><br><span class="line">        label-&gt;<span class="built_in">setFixedSize</span>(menuBtn-&gt;<span class="built_in">width</span>(), menuBtn-&gt;<span class="built_in">height</span>());</span><br><span class="line">        <span class="comment">//设置文字对齐方式 水平居中 Qt::AlignHCenter  垂直居中Qt::AlignVCenter  中间Qt::AlignCenter</span></span><br><span class="line">        label-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//便签覆盖在按钮上，会挡住鼠标的点击，要设置label的属性为穿透鼠标事件</span></span><br><span class="line">        label-&gt;<span class="built_in">setAttribute</span>(Qt::WA_TransparentForMouseEvents);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写绘图事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChooseLevelScene::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//加载背景</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">pix</span><span class="params">(<span class="string">&quot;:/res/OtherSceneBg.png&quot;</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">height</span>(), pix);</span><br><span class="line">    <span class="comment">//加载标题</span></span><br><span class="line">    pix.<span class="built_in">load</span>(<span class="string">&quot;:/res/Title.png&quot;</span>);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>((<span class="keyword">this</span>-&gt;<span class="built_in">width</span>() - pix.<span class="built_in">width</span>()) * <span class="number">0.5</span>, <span class="number">30</span>, pix.<span class="built_in">width</span>(), pix.<span class="built_in">height</span>(), pix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="翻金币界面"><a href="#翻金币界面" class="headerlink" title="翻金币界面"></a>翻金币界面</h3><h4 id="playscene-h"><a href="#playscene-h" class="headerlink" title="playscene.h"></a>playscene.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PLAYSCENE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLAYSCENE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mycoin.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSound&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayScene</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//explicit PlayScene(QWidget *parent = 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">PlayScene</span>(<span class="keyword">int</span> levelNum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写paintEvent事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//游戏地图</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameMap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//翻转金币</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">turnCoin</span><span class="params">(MyCoin *coin)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否胜利</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">justWin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//胜利的动画</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">animationOfWin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> levelIndex; <span class="comment">//记录关卡号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> gameArray[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    MyCoin *coinBtn[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isAnimation = <span class="literal">false</span>; <span class="comment">//是否有金币正在翻转，金币翻转时不能点击</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isWin = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    QLabel *winLabel; <span class="comment">//胜利的图片</span></span><br><span class="line"></span><br><span class="line">    QSound *flipSound; <span class="comment">//点击音乐的音效</span></span><br><span class="line"></span><br><span class="line">    QSound *backSound; <span class="comment">//点击返回的音效</span></span><br><span class="line"></span><br><span class="line">    QSound *winSound; <span class="comment">//胜利的音效</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playSceneBack</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// PLAYSCENE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="playscene-cpp"><a href="#playscene-cpp" class="headerlink" title="playscene.cpp"></a>playscene.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;playscene.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QIcon&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mypushbutton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFont&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mycoin.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dataconfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPropertyAnimation&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//PlayScene::PlayScene(QWidget *parent) :</span></span><br><span class="line"><span class="comment">//    QWidget(parent)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">PlayScene::<span class="built_in">PlayScene</span>(<span class="keyword">int</span> levelNum)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;levelIndex = levelNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化游戏场景</span></span><br><span class="line">    <span class="comment">//设置固定大小</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">320</span>, <span class="number">588</span>);</span><br><span class="line">    <span class="comment">//设置图标</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/res/Coin0001.png&quot;</span>));</span><br><span class="line">    <span class="comment">//设置标题</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;翻金币场景&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建菜单栏</span></span><br><span class="line">    QMenuBar *menuBar = <span class="keyword">new</span> <span class="built_in">QMenuBar</span>();</span><br><span class="line">    <span class="built_in">setMenuBar</span>(menuBar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建开始菜单</span></span><br><span class="line">    QMenu *startMenu = menuBar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    <span class="comment">//退出</span></span><br><span class="line">    QAction *quitAction = startMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">    <span class="built_in">connect</span>(quitAction, &amp;QAction::triggered, [=]()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//胜利的音效</span></span><br><span class="line">    winSound = <span class="keyword">new</span> <span class="built_in">QSound</span>(<span class="string">&quot;:/res/LevelWinSound.wav&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//点击金币的音效</span></span><br><span class="line">    flipSound = <span class="keyword">new</span> <span class="built_in">QSound</span>(<span class="string">&quot;:/res/ConFlipSound.wav&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//返回按钮的音效</span></span><br><span class="line">    backSound = <span class="keyword">new</span> <span class="built_in">QSound</span>(<span class="string">&quot;:/res/BackButtonSound.wav&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回按钮</span></span><br><span class="line">    MyPushButton *backBtn = <span class="keyword">new</span> <span class="built_in">MyPushButton</span>(<span class="string">&quot;:/res/BackButton.png&quot;</span>, <span class="string">&quot;:/res/BackButtonSelected.png&quot;</span>);</span><br><span class="line">    backBtn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    backBtn-&gt;<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;<span class="built_in">width</span>() - backBtn-&gt;<span class="built_in">width</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">height</span>() - backBtn-&gt;<span class="built_in">height</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点击返回</span></span><br><span class="line">    <span class="built_in">connect</span>(backBtn, &amp;QPushButton::clicked, [=]()&#123;</span><br><span class="line">        <span class="comment">//由于点击返回按钮之后，选择关卡页面会把该游戏界面的内存释放掉，速度很快，所以听不到返回音效</span></span><br><span class="line">        backSound-&gt;<span class="built_in">play</span>(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//告诉主场景 返回 主场景监听ChooseLevelScene的返回按钮</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        emit <span class="built_in">playSceneBack</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//设置字体</span></span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setFamily</span>(<span class="string">&quot;华文新魏&quot;</span>);</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">20</span>);  <span class="comment">//设置字号</span></span><br><span class="line">    QString str = <span class="built_in">QString</span>(<span class="string">&quot;Level: %1&quot;</span>).<span class="built_in">arg</span>(<span class="keyword">this</span>-&gt;levelIndex);<span class="comment">//显示的文字</span></span><br><span class="line">    <span class="comment">//将字体设置到标签控件中</span></span><br><span class="line">    label-&gt;<span class="built_in">setFont</span>(font);</span><br><span class="line">    label-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">    <span class="comment">//设置标签位置</span></span><br><span class="line">    label-&gt;<span class="built_in">setGeometry</span>(<span class="built_in">QRect</span>(<span class="number">30</span>, <span class="keyword">this</span>-&gt;<span class="built_in">height</span>() - <span class="number">50</span>, <span class="number">150</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化游戏地图</span></span><br><span class="line">    dataConfig data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            gameArray[i][j] = data.mData[<span class="keyword">this</span>-&gt;levelIndex][i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//胜利的标签和图片</span></span><br><span class="line">    winLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QPixmap <span class="title">pix</span><span class="params">(<span class="string">&quot;:/res/LevelCompletedDialogBg.png&quot;</span>)</span></span>;</span><br><span class="line">    winLabel-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, pix.<span class="built_in">width</span>(), pix.<span class="built_in">height</span>()); <span class="comment">//标签大小</span></span><br><span class="line">    winLabel-&gt;<span class="built_in">setPixmap</span>(pix); <span class="comment">//设置图片</span></span><br><span class="line">    winLabel-&gt;<span class="built_in">move</span>((<span class="keyword">this</span>-&gt;<span class="built_in">width</span>() - pix.<span class="built_in">width</span>()) * <span class="number">0.5</span>, -pix.<span class="built_in">height</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gameMap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlayScene::gameMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//显示金币背景图案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//绘制背景图片</span></span><br><span class="line">            QLabel *label = <span class="keyword">new</span> QLabel;</span><br><span class="line">            <span class="function">QPixmap <span class="title">pix</span><span class="params">(<span class="string">&quot;:/res/BoardNode.png&quot;</span>)</span></span>;</span><br><span class="line">            label-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, pix.<span class="built_in">width</span>(), pix.<span class="built_in">height</span>());</span><br><span class="line">            label-&gt;<span class="built_in">setPixmap</span>(pix);</span><br><span class="line">            label-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">            label-&gt;<span class="built_in">move</span>(<span class="number">57</span> + i * <span class="number">50</span>, <span class="number">200</span> + j * <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建金币</span></span><br><span class="line">            QString str = <span class="built_in">QString</span>(<span class="string">&quot;:/res/Coin0001.png&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(gameArray[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                str = <span class="string">&quot;:/res/Coin0008.png&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            MyCoin *coin = <span class="keyword">new</span> <span class="built_in">MyCoin</span>(str);</span><br><span class="line">            <span class="comment">//给金币属性赋值</span></span><br><span class="line">            coin-&gt;posX = i;</span><br><span class="line">            coin-&gt;posY = j;</span><br><span class="line">            coin-&gt;flag = gameArray[i][j];   <span class="comment">//1正面 0反面</span></span><br><span class="line">            coin-&gt;<span class="built_in">setParent</span>(label);</span><br><span class="line">            coin-&gt;<span class="built_in">move</span>((label-&gt;<span class="built_in">width</span>() - coin-&gt;<span class="built_in">width</span>()) * <span class="number">0.5</span>, (label-&gt;<span class="built_in">height</span>() - coin-&gt;<span class="built_in">height</span>()) * <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将金币放入到金币的二维数组，以便后期 的维护</span></span><br><span class="line">            coinBtn[i][j] = coin;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//监听金币是否翻转</span></span><br><span class="line">            <span class="built_in">connect</span>(coin, &amp;QPushButton::clicked, [=]()&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;isAnimation || isWin) <span class="keyword">return</span>;</span><br><span class="line">                flipSound-&gt;<span class="built_in">play</span>(); <span class="comment">//播放金币翻转的音效</span></span><br><span class="line">                <span class="built_in">turnCoin</span>(coin); <span class="comment">//翻转金币</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">justWin</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">animationOfWin</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//翻转金币</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlayScene::turnCoin</span><span class="params">(MyCoin *coin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;isAnimation = <span class="literal">true</span>;</span><br><span class="line">    coin-&gt;<span class="built_in">changeFlag</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//翻转周围硬币操作</span></span><br><span class="line">    <span class="keyword">if</span>(coin-&gt;posX + <span class="number">1</span> &lt; <span class="number">4</span>) <span class="comment">//右侧金币</span></span><br><span class="line">    &#123;</span><br><span class="line">        coinBtn[coin-&gt;posX + <span class="number">1</span>][coin-&gt;posY]-&gt;<span class="built_in">changeFlag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(coin-&gt;posX - <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="comment">//左侧金币</span></span><br><span class="line">    &#123;</span><br><span class="line">        coinBtn[coin-&gt;posX - <span class="number">1</span>][coin-&gt;posY]-&gt;<span class="built_in">changeFlag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(coin-&gt;posY + <span class="number">1</span> &lt; <span class="number">4</span>) <span class="comment">//下方金币</span></span><br><span class="line">    &#123;</span><br><span class="line">        coinBtn[coin-&gt;posX][coin-&gt;posY + <span class="number">1</span>]-&gt;<span class="built_in">changeFlag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(coin-&gt;posY - <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="comment">//上方金币</span></span><br><span class="line">    &#123;</span><br><span class="line">        coinBtn[coin-&gt;posX][coin-&gt;posY - <span class="number">1</span>]-&gt;<span class="built_in">changeFlag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;isAnimation = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否胜利</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PlayScene::justWin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断是否胜利</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;isWin = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(coinBtn[i][j]-&gt;flag == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;isWin = <span class="literal">false</span>;</span><br><span class="line">                i = <span class="number">4</span>; <span class="comment">// 跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;isWin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//胜利的特效</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlayScene::animationOfWin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    winSound-&gt;<span class="built_in">play</span>(); <span class="comment">//播放胜利的音效</span></span><br><span class="line">    <span class="comment">//动效</span></span><br><span class="line">    QPropertyAnimation *animation = <span class="keyword">new</span> <span class="built_in">QPropertyAnimation</span>(winLabel, <span class="string">&quot;geometry&quot;</span>);</span><br><span class="line">    <span class="comment">//设置时间间隔</span></span><br><span class="line">    animation-&gt;<span class="built_in">setDuration</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//设置起始位置</span></span><br><span class="line">    animation-&gt;<span class="built_in">setStartValue</span>(<span class="built_in">QRect</span>(winLabel-&gt;<span class="built_in">x</span>(), winLabel-&gt;<span class="built_in">y</span>(), winLabel-&gt;<span class="built_in">width</span>(), winLabel-&gt;<span class="built_in">height</span>()));</span><br><span class="line">    <span class="comment">//设置终点位置</span></span><br><span class="line">    animation-&gt;<span class="built_in">setEndValue</span>(<span class="built_in">QRect</span>(winLabel-&gt;<span class="built_in">x</span>(), winLabel-&gt;<span class="built_in">y</span>() + <span class="number">114</span>, winLabel-&gt;<span class="built_in">width</span>(), winLabel-&gt;<span class="built_in">height</span>()));</span><br><span class="line">    <span class="comment">//设置缓和曲线</span></span><br><span class="line">    animation-&gt;<span class="built_in">setEasingCurve</span>(QEasingCurve::OutBounce);</span><br><span class="line">    <span class="comment">//执行动画</span></span><br><span class="line">    animation-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写paintEvent事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlayScene::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    QPixmap pix;</span><br><span class="line">    pix.<span class="built_in">load</span>(<span class="string">&quot;:/res/PlayLevelSceneBg.png&quot;</span>);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">height</span>(), pix);</span><br><span class="line">    <span class="comment">//加载标题</span></span><br><span class="line">    pix.<span class="built_in">load</span>(<span class="string">&quot;:/res/Title.png&quot;</span>);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>((<span class="keyword">this</span>-&gt;<span class="built_in">width</span>() - pix.<span class="built_in">width</span>()) * <span class="number">0.5</span>, <span class="number">30</span>, pix.<span class="built_in">width</span>(), pix.<span class="built_in">height</span>(), pix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="自定义按钮"><a href="#自定义按钮" class="headerlink" title="自定义按钮"></a>自定义按钮</h3><h4 id="mypushbutton-h"><a href="#mypushbutton-h" class="headerlink" title="mypushbutton.h"></a>mypushbutton.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYPUSHBUTTON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYPUSHBUTTON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPushButton</span> :</span> <span class="keyword">public</span> QPushButton</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//explicit MyPushButton(QWidget *parent = 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数 参数1 正常显示的图片路径   参数2 按下后显示的图片路径</span></span><br><span class="line">    <span class="built_in">MyPushButton</span>(QString normalImg, QString pressImg = <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按钮图片和大小</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initPushButton</span><span class="params">(QString pixPath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按钮弹跳特效</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">zoomUp</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">zoomDown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写按钮 按下 和 释放事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *e)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString normalImgPath;</span><br><span class="line">    QString pressImgPath;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYPUSHBUTTON_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="mypushbutton-cpp"><a href="#mypushbutton-cpp" class="headerlink" title="mypushbutton.cpp"></a>mypushbutton.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mypushbutton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPropertyAnimation&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MyPushButton::MyPushButton(QWidget *parent) :</span></span><br><span class="line"><span class="comment">//    QWidget(parent)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">MyPushButton::<span class="built_in">MyPushButton</span>(QString normalImg, QString pressImg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;normalImgPath = normalImg;</span><br><span class="line">    <span class="keyword">this</span>-&gt;pressImgPath = pressImg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置按钮图片和大小</span></span><br><span class="line">    <span class="built_in">initPushButton</span>(normalImg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按钮图片和大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPushButton::initPushButton</span><span class="params">(QString pixPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPixmap pix;</span><br><span class="line">    <span class="keyword">bool</span> ret = pix.<span class="built_in">load</span>(pixPath);</span><br><span class="line">    <span class="keyword">if</span>(!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;图片加载失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置按钮固定大小</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(pix.<span class="built_in">width</span>(), pix.<span class="built_in">height</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置不规则图片样式</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton&#123;border:0px;&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置图标</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setIcon</span>(pix);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置图标大小</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(pix.<span class="built_in">width</span>(), pix.<span class="built_in">height</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向下跳</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPushButton::zoomDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建动态对象</span></span><br><span class="line">    QPropertyAnimation *animation = <span class="keyword">new</span> <span class="built_in">QPropertyAnimation</span>(<span class="keyword">this</span>, <span class="string">&quot;geometry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置动画时间间隔</span></span><br><span class="line">    animation-&gt;<span class="built_in">setDuration</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//起始位置</span></span><br><span class="line">    animation-&gt;<span class="built_in">setStartValue</span>(<span class="built_in">QRect</span>(<span class="keyword">this</span>-&gt;<span class="built_in">x</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">y</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">width</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">height</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束位置</span></span><br><span class="line">    animation-&gt;<span class="built_in">setEndValue</span>(<span class="built_in">QRect</span>(<span class="keyword">this</span>-&gt;<span class="built_in">x</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">y</span>() + <span class="number">10</span>, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">height</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置弹跳效果</span></span><br><span class="line">    animation-&gt;<span class="built_in">setEasingCurve</span>(QEasingCurve::OutElastic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行动画</span></span><br><span class="line">    animation-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向上跳</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPushButton::zoomUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建动态对象</span></span><br><span class="line">    QPropertyAnimation *animation = <span class="keyword">new</span> <span class="built_in">QPropertyAnimation</span>(<span class="keyword">this</span>, <span class="string">&quot;geometry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置动画时间间隔</span></span><br><span class="line">    animation-&gt;<span class="built_in">setDuration</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//起始位置</span></span><br><span class="line">    animation-&gt;<span class="built_in">setStartValue</span>(<span class="built_in">QRect</span>(<span class="keyword">this</span>-&gt;<span class="built_in">x</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">y</span>() + <span class="number">10</span>, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">height</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束位置</span></span><br><span class="line">    animation-&gt;<span class="built_in">setEndValue</span>(<span class="built_in">QRect</span>(<span class="keyword">this</span>-&gt;<span class="built_in">x</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">y</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">width</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">height</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置弹跳效果</span></span><br><span class="line">    animation-&gt;<span class="built_in">setEasingCurve</span>(QEasingCurve::OutElastic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行动画</span></span><br><span class="line">    animation-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPushButton::mousePressEvent</span><span class="params">(QMouseEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pressImgPath != <span class="string">&quot;&quot;</span>) <span class="comment">//传入的按下图片不为空 说明需要有按下状态 切换图片</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">initPushButton</span>(<span class="keyword">this</span>-&gt;pressImgPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> QPushButton::<span class="built_in">mousePressEvent</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPushButton::mouseReleaseEvent</span><span class="params">(QMouseEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pressImgPath != <span class="string">&quot;&quot;</span>) <span class="comment">//传入的按下图片不为空 说明需要有按下状态 切换图片</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">initPushButton</span>(<span class="keyword">this</span>-&gt;normalImgPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> QPushButton::<span class="built_in">mouseReleaseEvent</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="金币类"><a href="#金币类" class="headerlink" title="金币类"></a>金币类</h3><h4 id="mycoin-h"><a href="#mycoin-h" class="headerlink" title="mycoin.h"></a>mycoin.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYCOIN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYCOIN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCoin</span> :</span> <span class="keyword">public</span> QPushButton</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//explicit MyCoin(QWidget *parent = 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyCoin</span>(QString btnImg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置金币图片</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initCoinPicture</span><span class="params">(QString path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> posX;   <span class="comment">//x坐标</span></span><br><span class="line">    <span class="keyword">int</span> posY;   <span class="comment">//y坐标</span></span><br><span class="line">    <span class="keyword">bool</span> flag;  <span class="comment">//正反标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//改变标志的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeFlag</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    QTimer *postToNega;  <span class="comment">//正面翻反面的定时器</span></span><br><span class="line">    QTimer *negaToPost;  <span class="comment">//反面翻正面的定时器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isAnimation = <span class="literal">false</span>;   <span class="comment">//正在翻转动画</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYCOIN_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="mycoin-cpp"><a href="#mycoin-cpp" class="headerlink" title="mycoin.cpp"></a>mycoin.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mycoin.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MyCoin::MyCoin(QWidget *parent) :</span></span><br><span class="line"><span class="comment">//    QPushButton(parent)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">MyCoin::<span class="built_in">MyCoin</span>(QString btnImg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">initCoinPicture</span>(btnImg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化定时器对象</span></span><br><span class="line">    postToNega = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    negaToPost = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听正面翻反面的信号，并翻转金币</span></span><br><span class="line">    <span class="built_in">connect</span>(postToNega, &amp;QTimer::timeout, [=]()&#123;</span><br><span class="line">        QString str = <span class="built_in">QString</span>(<span class="string">&quot;:/res/Coin000%1&quot;</span>).<span class="built_in">arg</span>(<span class="keyword">this</span>-&gt;min++);</span><br><span class="line">        <span class="built_in">initCoinPicture</span>(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;min &gt; <span class="keyword">this</span>-&gt;max)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;isAnimation = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;min = <span class="number">1</span>;</span><br><span class="line">            postToNega-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听正面翻反面的信号，并翻转金币</span></span><br><span class="line">    <span class="built_in">connect</span>(negaToPost, &amp;QTimer::timeout, [=]()&#123;</span><br><span class="line">        QString str = <span class="built_in">QString</span>(<span class="string">&quot;:/res/Coin000%1&quot;</span>).<span class="built_in">arg</span>(<span class="keyword">this</span>-&gt;max--);</span><br><span class="line">        <span class="built_in">initCoinPicture</span>(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;max &lt; <span class="keyword">this</span>-&gt;min)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;isAnimation = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;max = <span class="number">8</span>;</span><br><span class="line">            negaToPost-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCoin::initCoinPicture</span><span class="params">(QString path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPixmap pix;</span><br><span class="line">    <span class="keyword">bool</span> ret = pix.<span class="built_in">load</span>(path);</span><br><span class="line">    <span class="keyword">if</span>(!ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; path &lt;&lt; <span class="string">&quot;图片加载失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置按钮大小</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(pix.<span class="built_in">width</span>(), pix.<span class="built_in">height</span>());</span><br><span class="line">    <span class="comment">//设置图片样式</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton&#123;border:0px;&#125;&quot;</span>);</span><br><span class="line">    <span class="comment">//按钮添加图片</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setIcon</span>(pix);</span><br><span class="line">    <span class="comment">//设置图片大小</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(pix.<span class="built_in">width</span>(), pix.<span class="built_in">height</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变标志的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCoin::changeFlag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;isAnimation)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;isAnimation = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;flag)</span><br><span class="line">    &#123;</span><br><span class="line">        postToNega-&gt;<span class="built_in">start</span>(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        negaToPost-&gt;<span class="built_in">start</span>(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;flag = !flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="游戏地图数据"><a href="#游戏地图数据" class="headerlink" title="游戏地图数据"></a>游戏地图数据</h3><h4 id="dataconfig-h"><a href="#dataconfig-h" class="headerlink" title="dataconfig.h"></a>dataconfig.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATACONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATACONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dataConfig</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">dataConfig</span><span class="params">(QObject *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    QMap&lt;<span class="keyword">int</span>, QVector&lt; QVector&lt;<span class="keyword">int</span>&gt; &gt; &gt;mData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DATACONFIG_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="dataconfig-cpp"><a href="#dataconfig-cpp" class="headerlink" title="dataconfig.cpp"></a>dataconfig.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dataconfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line">dataConfig::<span class="built_in">dataConfig</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array1[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125; &#125; ;</span><br><span class="line"></span><br><span class="line">     QVector&lt; QVector&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">         &#123;</span><br><span class="line">            v1.<span class="built_in">push_back</span>(array1[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">         v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">1</span>,v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array2[<span class="number">4</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                          &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                          &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                          &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125; ;</span><br><span class="line"></span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array2[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">2</span>,v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array3[<span class="number">4</span>][<span class="number">4</span>] = &#123;  &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array3[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">3</span>,v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array4[<span class="number">4</span>][<span class="number">4</span>] = &#123;   &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array4[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">4</span>,v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array5[<span class="number">4</span>][<span class="number">4</span>] = &#123;  &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array5[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">5</span>,v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array6[<span class="number">4</span>][<span class="number">4</span>] = &#123;   &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array6[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">6</span>,v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array7[<span class="number">4</span>][<span class="number">4</span>] = &#123;   &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array7[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">7</span>,v);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array8[<span class="number">4</span>][<span class="number">4</span>] = &#123;  &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array8[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">8</span>,v);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array9[<span class="number">4</span>][<span class="number">4</span>] = &#123;   &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array9[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">9</span>,v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array10[<span class="number">4</span>][<span class="number">4</span>] = &#123;  &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array10[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">10</span>,v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array11[<span class="number">4</span>][<span class="number">4</span>] = &#123;  &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array11[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">11</span>,v);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array12[<span class="number">4</span>][<span class="number">4</span>] = &#123;  &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array12[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">12</span>,v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array13[<span class="number">4</span>][<span class="number">4</span>] = &#123;    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                              &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                              &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                              &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array13[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">13</span>,v);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array14[<span class="number">4</span>][<span class="number">4</span>] = &#123;    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                              &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                              &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                              &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array14[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">14</span>,v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array15[<span class="number">4</span>][<span class="number">4</span>] = &#123;   &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                             &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                             &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                             &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array15[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">15</span>,v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array16[<span class="number">4</span>][<span class="number">4</span>] = &#123;   &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                             &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                             &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                             &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array16[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">16</span>,v);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array17[<span class="number">4</span>][<span class="number">4</span>] = &#123;  &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array17[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">17</span>,v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array18[<span class="number">4</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array18[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">18</span>,v);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array19[<span class="number">4</span>][<span class="number">4</span>] = &#123;   &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                             &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                             &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                             &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array19[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">19</span>,v);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> array20[<span class="number">4</span>][<span class="number">4</span>] = &#123;  &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125; ;</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          QVector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>;j++)</span><br><span class="line">          &#123;</span><br><span class="line">             v1.<span class="built_in">push_back</span>(array20[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mData.<span class="built_in">insert</span>(<span class="number">20</span>,v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//测试数据</span></span><br><span class="line"><span class="comment">//    for( QMap&lt;int, QVector&lt; QVector&lt;int&gt; &gt; &gt;::iterator it = mData.begin();it != mData.end();it++ )</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//         for(QVector&lt; QVector&lt;int&gt; &gt;::iterator it2 = (*it).begin(); it2!= (*it).end();it2++)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//            for(QVector&lt;int&gt;::iterator it3 = (*it2).begin(); it3 != (*it2).end(); it3++ )</span></span><br><span class="line"><span class="comment">//            &#123;</span></span><br><span class="line"><span class="comment">//                qDebug() &lt;&lt; *it3 ;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         qDebug() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><img src="/CoinFlip/image-20220314200636824.png" alt="image-20220314200636824" style="zoom: 80%;">

<img src="/CoinFlip/image-20220314201039691.png" alt="image-20220314201039691" style="zoom:80%;">

<img src="/CoinFlip/image-20220314201051661.png" alt="image-20220314201051661" style="zoom:80%;">]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT基础入门</title>
    <url>/QT%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>学习自黑马程序员&amp;传智教育</p>
<span id="more"></span>

<p>添加资源文件，图片视频等：</p>
<p>添加新文件 -》Qt -》 Qt资源文件 -》设定名称如：res </p>
<p>最后在项目栏出现 资源文件，资源下出现 res.qrc文件，右键 Open in Editor -》添加 -》添加前缀 如：/  -》然后就可以添加文件</p>
<p>.pro文件，类似VS项目的.sln文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-------------------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Project created by QtCreator 2022-03-09T11:26:42</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#-------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">QT       += core gui	<span class="comment"># Qt包含的模块 core 和 gui</span></span><br><span class="line"></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets <span class="comment"># 如果Qt版本大于4，包含模块widgets</span></span><br><span class="line"></span><br><span class="line">TARGET = myWiget	<span class="comment"># 目标 生成可执行文件的名称</span></span><br><span class="line">TEMPLATE = app		<span class="comment"># 模板 应用程序模板Application</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SOURCES += main.cpp\	<span class="comment"># 源文件名称</span></span><br><span class="line">        mywidget.cpp</span><br><span class="line"></span><br><span class="line">HEADERS  += mywidget.h	<span class="comment"># 头文件</span></span><br><span class="line"></span><br><span class="line">FORMS    += mywidget.ui</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mywidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span> <span class="comment">//包含一个应用程序类的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//程序入口  argc命令行变量的数量   argv命令行变量的数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a:应用程序对象，在Qt中，应用程序对象有且仅有一个</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//窗口对象，myWidget是QWidge的子类</span></span><br><span class="line">    myWidget w;</span><br><span class="line">    <span class="comment">//窗口对象默认不会显示，必须调用show方法</span></span><br><span class="line">    <span class="comment">//w.show();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//让应用程序对象进入消息循环</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>QT使用Lambda，在<code>.pro</code>文件中追加 <code>CONFIG    += c++11</code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line">QPushButton *mbtn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">QPushButton *mbtn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">mbtn1-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">mbtn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//mutable允许值传递的只读数据在lambda内可修改，但不会导致外部改变</span></span><br><span class="line"><span class="built_in">connect</span>(mbtn1, &amp;QPushButton::clicked, <span class="keyword">this</span>, [m]()<span class="keyword">mutable</span>&#123; m = <span class="number">100</span> + <span class="number">10</span>; <span class="built_in">qDebug</span>() &lt;&lt; m; &#125;);</span><br><span class="line"><span class="built_in">connect</span>(mbtn2, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123; <span class="built_in">qDebug</span>() &lt;&lt; m; &#125;);</span><br></pre></td></tr></table></figure>





<p>按钮<code>QPushButton</code> </p>
<p>继承关系：<code>QWidget &lt;- QAbstractButton &lt;- QPushButton</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//创建一个按钮</span></span><br><span class="line">QPushButton *btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line"><span class="comment">//btn-&gt;show();    //show以顶层方式弹出窗口控件</span></span><br><span class="line"><span class="comment">//让btn对象 依赖在主窗口中 设置父亲</span></span><br><span class="line">btn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//显示文本</span></span><br><span class="line">btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建第二个按钮，安装控件的大小创建窗口，需要设置窗口的大小</span></span><br><span class="line">QPushButton *btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//按钮重置大小</span></span><br><span class="line">btn2-&gt;<span class="built_in">resize</span>(<span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>



<p>对象树</p>
<p>构造重上向下，析构重下向上，一定程度上简化了内存的回收机制，前提要制定父亲<code>setParent()</code> </p>
<p><img src="/QT%E5%85%A5%E9%97%A8/image-20220309144838633.png" alt="image-20220309144838633"></p>
<h3 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h3><p>信号<code>signal</code>和槽<code>slot</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求 点击我的按钮 关闭窗口</span></span><br><span class="line"><span class="comment">//参数 信号的发送者 发送的信号（函数的地址） 信号的接收者  处理的槽函数</span></span><br><span class="line"><span class="built_in">connect</span>(myBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;myWidget::close);  <span class="comment">//信号连接</span></span><br></pre></td></tr></table></figure>

<p>自定义信号和槽</p>
<p>自定义信号：写到 <code>signals</code>下</p>
<ul>
<li>返回 void</li>
<li>需要声明，不需要实现</li>
<li>可以有参数，可以重载</li>
</ul>
<p>自定义槽函数：写到<code>public slot</code>下或 <code>public</code> 或者全局函数</p>
<ul>
<li>需要声明和实现</li>
<li>可以有参数，可以重载</li>
<li>返回 void</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Teacher.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hungry</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">//早期QT版本 必须写道public slots下，高级版本可以写到 public或者全局下</span></span><br><span class="line">    <span class="comment">//返回值  void 需要声明和实现</span></span><br><span class="line">    <span class="comment">//可以有参数，可以重载</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">treat</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student.cpp</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::treat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;请老师吃饭&quot;</span>;	<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//myWidget.cpp</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//创建一个老师对象</span></span><br><span class="line"><span class="keyword">this</span>-&gt;zt = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//创建一个学生对象</span></span><br><span class="line"><span class="keyword">this</span>-&gt;st = <span class="keyword">new</span> <span class="built_in">Student</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//老师饿了，学生请客的连接  //未重载时的写法</span></span><br><span class="line"><span class="built_in">connect</span>(zt, &amp;Teacher::hungry, st, &amp;Student::treat);</span><br><span class="line"><span class="built_in">classIsOver</span>();</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myWidget::classIsOver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//下课函数，调用后 触发老师饿了的信号</span></span><br><span class="line">    emit zt-&gt;<span class="built_in">hungry</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义信号和槽出现重载时</p>
<ul>
<li>利用函数指针明确函数地址 <code>void(Teacher::*tSignal)(QString) = &amp;Teacher::hungry()</code></li>
<li><code>QString</code> 转 <code>char*</code> ：先转成 <code>QByteArray</code> <code>.toUtf8()</code> 在转 <code>char*</code> <code>.data()</code> <ul>
<li><code>foodName.toUtf8().data()</code> </li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Teacher.h 增加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hungry</span><span class="params">(QString foodName)</span></span>;</span><br><span class="line"><span class="comment">//Student.h 增加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treat</span><span class="params">(QString foodName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;请老师吃：&quot;</span> &lt;&lt; foodName.<span class="built_in">toUtf8</span>().<span class="built_in">data</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//myWidget.cpp</span></span><br><span class="line"><span class="comment">//指针 -&gt; 地址  函数指针 -&gt; 函数地址   //重载后使用函数指针区分</span></span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (Teacher:: *teacherSignal)(QString) = &amp;Teacher::hungry;</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (Student:: *studentSlot)(QString) = &amp;Student::treat;</span><br><span class="line"><span class="built_in">connect</span>(zt, teacherSignal, st, studentSlot);</span><br><span class="line"><span class="built_in">classIsOver</span>();</span><br></pre></td></tr></table></figure>

<p>信号可以连接信号</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">void</span></span> (Teacher:: *teacherSignal2)() = &amp;Teacher::hungry;</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (Student:: *studentSlot2)() = &amp;Student::treat;</span><br><span class="line"><span class="built_in">connect</span>(zt, teacherSignal2, st, studentSlot2);	<span class="comment">//老师饿了的信号 连接 学生请客的信号</span></span><br><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, zt, teacherSignal2);<span class="comment">//按钮点击的信号 连接 老师饿了的信号</span></span><br></pre></td></tr></table></figure>

<p>信号可以断开<code>disconnect</code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(btn, &amp;QPushButton::clicked, zt, teacherSignal2);</span><br></pre></td></tr></table></figure>

<p>拓展</p>
<ul>
<li>1、信号是可以连接信号</li>
<li>2、一个信号可以连接多个槽函数</li>
<li>3、多个信号 可以连接 同一个槽函数</li>
<li>4、信号和槽函数的参数必须一一对应</li>
<li>5、信号的参数个数 可以多于 槽函数的参数，但前面的类型还是要对应</li>
<li>6、QT4版本的信号连接 <code>connect(zt, SIGNAL(hungry()), st, SLOT(treat()));</code> </li>
</ul>
<h3 id="窗口控件"><a href="#窗口控件" class="headerlink" title="窗口控件"></a>窗口控件</h3><p><strong>菜单栏，工具栏，状态栏，铆接部件，核心部件</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//1、菜单栏创建，最多只有一个</span></span><br><span class="line">   QMenuBar *bar = <span class="built_in">menuBar</span>();	<span class="comment">//注意，没有 new </span></span><br><span class="line">   <span class="built_in">setMenuBar</span>(bar);			<span class="comment">//注意：是set 不是 add</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建菜单</span></span><br><span class="line">   QMenu *fileMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">   QMenu *editMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;编辑&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建菜单项</span></span><br><span class="line">   QAction *newAction =  fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;新建&quot;</span>);</span><br><span class="line">   <span class="comment">//添加分隔线</span></span><br><span class="line">   fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">   QAction *openAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2、工具栏，可以有多个</span></span><br><span class="line">   QToolBar *toolBar = <span class="keyword">new</span> <span class="built_in">QToolBar</span>(<span class="keyword">this</span>);</span><br><span class="line">   <span class="built_in">addToolBar</span>(Qt::LeftToolBarArea, toolBar);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//设置移动（总开关）</span></span><br><span class="line">   toolBar-&gt;<span class="built_in">setMovable</span>(<span class="literal">false</span>);</span><br><span class="line">   <span class="comment">//设置停靠范围</span></span><br><span class="line">   toolBar-&gt;<span class="built_in">setAllowedAreas</span>(Qt::LeftToolBarArea | Qt::RightToolBarArea);</span><br><span class="line">   <span class="comment">//设置浮动</span></span><br><span class="line">   toolBar-&gt;<span class="built_in">setFloatable</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//工具栏中设置内容</span></span><br><span class="line">   toolBar-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line">   toolBar-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">   toolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">   <span class="comment">//工具栏中添加控件</span></span><br><span class="line">   QPushButton *btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;aa&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">   toolBar-&gt;<span class="built_in">addWidget</span>(btn);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、状态栏</span></span><br><span class="line">   QStatusBar *stBar = <span class="built_in">statusBar</span>();</span><br><span class="line">   <span class="comment">//设置到窗口中</span></span><br><span class="line">   <span class="built_in">setStatusBar</span>(stBar);</span><br><span class="line">   <span class="comment">//添加标签控件</span></span><br><span class="line">   QLabel * label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;提示信息&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">   stBar-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">   QLabel * label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;最右边&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">   stBar-&gt;<span class="built_in">addPermanentWidget</span>(label2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、铆接部件 浮动窗口 可以多个</span></span><br><span class="line">   QDockWidget *dockWidget = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;浮动&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">   <span class="comment">//设置到窗口中</span></span><br><span class="line">   <span class="built_in">addDockWidget</span>(Qt::BottomDockWidgetArea, dockWidget);</span><br><span class="line">   <span class="comment">//设置后期停靠区域，只允许上下</span></span><br><span class="line">   dockWidget-&gt;<span class="built_in">setAllowedAreas</span>(Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5、设置中心部件，只能一个</span></span><br><span class="line">   QTextEdit *textEdit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">   <span class="built_in">setCentralWidget</span>(textEdit);</span><br></pre></td></tr></table></figure>



<p><strong>按钮</strong></p>
<ul>
<li><strong>QPushButton：常用按钮</strong></li>
<li><strong>QToolButton：工具按钮</strong>，用于显示图片<ul>
<li>显示文字，修改 <code>toolButtonStytle</code> </li>
<li>凸起风格 <code>autoRaise</code></li>
</ul>
</li>
<li><strong>RadioButton：单选按钮</strong>，设置默认 <code>ui-&gt;按钮名称-&gt;setChecked(true);</code></li>
<li><strong>CheckBox：多选按钮</strong>，监听状态，2选择，0未选<ul>
<li>设置半选择 <code>tristate</code> 1半选</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置单选按钮 男默认选中</span></span><br><span class="line">ui-&gt;rBtnMan-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//选中女后 打印信息</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;rBtnWoman, &amp;QRadioButton::clicked, [=]()&#123;</span><br><span class="line">   <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;选中性别女&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//多选按钮  2 选中  0 未选中</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;cBox, &amp;QCheckBox::stateChanged, [=](<span class="keyword">int</span> state) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; state;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





<p><strong>QListWidget：列表容器</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    //利用listWidget写诗</span></span><br><span class="line"><span class="comment">//    QListWidgetItem * item = new QListWidgetItem(&quot;锄禾日当午&quot;);</span></span><br><span class="line"><span class="comment">//    //将一行诗放入到listWidget控件中</span></span><br><span class="line"><span class="comment">//    ui-&gt;listWidget-&gt;addItem(item);</span></span><br><span class="line"><span class="comment">//    //设置文本水平居中</span></span><br><span class="line"><span class="comment">//    item-&gt;setTextAlignment(Qt::AlignHCenter);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//QStringList  QList&lt;QString&gt;</span></span><br><span class="line">    QStringList list;</span><br><span class="line">    list &lt;&lt; &quot;锄禾日当午&quot; &lt;&lt; &quot;汗滴禾下土&quot; &lt;&lt; &quot;谁知盘中餐&quot; &lt;&lt; &quot;粒粒皆辛苦&quot; ;</span><br><span class="line">    ui-&gt;listWidget-&gt;<span class="built_in">addItems</span>(list);</span><br></pre></td></tr></table></figure>



<p><strong>QTreeWidget：树控件</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//设置水平头</span></span><br><span class="line">   ui-&gt;treeWidget-&gt;<span class="built_in">setHeaderLabels</span>(<span class="built_in">QStringList</span>() &lt;&lt; <span class="string">&quot;英雄&quot;</span> &lt;&lt; <span class="string">&quot;英雄介绍&quot;</span>);</span><br><span class="line"><span class="comment">//创建根结点</span></span><br><span class="line">   QTreeWidgetItem * liItem = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(<span class="built_in">QStringList</span>() &lt;&lt; <span class="string">&quot;力量&quot;</span>);</span><br><span class="line">   QTreeWidgetItem * miItem = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(<span class="built_in">QStringList</span>() &lt;&lt; <span class="string">&quot;敏捷&quot;</span>);</span><br><span class="line">   <span class="comment">//加载根节点</span></span><br><span class="line">   ui-&gt;treeWidget-&gt;<span class="built_in">addTopLevelItem</span>(liItem);</span><br><span class="line">   ui-&gt;treeWidget-&gt;<span class="built_in">addTopLevelItem</span>(miItem);</span><br><span class="line">   <span class="comment">//追加子结点</span></span><br><span class="line">   QStringList heroL1, heroL2;</span><br><span class="line">   heroL1 &lt;&lt; <span class="string">&quot;赵云&quot;</span> &lt;&lt; <span class="string">&quot;天美亲儿子&quot;</span>;</span><br><span class="line">   heroL2 &lt;&lt; <span class="string">&quot;李白&quot;</span> &lt;&lt; <span class="string">&quot;打野一哥&quot;</span>;</span><br><span class="line">   QTreeWidgetItem *l1 = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroL1);</span><br><span class="line">   QTreeWidgetItem *l2 = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroL2);</span><br><span class="line">   liItem-&gt;<span class="built_in">addChild</span>(l1);</span><br><span class="line">   liItem-&gt;<span class="built_in">addChild</span>(l2);</span><br></pre></td></tr></table></figure>



<p><strong>QTableWidget：表格控件</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//TableWidget 控件</span></span><br><span class="line">   <span class="comment">//设置列数</span></span><br><span class="line">   ui-&gt;tableWidget-&gt;<span class="built_in">setColumnCount</span>(<span class="number">3</span>);</span><br><span class="line">   <span class="comment">//设置水平表头</span></span><br><span class="line">   ui-&gt;tableWidget-&gt;<span class="built_in">setHorizontalHeaderLabels</span>(<span class="built_in">QStringList</span>() &lt;&lt; <span class="string">&quot;姓名&quot;</span> &lt;&lt; <span class="string">&quot;性别&quot;</span> &lt;&lt; <span class="string">&quot;年龄&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//设置行数</span></span><br><span class="line">   ui-&gt;tableWidget-&gt;<span class="built_in">setRowCount</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="comment">//设置正文</span></span><br><span class="line">   <span class="comment">//ui-&gt;tableWidget-&gt;setItem(0, 0, new QTableWidgetItem(&quot;亚瑟&quot;));</span></span><br><span class="line"><span class="comment">//批量设置表头</span></span><br><span class="line">   QStringList nameList;</span><br><span class="line">   nameList &lt;&lt; <span class="string">&quot;亚瑟&quot;</span> &lt;&lt; <span class="string">&quot;赵云&quot;</span> &lt;&lt; <span class="string">&quot;张飞&quot;</span> &lt;&lt; <span class="string">&quot;关羽&quot;</span> &lt;&lt; <span class="string">&quot;花木兰&quot;</span>;</span><br><span class="line">   QList&lt;QString&gt; sexList;</span><br><span class="line">   sexList &lt;&lt; <span class="string">&quot;男&quot;</span> &lt;&lt; <span class="string">&quot;男&quot;</span> &lt;&lt; <span class="string">&quot;男&quot;</span> &lt;&lt; <span class="string">&quot;男&quot;</span> &lt;&lt; <span class="string">&quot;女&quot;</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">       <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">       ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(i, col++, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(nameList[i]));</span><br><span class="line">       ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(i, col++, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(sexList[i]));</span><br><span class="line">       <span class="comment">//int 转 QString</span></span><br><span class="line">       ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(i, col++, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(QString::<span class="built_in">number</span>(i+<span class="number">18</span>)));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>其他控件</strong></p>
<ul>
<li><code>Stacked Widget</code> 栈控件 <code>ui-&gt;stackedWidget-&gt;setCurrentIndex(1);</code></li>
<li><code>combo Box</code> 下拉框 <code>ui-&gt;comboBox-&gt;addItem(&quot;奔驰&quot;);</code></li>
<li><code>QLable</code> 标签 <ul>
<li>显示图片 <code>ui-&gt;label_pic-&gt;setPixmap(QPixmap(&quot;:/Image/butterfly.png&quot;));</code></li>
<li>显示动图 <code>QMovie movie = new QMovie(&quot;路径&quot;); ui-&gt;lable_movie-&gt;setMovie(movie); movie-&gt;start();</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈控件的使用</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//设置默认定位 ScrollArea</span></span><br><span class="line">   ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//ScrollArea按钮</span></span><br><span class="line">   <span class="built_in">connect</span>(ui-&gt;btn_ScrollArea, &amp;QPushButton::clicked, [=]()&#123;</span><br><span class="line">       ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">2</span>);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//ToolBox按钮</span></span><br><span class="line">   <span class="built_in">connect</span>(ui-&gt;btn_ToolBox, &amp;QPushButton::clicked, [=]()&#123;</span><br><span class="line">       ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//TabWidget按钮</span></span><br><span class="line">   <span class="built_in">connect</span>(ui-&gt;btn_TabWidget, &amp;QPushButton::clicked, [=]()&#123;</span><br><span class="line">       ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//下拉框</span></span><br><span class="line">   ui-&gt;comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;奔驰&quot;</span>);</span><br><span class="line">   ui-&gt;comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;宝马&quot;</span>);</span><br><span class="line">   ui-&gt;comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;拖拉机&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//点击按钮 选择拖拉机选项</span></span><br><span class="line">   <span class="built_in">connect</span>(ui-&gt;btn_Select, &amp;QPushButton::clicked, [=]()&#123;</span><br><span class="line">       <span class="comment">//ui-&gt;comboBox-&gt;setCurrentIndex(2);</span></span><br><span class="line">       ui-&gt;comboBox-&gt;<span class="built_in">setCurrentText</span>(<span class="string">&quot;拖拉机&quot;</span>);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//利用QLabel显示图片</span></span><br><span class="line">   ui-&gt;label_Pic-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;E:/QT/HeiMa_jiaocheng/06_QtControl/Image/butterfly.png&quot;</span>));</span><br><span class="line">   <span class="comment">//利用QLabel显示动图</span></span><br><span class="line">   QMovie * movie = <span class="keyword">new</span> <span class="built_in">QMovie</span>(<span class="string">&quot;E:/QT/HeiMa_jiaocheng/06_QtControl/Image/mario.gif&quot;</span>);</span><br><span class="line">   ui-&gt;label_movie-&gt;<span class="built_in">setMovie</span>(movie);</span><br><span class="line">   <span class="comment">//播放动图</span></span><br><span class="line">   movie-&gt;<span class="built_in">start</span>();</span><br></pre></td></tr></table></figure>



<h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><p><strong>模态对话框、非模态对话框</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模态对话框  阻塞</span></span><br><span class="line"><span class="function">QDialog <span class="title">dlg</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">dlg.<span class="built_in">resize</span>(<span class="number">200</span>, <span class="number">100</span>);  <span class="comment">//默认的对话框窗体很小，输出栏会报错</span></span><br><span class="line">dlg.<span class="built_in">exec</span>(); <span class="comment">//因为这个函数，阻塞，所以该栈上的内存没被释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非模态对话框</span></span><br><span class="line"><span class="comment">//要用指针类型动态分配在堆区，不然的话对话框会在lambda表达式结束后消失 QDialog dlg2(this);不行</span></span><br><span class="line">QDialog *dlg2 = <span class="keyword">new</span> <span class="built_in">QDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">dlg2-&gt;<span class="built_in">resize</span>(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">dlg2-&gt;<span class="built_in">show</span>();</span><br><span class="line">dlg2-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);<span class="comment">//设置对话框在点击关闭按钮时释放堆区对象</span></span><br></pre></td></tr></table></figure>



<p><strong>消息对话框：</strong>模态，<code>QMessageBox</code>  </p>
<ul>
<li>错误对话框 <code>QMessageBox::critical</code></li>
<li>信息对话框 <code>QMessageBox::information</code></li>
<li>问题对话框 <code>QMessageBox::question</code></li>
<li>警告对话框 <code>QMessageBox::warning</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消息对话框：</span></span><br><span class="line"><span class="comment">//参数1 父亲  参数2 标题  参数3 提示内容  参数4 按键类型 参数5 默认关联回车按键  返回值StandardButton</span></span><br><span class="line"><span class="comment">//错误对话框</span></span><br><span class="line">QMessageBox::<span class="built_in">critical</span>(<span class="keyword">this</span>, <span class="string">&quot;critical&quot;</span>, <span class="string">&quot;错误&quot;</span>);</span><br><span class="line"><span class="comment">//信息对话框</span></span><br><span class="line">QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;信息&quot;</span>);</span><br><span class="line"><span class="comment">//提问对话框       </span></span><br><span class="line"><span class="keyword">if</span>(QMessageBox::Save == QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>, <span class="string">&quot;ques&quot;</span>, <span class="string">&quot;提问&quot;</span>, QMessageBox::Save | QMessageBox::Cancel, QMessageBox::Cancel)) &#123;</span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;已保存&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//警示对话框</span></span><br><span class="line">QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;警告&quot;</span>);</span><br></pre></td></tr></table></figure>



<p><strong>颜色对话框：</strong><code>QColorDialog</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//颜色对话框</span></span><br><span class="line">QColor color = QColorDialog::<span class="built_in">getColor</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));	<span class="comment">//设置初始颜色红色</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;r = &quot;</span> &lt;&lt; color.<span class="built_in">red</span>() &lt;&lt; <span class="string">&quot; g = &quot;</span> &lt;&lt; color.<span class="built_in">green</span>() &lt;&lt; <span class="string">&quot; b = &quot;</span> &lt;&lt; color.<span class="built_in">blue</span>() &lt;&lt; endl; <span class="comment">//输出color接收到的颜色值</span></span><br></pre></td></tr></table></figure>



<p><strong>文件对话框</strong>：<code>QFileDialog</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件对话框</span></span><br><span class="line"><span class="comment">//参数1 父亲 参数2 标题 参数3 默认打开路径 参数4 过滤文件格式	//返回值是选取的文件路径</span></span><br><span class="line">QString str = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>, <span class="string">&quot;打开文件&quot;</span>, <span class="string">&quot;D:\\MLZ107\\Desktop&quot;</span>, <span class="string">&quot;(*.txt)&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; str &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<p><strong>字体对话框</strong>：<code>QFontDialog</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字体对话框</span></span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line">QFont font = QFontDialog::<span class="built_in">getFont</span>(&amp;flag, <span class="built_in">QFont</span>(<span class="string">&quot;仿宋&quot;</span>, <span class="number">14</span>));</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;字体：&quot;</span> &lt;&lt; font.<span class="built_in">family</span>() &lt;&lt; <span class="string">&quot; 字号：&quot;</span> &lt;&lt; font.<span class="built_in">pointSize</span>() &lt;&lt; <span class="string">&quot; 是否加粗：&quot;</span> &lt;&lt; font.<span class="built_in">bold</span>() &lt;&lt; <span class="string">&quot; 是否倾斜：&quot;</span> &lt;&lt; font.<span class="built_in">italic</span>();</span><br></pre></td></tr></table></figure>





<h3 id="窗口布局"><a href="#窗口布局" class="headerlink" title="窗口布局"></a>窗口布局</h3><ul>
<li><strong>Push Button：按钮</strong></li>
<li><strong>Label：标签</strong></li>
<li><strong>Line Edit：单行输入</strong></li>
<li><strong>Horizontal Spacer：水平弹簧</strong></li>
<li><strong>Vertical Spacer：垂直弹簧</strong> </li>
<li><strong>Vertical Layout：垂直布局</strong></li>
<li><strong>Horizontal Layout：水平布局</strong></li>
<li><strong>Grid Layout：栅格布局</strong></li>
</ul>
<p>默认窗口和控件之间有间隙，可以调整</p>
<h3 id="自定义控件封装"><a href="#自定义控件封装" class="headerlink" title="自定义控件封装"></a>自定义控件封装</h3><p>添加新文件 -》Qt -》设计师界面类 要设置要继承的类如widget，会生成 （.h  .cpp  . ui）</p>
<p>.ui文件中该控件的功能，并在.h,.cpp文件中提供接口</p>
<p>主界面的.ui文件中添加widget控件，右键提升为自定义的控件</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><strong>鼠标事件QMouseEvent</strong></p>
<ul>
<li><strong>鼠标进入</strong> <code>enterEvent</code></li>
<li><strong>鼠标离开事件</strong> <code>leaveEvent</code></li>
<li><strong>鼠标按下</strong> <code>mousePressEvent</code></li>
<li><strong>鼠标释放</strong> <code>mouseReleaseEvent</code></li>
<li><strong>鼠标移动</strong> <code>mouseMoveEvent</code></li>
<li><code>ev-&gt;x()</code> 鼠标x的坐标 <code>ev-&gt;y()</code> 鼠标y的坐标</li>
<li><code>ev-&gt;button()</code>判断按键 <code>Qt::LeftButton</code> <code>Qt::RightButton</code></li>
<li><code>ev-&gt;buttons()</code> 判断组号按键 判断移动时 <code>Qt::LeftButton &amp; Qt::RightButton</code></li>
<li>格式化字符串 <code>QString(&quot;%1 %2&quot;).arg(111).arg(&quot;我的&quot;);</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mylabel.cpp</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">//鼠标进入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLabel::enterEvent</span><span class="params">(QEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;鼠标进入myLabel&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标离开</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLabel::leaveEvent</span><span class="params">(QEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;鼠标离开myLabel&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标按下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLabel::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//左键按下</span></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">button</span>() == Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span> () &lt;&lt; <span class="string">&quot;鼠标按下：x = &quot;</span> &lt;&lt; ev-&gt;<span class="built_in">x</span>() &lt;&lt; <span class="string">&quot; y = &quot;</span> &lt;&lt; ev-&gt;<span class="built_in">y</span>() &lt;&lt; <span class="string">&quot; globalX = &quot;</span> &lt;&lt; ev-&gt;<span class="built_in">globalX</span>() &lt;&lt; <span class="string">&quot; globalY = &quot;</span> &lt;&lt; ev-&gt;<span class="built_in">globalY</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标移动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLabel::mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//左键按下移动</span></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span> () &lt;&lt; <span class="string">&quot;鼠标移动：x = &quot;</span> &lt;&lt; ev-&gt;<span class="built_in">x</span>() &lt;&lt; <span class="string">&quot; y = &quot;</span> &lt;&lt; ev-&gt;<span class="built_in">y</span>() &lt;&lt; <span class="string">&quot; globalX = &quot;</span> &lt;&lt; ev-&gt;<span class="built_in">globalX</span>() &lt;&lt; <span class="string">&quot; globalY = &quot;</span> &lt;&lt; ev-&gt;<span class="built_in">globalY</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLabel::mouseReleaseEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//右键释放</span></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">button</span>() == Qt::RightButton)</span><br><span class="line">    &#123;</span><br><span class="line">        QString str = <span class="built_in">QString</span>(<span class="string">&quot;鼠标释放：x = %1 y = %2 globalX = %3 globalY = %4&quot;</span>).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">y</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">globalX</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">globalY</span>());</span><br><span class="line">        <span class="comment">//qDebug () &lt;&lt; &quot;鼠标释放：x = &quot; &lt;&lt; ev-&gt;x() &lt;&lt; &quot; y = &quot; &lt;&lt; ev-&gt;y() &lt;&lt; &quot; globalX = &quot; &lt;&lt; ev-&gt;globalX() &lt;&lt; &quot; globalY = &quot; &lt;&lt; ev-&gt;globalY();</span></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p><strong>定时器事件</strong></p>
<ul>
<li>重写事件 <code>void timerEvent(QTimerEvent *);</code></li>
<li>启动定时器 <code>startTimer(1000);</code> 单位：ms，<strong>返回值</strong>：<code>int</code>定时器的唯一标识id</li>
<li><code>startTimer</code>返回值 可以和 <code>ev-&gt;timeId()</code>比较，选择执行哪个定时事件</li>
<li>关闭定时器<code>killTimer(int id);</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">//启动定时器</span></span><br><span class="line">    id1 = <span class="built_in">startTimer</span>(<span class="number">1000</span>);	<span class="comment">//ms毫秒</span></span><br><span class="line">    id2 = <span class="built_in">startTimer</span>(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::timerEvent</span><span class="params">(QTimerEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id1 == ev-&gt;<span class="built_in">timerId</span>())  <span class="comment">//比较定时器的id标识</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">        ui-&gt;label_2-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(num1++));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id2 == ev-&gt;<span class="built_in">timerId</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br><span class="line">        ui-&gt;label_3-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(num2++));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>定时器类QTimer</strong>：创建定时事件的第二种用法，推荐，定时事件分开，比较独立</p>
<ul>
<li>创建定时器对象 <code>QTimer * timer = new QTimer(this);</code></li>
<li>启动定时器 <code>timer-&gt;start(1000);</code> 单位：<code>ms</code></li>
<li>每隔一定时间，发送信号 <code>timeout</code>，监听 <code>connect(timer, &amp;Timer::timeout, 目标函数);</code>，目标函数为每个一定时间想做的事</li>
<li>暂停 <code>timer-&gt;stop();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定时器的第二种方式</span></span><br><span class="line">QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);   <span class="comment">//创建对象</span></span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">500</span>);                  <span class="comment">//定时 0.5s</span></span><br><span class="line"><span class="built_in">connect</span>(timer, &amp;QTimer::timeout, [=]()&#123; <span class="comment">//每隔0.5s label_4显示的数字加1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    ui-&gt;label_4-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(num++));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;btn, &amp;QPushButton::clicked, [=]()&#123;  <span class="comment">//点击按钮，定时器暂停或恢复</span></span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        ui-&gt;btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;恢复&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        timer-&gt;<span class="built_in">start</span>(<span class="number">500</span>);</span><br><span class="line">        ui-&gt;btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;暂停&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flag = !flag;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>事件分发器</strong>：用于事件的分发，可以做拦截操作，不建议</p>
<ul>
<li><code>type()</code>用于判断时间的类型，如：<code>MouseButtonPress、MouseButtonMove</code> </li>
</ul>
<p><img src="/QT%E5%85%A5%E9%97%A8/image-20220312141940198.png" alt="image-20220312141940198"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过event事件分发器 拦截 鼠标按下事件</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myLabel::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果是鼠标按下， 在event事件分发中做拦截</span></span><br><span class="line">    <span class="keyword">if</span>(QEvent::MouseButtonPress == e-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line">        QMouseEvent *ev = <span class="keyword">static_cast</span>&lt;QMouseEvent*&gt;(e);	<span class="comment">//类型转换</span></span><br><span class="line">        QString str = <span class="built_in">QString</span>(<span class="string">&quot;Event函数中：鼠标按下 x = %1 y = %2 globalX = %3 globalY = %4&quot;</span>).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">y</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">globalX</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">globalY</span>());</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; str;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//true代表用户自己处理，不向下分发</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他事件 交给父类处理 默认处理</span></span><br><span class="line">    <span class="keyword">return</span> QLabel::<span class="built_in">event</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>事件过滤器</strong>：在程序将事件分发到事件分发器前，可以利用过滤器做拦截</p>
<p><img src="/QT%E5%85%A5%E9%97%A8/image-20220312144312959.png" alt="image-20220312144312959"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Widget.h</span></span><br><span class="line">...</span><br><span class="line">	<span class="comment">//重写事件过滤器的事件</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *, QEvent *)</span></span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//Widget.cpp</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//步骤2：重写eventFilter事件</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Widget::eventFilter</span><span class="params">(QObject *obj, QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj == ui-&gt;label)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress)</span><br><span class="line">        &#123;</span><br><span class="line">            QMouseEvent *ev = <span class="keyword">static_cast</span>&lt;QMouseEvent*&gt;(e);</span><br><span class="line">            QString str = <span class="built_in">QString</span>(<span class="string">&quot;事件过滤器中：鼠标按下 x = %1 y = %2 globalX = %3 globalY = %4&quot;</span>).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">y</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">globalX</span>()).<span class="built_in">arg</span>(ev-&gt;<span class="built_in">globalY</span>());</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; str;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//true代表用户自己处理，不向下分发</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他事件 交给父类处理 默认处理</span></span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">eventFilter</span>(obj, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="绘图QPainter"><a href="#绘图QPainter" class="headerlink" title="绘图QPainter"></a>绘图QPainter</h3><ul>
<li>绘图事件 <code>void paintEvent(QPaintEvent *);</code> 自动调用</li>
<li>声明一个画家对象 <code>QPainter painter(this);</code> this指定绘图设备</li>
<li>设置画笔 <code>QPen</code> 设置画笔宽度 <code>setWidth</code> 风格 <code>setStyle</code></li>
<li>设置画刷 <code>QBrush</code> 风格<code>setStyle</code></li>
<li>画家使用画笔<code>painter.setPen(pen);</code> 使用画刷 <code>painter.setBrush(brush);</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绘图事件，自动调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//实例化回家对象</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>; <span class="comment">//this指定绘图设备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置画笔</span></span><br><span class="line">    <span class="function">QPen <span class="title">pen</span><span class="params">(QColor(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="comment">//设置画笔宽度</span></span><br><span class="line">    pen.<span class="built_in">setWidth</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//设置画笔风格</span></span><br><span class="line">    pen.<span class="built_in">setStyle</span>(Qt::DotLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画刷</span></span><br><span class="line">    <span class="function">QBrush <span class="title">brush</span><span class="params">(Qt::cyan)</span></span>;</span><br><span class="line">    <span class="comment">//设置画刷风格</span></span><br><span class="line">    brush.<span class="built_in">setStyle</span>(Qt::Dense7Pattern);</span><br><span class="line">    <span class="comment">//让画家使用画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//让画家使用该画笔</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">    painter.</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画线</span></span><br><span class="line">    painter.<span class="built_in">drawLine</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">QPoint</span>(<span class="number">100</span>, <span class="number">100</span>));   <span class="comment">//线段两端点的坐标</span></span><br><span class="line">    <span class="comment">//画圆 Ellipse椭圆</span></span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPoint</span>(<span class="number">100</span>, <span class="number">100</span>), <span class="number">50</span>, <span class="number">50</span>);  <span class="comment">//圆心 半长轴 和 半短轴</span></span><br><span class="line">    <span class="comment">//画矩形</span></span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="built_in">QRect</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">50</span>));</span><br><span class="line">    <span class="comment">//画文字</span></span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="built_in">QRect</span>(<span class="number">10</span>, <span class="number">200</span>, <span class="number">150</span>, <span class="number">50</span>), <span class="string">&quot;好好学习，天天向上&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抗锯齿 效率低 <code>painter.setRenderHint(QPainter::Antialiasing);</code></li>
<li>画家移动位置 <code>QPainter.translate(100, 0);</code><ul>
<li>保存状态 <code>save();</code></li>
<li>还原状态 <code>restore();</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>; <span class="comment">//创建画家</span></span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing); <span class="comment">//设置抗锯齿</span></span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPoint</span>(<span class="number">50</span>, <span class="number">50</span>), <span class="number">50</span>, <span class="number">50</span>);    <span class="comment">//画圆</span></span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">translate</span>(<span class="number">100</span>, <span class="number">0</span>);  <span class="comment">//将画家从当前位置（0,0）移动x:100、y:0的距离 （100,0）</span></span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">50</span>);   <span class="comment">//画矩形</span></span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">translate</span>(<span class="number">100</span>, <span class="number">0</span>);  <span class="comment">//将画家从当前位置（100,0）移动x:100、y:0的距离 （200,0）</span></span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">50</span>);   <span class="comment">//画矩形</span></span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">save</span>();             <span class="comment">//保存当前状态</span></span><br><span class="line">    painter.<span class="built_in">translate</span>(<span class="number">0</span>, <span class="number">100</span>);  <span class="comment">//将画家从当前位置（200,0）移动x:0、y:100的距离 （200,100）</span></span><br><span class="line">    painter.<span class="built_in">restore</span>();          <span class="comment">//恢复保存的画家状态</span></span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPoint</span>(<span class="number">30</span>, <span class="number">30</span>), <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>利用画家画图片</strong></p>
<ul>
<li><p>将图片添加到项目资源中</p>
</li>
<li><p><code>painter.drawPixmap(x, y, QPixmap(&quot;:/Image/Luffy.png&quot;));</code> (x,y)绘图起点坐标</p>
</li>
<li><p>手动调用绘图事件进行更新，推荐<code>update()</code>，当然<code>repaint()</code>也可以</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//点击移动按钮，移动图片</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btn, &amp;QPushButton::clicked, [=]()&#123;</span><br><span class="line">        posX += <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">update</span>();   <span class="comment">//手动调用绘图事件，repaint也可以，但推荐update，</span></span><br><span class="line">    &#125;);</span><br><span class="line">    QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);	<span class="comment">//使用QTimer实现图片自动移动</span></span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">500</span>);</span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, [=]()&#123;</span><br><span class="line">        posX += <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">update</span>();   <span class="comment">//手动调用绘图事件，repaint也可以，但推荐update，</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//如果超出屏幕，从0开始</span></span><br><span class="line">    <span class="keyword">if</span>(posX &gt; <span class="keyword">this</span>-&gt;<span class="built_in">width</span>()) <span class="comment">//width()获取窗口宽度，height是高度</span></span><br><span class="line">    &#123;</span><br><span class="line">        posX = -<span class="built_in">QPixmap</span>(<span class="string">&quot;:/Image/Luffy.png&quot;</span>).<span class="built_in">width</span>(); <span class="comment">//获取图片的宽度</span></span><br><span class="line">    &#125;</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(posX, <span class="number">0</span>, <span class="built_in">QPixmap</span>(<span class="string">&quot;:/Image/Luffy.png&quot;</span>));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="绘图设备"><a href="#绘图设备" class="headerlink" title="绘图设备"></a>绘图设备</h3><p><strong>QPaintDevice</strong>的子类在Qt里面有4中：</p>
<ul>
<li><p><strong>QPixmap</strong>：专门为图像在屏幕上的显示做优化</p>
</li>
<li><p><strong>QBitmap</strong>：是<code>QPixmap</code>的一个子类，它的色度限定为1(黑白色)，可以使用<code>QPixmap</code>的<code>isQBitmap()</code>函数来确定这个<code>QPixmap</code>是不是一个<code>QBitmap</code></p>
</li>
<li><p><strong>QImage</strong>：专门为图像的像素级访问做优化</p>
</li>
<li><p><strong>QPicture</strong>：可以记录和重现<code>QPainter</code>的各条命令</p>
</li>
</ul>
<p>前例中在<code>QWidget</code>能画图是因为<code>QWidget</code>继承自<code>QPaintDevice</code></p>
<p><strong>QPixmap</strong></p>
<ul>
<li>创建<code>QPixmap pix(w, h);</code></li>
<li>填充颜色 <code>pix.fill(颜色);</code></li>
<li>利用画家在pix上画画 <code>QPainter painter(&amp;pix);</code></li>
<li>保存 <code>pix.save(路径);</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Pixmap绘图设备，300x300的画布</span></span><br><span class="line">   <span class="function">QPixmap <span class="title">pix</span><span class="params">(<span class="number">300</span>, <span class="number">300</span>)</span></span>;</span><br><span class="line">   <span class="comment">//画布填充颜色，默认黑色</span></span><br><span class="line">   pix.<span class="built_in">fill</span>(Qt::white);</span><br><span class="line">   <span class="comment">//创建画家</span></span><br><span class="line">   <span class="function">QPainter <span class="title">painter</span><span class="params">(&amp;pix)</span></span>;</span><br><span class="line">   <span class="comment">//设置画笔</span></span><br><span class="line">   painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::green));</span><br><span class="line">   <span class="comment">//画一个圆</span></span><br><span class="line">   painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPoint</span>(<span class="number">150</span>, <span class="number">150</span>), <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">   <span class="comment">//保存图片</span></span><br><span class="line">   pix.<span class="built_in">save</span>(<span class="string">&quot;E:/QT/pix.png&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>QImage</strong></p>
<ul>
<li>创建 <code>QImage img(w, h, QImage::Format_RGB32);</code></li>
<li>设置像素 <code>setPixel(x, y, value);</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//QImage 绘图设备</span></span><br><span class="line">    <span class="function">QImage <span class="title">img</span><span class="params">(<span class="number">300</span>, <span class="number">300</span>, QImage::Format_ARGB32)</span></span>;</span><br><span class="line">    img.<span class="built_in">fill</span>(Qt::white);</span><br><span class="line"></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(&amp;img)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::blue));</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPoint</span>(<span class="number">150</span>, <span class="number">150</span>),<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//保存</span></span><br><span class="line">    img.<span class="built_in">save</span>(<span class="string">&quot;E:/QT/img.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">//修改像素点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//利用QImage修改像素</span></span><br><span class="line">    QImage img;</span><br><span class="line">    img.<span class="built_in">load</span>(<span class="string">&quot;:/Image/Luffy.png&quot;</span>); <span class="comment">//加载图片</span></span><br><span class="line">	<span class="comment">//修改像素点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">50</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">50</span>; j &lt; <span class="number">100</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            QRgb value = <span class="built_in">qRgb</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            img.<span class="built_in">setPixel</span>(i, j, value); <span class="comment">//修改某点像素值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    painter.<span class="built_in">drawImage</span>(<span class="number">0</span>, <span class="number">0</span>, img); <span class="comment">//画QImage</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>QPicture</strong>：可以记录和重现绘图指令，但不能直接显示图片</p>
<ul>
<li>创建 <code>QPicture pic</code></li>
<li>开始记录 <code>painter.begin(&amp;pic);</code></li>
<li>结束记录 <code>painter.end();</code></li>
<li>保存 <code>pic.save(&quot;路径任意后缀名&quot;);</code></li>
<li>重现 利用画家重现 <code>painter.drawPicture(x, y, pic);</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//QPicture 绘图设备 可以记录和重现绘图指令</span></span><br><span class="line">	<span class="comment">//保存指令</span></span><br><span class="line">    QPicture pic;</span><br><span class="line">    QPainter painter;</span><br><span class="line">    painter.<span class="built_in">begin</span>(&amp;pic);    <span class="comment">//开始记录 往pic上画的指令</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::blue));</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPoint</span>(<span class="number">150</span>, <span class="number">150</span>), <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    painter.<span class="built_in">end</span>();  <span class="comment">//结束画画</span></span><br><span class="line">    pic.<span class="built_in">save</span>(<span class="string">&quot;E:/QT/pic.pic&quot;</span>);  <span class="comment">//保存</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">//重现指令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//重现QPicture的绘图指令</span></span><br><span class="line">    QPicture pic;</span><br><span class="line">    pic.<span class="built_in">load</span>(<span class="string">&quot;E:/QT/pic.pic&quot;</span>);</span><br><span class="line">    painter.<span class="built_in">drawPicture</span>(<span class="number">0</span>, <span class="number">0</span>, pic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>QBitmap</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PaintWidget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/Image/butterfly.png&quot;</span>)</span></span>;  <span class="comment">//背景透明</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap1</span><span class="params">(<span class="string">&quot;:/Image/butterfly1.png&quot;</span>)</span></span>; <span class="comment">//白色背景</span></span><br><span class="line">    <span class="function">QBitmap <span class="title">bitmap</span><span class="params">(<span class="string">&quot;:/Image/butterfly.png&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">QBitmap <span class="title">bitmap1</span><span class="params">(<span class="string">&quot;:/Image/butterfly1.png&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="number">0</span>, pixmap);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">200</span>, <span class="number">0</span>, pixmap1);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="number">130</span>, bitmap);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">200</span>, <span class="number">130</span>, bitmap1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/QT%E5%85%A5%E9%97%A8/image-20220312175643584.png" alt="image-20220312175643584"></p>
<h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p><strong>QFile文件读取</strong> </p>
<p><strong>QFileDialog文件对话框</strong></p>
<p><strong>QByteArray</strong></p>
<p><strong>QFileInfo文件信息类</strong> </p>
<p><strong>QTextCodec编码格式类</strong></p>
<p><code>QFile默认支持的格式为UTF-8</code> </p>
<ul>
<li><p><code>QFile file(str);</code> 创建对象，str是文件路径</p>
</li>
<li><p><code>close()</code> 关闭文件</p>
</li>
<li><p><code>atEnd()</code> 判断是否是文件尾</p>
</li>
<li><p><code>readAll()</code> 读取所有内容</p>
</li>
<li><p><code>readLine()</code> 读取一行</p>
</li>
<li><p><code>write(内容)</code> 写入</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(path)</span></span>;	<span class="comment">//文件路径</span></span><br><span class="line">file.<span class="built_in">open</span>(QIODevice::ReadOnly);	<span class="comment">//打开方式，只读</span></span><br><span class="line">QByteArray array = file.<span class="built_in">readAll</span>();	<span class="comment">//读取所有数据</span></span><br><span class="line">QByteArray array2;</span><br><span class="line"><span class="keyword">while</span>(!file.<span class="built_in">atEnd</span>()) <span class="comment">//一行行读取</span></span><br><span class="line">&#123;</span><br><span class="line">    array2 += file.<span class="built_in">readLine</span>();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>编码格式类QTextCodec</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTextCodec * codec = QTextCodec::<span class="built_in">codeForName</span>(<span class="string">&quot;gbk&quot;</span>); <span class="comment">//设置编码格式</span></span><br><span class="line">codec-&gt;<span class="built_in">toUnicode</span>(array);	<span class="comment">//进行转码 成设置的编码格式</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点击按钮弹出文件对话框，选择文件在TextEdit中显示</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, [=]()&#123;</span><br><span class="line">    QString str = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>, <span class="string">&quot;打开文件&quot;</span>, <span class="string">&quot;D:\\MLZ107\\Desktop&quot;</span>);</span><br><span class="line">    ui-&gt;lineEdit-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line"></span><br><span class="line">    QTextCodec *codec = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;GBK&quot;</span>);   <span class="comment">//设置编码格式</span></span><br><span class="line"></span><br><span class="line">    QFile <span class="built_in">file</span>(str);<span class="comment">//str文件路径   QFile默认编码格式UTF-8</span></span><br><span class="line">    file.<span class="built_in">open</span>(QIODevice::ReadOnly);<span class="comment">//打开方式</span></span><br><span class="line">    QByteArray array = file.<span class="built_in">readAll</span>();<span class="comment">//读取所有内容</span></span><br><span class="line">    <span class="comment">//ui-&gt;textEdit-&gt;setText(array);//在textEdit中显示</span></span><br><span class="line">    ui-&gt;textEdit-&gt;<span class="built_in">setText</span>(codec-&gt;<span class="built_in">toUnicode</span>(array));</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();   <span class="comment">//关闭文件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">      <span class="comment">//写内容</span></span><br><span class="line">file.<span class="built_in">open</span>(str);</span><br><span class="line">      file.<span class="built_in">open</span>(QIODevice::Append);</span><br><span class="line">      file.<span class="built_in">write</span>(<span class="string">&quot;fjeofj都无可哦&quot;</span>);</span><br><span class="line">      file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>



<p><strong>QFileInfo</strong>读取文件信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">info.<span class="built_in">size</span>();	<span class="comment">//文件大小</span></span><br><span class="line">info.<span class="built_in">suffix</span>();	<span class="comment">//文件后缀名</span></span><br><span class="line">info.<span class="built_in">fileName</span>();	<span class="comment">//文件名</span></span><br><span class="line">info.<span class="built_in">filePath</span>();	<span class="comment">//文件路径</span></span><br><span class="line">info.<span class="built_in">created</span>().<span class="built_in">toString</span>(<span class="string">&quot;yyyy/MM/dd hh:mm:ss&quot;</span>);	<span class="comment">//文件创建日期，并转化为字符串</span></span><br><span class="line">info.<span class="built_in">lastModified</span>()<span class="built_in">toString</span>(<span class="string">&quot;yyyy/MM/dd hh:mm:ss&quot;</span>);	<span class="comment">//文件最后修改日期，并转化为字符串	</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QFileInfo <span class="title">info</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;文件大小：&quot;</span> &lt;&lt; info.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; 后缀名：&quot;</span> &lt;&lt; info.<span class="built_in">suffix</span>() &lt;&lt; <span class="string">&quot; 文件名：&quot;</span> &lt;&lt; info.<span class="built_in">fileName</span>() &lt;&lt; <span class="string">&quot; 文件路径：&quot;</span> &lt;&lt; info.<span class="built_in">filePath</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;创建日期：&quot;</span> &lt;&lt; info.<span class="built_in">created</span>().<span class="built_in">toString</span>(<span class="string">&quot;yyyy/MM/dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;最后修改时间：&quot;</span> &lt;&lt; info.<span class="built_in">lastModified</span>().<span class="built_in">toString</span>(<span class="string">&quot;yyyy/MM/dd hh:mm:ss&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h3><p>1、使用<code>QT</code>的Release构建项目，将构建出来的<code>exe</code> 文件单独放置一个空文件夹中</p>
<p>2、确保<code>QT</code>的安装路径<code>D:\Qt\Qt5.3.1\5.3\mingw482_32\bin</code>有<code>windeployqt.exe</code>文件添加在环境变量中</p>
<p>3、在<code>exe</code> 所在空文件中打开<code>cmd</code>窗口输入 <code>windeployqt xxx.exe</code></p>
<p>第三方软件打包：<code>hm nis edit</code> </p>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础</title>
    <url>/python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Python的一些高级用法</p>
<span id="more"></span>

<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p><code>print</code>默认换行，末尾加上<code>end=&quot;&quot;</code>不换行</p>
<p><code>del</code> 删除的是变量而不是数据</p>
<hr>
<p>Python默认编码是UTF-8，可用源码文件指定不同的编码</p>
<p>如#-* -coding:GBK-* -    允许在源文件中使用GBK编码<br>如decode(‘unicode-escape‘, ‘ignore’)</p>
<p>UTF-8编码转化为GBK编码：</p>
<p>decode(‘UTF-8’)</p>
<p>encode(‘GBK’)</p>
<p>GBK编码转化为UTF-8编码：</p>
<p>decode(‘GBK’)</p>
<p>encode(‘UTF-8’)</p>
<hr>
<p>单行注释#</p>
<p>多行注释’’’  ‘’’或”””   “””</p>
<p>缩进需一致</p>
<p>多行语句 \  或 将语句放在[]{}()中</p>
<hr>
<p>常见函数</p>
<p><code>input()</code> 读入一行文本</p>
<p><code>print()</code> 输出，打印</p>
<p><code>pass</code> 命令，占位，不被执行</p>
<p><code>del</code> 命令 如：<code>del a</code></p>
<p><code>id()</code> 查看变量指向的内存地址，变量实际储存的是内存地址</p>
<p><code>type()</code> 标识对象类型</p>
<p><code>help()</code> 查看函数帮助信息，如<code>help(print)</code></p>
<p><code>dir()</code> 查看函数的属性和具有的方法，如<code>dir(print)</code></p>
<hr>
<p>Python关键字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(keyword.kwlist)	<span class="comment">#打印关键字列表</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">False	class	finally is  return	None	continue	for		lambda  try True	def		from	nonlocal	while	and     del     global  not		with		as		elif		if		or		yield		assret	else    pass	break	except	in		raise	async	await	import</span><br></pre></td></tr></table></figure>



<p>十进制：</p>
<p>二进制：0b或0B开头</p>
<p>八进制：0o或0O开头</p>
<p>十六进制：0x或0X开头</p>
<p>python的相对路径是  <code>&quot;.\xxx\xx&quot;</code>  </p>
<hr>
<h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。对<code>list、tuple、str</code>等类型的数据可使用<code>for...in...</code>的循环从其中依次取数据，将这样的过程称为<code>遍历</code>，也称<code>迭代</code>。</p>
<p><code>可迭代对象Iterable</code>是可以直接作用于<code>for循环的对象</code>的统称，包括<code>序列对象（列表，元组和字符串）和可迭代的非序列对象（集合、字典、文件和生成器）</code></p>
<p>迭代器是一个带状态的对象，它能在调用<code>next()</code>方法的时候返回集合中下一个值，任何实现了<code>__iter__()</code>方法和<code>__next__()</code>方法的对象都是迭代器，<code>__iter__()</code>返回迭代器自身，<code>__next__()</code>返回容器中的下一个值，如果集合中没有更多元素了，则抛出<code>StopIteration</code>异常</p>
<p>迭代器是一个可以记住遍历位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有元素被访问完结束。迭代器只能往前不会后退。</p>
<p>可以使用<code>isinstance()</code>函数判断一个对象是否是Iterable对象</p>
<p>迭代器有两个基本函数：<code>iter()</code>和<code>next()</code></p>
<ul>
<li><p><code>iter(iterable)</code>：从可迭代对象中返回一个迭代器，iterable必须是能提供一个迭代器的对象</p>
</li>
<li><p><code>next(iterator)</code>：从迭代器iterator中获取下一条记录，如果无法获取下一条记录，则触发stoprerator异常</p>
</li>
</ul>
<p>借助<code>iter()函数可将list、dict、str等可迭代对象Iterable变成迭代器Iterator</code>。</p>
<p>可迭代对象Iterable实现了<code>__iter__()</code>方法，该方法返回一个迭代器对象。迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了<code>__nest__()</code>方法和<code>__iter__()</code>方法，迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果。</p>
<p><code>字符串、列表或元组对象</code>都可用于创建迭代器</p>
<p>可迭代对象和迭代器遍历方面存在差异。迭代器遍历完一次就不能从头开始，即迭代器只能往前不会后退。对列表等可迭代对象，可以多次遍历。</p>
<p><code>StopIteration</code>异常用于标识迭代的完成，防止出现无限循环的情况，在<code>__next__()</code>方法中可以设置在完成指定循环次数后触发StopIteration异常来结束迭代</p>
<hr>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>1、列表生成式</p>
<p>2、生成器生成式</p>
<p>受到内存限制列表容量肯定是有限的，生成器生成式就是利用某种算法推算出后续元素，不必创建完整的列表，从而节省大量空间。在Python中，一边循环一边计算的机制，称为<code>生成器generator</code>。</p>
<p>生成器是一种特殊的程序，可以被用作控制循环的迭代行为，Python中<code>生成器是迭代器的一种</code>，使用<code>yield</code>返回值函数，每次调用yield会暂停，且可以使用<code>next()</code>函数和<code>send()</code>函数恢复生成器。</p>
<p>生成器类似于返回值为数组的一个函数，这个函数可以接受参数，可以被调用，但是，不同于一般的函数会一次性返回包括所有数值的数组，生成器一次只能产生一个值，这样消耗的内存数量将大大减小，</p>
<p>而且允许调用函数可以很快的处理前几个返回值，因此生成器看起来像是一个函数，但是变现的却像迭代器。</p>
<p>生成器可以理解为用于生成列表、元组等可迭代对象的机器。既然是机器，没启动之前，在Python中只是一个符号。生成器还不是实际意义上的列表，因此比列表更加节省内存空间，必要时，生成器可按照需要去生成列表。</p>
<p>3、创建生成器方法</p>
<p>1.生成器生成式。将列表生成式的[]改成()，列表生成式就变成生成器</p>
<p>2.生成器函数。若一个函数定义中包含yield关键字，那么这个函数就是一个生成器函数。调用生成器函数会自动挂起，然后重新拾起继续执行，利用yield关键字挂起函数，给调用者返回一个值，同时保留了当前足够多的状态，可以使函数继续执行。</p>
<p><code>迭代器和生成器特点：按需计算，省空间，支持大数据</code></p>
<p>生成器的函数或方法</p>
<p>1、<code>__next__()方法和next()内置函数</code></p>
<p>调用生成器函数来生成一个生成器g时，这个生成器对象就会自带一个<code>g.__next__()</code>方法，它可以开始或继续函数并运行到下一个yield结果的返回或引发一个StopIteration异常（这个异常是在运行到了函数末尾或则遇到了return语句的时候引起）。也可以通过Python的内置函数next()来调用<code>X.__next__()</code></p>
<p>方法，结果都是一样的。</p>
<p>2、<code>send()方法</code></p>
<p>send()方法和next()方法在一定意义上作用是相似的，都具有唤醒并继续执行的作用。但send()可以传递yield的值，next()只能传递None。所以next()和send(None)作用是一样的。</p>
<p>从技术上讲，yield是一个表达式，它是有返回值的，当使用内置的next()函数或__next__()方法时，默认yield表达式的返回值为None，使用send(value)方法可以把一个值传递给生成器，使得yield表达式的返回值为send()方法传入的值。</p>
<p>生成器刚启动时（第一次调用），请使用next()语句或是send(None)，不能直接发送一个非None的值，否则会报TypeError，因为没有yield语句来接收这个值。</p>
<p>send(msg)和next()的返回值比较特殊，是下一个yield表达式的参数（如yield 5,则返回5）</p>
<p>yield的返回值由send()方法传入，send()方法或next()方法的返回值为yield表达式的参数(如yield 1，返回1)</p>
<p>3、<code>生成器函数中的return语句</code></p>
<p>当生成器运行到了return语句时，会抛出StopIteration的异常，异常的值就是return值；另外，即使return后面有yield语句，也不会被执行。</p>
<p>4、<code>close()方法与throw()方法</code></p>
<p>一个生成器对象也有close()方法与throw()方法，可以使用它们提前关闭一个生成器或抛出一个异常；使用close()方法时，它本质上是在生成器内部产生了一个终止迭代的GeneratorExit异常。throw()方法通过抛出一个GeneratorExit异常来终止Generator。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类的定义</p>
<pre><code>类声明和类体。类声明部分包括class关键字、类名和冒号：。class关键字和类名之间有空格。类体由统一缩进的部分组成，缩进部分包括成员变量和成员方法。成员变量和成员方法统称成员。

class 类名 [(父类名)]:
</code></pre>
<p>对象的创建和使用</p>
<pre><code>对象是类的实例。对象名=类名();

创建对象后，可以访问对象的成员。对象.变量|方法(参数)
</code></pre>
<p>成员的访问</p>
<pre><code>在Python中，类中定义的成员变量和方法有的属于类(即类的成员变量和方法)，有的属于对象(实例变量和实例方法)

对属于类的成员变量和方法，采取“类名.变量|方法(参数)”的形式访问，对属于对象的成员变量和方法采取“对象名.变量|方法(参数)”的形式访问

Python语言是一种动态语言，没有前缀“类名.”或“对象名.”，就很难区别变量和方法的归属。同时Python允许在程序中视情况可动态增加和删除成员变量和方法。
</code></pre>
<p>成员变量</p>
<pre><code>类中的变量可分为成员变量和非成员变量两种。非成员变量是在方法体中定义的局部变量和方法的参数。

成员变量描述了类和对象的状态（或属性），对成员变量的操作实际上就是改变对象的状态（或属性）使之满足程序的需要。成员变量可分为属于类的变量（类变量）和属于对象的变量（实例变量）。每种类型的变量又可分为私有变量和公共变量。

类变量属于类本身，用于定义类本身所包含的状态数据。以“类名.变量=值”形式定义变量

实例变量则属于该类的对象，用于定义对象所包含的状态数据。以“对象名.变量=值”形式定义的变量，

一般来说，实例变量在构造函数__init__()中创建。
</code></pre>
<p>成员变量的归属</p>
<pre><code>Python中采取“xxx.变量=值”形式定义（包括增加）的成员变量究竟属于类变量还是实例变量，取决于“xxx”是对象名还是类名。“xxx”是类名，则是类变量；是对象名，则是实例变量。

Python语言是一种动态语言，同一名称的成员变量，可能随着xxx的不同，归属也不同

成员变量采取“xxx.变量”形式访问，xxx可以是对象名和类名。对于类变量，一般“类名.变量”。
</code></pre>
<blockquote>
<p>成员变量可分为私有变量和公共变量。<code>私有变量以“双下划线”</code>为开始。公有变量可以“对象.变量”或“类名.变量”形式访问，但私有变量不能通过这种方式访问。私有变量可通过类或对象能访问的方法间接访问。</p>
</blockquote>
<blockquote>
<p>Python并没有对私有变量提供严格的访问保护机制。私有变量在类的外部不能直接访问，需通过调用类或对象可访问成员方法来访问，或者通过Python支持的特殊方式来访问。Python提供了访问私有变量的特殊方式，可用于程序的测试和调试，对于成员方法也有同样性质。</p>
</blockquote>
<p>成员方法</p>
<pre><code>从是否包含特定标识符角度，成员方法可以分为静态方法、类方法、抽象方法和其他方法。
</code></pre>
<blockquote>
<p>静态方法是以<code>@staticmethod</code>表示的方法，类方法是以<code>@classmethod</code>标识的方法。</p>
</blockquote>
<blockquote>
<p>抽象方法是以<code>@abstractmethod</code>标识的方法。其他方法是指没有这些修饰符标识的方法。</p>
</blockquote>
<pre><code>从访问权限角度，成员方法又可分为公共方法和私有方法。私有方法是类中那些以两个下划线“__”开头的方法
</code></pre>
<p>成员方法的调用</p>
<pre><code>在Python中，视情况可用“类名.成员”和“对象名.成员”形式调用。
</code></pre>
<blockquote>
<p>绑定式调用：在调用时自动将调用者绑定到被调用方法的第一个参数self的调用方式。按照习惯，一般将这种调用方式下的形参的第一个参数命名为self，self参数代表当前调用者。由于这种绑定是自动执行的，因此不需要给第一参数显示地传值。形式上看，这种调用实参比形参少1个参数。</p>
</blockquote>
<blockquote>
<p>非绑定式调用：会调用时不会将调用者绑定到被调用方法的第一个参数self的调用方式。</p>
</blockquote>
<blockquote>
<p>普通方法的调用：“xxx.方法()”方式调用时，如果“xxx”是一个对象名或实质性地与一个对象对应，那么Python按照绑定式调用方式调用方法，系统自动将调用者绑定到被调用方法的第一形参。</p>
</blockquote>
<blockquote>
<p>类外，“xxx.方法()”具体表现为“对象名.方法()”，类内“xxx.方法()”具体表现为“self.方法()“，self与某个对象是一 一对应的。故统称为“对象名.方法()”，是一种绑定式调用。</p>
</blockquote>
<blockquote>
<p>“类名.方法()”的调用方式是非绑定式调用。因此，对一个方法而言，如果设计者在定义式约定第一个参数self是用来接收采取“对象名.方法()”调用方式自动绑定的对象名，那么采取“类名.方法()”调用类中这类含有self参数的方法时，由于系统不会将调用者自动绑定到被调用方法的第一个形参self参数，因此为了正确调用方法得到预期结果，要求实参和形参实质性地一致，此时必须显示地给self参数传递一个值，明确指定self与谁对应，传递的值可能是某个对象名或类名。</p>
</blockquote>
<blockquote>
<p>类中私有方法不能采取“对象名.方法()”或“类名.方法()”形式直接调用。</p>
</blockquote>
<p>静态方法和类方法的调用</p>
<pre><code>两者都可以通过“类名.方法()”或“对象名.方法()”调用，但不能直接访问属于对象的成员，只能访问属于类的成员。静态方法和类方法不属于任何实例，不会绑定到任何实例，当然也不依赖于任何实例的状态，与实例方法相比能够减少很多开销。

类方法一般以cls作为类方法的第一个参数表示该类自身，在调用类方法时不需要为该参数传递值，静态方法则可以不接收任何参数。
</code></pre>
<p>构造方法</p>
<blockquote>
<p><code>__init__()</code>是构造方法。以类为基础创建对象时，会自动调用构造方法，同时将对象名自动绑定构造方法的第一个形参self，Python通过调用构造方法对类实例化。构造方法是一个类创建对象的根本途径。</p>
</blockquote>
<blockquote>
<p>在类的定义中可以没有显示定义的构造方法<code>__init__()</code>，此时调用只包含一个self参数的默认构造方法来创建对象。</p>
</blockquote>
<blockquote>
<p>除了在以类为基础创建对象时自动调用构造方法外，程序也可以采取“对象名.方法()”或“类名.方法()”的方式调用构造方法，这点与Java语言有别。</p>
</blockquote>
<p>析构方法</p>
<blockquote>
<p>实例方法中还有一个特别的方法：<code>__del__()</code>，这个方法被称为析构方法。析构方法用于释放内存空间。</p>
</blockquote>
<blockquote>
<p>当使用del删除对象时，会调用它本身的析构方法，另外当对象在某个作用域调用完毕，在跳出其作用域的同时析构方法也会被调用一次，这样可以用来释放内存空间。</p>
</blockquote>
<pre><code>__del__()也是可选的，如果不提供，则Python会在后台提供默认析构方法。如果要显示调用析构方法，可以使用del关键字。del 对象名。
</code></pre>
<p>成员增加与删除</p>
<pre><code>Python是一门动态语言，类中的成员可以动态增加或删除。程序中可根据需要在适当位置通过“类.成员 = 值”

“对象名.成员 = 值”的赋值方式可以动态增加成员，通过“del 类.成员”“del 对象名.成员”形式动态删除成员

增加和删除成员变量

类名.成员变量=值    对象名.成员变量=值  或  self.成员变量=值

del 类名.成员变量    del 对象名.成员变量  或   del self.成员变量
</code></pre>
<p>增加和删除成员的方法</p>
<pre><code>先定义一个方法   def  名称(参数)    动态绑定到对象
</code></pre>
<p>继承</p>
<pre><code>首先创建一个共有属性和方法的一般类（父类或超类），然后基于该一般类再创建具有特殊属性和方法新类（子类）。
</code></pre>
<p>单继承：子类只从一个父类继承。多继承：子类从一个以上父类继承</p>
<p><code>class Subclass (SuperClass1,SuperClass2,...)</code></p>
<pre><code>父类的顺序影响着子类对父类方法的继承，如果父类中有方法和形参结构相同的方法，而在子类使用时并未指定调用哪个父类的方法，那么Python将从左至右搜索，即方法在子类中未找到时，从左到右查找父类中是否包含方法。

方法的覆盖发生在父类和子类之间，如果子类中定义的某个方法与父类中定义的某个方法的名称相同，那么子类中的这个方法将覆盖父类对应的那个方法。
</code></pre>
<p>super关键字</p>
<pre><code>Python的子类也会继承得到父类的构造方法，Python的子类也可以定义构造方法来覆盖父类的构造方法，通过super可在子类构造方法中调用父类中被覆盖的方法。如果子类有多个直接父类，那么排在前面的父类的构造方法会被优先调用。
</code></pre>
<p>抽象类</p>
<pre><code>抽象类是一个特殊的类，只能被继承，不能实例化，抽象类中可以有抽象方法和普通方法。子类继承了抽象类父类，子类必须实现父类的抽象方法。
</code></pre>
<p>定义抽象类</p>
<blockquote>
<p>导入abc模块   <code>import abc</code>或<code>from abc import ABCMeta,abstractmethod</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名(<span class="params">metaclass = abc.ABCMeta</span>)   或   <span class="title">class</span> 类名:</span></span><br><span class="line">	metaclass=abc.ABCMeta</span><br></pre></td></tr></table></figure>

<p>定义抽象方法  </p>
<p>抽象方法：只定义方法，不具体实现方法体。在抽象方法时需要在前面加入：<code>@abstractmethod</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@abc.abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 函数名(<span class="params">self</span>)</span></span><br></pre></td></tr></table></figure>

<p>子类实现抽象方法</p>
<h2 id="Python异常处理机制"><a href="#Python异常处理机制" class="headerlink" title="Python异常处理机制"></a>Python异常处理机制</h2><p>在Python中所有的异常都是<code>BaseException</code>的实例。</p>
<blockquote>
<p>异常处理是指用户程序以预定的方式响应运行错误和异常的能力。异常处理将会改变程序的控制流程，让程序有机会对错误报错作出处理。它的基本方式是：当一个方法引发一个异常后，将异常抛出，由该方法的直接或者间接调用者处理异常。</p>
</blockquote>
<blockquote>
<p>在程序开发的过程中，常常采用返回值进行错误处理。通常在编写一个方法时，可以返回一个状态代码，调用者根据状态代码判断出错与否，并按照状态代码代表的错误类型进行相应的处理，或显示一个错误页面，或提示错误信息。这种通过返回值进行错误处理的方法很有效，但是有许多不足之处，主要表现为：程序复杂；可靠性差；返回信息有限；返回代码标准化困难；为了保证程序的健壮性与容错性，即在遇到错误时程序不会崩溃，需要对异常进行处理。</p>
</blockquote>
<p>1、如果错误发生的条件是可预知的，我们需要用if进行处理，在错误发生之前进行预防。</p>
<p>2、如果错误发生的条件是不可预知的，则需要用到 try…….execpt：在错误发生之后进行处理。</p>
<ul>
<li><p><code>try...except</code>异常处理</p>
<p>  异常处理语句有<code>try、except、else、finally、raise</code><br>  <br>使用as可以获取异常参数。格式： <code>except 异常类型 as e:</code></p>
</li>
<li><p><code>raise</code>抛出异常</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">raise语句允许程序员强制发生指定的异常。raise语法格式：raise [Exception[(args)]]，Exception是异常类型，args是一个异常参数值。</span><br><span class="line"></span><br><span class="line">raise：单独一个raise。</span><br><span class="line"></span><br><span class="line">raise 异常类：指定异常类的默认实例</span><br><span class="line"></span><br><span class="line">raise 异常对象：引发指定的异常的对象</span><br></pre></td></tr></table></figure></li>
<li><p>自定义异常</p>
<p>大多数异常都定义为名称以Error结尾。通过继承Exception类或它的子类，实现自定义异常类。对于自定义异常类，必须采用throw语句抛出异常，这种类型的异常不会自行产生。</p>
</li>
</ul>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>在python中，可以访问不同的数据库（如SQLite数据库、Access数据库、MySQL数据库等）。</p>
<p><code>Python中，访问数据库的基本流程如下：</code></p>
<ul>
<li><p>调用connect()方法打开数据库连接，该方法返回数据库连接对象</p>
</li>
<li><p>通过数据库连接对象打开游标</p>
</li>
<li><p>使用游标执行SQL语句（包括DDL、DML、select查询语句等）。如果执行的是查询语句，则处理查询数据。</p>
</li>
<li><p>关闭游标</p>
</li>
<li><p>关闭数据库连接</p>
</li>
</ul>
<p>数据库连接对象通常会具有如下方法的属性：</p>
<ul>
<li><p><code>cursor(factory=Cursor)</code>: 打开游标</p>
</li>
<li><p><code>commit()</code>: 提交事务</p>
</li>
<li><p><code>rollback()</code>: 回滚事务</p>
</li>
<li><p><code>close()</code>: 关闭数据库连接</p>
</li>
<li><p><code>isolation_level</code>: 返回或设置数据库连接中事务的隔离级别</p>
</li>
<li><p><code>in_transaction</code>: 判断当前是否处于事务中</p>
</li>
<li><p><code>cursor()</code>: 返回一个游标对象，该对象主要用于执行不同的SQL语句，包括DDL、DML、select查询语句等。使用游标执行不同的SQL语句返回不同的数据</p>
</li>
</ul>
<p>游标对象通常会具有如下的方法和属性：</p>
<ul>
<li><p><code>execute(sql[,parameters])</code>：执行SQL语句。parameters参数用于为SQL语句中的参数指定值</p>
</li>
<li><p><code>executemany(sql,seq_of_parameters)</code>：重复执行SQL语句。可以通过seq_of_parameters序列为SQL语句中的参数指定值，该序列有多少个元素，SQL被执行多少次。</p>
</li>
<li><p><code>executescript(sql_script)</code>：该方法可以直接执行包含多条SQL语句的SQL脚本</p>
</li>
<li><p><code>fetchone()</code>：获取查询结果集的下一行。如果没有下一行，返回None</p>
</li>
<li><p><code>fetchmany(size = cursor.arraysize)</code>：返回查询结果集的下N行组成的列表。如果没有更多的数据行，返回空列表。</p>
</li>
<li><p><code>fetchall()</code>：返回查询结果集的全部行组成的列表</p>
</li>
<li><p><code>close()</code>：关闭游标</p>
</li>
<li><p><code>rowcount</code> :该只读属性返回受 SQL 语句影响的行数。对于 executemany()方法,该方法所修改的记录条数也可通过该属性获取。</p>
</li>
<li><p><code>lastrowid</code> :该只读属性可获取最后修改行的 rowid 。</p>
</li>
<li><p><code>arraysize</code> :用于设置或获取 fetchmany()默认获取的记录条数,该属性默认为1。有些数据库模块没有该属性。</p>
</li>
<li><p><code>description</code> :该只读属性可获取最后一次查询返回的所有列的信息。</p>
</li>
<li><p><code>connection</code> :该只读属性返回创建游标的数据库连接对象。有些数据库模块没有该属性。</p>
</li>
</ul>
<p>基本 SQL 语句</p>
<pre><code>SQL 是由命令、子句和运算符所构成的,这些元素结合起来组成用于创建、更新和操作数据库的语句。
</code></pre>
<p>SQL命令</p>
<pre><code>SQL 命令分为两类:数据定义 DDL 命令(表8.7)和数据操纵 DML 命令(表8.8)。表8.7 数据定义 DDL 命令
</code></pre>
<p>SQL 运算符</p>
<blockquote>
<p>SQL 运算符包括逻辑运算符和比较运算符。其中逻辑运算符包括 <code>AND、OR 、 NOT </code>,比较运算符包括<code>&lt;、&lt;=、&gt;、&gt;=、=、&lt;&gt;、 BETWEEN 、 LIKE 和 IN </code>。</p>
</blockquote>
<p>举例说明如下。</p>
<p>（1）<code>SELECT</code> 语句,用于从表中选取数据,结果被存储在一个结果表中(称为结果集)。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SELECТ<span class="operator">*</span> FROМ tablel </span><br><span class="line"></span><br><span class="line">SELECТ fldl ,fld2 FROМ table1</span><br><span class="line"></span><br><span class="line">SELECТ table1.fld1,table2.fld2 <span class="keyword">FROM</span> table1,table2 </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> fld1,fld2 FROМ table1 <span class="keyword">WHERE</span> fld1 <span class="keyword">LIKE</span> <span class="string">&#x27;刘%&#x27;</span></span><br><span class="line"></span><br><span class="line">SELECТ fld1,fld2 FROМ table1 <span class="keyword">WHERE</span> fld1 <span class="keyword">BETWEEN</span> <span class="string">&#x27;1-1-1999&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;6-30-1999&#x27;</span></span><br><span class="line"></span><br><span class="line">SELECТ table1.fld1,table2.fld2 FROМ table1,table2 <span class="keyword">WHERE</span> table1.fld3<span class="operator">=</span>table2.fld3 <span class="keyword">GROUP</span> <span class="keyword">BY</span> table1.fld1</span><br><span class="line"></span><br><span class="line">SELECТ table1.fld1,table2.fld2 FROМ table1,table2 <span class="keyword">WHERE</span> table1.fld3<span class="operator">=</span>table2.fld3 <span class="keyword">GROUP</span> <span class="keyword">BY</span> table1.fld1 <span class="keyword">HAVING</span> table1.fld1<span class="operator">*</span>table2.fld2<span class="operator">&gt;=</span><span class="number">100</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>说明:</code> SELECT语句的 HAVING 用于确定带 GROUP BY 子句的查询中具体显示哪些记录,<br>即用 GROUP BY 子句完成分组后,可以用 HAVING 子句来显示满足指定条件的分组。</p>
</blockquote>
<p>（2）<code>SELECT … INTO</code> 语句,用来从查询结果中建立新表。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SELECТ fld1,fld2 <span class="keyword">FROM</span> table1 <span class="keyword">INTo</span> table4  </span><br><span class="line"># 以表table1所有行中字段fld1和fld2的内容为基础建立表table4,表table4中每行包含字段fld1和fld2。</span><br></pre></td></tr></table></figure>

<p>（3）<code>DELETE</code>语句，用于删除表中的行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名称 <span class="keyword">WHERE</span> 条件</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line"> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> fld1 <span class="keyword">LIKE</span> <span class="string">&#x27;刘%&#x27;</span>   </span><br><span class="line"> # 删除表table1中字段fld1包含<span class="string">&#x27;刘&#x27;</span>的行(记录)</span><br></pre></td></tr></table></figure>

<p>（4）<code>INSERT INTO</code>语句，用于向表格中插入新的行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line"></span><br><span class="line">INSERТ <span class="keyword">IN</span>ТO 表名称 <span class="keyword">VALUES</span> (值<span class="number">1</span>,值<span class="number">2</span>,…)</span><br><span class="line"></span><br><span class="line">也可以指定所要插人数据的列:</span><br><span class="line"></span><br><span class="line">INSERТ <span class="keyword">IN</span>ТO table_name (列<span class="number">1</span>,列<span class="number">2</span>,…) <span class="keyword">VALUES</span> (值<span class="number">1</span>,值<span class="number">2</span>,…)</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">IN</span>ТO table1(fld1,fld2,fld3) <span class="keyword">VALUES</span> (<span class="string">&#x27;aaaa&#x27;</span>,<span class="string">&#x27;1997-12-1&#x27;</span>,<span class="number">12</span>) #往表 table1插入一行,</span><br><span class="line"></span><br><span class="line">该行中字段 fldl ,fld2,fld3的内容分别为<span class="string">&#x27; aaaa &#x27;</span>,<span class="string">&#x27;1997-12-1&#x27;</span>,<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>（5）<code>UPDATE</code> 语句,用于修改表中的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line"></span><br><span class="line">UPDATE 表名称 <span class="keyword">SET</span> 列名称<span class="operator">=</span>新值 <span class="keyword">WHERE</span> 条件</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line"></span><br><span class="line">UPDATE table1 <span class="keyword">set</span> fld1<span class="operator">=</span><span class="string">&#x27;2222＇#将表table1中所有行中字段fld1的内容修改为&#x27;</span><span class="number">2222</span>＇</span><br></pre></td></tr></table></figure>


<h3 id="SQLite-数据库"><a href="#SQLite-数据库" class="headerlink" title="SQLite 数据库"></a>SQLite 数据库</h3><p>1.SQLite3模块简介</p>
<p>(1)SQLite3模块命令,详见表8.10。</p>
<p>清华源：-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>比赛流程管理系统</title>
    <url>/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>学习自黑马程序员&amp;传智教育，文档资料有修改</p>
<span id="more"></span>

<h1 id="演讲比赛流程管理系统"><a href="#演讲比赛流程管理系统" class="headerlink" title="演讲比赛流程管理系统"></a>演讲比赛流程管理系统</h1><h2 id="1、-演讲比赛程序需求"><a href="#1、-演讲比赛程序需求" class="headerlink" title="1、 演讲比赛程序需求"></a>1、 演讲比赛程序需求</h2><p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154762048.png" alt="1548154762048"></p>
<h3 id="1-1-比赛规则"><a href="#1-1-比赛规则" class="headerlink" title="1.1 比赛规则"></a>1.1 比赛规则</h3><ul>
<li>学校举行一场演讲比赛，共有<strong>12个人</strong>参加。<strong>比赛共两轮</strong>，第一轮为淘汰赛，第二轮为决赛。</li>
<li>比赛方式：<strong>分组比赛，每组6个人</strong>；选手每次要随机分组，进行比赛</li>
<li>每名选手都有对应的<strong>编号</strong>，如 10001 ~ 10012 </li>
<li>第一轮分为两个小组，每组6个人。 整体按照选手编号进行<strong>抽签</strong>后顺序演讲。</li>
<li>当小组演讲完后，淘汰组内排名最后的三个选手，<strong>前三名晋级</strong>，进入下一轮的比赛。</li>
<li>第二轮为决赛，<strong>前三名胜出</strong></li>
<li>每轮比赛过后需要<strong>显示晋级选手的信息</strong></li>
</ul>
<h3 id="1-2-程序功能"><a href="#1-2-程序功能" class="headerlink" title="1.2 程序功能"></a>1.2 程序功能</h3><ul>
<li>开始演讲比赛：完成整届比赛的流程，每个比赛阶段需要给用户一个提示，用户按任意键后继续下一个阶段</li>
<li>查看往届记录：查看之前比赛前三名结果，每次比赛都会记录到文件中，文件用.csv后缀名保存</li>
<li>清空比赛记录：将文件中数据清空</li>
<li>退出比赛程序：可以退出当前程序</li>
</ul>
<h3 id="1-3-程序效果图："><a href="#1-3-程序效果图：" class="headerlink" title="1.3 程序效果图："></a>1.3 程序效果图：</h3><p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548155966702.png" alt="1548155966702"></p>
<h2 id="2、-项目创建"><a href="#2、-项目创建" class="headerlink" title="2、 项目创建"></a>2、 项目创建</h2><p>创建项目步骤如下：</p>
<ul>
<li>创建新项目</li>
<li>添加文件</li>
</ul>
<h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><ul>
<li>打开vs2017后，点击创建新项目，创建新的C++项目</li>
</ul>
<p>如图：</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548121881969.png" alt="1548121881969"></p>
<ul>
<li>填写项目名称以及选取项目路径，点击确定生成项目</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548122271773.png" alt="1548122271773"></p>
<h3 id="2-2-添加文件"><a href="#2-2-添加文件" class="headerlink" title="2.2 添加文件"></a>2.2 添加文件</h3><ul>
<li>右键源文件，进行添加文件操作</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548122420253.png" alt="1548122420253"></p>
<ul>
<li>填写文件名称，点击添加</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548122510869.png" alt="1548122510869"></p>
<ul>
<li>生成文件成功，效果如下图</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548122619712.png" alt="1548122619712"></p>
<ul>
<li>至此，项目已创建完毕</li>
</ul>
<h2 id="3、-创建管理类"><a href="#3、-创建管理类" class="headerlink" title="3、 创建管理类"></a>3、 创建管理类</h2><p><strong>功能描述：</strong></p>
<ul>
<li>提供菜单界面与用户交互</li>
<li>对演讲比赛流程进行控制</li>
<li>与文件的读写交互</li>
</ul>
<h3 id="3-1创建文件"><a href="#3-1创建文件" class="headerlink" title="3.1创建文件"></a>3.1创建文件</h3><ul>
<li>在头文件和源文件的文件夹下分别创建speechManager.h 和 speechManager.cpp文件</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548123402593.png" alt="1548123402593"></p>
<h3 id="3-2-头文件实现"><a href="#3-2-头文件实现" class="headerlink" title="3.2 头文件实现"></a>3.2 头文件实现</h3><p>在speechManager.h中设计管理类</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演讲管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpeechManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">SpeechManager</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">SpeechManager</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-源文件实现"><a href="#3-3-源文件实现" class="headerlink" title="3.3 源文件实现"></a>3.3 源文件实现</h3><p>在speechManager.cpp中将构造和析构函数空实现补全</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;speechManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SpeechManager::<span class="built_in">SpeechManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SpeechManager::~<span class="built_in">SpeechManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>至此演讲管理类以创建完毕</li>
</ul>
<h2 id="4、-菜单功能"><a href="#4、-菜单功能" class="headerlink" title="4、 菜单功能"></a>4、 菜单功能</h2><p>功能描述：与用户的沟通界面</p>
<h3 id="4-1-添加成员函数"><a href="#4-1-添加成员函数" class="headerlink" title="4.1 添加成员函数"></a>4.1 添加成员函数</h3><p>在管理类speechManager.h中添加成员函数  <code>void show_Menu();</code></p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548123942072.png" alt="1548123942072"></p>
<h3 id="4-2-菜单功能实现"><a href="#4-2-菜单功能实现" class="headerlink" title="4.2 菜单功能实现"></a>4.2 菜单功能实现</h3><ul>
<li>在管理类speechManager.cpp中实现 show_Menu()函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::show_Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********************************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  欢迎参加演讲比赛 ************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  1.开始演讲比赛  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  2.查看往届记录  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  3.清空比赛记录  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  0.退出比赛程序  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********************************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-测试菜单功能"><a href="#4-3-测试菜单功能" class="headerlink" title="4.3 测试菜单功能"></a>4.3 测试菜单功能</h3><ul>
<li>在演讲比赛流程管理系统.cpp中测试菜单功能</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;speechManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	SpeechManager sm;</span><br><span class="line"></span><br><span class="line">	sm.<span class="built_in">show_Menu</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行效果如图：</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548124599641.png" alt="1548124599641"></p>
<ul>
<li>菜单界面搭建完毕</li>
</ul>
<h2 id="5、-退出功能"><a href="#5、-退出功能" class="headerlink" title="5、 退出功能"></a>5、 退出功能</h2><h3 id="5-1-提供功能接口"><a href="#5-1-提供功能接口" class="headerlink" title="5.1  提供功能接口"></a>5.1  提供功能接口</h3><ul>
<li>在main函数中提供分支选择，提供每个功能接口</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	SpeechManager sm;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> choice = <span class="number">0</span>; <span class="comment">//用来存储用户的选项</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sm.<span class="built_in">show_Menu</span>();</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入您的选择： &quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; choice; <span class="comment">// 接受用户的选项</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (choice)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//开始比赛</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//查看记录</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//清空记录</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//退出系统</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>); <span class="comment">//清屏</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-实现退出功能"><a href="#5-2-实现退出功能" class="headerlink" title="5.2 实现退出功能"></a>5.2 实现退出功能</h3><p>在speechManager.h中提供退出系统的成员函数 <code>    void exitSystem();</code></p>
<p>在speechManager.cpp中提供具体的功能实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::exitSystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;欢迎下次使用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-3测试功能"><a href="#5-3测试功能" class="headerlink" title="5.3测试功能"></a>5.3测试功能</h3><p>在main函数分支 0  选项中，调用退出程序的接口</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548124853576.png" alt="1548124853576"></p>
<p>运行测试效果如图：</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548124888578.png" alt="1548124888578"></p>
<h2 id="6、演讲比赛功能"><a href="#6、演讲比赛功能" class="headerlink" title="6、演讲比赛功能"></a>6、演讲比赛功能</h2><h3 id="6-1-功能分析"><a href="#6-1-功能分析" class="headerlink" title="6.1 功能分析"></a>6.1 功能分析</h3><p>比赛流程分析：</p>
<p>抽签 → 开始演讲比赛 → 显示第一轮比赛结果 → </p>
<p>抽签 → 开始演讲比赛 → 显示前三名结果 → 保存分数</p>
<h3 id="6-2-创建选手类"><a href="#6-2-创建选手类" class="headerlink" title="6.2 创建选手类"></a>6.2 创建选手类</h3><ul>
<li>选手类中的属性包含：选手姓名、分数</li>
<li>头文件中创建 speaker.h文件，并添加代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Speaker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">double</span> m_Score[<span class="number">2</span>]; <span class="comment">//分数  最多有两轮得分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-比赛"><a href="#6-3-比赛" class="headerlink" title="6.3 比赛"></a>6.3 比赛</h3><h4 id="6-3-1-成员属性添加"><a href="#6-3-1-成员属性添加" class="headerlink" title="6.3.1 成员属性添加"></a>6.3.1 成员属性添加</h4><ul>
<li>在speechManager.h中添加属性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比赛选手 容器  12人</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一轮晋级容器  6人</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//胜利前三名容器  3人</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;vVictory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放编号 以及对应的 具体选手 容器</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, Speaker&gt; m_Speaker;</span><br></pre></td></tr></table></figure>





<h4 id="6-3-2-初始化属性"><a href="#6-3-2-初始化属性" class="headerlink" title="6.3.2 初始化属性"></a>6.3.2 初始化属性</h4><ul>
<li>在speechManager.h中提供开始比赛的的成员函数 <code>void initSpeech();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSpeech</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现<code>void initSpeech();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::initSpeech</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//容器保证为空</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;v1.<span class="built_in">clear</span>();  </span><br><span class="line">	<span class="keyword">this</span>-&gt;v2.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;vVictory.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Speaker.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="comment">//初始化比赛轮数</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Index = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>SpeechManager构造函数中调用<code>void initSpeech();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SpeechManager::<span class="built_in">SpeechManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//初始化属性</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">initSpeech</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="6-3-3-创建选手"><a href="#6-3-3-创建选手" class="headerlink" title="6.3.3 创建选手"></a>6.3.3 创建选手</h4><ul>
<li>在speechManager.h中提供开始比赛的的成员函数 <code>void createSpeaker();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化创建12名选手</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createSpeaker</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现<code>void createSpeaker();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::createSpeaker</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDEFGHIJKL&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nameSeed.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">		name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">		Speaker sp;</span><br><span class="line">		sp.m_Name = name;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			sp.m_Score[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//12名选手编号</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;v1.<span class="built_in">push_back</span>(i + <span class="number">10001</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//选手编号 以及对应的选手 存放到map容器中</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Speaker.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(i + <span class="number">10001</span>, sp));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>SpeechManager类的 构造函数中调用<code>void createSpeaker();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SpeechManager::<span class="built_in">SpeechManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化属性</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">initSpeech</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//创建选手</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">createSpeaker</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>测试 在main函数中，可以在创建完管理对象后，使用下列代码测试12名选手初始状态</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, Speaker&gt;::iterator it = sm.m_Speaker.<span class="built_in">begin</span>(); it != sm.m_Speaker.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">	cout  &lt;&lt; <span class="string">&quot;选手编号：&quot;</span> &lt;&lt; it-&gt;first </span><br><span class="line">          &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; it-&gt;second.m_Name </span><br><span class="line">          &lt;&lt; <span class="string">&quot; 成绩： &quot;</span> &lt;&lt; it-&gt;second.m_Score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548141605742.png" alt="1548141605742"></p>
<ul>
<li>测试效果如图：</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548141560164.png" alt="1548141560164"></p>
<ul>
<li>测试完毕后，可以将测试代码删除或注释。</li>
</ul>
<h4 id="6-3-4-开始比赛成员函数添加"><a href="#6-3-4-开始比赛成员函数添加" class="headerlink" title="6.3.4 开始比赛成员函数添加"></a>6.3.4 开始比赛成员函数添加</h4><ul>
<li>在speechManager.h中提供开始比赛的的成员函数 <code>void startSpeech();</code></li>
<li>该函数功能是主要控制比赛的流程</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始比赛 - 比赛流程控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpeech</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中将startSpeech的空实现先写入</li>
<li>我们可以先将整个比赛的流程 写到函数中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始比赛</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::startSpeech</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一轮比赛</span></span><br><span class="line">	<span class="comment">//1、抽签</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2、比赛</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、显示晋级结果</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二轮比赛</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、抽签</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、比赛</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、显示最终结果</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、保存分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="6-3-5-抽签"><a href="#6-3-5-抽签" class="headerlink" title="6.3.5 抽签"></a>6.3.5 抽签</h4><p><strong>功能描述：</strong></p>
<ul>
<li>正式比赛前，所有选手的比赛顺序需要打乱，我们只需要将存放选手编号的容器  打乱次序即可</li>
</ul>
<ul>
<li>在speechManager.h中提供抽签的的成员函数 <code>void speechDraw();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽签</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speechDraw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现成员函数 <code>void speechDraw();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::speechDraw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第 &lt;&lt; &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot; &gt;&gt; 轮比赛选手正在抽签&quot;</span>&lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;抽签后演讲顺序如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">random_shuffle</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v1.<span class="built_in">begin</span>(); it != v1.<span class="built_in">end</span>(); it++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">random_shuffle</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在startSpeech比赛流程控制的函数中，调用抽签函数</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548143871202.png" alt="1548143871202"></p>
<ul>
<li>在main函数中，分支1选项中，调用开始比赛的接口</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548143543475.png" alt="1548143543475"></p>
<ul>
<li>测试</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548143610682.png" alt="1548143610682"></p>
<h4 id="6-3-6-开始比赛"><a href="#6-3-6-开始比赛" class="headerlink" title="6.3.6 开始比赛"></a>6.3.6 开始比赛</h4><ul>
<li>在speechManager.h中提供比赛的的成员函数 <code>void speechContest();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比赛</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speechContest</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现成员函数 <code>void speechContest();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::speechContest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------------- 第&quot;</span>&lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot;轮正式比赛开始：------------- &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	multimap&lt;<span class="keyword">double</span>, <span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; groupScore; <span class="comment">//临时容器，保存key分数 value 选手编号</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//记录人员数，6个为1组</span></span><br><span class="line"></span><br><span class="line">	vector &lt;<span class="keyword">int</span>&gt;v_Src;   <span class="comment">//比赛的人员容器</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		v_Src = v1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		v_Src = v2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历所有参赛选手</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v_Src.<span class="built_in">begin</span>(); it != v_Src.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//评委打分</span></span><br><span class="line">		deque&lt;<span class="keyword">double</span>&gt;d;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">double</span> score = (<span class="built_in">rand</span>() % <span class="number">401</span> + <span class="number">600</span>) / <span class="number">10.f</span>;  <span class="comment">// 600 ~ 1000</span></span><br><span class="line">			<span class="comment">//cout &lt;&lt; score &lt;&lt; &quot; &quot;;</span></span><br><span class="line">			d.<span class="built_in">push_back</span>(score);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), greater&lt;<span class="keyword">double</span>&gt;());				<span class="comment">//排序</span></span><br><span class="line">		d.<span class="built_in">pop_front</span>();												<span class="comment">//去掉最高分</span></span><br><span class="line">		d.<span class="built_in">pop_back</span>();												<span class="comment">//去掉最低分</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">double</span> sum = <span class="built_in">accumulate</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">0.0f</span>);				<span class="comment">//获取总分</span></span><br><span class="line">		<span class="keyword">double</span> avg = sum / (<span class="keyword">double</span>)d.<span class="built_in">size</span>();									<span class="comment">//获取平均分</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//每个人平均分</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;编号： &quot; &lt;&lt; *it  &lt;&lt; &quot; 选手： &quot; &lt;&lt; this-&gt;m_Speaker[*it].m_Name &lt;&lt; &quot; 获取平均分为： &quot; &lt;&lt; avg &lt;&lt; endl;  //打印分数</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Speaker[*it].m_Score[<span class="keyword">this</span>-&gt;m_Index - <span class="number">1</span>] = avg;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//6个人一组，用临时容器保存</span></span><br><span class="line">		groupScore.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(avg, *it));</span><br><span class="line">		<span class="keyword">if</span> (num % <span class="number">6</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; num / <span class="number">6</span> &lt;&lt; <span class="string">&quot;小组比赛名次：&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">for</span> (multimap&lt;<span class="keyword">double</span>, <span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = groupScore.<span class="built_in">begin</span>(); it != groupScore.<span class="built_in">end</span>(); it++)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;编号: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Speaker[it-&gt;second].m_Name &lt;&lt; <span class="string">&quot; 成绩： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Speaker[it-&gt;second].m_Score[<span class="keyword">this</span>-&gt;m_Index - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//取前三名</span></span><br><span class="line">			<span class="keyword">for</span> (multimap&lt;<span class="keyword">double</span>, <span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = groupScore.<span class="built_in">begin</span>(); it != groupScore.<span class="built_in">end</span>() &amp;&amp; count &lt; <span class="number">3</span>; it++, count++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					v2.<span class="built_in">push_back</span>((*it).second);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					vVictory.<span class="built_in">push_back</span>((*it).second);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			groupScore.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------------- 第&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot;轮比赛完毕  ------------- &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在startSpeech比赛流程控制的函数中，调用比赛函数</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548144491984.png" alt="1548144491984"></p>
<ul>
<li>再次运行代码，测试比赛</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548144765146.png" alt="1548144765146"></p>
<h4 id="6-3-7-显示比赛分数"><a href="#6-3-7-显示比赛分数" class="headerlink" title="6.3.7 显示比赛分数"></a>6.3.7 显示比赛分数</h4><ul>
<li>在speechManager.h中提供比赛的的成员函数 <code>void showScore();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示比赛结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showScore</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现成员函数 <code>void  showScore();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::showScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------第&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot;轮晋级选手信息如下：-----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		v = v2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		v = vVictory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;选手编号：&quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; m_Speaker[*it].m_Name &lt;&lt; <span class="string">&quot; 得分： &quot;</span> &lt;&lt; m_Speaker[*it].m_Score[<span class="keyword">this</span>-&gt;m_Index - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">show_Menu</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在startSpeech比赛流程控制的函数中，调用显示比赛分数函数</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548146903960.png" alt="1548146903960"></p>
<ul>
<li>运行代码，测试效果</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548146961550.png" alt="1548146961550"></p>
<h4 id="6-3-8-第二轮比赛"><a href="#6-3-8-第二轮比赛" class="headerlink" title="6.3.8 第二轮比赛"></a>6.3.8 第二轮比赛</h4><p>第二轮比赛流程同第一轮，只是比赛的轮是+1，其余流程不变</p>
<ul>
<li>在startSpeech比赛流程控制的函数中，加入第二轮的流程</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548148593215.png" alt="1548148593215"></p>
<p>测试，将整个比赛流程都跑通</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548148536395.png" alt="1548148536395"></p>
<h3 id="6-4-保存分数"><a href="#6-4-保存分数" class="headerlink" title="6.4 保存分数"></a>6.4 保存分数</h3><p><strong>功能描述：</strong></p>
<ul>
<li>将每次演讲比赛的得分记录到文件中</li>
</ul>
<p><strong>功能实现：</strong></p>
<ul>
<li>在speechManager.h中添加保存记录的成员函数 <code>void saveRecord();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveRecord</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现成员函数 <code>void saveRecord();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::saveRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;speech.csv&quot;</span>, ios::out | ios::app); <span class="comment">// 用输出的方式打开文件  -- 写文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//将每个人数据写入到文件中</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = vVictory.<span class="built_in">begin</span>(); it != vVictory.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		ofs &lt;&lt; *it &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">			&lt;&lt; m_Speaker[*it].m_Score[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ofs &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;记录已经保存&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在startSpeech比赛流程控制的函数中，最后调用保存记录分数函数</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548149937860.png" alt="1548149937860"></p>
<ul>
<li>测试，整个比赛完毕后记录保存情况</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548149912863.png" alt="1548149912863"></p>
<p>利用记事本打开文件 speech.csv，里面保存了前三名选手的编号以及得分</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548150047975.png" alt="1548150047975"></p>
<p>至此，整个演讲比赛功能制作完毕！</p>
<h2 id="7、-查看记录"><a href="#7、-查看记录" class="headerlink" title="7、 查看记录"></a>7、 查看记录</h2><h3 id="7-1-读取记录分数"><a href="#7-1-读取记录分数" class="headerlink" title="7.1 读取记录分数"></a>7.1 读取记录分数</h3><ul>
<li>在speechManager.h中添加保存记录的成员函数 <code>void loadRecord();</code></li>
<li>添加判断文件是否为空的标志  <code>bool fileIsEmpty;</code></li>
<li>添加往届记录的容器<code>map&lt;int, vector&lt;string&gt;&gt; m_Record;</code>   </li>
</ul>
<p>其中m_Record 中的key代表第几届，value记录具体的信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadRecord</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件为空的标志</span></span><br><span class="line"><span class="keyword">bool</span> fileIsEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往届记录</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, vector&lt;string&gt;&gt; m_Record;</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现成员函数 <code>void loadRecord();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::loadRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;speech.csv&quot;</span>, ios::in)</span></span>; <span class="comment">//输入流对象 读取文件</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;fileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		ifs.<span class="built_in">close</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	ifs &gt;&gt; ch;</span><br><span class="line">	<span class="keyword">if</span> (ifs.<span class="built_in">eof</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">this</span>-&gt;fileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">		ifs.<span class="built_in">close</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//文件不为空</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;fileIsEmpty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">putback</span>(ch); <span class="comment">//读取的单个字符放回去</span></span><br><span class="line"></span><br><span class="line">	string data;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; data &lt;&lt; endl;</span></span><br><span class="line">		vector&lt;string&gt;v;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			pos = data.<span class="built_in">find</span>(<span class="string">&quot;,&quot;</span>, start); <span class="comment">//从0开始查找 &#x27;,&#x27;</span></span><br><span class="line">			<span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>; <span class="comment">//找不到break返回</span></span><br><span class="line">			&#125;</span><br><span class="line">			string tmp = data.<span class="built_in">substr</span>(start, pos - start); <span class="comment">//找到了,进行分割 参数1 起始位置，参数2 截取长度</span></span><br><span class="line">			v.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">			start = pos + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Record.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(index, v));</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在SpeechManager构造函数中调用获取往届记录函数</li>
</ul>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548151977242.png" alt="1548151977242"></p>
<h3 id="7-2-查看记录功能"><a href="#7-2-查看记录功能" class="headerlink" title="7.2 查看记录功能"></a>7.2 查看记录功能</h3><ul>
<li>在speechManager.h中添加保存记录的成员函数 <code>void showRecord();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示往届得分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showRecord</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现成员函数 <code>void showRecord();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::showRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Record.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;届 &quot;</span> &lt;&lt;</span><br><span class="line">			<span class="string">&quot;冠军编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; 得分：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">			<span class="string">&quot;亚军编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">2</span>] &lt;&lt; <span class="string">&quot; 得分：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">3</span>] &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">			<span class="string">&quot;季军编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">4</span>] &lt;&lt; <span class="string">&quot; 得分：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">5</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-3-测试功能"><a href="#7-3-测试功能" class="headerlink" title="7.3 测试功能"></a>7.3 测试功能</h3><p>在main函数分支 2  选项中，调用查看记录的接口</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548152359604.png" alt="1548152359604"></p>
<p>显示效果如图：（本次测试添加了4条记录）</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548152394715.png" alt="1548152394715"></p>
<h3 id="7-4-bug解决"><a href="#7-4-bug解决" class="headerlink" title="7.4 bug解决"></a>7.4 bug解决</h3><p>目前程序中有几处bug未解决：</p>
<ol>
<li>查看往届记录，若文件不存在或为空，并未提示</li>
</ol>
<p>解决方式：在showRecord函数中，开始判断文件状态并加以判断</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548152803116.png" alt="1548152803116"></p>
<ol start="2">
<li>若记录为空或不存在，比完赛后依然提示记录为空</li>
</ol>
<p>解决方式：saveRecord中更新文件为空的标志</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548153005042.png" alt="1548153005042"></p>
<ol start="3">
<li>比完赛后查不到本届比赛的记录，没有实时更新</li>
</ol>
<p>解决方式：比赛完毕后，所有数据重置</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548153319587.png" alt="1548153319587"></p>
<ol start="4">
<li>在初始化时，没有初始化记录容器</li>
</ol>
<p>解决方式：initSpeech中添加 初始化记录容器</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154340974.png" alt="1548154340974"></p>
<ol start="5">
<li>每次记录都是一样的</li>
</ol>
<p>解决方式：在main函数一开始 添加随机数种子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>



<p>所有bug解决后 测试：</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548153571603.png" alt="1548153571603"></p>
<h2 id="8、-清空记录"><a href="#8、-清空记录" class="headerlink" title="8、 清空记录"></a>8、 清空记录</h2><h3 id="8-1-清空记录功能实现"><a href="#8-1-清空记录功能实现" class="headerlink" title="8.1 清空记录功能实现"></a>8.1 清空记录功能实现</h3><ul>
<li>在speechManager.h中添加保存记录的成员函数 <code>void clearRecord();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearRecord</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现成员函数 <code>void clearRecord();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::clearRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;确认清空？&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、确认&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、返回&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//打开模式 ios::trunc 如果存在删除文件并重新创建</span></span><br><span class="line">		<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;speech.csv&quot;</span>, ios::trunc)</span></span>;</span><br><span class="line">		ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//初始化属性</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">initSpeech</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建选手</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">createSpeaker</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取往届记录</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">loadRecord</span>();</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;清空成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-测试清空"><a href="#8-2-测试清空" class="headerlink" title="8.2 测试清空"></a>8.2 测试清空</h3><p>在main函数分支 3  选项中，调用清空比赛记录的接口</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154674242.png" alt="1548154674242"></p>
<p>运行程序，测试清空记录：</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154004738.png" alt="1548154004738"></p>
<p>speech.csv中记录也为空</p>
<p><img src="/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154508831.png" alt="1548154508831"></p>
<ul>
<li>至此本案例结束！ <code>^_^</code></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据类型</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>原文链接：<a href="https://www.cnblogs.com/-xlp/p/8617760.html">MySQL中数据类型介绍 - myxlp - 博客园 (cnblogs.com)</a> </p>
<span id="more"></span>

<h2 id="MYSQL中数据类型介绍"><a href="#MYSQL中数据类型介绍" class="headerlink" title="MYSQL中数据类型介绍"></a><strong>MYSQL中数据类型介绍</strong></h2><h3 id="一、MySQL的数据类型"><a href="#一、MySQL的数据类型" class="headerlink" title="一、MySQL的数据类型"></a><strong>一、MySQL的数据类型</strong></h3><p>主要包括以下五大类：</p>
<p>整数类型：<code>BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</code></p>
<p>浮点数类型：<code>FLOAT、DOUBLE、DECIMAL</code></p>
<p>字符串类型：<code>CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</code></p>
<p>日期类型：<code>Date、DateTime、TimeStamp、Time、Year</code></p>
<p>其他数据类型：<code>BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection</code>等</p>
<h4 id="1、整型"><a href="#1、整型" class="headerlink" title="1、整型"></a>1、整型</h4><table>
<thead>
<tr>
<th>MySQL数据类型</th>
<th>含义（有符号）</th>
</tr>
</thead>
<tbody><tr>
<td>tinyint(m)</td>
<td>1个字节 范围(-128~127)</td>
</tr>
<tr>
<td>smallint(m)</td>
<td>2个字节 范围(-32768~32767)</td>
</tr>
<tr>
<td>mediumint(m)</td>
<td>3个字节 范围(-8388608~8388607)</td>
</tr>
<tr>
<td>int(m)</td>
<td>4个字节 范围(-2147483648~2147483647)</td>
</tr>
<tr>
<td>bigint(m)</td>
<td>8个字节 范围(+-9.22*10的18次方)</td>
</tr>
</tbody></table>
<p>取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。</p>
<p> int(m)里的m是表示SELECT查询结果集中的显示宽度，并不影响实际的取值范围，没有影响到显示的宽度，不知道这个m有什么用。</p>
<h4 id="2、浮点型-float和double"><a href="#2、浮点型-float和double" class="headerlink" title="2、浮点型(float和double)"></a>2、浮点型(float和double)</h4><table>
<thead>
<tr>
<th>MySQL数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>float(m,d)</td>
<td>单精度浮点型  8位精度(4字节)   m总个数，d小数位</td>
</tr>
<tr>
<td>double(m,d)</td>
<td>双精度浮点型  16位精度(8字节)   m总个数，d小数位</td>
</tr>
</tbody></table>
<p>设一个字段定义为float(6,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。整数部分最大是3位，如果插入数12.123456，存储的是12.1234，如果插入12.12，存储的是12.1200.</p>
<h4 id="3、定点数"><a href="#3、定点数" class="headerlink" title="3、定点数"></a>3、定点数</h4><p>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。 </p>
<p>decimal(m,d) 参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位。</p>
<h4 id="4、字符串-char-varchar-text"><a href="#4、字符串-char-varchar-text" class="headerlink" title="4、字符串(char, varchar, text)"></a>4、字符串(char, varchar, text)</h4><table>
<thead>
<tr>
<th>MySQL数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>char(n)</td>
<td>固定长度，最多255个字符</td>
</tr>
<tr>
<td>varchar(n)</td>
<td>固定长度，最多65535个字符</td>
</tr>
<tr>
<td>tinytext</td>
<td>可变长度，最多255个字符</td>
</tr>
<tr>
<td>text</td>
<td>可变长度，最多65535个字符</td>
</tr>
<tr>
<td>mediumtext</td>
<td>可变长度，最多2的24次方-1个字符</td>
</tr>
<tr>
<td>longtext</td>
<td>可变长度，最多2的32次方-1个字符</td>
</tr>
</tbody></table>
<p>char和varchar：</p>
<p>1.char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。 </p>
<p>2.char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，所以varchar(4),存入3个字符将占用4个字节。 </p>
<p>3.char类型的字符串检索速度要比varchar类型的快。</p>
<p>varchar和text： </p>
<p>1.varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，text是实际字符数+2个字节。 </p>
<p>2.text类型不能有默认值。 </p>
<p>3.varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。</p>
<h4 id="5-二进制数据-Blob"><a href="#5-二进制数据-Blob" class="headerlink" title="5.二进制数据(Blob)"></a>5.二进制数据(Blob)</h4><p>1.BLOB和text存储方式不同，TEXT以文本方式存储，英文存储区分大小写，而Blob是以二进制方式存储，不分大小写。</p>
<p>2.BLOB存储的数据只能整体读出。 </p>
<p>3.TEXT可以指定字符集，BLOB不用指定字符集。</p>
<h4 id="6-日期时间类型"><a href="#6-日期时间类型" class="headerlink" title="6.日期时间类型"></a>6.日期时间类型</h4><table>
<thead>
<tr>
<th>MySQL数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>date</td>
<td>日期 ‘2008-12-2’</td>
</tr>
<tr>
<td>time</td>
<td>时间 ‘12:25:36’</td>
</tr>
<tr>
<td>datetime</td>
<td>日期时间 ‘2008-12-2 22:06:44’</td>
</tr>
<tr>
<td>timestamp</td>
<td>自动存储记录修改时间</td>
</tr>
</tbody></table>
<p>若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。</p>
<h4 id="数据类型的属性"><a href="#数据类型的属性" class="headerlink" title="数据类型的属性"></a>数据类型的属性</h4><table>
<thead>
<tr>
<th>MySQL关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>数据列可包含NULL值</td>
</tr>
<tr>
<td>NOT NULL</td>
<td>数据列不允许包含NULL值</td>
</tr>
<tr>
<td>DEFAULT</td>
<td>默认值</td>
</tr>
<tr>
<td>PRIMARY KEY</td>
<td>主键</td>
</tr>
<tr>
<td>AUTO_INCREMENT</td>
<td>自动递增，适用于整数类型</td>
</tr>
<tr>
<td>UNSIGNED</td>
<td>无符号</td>
</tr>
<tr>
<td>CHARACTER SET name</td>
<td>指定一个字符集</td>
</tr>
</tbody></table>
<h3 id="二、MYSQL数据类型的长度和范围"><a href="#二、MYSQL数据类型的长度和范围" class="headerlink" title="二、MYSQL数据类型的长度和范围"></a><strong>二、MYSQL数据类型的长度和范围</strong></h3><p>各数据类型及字节长度一览表：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>字节长度</th>
<th>范围或用法</th>
</tr>
</thead>
<tbody><tr>
<td>Bit</td>
<td>1</td>
<td>无符号[0,255]，有符号[-128,127]，天缘博客备注：BIT和BOOL布尔型都占用1字节</td>
</tr>
<tr>
<td>TinyInt</td>
<td>1</td>
<td>整数[0,255]</td>
</tr>
<tr>
<td>SmallInt</td>
<td>2</td>
<td>无符号[0,65535]，有符号[-32768,32767]</td>
</tr>
<tr>
<td>MediumInt</td>
<td>3</td>
<td>无符号[0,2^24-1]，有符号[-2^23,2^23-1]]</td>
</tr>
<tr>
<td>Int</td>
<td>4</td>
<td>无符号[0,2^32-1]，有符号[-2^31,2^31-1]</td>
</tr>
<tr>
<td>BigInt</td>
<td>8</td>
<td>无符号[0,2^64-1]，有符号[-2^63 ,2^63 -1]</td>
</tr>
<tr>
<td>Float(M,D)</td>
<td>4</td>
<td>单精度浮点数。天缘博客提醒这里的D是精度，如果D&lt;=24则为默认的FLOAT，如果D&gt;24则会自动被转换为DOUBLE型。</td>
</tr>
<tr>
<td>Double(M,D)</td>
<td>8</td>
<td>双精度浮点。</td>
</tr>
<tr>
<td>Decimal(M,D)</td>
<td>M+1或M+2</td>
<td>未打包的浮点数，用法类似于FLOAT和DOUBLE，天缘博客提醒您如果在ASP中使用到Decimal数据类型，直接从数据库读出来的Decimal可能需要先转换成Float或Double类型后再进行运算。</td>
</tr>
<tr>
<td>Date</td>
<td>3</td>
<td>以YYYY-MM-DD的格式显示，比如：2009-07-19</td>
</tr>
<tr>
<td>Date Time</td>
<td>8</td>
<td>以YYYY-MM-DD HH:MM:SS的格式显示，比如：2009-07-19 11：22：30</td>
</tr>
<tr>
<td>TimeStamp</td>
<td>4</td>
<td>以YYYY-MM-DD的格式显示，比如：2009-07-19</td>
</tr>
<tr>
<td>Time</td>
<td>3</td>
<td>以HH:MM:SS的格式显示。比如：11：22：30</td>
</tr>
<tr>
<td>Year</td>
<td>1</td>
<td>以YYYY的格式显示。比如：2009</td>
</tr>
<tr>
<td>Char(M)</td>
<td>M</td>
<td>定长字符串。</td>
</tr>
<tr>
<td>VarChar(M)</td>
<td>M</td>
<td>变长字符串，要求M&lt;=255</td>
</tr>
<tr>
<td>Binary(M)</td>
<td>M</td>
<td>类似Char的二进制存储，特点是插入定长不足补0</td>
</tr>
<tr>
<td>VarBinary(M)</td>
<td>M</td>
<td>类似VarChar的变长二进制存储，特点是定长不补0</td>
</tr>
<tr>
<td>Tiny Text</td>
<td>Max:255</td>
<td>大小写不敏感</td>
</tr>
<tr>
<td>Text</td>
<td>Max:64K</td>
<td>大小写不敏感</td>
</tr>
<tr>
<td>Medium Text</td>
<td>Max:16M</td>
<td>大小写不敏感</td>
</tr>
<tr>
<td>Long Text</td>
<td>Max:4G</td>
<td>大小写不敏感</td>
</tr>
<tr>
<td>TinyBlob</td>
<td>Max:255</td>
<td>大小写敏感</td>
</tr>
<tr>
<td>Blob</td>
<td>Max:64K</td>
<td>大小写敏感</td>
</tr>
<tr>
<td>MediumBlob</td>
<td>Max:16M</td>
<td>大小写敏感</td>
</tr>
<tr>
<td>LongBlob</td>
<td>Max:4G</td>
<td>大小写敏感</td>
</tr>
<tr>
<td>Enum</td>
<td>1或2</td>
<td>最大可达65535个不同的枚举值</td>
</tr>
<tr>
<td>Set</td>
<td>可达8</td>
<td>最大可达64个不同的值</td>
</tr>
<tr>
<td>Geometry</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Point</td>
<td></td>
<td></td>
</tr>
<tr>
<td>LineString</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Polygon</td>
<td></td>
<td></td>
</tr>
<tr>
<td>MultiPoint</td>
<td></td>
<td></td>
</tr>
<tr>
<td>MultiLineString</td>
<td></td>
<td></td>
</tr>
<tr>
<td>MultiPolygon</td>
<td></td>
<td></td>
</tr>
<tr>
<td>GeometryCollection</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="三、使用建议"><a href="#三、使用建议" class="headerlink" title="三、使用建议"></a><strong>三、使用建议</strong></h3><p>1、在指定数据类型的时候一般是采用从小原则，比如能用TINY INT的最好就不用INT，能用FLOAT类型的就不用DOUBLE类型，这样会对MYSQL在运行效率上提高很大，尤其是大数据量测试条件下。</p>
<p>2、不需要把数据表设计的太过复杂，功能模块上区分或许对于后期的维护更为方便，慎重出现大杂烩数据表</p>
<p>3、数据表和字段的起名字也是一门学问</p>
<p>4、设计数据表结构之前请先想象一下是你的房间，或许结果会更加合理、高效</p>
<p>5、数据库的最后设计结果一定是效率和可扩展性的折中，偏向任何一方都是欠妥的</p>
<h3 id="选择数据类型的基本原则"><a href="#选择数据类型的基本原则" class="headerlink" title="选择数据类型的基本原则"></a><strong>选择数据类型的基本原则</strong></h3><p>前提：使用适合存储引擎。</p>
<p>选择原则：根据选定的存储引擎，确定如何选择合适的数据类型。</p>
<p>下面的选择方法按存储引擎分类：</p>
<ul>
<li>MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。</li>
<li>MEMORY存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系。两者都是作为CHAR类型处理的。</li>
<li>InnoDB 存储引擎和数据列：建议使用 VARCHAR类型。</li>
</ul>
<p>对于InnoDB数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的CHAR列不一定比使用可变长度VARCHAR列简单。因而，主要的性能因素是数据行使用的存储总量。由于CHAR平均占用的空间多于VARCHAR，因此使用VARCHAR来最小化需要处理的数据行的存储总量和磁盘I/O是比较好的。</p>
<p>下面说一下固定长度数据列与可变长度的数据列。</p>
<h3 id="char与varchar"><a href="#char与varchar" class="headerlink" title="char与varchar"></a><strong>char与varchar</strong></h3><p>CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>下面的表显示了将各种字符串值保存到CHAR(4)和VARCHAR(4)列后的结果，说明了CHAR和VARCHAR之间的差别：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>CHAR(4)</th>
<th>存储需求</th>
<th>VARCHAR(4)</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>‘’</td>
<td>‘  ‘</td>
<td>4个字节</td>
<td>‘’</td>
<td>1个字节</td>
</tr>
<tr>
<td>‘ab’</td>
<td>‘ab ‘</td>
<td>4个字节</td>
<td>‘ab ‘</td>
<td>3个字节</td>
</tr>
<tr>
<td>‘abcd’</td>
<td>‘abcd’</td>
<td>4个字节</td>
<td>‘abcd’</td>
<td>5个字节</td>
</tr>
<tr>
<td>‘abcdefgh’</td>
<td>‘abcd’</td>
<td>4个字节</td>
<td>‘abcd’</td>
<td>5个字节</td>
</tr>
</tbody></table>
<p>请注意上表中最后一行的值只适用不使用严格模式时；如果MySQL运行在严格模式，超过列长度不的值不保存，并且会出现错误。</p>
<p>从CHAR(4)和VARCHAR(4)列检索的值并不总是相同，因为检索时从CHAR列删除了尾部的空格。通过下面的例子说明该差别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE vc (v VARCHAR(4), c CHAR(4));</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO vc VALUES (&#x27;ab &#x27;, &#x27;ab &#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT CONCAT(v, &#x27;+&#x27;), CONCAT(c, &#x27;+&#x27;) FROM vc;</span><br><span class="line">+----------------+----------------+</span><br><span class="line">| CONCAT(v, &#x27;+&#x27;) | CONCAT(c, &#x27;+&#x27;) |</span><br><span class="line">+----------------+----------------+</span><br><span class="line">| ab +     | ab+      |</span><br><span class="line">+----------------+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<h3 id="text和blob"><a href="#text和blob" class="headerlink" title="text和blob"></a><strong>text和blob</strong></h3><p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p>
<p>①BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的”空洞”，以后填入这些”空洞”的记录可能长度不同,为了提高性能,建议定期使用 OPTIMIZE TABLE 功能对这类表进行碎片整理.</p>
<p>②使用合成的（synthetic）索引。合成的索引列在某些时候是有用的。一种办法是根据其它的列的内容建立一个散列值，并把这个值存储在单独的数据列中。接下来你就可以通过检索散列值找到数据行了。但是，我们要注意这种技术只能用于精确匹配的查询（散列值对于类似&lt;或&gt;=等范围搜索操作符 是没有用处的）。我们可以使用MD5()函数生成散列值，也可以使用SHA1()或CRC32()，或者使用自己的应用程序逻辑来计算散列值。请记住数值型散列值可以很高效率地存储。同样，如果散列算法生成的字符串带有尾部空格，就不要把它们存储在CHAR或VARCHAR列中，它们会受到尾部空格去除的影响。合成的散列索引对于那些BLOB或TEXT数据列特别有用。用散列标识符值查找的速度比搜索BLOB列本身的速度快很多。</p>
<p>③在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT *查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。这也是 BLOB或TEXT标识符信息存储在合成的索引列中对我们有所帮助的例子。你可以搜索索引列，决定那些需要的数据行，然后从合格的数据行中检索BLOB或 TEXT值。</p>
<p>④把BLOB或TEXT列分离到单独的表中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中 的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会减少主表中的碎片，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT *查询的时候不会通过网络传输大量的BLOB或TEXT值。</p>
<h3 id="浮点数与定点数"><a href="#浮点数与定点数" class="headerlink" title="浮点数与定点数"></a><strong>浮点数与定点数</strong></h3><p>为了能够引起大家的重视，在介绍浮点数与定点数以前先让大家看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE test (c1 float(10,2),c2 decimal(10,2));</span><br><span class="line">Query OK, 0 rows affected (0.29 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into test values(131072.32,131072.32);</span><br><span class="line">Query OK, 1 row affected (0.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test;</span><br><span class="line">+-----------+-----------+</span><br><span class="line">| c1    | c2    |</span><br><span class="line">+-----------+-----------+</span><br><span class="line">| 131072.31 | 131072.32 |</span><br><span class="line">+-----------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>


<p>从上面的例子中我们看到c1列的值由131072.32变成了131072.31，这就是浮点数的不精确性造成的。</p>
<p>在mysql中float、double（或real）是浮点数，decimal（或numberic）是定点数。</p>
<p>浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的数据范围；它的缺点是会引起精度问题。在今后关于浮点数和定点数的应用中，大家要记住以下几点：</p>
<ol>
<li>浮点数存在误差问题；</li>
<li>对货币等对精度敏感的数据，应该用定点数表示或存储；</li>
<li>编程中，如果用到浮点数，要特别注意误差问题，并尽量避免做浮点数比较；</li>
<li>要注意浮点数中一些特殊值的处理。</li>
</ol>
<hr>
<p>原文链接：<a href="https://www.cnblogs.com/-xlp/p/8617760.html">MySQL中数据类型介绍 - myxlp - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫基础简介</title>
    <url>/%E6%B3%A2%E6%99%93%E5%BC%A0%E8%AF%BE%E4%BB%B6/</url>
    <content><![CDATA[<p>学自路飞学城</p>
<span id="more"></span>

<h3 id="爬虫基础简介"><a href="#爬虫基础简介" class="headerlink" title="爬虫基础简介"></a>爬虫基础简介</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前戏：</span><br><span class="line">    1.你是否在夜深人静的时候，想看一些会让你更睡不着的图片却苦于没有资源...</span><br><span class="line">    2.你是否在节假日出行高峰的时候，想快速抢购火车票成功...</span><br><span class="line">    3.你是否在网上购物的时候，想快速且精准的定位到口碑质量最好的商品...</span><br><span class="line"></span><br><span class="line">什么是爬虫：</span><br><span class="line">    - 通过编写程序，模拟浏览器上网，然后让其去互联网上抓取数据的过程。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">爬虫的价值：</span><br><span class="line">    - 实际应用</span><br><span class="line">    - 就业</span><br><span class="line"></span><br><span class="line">爬虫究竟是合法还是违法的？</span><br><span class="line">- 在法律中是不被禁止</span><br><span class="line">- 具有违法风险</span><br><span class="line">- 善意爬虫  恶意爬虫</span><br><span class="line"></span><br><span class="line">爬虫带来的风险可以体现在如下2方面：</span><br><span class="line">    - 爬虫干扰了被访问网站的正常运营</span><br><span class="line">    - 爬虫抓取了收到法律保护的特定类型的数据或信息</span><br><span class="line"></span><br><span class="line">如何在使用编写爬虫的过程中避免进入局子的厄运呢？</span><br><span class="line">    - 时常的优化自己的程序，避免干扰被访问网站的正常运行</span><br><span class="line">    - 在使用，传播爬取到的数据时，审查抓取到的内容，如果发现了涉及到用户隐私商业机密等敏感内容需要及时停止爬取或传播</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">爬虫在使用场景中的分类</span><br><span class="line">    - 通用爬虫：</span><br><span class="line">        抓取系统重要组成部分。抓取的是一整张页面数据。</span><br><span class="line">    - 聚焦爬虫：</span><br><span class="line">        是建立在通用爬虫的基础之上。抓取的是页面中特定的局部内容。</span><br><span class="line">    - 增量式爬虫：</span><br><span class="line">        检测网站中数据更新的情况。只会抓取网站中最新更新出来的数据。</span><br><span class="line"></span><br><span class="line">爬虫的矛与盾</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">反爬机制</span><br><span class="line">    门户网站，可以通过制定相应的策略或者技术手段，防止爬虫程序进行网站数据的爬取。</span><br><span class="line"></span><br><span class="line">反反爬策略</span><br><span class="line">    爬虫程序可以通过制定相关的策略或者技术手段，破解门户网站中具备的反爬机制，从而可以获取门户网站中相关的数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">robots.txt协议：</span><br><span class="line">    君子协议。规定了网站中哪些数据可以被爬虫爬取哪些数据不可以被爬取。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http协议</span><br><span class="line">    - 概念：就是服务器和客户端进行数据交互的一种形式。</span><br><span class="line">常用请求头信息</span><br><span class="line">    - User-Agent：请求载体的身份标识</span><br><span class="line">    - Connection：请求完毕后，是断开连接还是保持连接</span><br><span class="line"></span><br><span class="line">常用响应头信息</span><br><span class="line">    - Content-Type：服务器响应回客户端的数据类型</span><br><span class="line"></span><br><span class="line">https协议：</span><br><span class="line">    - 安全的超文本传输协议</span><br><span class="line"></span><br><span class="line">加密方式</span><br><span class="line">    - 对称秘钥加密</span><br><span class="line">    - 非对称秘钥加密</span><br><span class="line">    - 证书秘钥加密</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="requests模块基础"><a href="#requests模块基础" class="headerlink" title="requests模块基础"></a>requests模块基础</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requests模块</span><br><span class="line">    - urllib模块</span><br><span class="line">    - requests模块</span><br><span class="line"></span><br><span class="line">requests模块：python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率极高。</span><br><span class="line">作用：模拟浏览器发请求。</span><br><span class="line"></span><br><span class="line">如何使用：（requests模块的编码流程）</span><br><span class="line">    - 指定url</span><br><span class="line">        - UA伪装</span><br><span class="line">        - 请求参数的处理</span><br><span class="line">    - 发起请求</span><br><span class="line">    - 获取响应数据</span><br><span class="line">    - 持久化存储</span><br><span class="line"></span><br><span class="line">环境安装：</span><br><span class="line">    pip install requests</span><br><span class="line"></span><br><span class="line">实战编码：</span><br><span class="line">    - 需求：爬取搜狗首页的页面数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实战巩固</span><br><span class="line">    - 需求：爬取搜狗指定词条对应的搜索结果页面（简易网页采集器）</span><br><span class="line">        - UA检测</span><br><span class="line">        - UA伪装</span><br><span class="line">    - 需求：破解百度翻译</span><br><span class="line">        - post请求（携带了参数）</span><br><span class="line">        - 响应数据是一组json数据</span><br><span class="line">    - 需求：爬取豆瓣电影分类排行榜 https://movie.douban.com/中的电影详情数据</span><br><span class="line"></span><br><span class="line">    - 作业：爬取肯德基餐厅查询http://www.kfc.com.cn/kfccda/index.aspx中指定地点的餐厅数据</span><br><span class="line"></span><br><span class="line">    - 需求：爬取国家药品监督管理总局中基于中华人民共和国化妆品生产许可证相关数据</span><br><span class="line">                http://125.35.6.84:81/xk/</span><br><span class="line">        - 动态加载数据</span><br><span class="line">        - 首页中对应的企业信息数据是通过ajax动态请求到的。</span><br><span class="line"></span><br><span class="line">        http://125.35.6.84:81/xk/itownet/portal/dzpz.jsp?id=e6c1aa332b274282b04659a6ea30430a</span><br><span class="line">        http://125.35.6.84:81/xk/itownet/portal/dzpz.jsp?id=f63f61fe04684c46a016a45eac8754fe</span><br><span class="line">        - 通过对详情页url的观察发现：</span><br><span class="line">            - url的域名都是一样的，只有携带的参数（id）不一样</span><br><span class="line">            - id值可以从首页对应的ajax请求到的json串中获取</span><br><span class="line">            - 域名和id值拼接处一个完整的企业对应的详情页的url</span><br><span class="line">        - 详情页的企业详情数据也是动态加载出来的</span><br><span class="line">            - http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById</span><br><span class="line">            - http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById</span><br><span class="line">            - 观察后发现：</span><br><span class="line">                - 所有的post请求的url都是一样的，只有参数id值是不同。</span><br><span class="line">                - 如果我们可以批量获取多家企业的id后，就可以将id和url形成一个完整的详情页对应详情数据的ajax请求的url</span><br><span class="line"></span><br><span class="line">数据解析：</span><br><span class="line">    聚焦爬虫</span><br><span class="line">    正则</span><br><span class="line">    bs4</span><br><span class="line">    xpath</span><br></pre></td></tr></table></figure>



<h3 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">聚焦爬虫:爬取页面中指定的页面内容。</span><br><span class="line">    - 编码流程：</span><br><span class="line">        - 指定url</span><br><span class="line">        - 发起请求</span><br><span class="line">        - 获取响应数据</span><br><span class="line">        - 数据解析</span><br><span class="line">        - 持久化存储</span><br><span class="line"></span><br><span class="line">数据解析分类：</span><br><span class="line">    - 正则</span><br><span class="line">    - bs4</span><br><span class="line">    - xpath（***）</span><br><span class="line"></span><br><span class="line">数据解析原理概述：</span><br><span class="line">    - 解析的局部的文本内容都会在标签之间或者标签对应的属性中进行存储</span><br><span class="line">    - 1.进行指定标签的定位</span><br><span class="line">    - 2.标签或者标签对应的属性中存储的数据值进行提取（解析）</span><br><span class="line"></span><br><span class="line">正则解析：</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;thumb&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;/article/121721100&quot; target=&quot;_blank&quot;&gt;</span><br><span class="line">&lt;img src=&quot;//pic.qiushibaike.com/system/pictures/12172/121721100/medium/DNXDX9TZ8SDU6OK2.jpg&quot; alt=&quot;指引我有前进的方向&quot;&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">ex = &#x27;&lt;div class=&quot;thumb&quot;&gt;.*?&lt;img src=&quot;(.*?)&quot; alt.*?&lt;/div&gt;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bs4进行数据解析</span><br><span class="line">    - 数据解析的原理：</span><br><span class="line">        - 1.标签定位</span><br><span class="line">        - 2.提取标签、标签属性中存储的数据值</span><br><span class="line">    - bs4数据解析的原理：</span><br><span class="line">        - 1.实例化一个BeautifulSoup对象，并且将页面源码数据加载到该对象中</span><br><span class="line">        - 2.通过调用BeautifulSoup对象中相关的属性或者方法进行标签定位和数据提取</span><br><span class="line">    - 环境安装：</span><br><span class="line">        - pip install bs4</span><br><span class="line">        - pip install lxml</span><br><span class="line">    - 如何实例化BeautifulSoup对象：</span><br><span class="line">        - from bs4 import BeautifulSoup</span><br><span class="line">        - 对象的实例化：</span><br><span class="line">            - 1.将本地的html文档中的数据加载到该对象中</span><br><span class="line">                    fp = open(&#x27;./test.html&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)</span><br><span class="line">                    soup = BeautifulSoup(fp,&#x27;lxml&#x27;)</span><br><span class="line">            - 2.将互联网上获取的页面源码加载到该对象中</span><br><span class="line">                    page_text = response.text</span><br><span class="line">                    soup = BeatifulSoup(page_text,&#x27;lxml&#x27;)</span><br><span class="line">        - 提供的用于数据解析的方法和属性：</span><br><span class="line">            - soup.tagName:返回的是文档中第一次出现的tagName对应的标签</span><br><span class="line">            - soup.find():</span><br><span class="line">                - find(&#x27;tagName&#x27;):等同于soup.div</span><br><span class="line">                - 属性定位：</span><br><span class="line">                    -soup.find(&#x27;div&#x27;,class_/id/attr=&#x27;song&#x27;)</span><br><span class="line">            - soup.find_all(&#x27;tagName&#x27;):返回符合要求的所有标签（列表）</span><br><span class="line">        - select：</span><br><span class="line">            - select(&#x27;某种选择器（id，class，标签...选择器）&#x27;),返回的是一个列表。</span><br><span class="line">            - 层级选择器：</span><br><span class="line">                - soup.select(&#x27;.tang &gt; ul &gt; li &gt; a&#x27;)：&gt;表示的是一个层级</span><br><span class="line">                - oup.select(&#x27;.tang &gt; ul a&#x27;)：空格表示的多个层级</span><br><span class="line">        - 获取标签之间的文本数据：</span><br><span class="line">            - soup.a.text/string/get_text()</span><br><span class="line">            - text/get_text():可以获取某一个标签中所有的文本内容</span><br><span class="line">            - string：只可以获取该标签下面直系的文本内容</span><br><span class="line">        - 获取标签中属性值：</span><br><span class="line">            - soup.a[&#x27;href&#x27;]</span><br><span class="line"></span><br><span class="line">xpath解析：最常用且最便捷高效的一种解析方式。通用性。</span><br><span class="line"></span><br><span class="line">    - xpath解析原理：</span><br><span class="line">        - 1.实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中。</span><br><span class="line">        - 2.调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获。</span><br><span class="line">    - 环境的安装：</span><br><span class="line">        - pip install lxml</span><br><span class="line">    - 如何实例化一个etree对象:from lxml import etree</span><br><span class="line">        - 1.将本地的html文档中的源码数据加载到etree对象中：</span><br><span class="line">            etree.parse(filePath)</span><br><span class="line">        - 2.可以将从互联网上获取的源码数据加载到该对象中</span><br><span class="line">            etree.HTML(&#x27;page_text&#x27;)</span><br><span class="line">        - xpath(&#x27;xpath表达式&#x27;)</span><br><span class="line">    - xpath表达式:</span><br><span class="line">        - /:表示的是从根节点开始定位。表示的是一个层级。</span><br><span class="line">        - //:表示的是多个层级。可以表示从任意位置开始定位。</span><br><span class="line">        - 属性定位：//div[@class=&#x27;song&#x27;] tag[@attrName=&quot;attrValue&quot;]</span><br><span class="line">        - 索引定位：//div[@class=&quot;song&quot;]/p[3] 索引是从1开始的。</span><br><span class="line">        - 取文本：</span><br><span class="line">            - /text() 获取的是标签中直系的文本内容</span><br><span class="line">            - //text() 标签中非直系的文本内容（所有的文本内容）</span><br><span class="line">        - 取属性：</span><br><span class="line">            /@attrName     ==&gt;img/src</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作业：</span><br><span class="line">    爬取站长素材中免费简历模板</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证码识别</span><br><span class="line"></span><br><span class="line">验证码和爬虫之间的爱恨情仇？</span><br><span class="line">反爬机制：验证码.识别验证码图片中的数据，用于模拟登陆操作。</span><br><span class="line"></span><br><span class="line">识别验证码的操作：</span><br><span class="line">    - 人工肉眼识别。（不推荐）</span><br><span class="line">    - 第三方自动识别（推荐）</span><br><span class="line">        - 云打码：http://www.yundama.com/demo.html</span><br><span class="line">云打码的使用流程：</span><br><span class="line">    - 注册：普通和开发者用户</span><br><span class="line">    - 登录：</span><br><span class="line">        - 普通用户的登录：查询该用户是否还有剩余的题分</span><br><span class="line">        - 开发者用户的登录：</span><br><span class="line">            - 创建一个软件：我的软件-》添加新软件-》录入软件名称-》提交（软件id和秘钥）</span><br><span class="line">            - 下载示例代码：开发文档-》点此下载：云打码接口DLL-》PythonHTTP示例下载</span><br><span class="line">实战：识别古诗文网登录页面中的验证码。</span><br><span class="line">使用打码平台识别验证码的编码流程：</span><br><span class="line">    - 将验证码图片进行本地下载</span><br><span class="line">    - 调用平台提供的示例代码进行图片数据识别</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="requests模块高级"><a href="#requests模块高级" class="headerlink" title="requests模块高级"></a>requests模块高级</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模拟登录：</span><br><span class="line">    - 爬取基于某些用户的用户信息。</span><br><span class="line">需求：对人人网进行模拟登录。</span><br><span class="line">    - 点击登录按钮之后会发起一个post请求</span><br><span class="line">    - post请求中会携带登录之前录入的相关的登录信息（用户名，密码，验证码......）</span><br><span class="line">    - 验证码：每次请求都会变化</span><br><span class="line"></span><br><span class="line">需求：爬取当前用户的相关的用户信息（个人主页中显示的用户信息）</span><br><span class="line"></span><br><span class="line">http/https协议特性：无状态。</span><br><span class="line">没有请求到对应页面数据的原因：</span><br><span class="line">    发起的第二次基于个人主页页面请求的时候，服务器端并不知道该此请求是基于登录状态下的请求。</span><br><span class="line">cookie：用来让服务器端记录客户端的相关状态。</span><br><span class="line">    - 手动处理：通过抓包工具获取cookie值，将该值封装到headers中。（不建议）</span><br><span class="line">    - 自动处理：</span><br><span class="line">        - cookie值的来源是哪里？</span><br><span class="line">            - 模拟登录post请求后，由服务器端创建。</span><br><span class="line">        session会话对象：</span><br><span class="line">            - 作用：</span><br><span class="line">                1.可以进行请求的发送。</span><br><span class="line">                2.如果请求过程中产生了cookie，则该cookie会被自动存储/携带在该session对象中。</span><br><span class="line">        - 创建一个session对象：session = requests.Session()</span><br><span class="line">        - 使用session对象进行模拟登录post请求的发送（cookie就会被存储在session中）</span><br><span class="line">        - session对象对个人主页对应的get请求进行发送（携带了cookie）</span><br><span class="line"></span><br><span class="line">代理：破解封IP这种反爬机制。</span><br><span class="line">什么是代理：</span><br><span class="line">    - 代理服务器。</span><br><span class="line">代理的作用：</span><br><span class="line">    - 突破自身IP访问的限制。</span><br><span class="line">    - 隐藏自身真实IP</span><br><span class="line">代理相关的网站：</span><br><span class="line">    - 快代理</span><br><span class="line">    - 西祠代理</span><br><span class="line">    - www.goubanjia.com</span><br><span class="line">代理ip的类型：</span><br><span class="line">    - http：应用到http协议对应的url中</span><br><span class="line">    - https：应用到https协议对应的url中</span><br><span class="line"></span><br><span class="line">代理ip的匿名度：</span><br><span class="line">    - 透明：服务器知道该次请求使用了代理，也知道请求对应的真实ip</span><br><span class="line">    - 匿名：知道使用了代理，不知道真实ip</span><br><span class="line">    - 高匿：不知道使用了代理，更不知道真实的ip</span><br></pre></td></tr></table></figure>



<h3 id="高性能异步爬虫"><a href="#高性能异步爬虫" class="headerlink" title="高性能异步爬虫"></a>高性能异步爬虫</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">高性能异步爬虫</span><br><span class="line">目的：在爬虫中使用异步实现高性能的数据爬取操作。</span><br><span class="line"></span><br><span class="line">异步爬虫的方式：</span><br><span class="line">    - 1.多线程，多进程（不建议）：</span><br><span class="line">        好处：可以为相关阻塞的操作单独开启线程或者进程，阻塞操作就可以异步执行。</span><br><span class="line">        弊端：无法无限制的开启多线程或者多进程。</span><br><span class="line">    - 2.线程池、进程池（适当的使用）：</span><br><span class="line">        好处：我们可以降低系统对进程或者线程创建和销毁的一个频率，从而很好的降低系统的开销。</span><br><span class="line">        弊端：池中线程或进程的数量是有上限。</span><br><span class="line"></span><br><span class="line">- 3.单线程+异步协程（推荐）：</span><br><span class="line">    event_loop：事件循环，相当于一个无限循环，我们可以把一些函数注册到这个事件循环上，</span><br><span class="line">    当满足某些条件的时候，函数就会被循环执行。</span><br><span class="line"></span><br><span class="line">    coroutine：协程对象，我们可以将协程对象注册到事件循环中，它会被事件循环调用。</span><br><span class="line">    我们可以使用 async 关键字来定义一个方法，这个方法在调用时不会立即被执行，而是返回</span><br><span class="line">    一个协程对象。</span><br><span class="line"></span><br><span class="line">    task：任务，它是对协程对象的进一步封装，包含了任务的各个状态。</span><br><span class="line"></span><br><span class="line">    future：代表将来执行或还没有执行的任务，实际上和 task 没有本质区别。</span><br><span class="line"></span><br><span class="line">    async 定义一个协程.</span><br><span class="line"></span><br><span class="line">    await 用来挂起阻塞方法的执行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="动态数据加载处理"><a href="#动态数据加载处理" class="headerlink" title="动态数据加载处理"></a>动态数据加载处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">selenium模块的基本使用</span><br><span class="line"></span><br><span class="line">问题：selenium模块和爬虫之间具有怎样的关联？</span><br><span class="line">    - 便捷的获取网站中动态加载的数据</span><br><span class="line">    - 便捷实现模拟登录</span><br><span class="line">什么是selenium模块？</span><br><span class="line">    - 基于浏览器自动化的一个模块。</span><br><span class="line"></span><br><span class="line">selenium使用流程：</span><br><span class="line">    - 环境安装：pip install selenium</span><br><span class="line">    - 下载一个浏览器的驱动程序（谷歌浏览器）</span><br><span class="line">        - 下载路径：http://chromedriver.storage.googleapis.com/index.html</span><br><span class="line">        - 驱动程序和浏览器的映射关系：http://blog.csdn.net/huilan_same/article/details/51896672</span><br><span class="line">    - 实例化一个浏览器对象</span><br><span class="line">    - 编写基于浏览器自动化的操作代码</span><br><span class="line">        - 发起请求：get(url)</span><br><span class="line">        - 标签定位：find系列的方法</span><br><span class="line">        - 标签交互：send_keys(&#x27;xxx&#x27;)</span><br><span class="line">        - 执行js程序：excute_script(&#x27;jsCode&#x27;)</span><br><span class="line">        - 前进，后退：back(),forward()</span><br><span class="line">        - 关闭浏览器：quit()</span><br><span class="line"></span><br><span class="line">    - selenium处理iframe</span><br><span class="line">        - 如果定位的标签存在于iframe标签之中，则必须使用switch_to.frame(id)</span><br><span class="line">        - 动作链（拖动）：from selenium.webdriver import ActionChains</span><br><span class="line">            - 实例化一个动作链对象：action = ActionChains(bro)</span><br><span class="line">            - click_and_hold（div）：长按且点击操作</span><br><span class="line">            - move_by_offset(x,y)</span><br><span class="line">            - perform()让动作链立即执行</span><br><span class="line">            - action.release()释放动作链对象</span><br><span class="line"></span><br><span class="line">12306模拟登录</span><br><span class="line">    - 超级鹰：http://www.chaojiying.com/about.html</span><br><span class="line">        - 注册：普通用户</span><br><span class="line">        - 登录：普通用户</span><br><span class="line">            - 题分查询：充值</span><br><span class="line">            - 创建一个软件（id）</span><br><span class="line">            - 下载示例代码</span><br><span class="line"></span><br><span class="line">    - 12306模拟登录编码流程：</span><br><span class="line">        - 使用selenium打开登录页面</span><br><span class="line">        - 对当前selenium打开的这张页面进行截图</span><br><span class="line">        - 对当前图片局部区域（验证码图片）进行裁剪</span><br><span class="line">            - 好处：将验证码图片和模拟登录进行一一对应。</span><br><span class="line">        - 使用超级鹰识别验证码图片（坐标）</span><br><span class="line">        - 使用动作链根据坐标实现点击操作</span><br><span class="line">        - 录入用户名密码，点击登录按钮实现登录</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="scrapy框架"><a href="#scrapy框架" class="headerlink" title="scrapy框架"></a>scrapy框架</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scrapy框架</span><br><span class="line"></span><br><span class="line">- 什么是框架？</span><br><span class="line">    - 就是一个集成了很多功能并且具有很强通用性的一个项目模板。</span><br><span class="line"></span><br><span class="line">- 如何学习框架？</span><br><span class="line">    - 专门学习框架封装的各种功能的详细用法。</span><br><span class="line"></span><br><span class="line">- 什么是scrapy？</span><br><span class="line">    - 爬虫中封装好的一个明星框架。功能：高性能的持久化存储，异步的数据下载，高性能的数据解析，分布式</span><br><span class="line"></span><br><span class="line">- scrapy框架的基本使用</span><br><span class="line">    - 环境的安装：</span><br><span class="line">        - mac or linux：pip install scrapy</span><br><span class="line">        - windows:</span><br><span class="line">            - pip install wheel</span><br><span class="line">            - 下载twisted，下载地址为http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted</span><br><span class="line">            - 安装twisted：pip install Twisted‑17.1.0‑cp36‑cp36m‑win_amd64.whl</span><br><span class="line">            - pip install pywin32</span><br><span class="line">            - pip install scrapy</span><br><span class="line">            测试：在终端里录入scrapy指令，没有报错即表示安装成功！</span><br><span class="line">    - 创建一个工程：scrapy startproject xxxPro</span><br><span class="line">    - cd xxxPro</span><br><span class="line">    - 在spiders子目录中创建一个爬虫文件</span><br><span class="line">        - scrapy genspider spiderName www.xxx.com</span><br><span class="line">    - 执行工程：</span><br><span class="line">        - scrapy crawl spiderName</span><br><span class="line"></span><br><span class="line">- scrapy数据解析</span><br><span class="line"></span><br><span class="line">- scrapy持久化存储</span><br><span class="line">    - 基于终端指令：</span><br><span class="line">        - 要求：只可以将parse方法的返回值存储到本地的文本文件中</span><br><span class="line">        - 注意：持久化存储对应的文本文件的类型只可以为：&#x27;json&#x27;, &#x27;jsonlines&#x27;, &#x27;jl&#x27;, &#x27;csv&#x27;, &#x27;xml&#x27;, &#x27;marshal&#x27;, &#x27;pickle</span><br><span class="line">        - 指令：scrapy crawl xxx -o filePath</span><br><span class="line">        - 好处：简介高效便捷</span><br><span class="line">        - 缺点：局限性比较强（数据只可以存储到指定后缀的文本文件中）</span><br><span class="line"></span><br><span class="line">    - 基于管道：</span><br><span class="line">        - 编码流程：</span><br><span class="line">            - 数据解析</span><br><span class="line">            - 在item类中定义相关的属性</span><br><span class="line">            - 将解析的数据封装存储到item类型的对象</span><br><span class="line">            - 将item类型的对象提交给管道进行持久化存储的操作</span><br><span class="line">            - 在管道类的process_item中要将其接受到的item对象中存储的数据进行持久化存储操作</span><br><span class="line">            - 在配置文件中开启管道</span><br><span class="line">        - 好处：</span><br><span class="line">            - 通用性强。</span><br><span class="line"></span><br><span class="line">    - 面试题：将爬取到的数据一份存储到本地一份存储到数据库，如何实现？</span><br><span class="line">        - 管道文件中一个管道类对应的是将数据存储到一种平台</span><br><span class="line">        - 爬虫文件提交的item只会给管道文件中第一个被执行的管道类接受</span><br><span class="line">        - process_item中的return item表示将item传递给下一个即将被执行的管道类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 基于Spider的全站数据爬取</span><br><span class="line">    - 就是将网站中某板块下的全部页码对应的页面数据进行爬取</span><br><span class="line">    - 需求：爬取校花网中的照片的名称</span><br><span class="line">    - 实现方式：</span><br><span class="line">        - 将所有页面的url添加到start_urls列表（不推荐）</span><br><span class="line">        - 自行手动进行请求发送（推荐）</span><br><span class="line">            - 手动请求发送：</span><br><span class="line">                - yield scrapy.Request(url,callback):callback专门用做于数据解析</span><br><span class="line"></span><br><span class="line">- 五大核心组件</span><br><span class="line">    引擎(Scrapy)</span><br><span class="line">        用来处理整个系统的数据流处理, 触发事务(框架核心)</span><br><span class="line">    调度器(Scheduler)</span><br><span class="line">        用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址</span><br><span class="line">    下载器(Downloader)</span><br><span class="line">        用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)</span><br><span class="line">    爬虫(Spiders)</span><br><span class="line">        爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面</span><br><span class="line">    项目管道(Pipeline)</span><br><span class="line">        负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 请求传参</span><br><span class="line">    - 使用场景：如果爬取解析的数据不在同一张页面中。（深度爬取）</span><br><span class="line">    - 需求：爬取boss的岗位名称，岗位描述</span><br><span class="line"></span><br><span class="line">- 图片数据爬取之ImagesPipeline</span><br><span class="line">    - 基于scrapy爬取字符串类型的数据和爬取图片类型的数据区别？</span><br><span class="line">        - 字符串：只需要基于xpath进行解析且提交管道进行持久化存储</span><br><span class="line">        - 图片：xpath解析出图片src的属性值。单独的对图片地址发起请求获取图片二进制类型的数据</span><br><span class="line"></span><br><span class="line">    - ImagesPipeline：</span><br><span class="line">        - 只需要将img的src的属性值进行解析，提交到管道，管道就会对图片的src进行请求发送获取图片的二进制类型的数据，且还会帮我们进行持久化存储。</span><br><span class="line">    - 需求：爬取站长素材中的高清图片</span><br><span class="line">    - 使用流程：</span><br><span class="line">        - 数据解析（图片的地址）</span><br><span class="line">        - 将存储图片地址的item提交到制定的管道类</span><br><span class="line">        - 在管道文件中自定制一个基于ImagesPipeLine的一个管道类</span><br><span class="line">            - get_media_request</span><br><span class="line">            - file_path</span><br><span class="line">            - item_completed</span><br><span class="line">        - 在配置文件中：</span><br><span class="line">            - 指定图片存储的目录：IMAGES_STORE = &#x27;./imgs_bobo&#x27;</span><br><span class="line">            - 指定开启的管道：自定制的管道类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 中间件</span><br><span class="line">    - 下载中间件</span><br><span class="line">        - 位置：引擎和下载器之间</span><br><span class="line">        - 作用：批量拦截到整个工程中所有的请求和响应</span><br><span class="line">        - 拦截请求：</span><br><span class="line">            - UA伪装:process_request</span><br><span class="line">            - 代理IP:process_exception:return request</span><br><span class="line"></span><br><span class="line">        - 拦截响应：</span><br><span class="line">            - 篡改响应数据，响应对象</span><br><span class="line">            - 需求：爬取网易新闻中的新闻数据（标题和内容）</span><br><span class="line">                - 1.通过网易新闻的首页解析出五大板块对应的详情页的url（没有动态加载）</span><br><span class="line">                - 2.每一个板块对应的新闻标题都是动态加载出来的（动态加载）</span><br><span class="line">                - 3.通过解析出每一条新闻详情页的url获取详情页的页面源码，解析出新闻内容</span><br><span class="line"></span><br><span class="line">- CrawlSpider:类，Spider的一个子类</span><br><span class="line">    - 全站数据爬取的方式</span><br><span class="line">        - 基于Spider：手动请求</span><br><span class="line">        - 基于CrawlSpider</span><br><span class="line">    - CrawlSpider的使用：</span><br><span class="line">        - 创建一个工程</span><br><span class="line">        - cd XXX</span><br><span class="line">        - 创建爬虫文件（CrawlSpider）：</span><br><span class="line">            - scrapy genspider -t crawl xxx www.xxxx.com</span><br><span class="line">            - 链接提取器：</span><br><span class="line">                - 作用：根据指定的规则（allow）进行指定链接的提取</span><br><span class="line">            - 规则解析器：</span><br><span class="line">                - 作用：将链接提取器提取到的链接进行指定规则（callback）的解析</span><br><span class="line">        #需求：爬取sun网站中的编号，新闻标题，新闻内容，标号</span><br><span class="line">            - 分析：爬取的数据没有在同一张页面中。</span><br><span class="line">            - 1.可以使用链接提取器提取所有的页码链接</span><br><span class="line">            - 2.让链接提取器提取所有的新闻详情页的链接</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 分布式爬虫</span><br><span class="line">    - 概念：我们需要搭建一个分布式的机群，让其对一组资源进行分布联合爬取。</span><br><span class="line">    - 作用：提升爬取数据的效率</span><br><span class="line"></span><br><span class="line">    - 如何实现分布式？</span><br><span class="line">        - 安装一个scrapy-redis的组件</span><br><span class="line">        - 原生的scarapy是不可以实现分布式爬虫，必须要让scrapy结合着scrapy-redis组件一起实现分布式爬虫。</span><br><span class="line">        - 为什么原生的scrapy不可以实现分布式？</span><br><span class="line">            - 调度器不可以被分布式机群共享</span><br><span class="line">            - 管道不可以被分布式机群共享</span><br><span class="line">        - scrapy-redis组件作用：</span><br><span class="line">            - 可以给原生的scrapy框架提供可以被共享的管道和调度器</span><br><span class="line">        - 实现流程</span><br><span class="line">            - 创建一个工程</span><br><span class="line">            - 创建一个基于CrawlSpider的爬虫文件</span><br><span class="line">            - 修改当前的爬虫文件：</span><br><span class="line">                - 导包：from scrapy_redis.spiders import RedisCrawlSpider</span><br><span class="line">                - 将start_urls和allowed_domains进行注释</span><br><span class="line">                - 添加一个新属性：redis_key = &#x27;sun&#x27; 可以被共享的调度器队列的名称</span><br><span class="line">                - 编写数据解析相关的操作</span><br><span class="line">                - 将当前爬虫类的父类修改成RedisCrawlSpider</span><br><span class="line">            - 修改配置文件settings</span><br><span class="line">                - 指定使用可以被共享的管道：</span><br><span class="line">                    ITEM_PIPELINES = &#123;</span><br><span class="line">                        &#x27;scrapy_redis.pipelines.RedisPipeline&#x27;: 400</span><br><span class="line">                    &#125;</span><br><span class="line">                - 指定调度器：</span><br><span class="line">                    # 增加了一个去重容器类的配置, 作用使用Redis的set集合来存储请求的指纹数据, 从而实现请求去重的持久化</span><br><span class="line">                    DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><span class="line">                    # 使用scrapy-redis组件自己的调度器</span><br><span class="line">                    SCHEDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><span class="line">                    # 配置调度器是否要持久化, 也就是当爬虫结束了, 要不要清空Redis中请求队列和去重指纹的set。如果是True, 就表示要持久化存储, 就不清空数据, 否则清空数据</span><br><span class="line">                    SCHEDULER_PERSIST = True</span><br><span class="line">                - 指定redis服务器：</span><br><span class="line"></span><br><span class="line">            - redis相关操作配置：</span><br><span class="line">                - 配置redis的配置文件：</span><br><span class="line">                    - linux或者mac：redis.conf</span><br><span class="line">                    - windows:redis.windows.conf</span><br><span class="line">                    - 代开配置文件修改：</span><br><span class="line">                        - 将bind 127.0.0.1进行删除</span><br><span class="line">                        - 关闭保护模式：protected-mode yes改为no</span><br><span class="line">                - 结合着配置文件开启redis服务</span><br><span class="line">                    - redis-server 配置文件</span><br><span class="line">                - 启动客户端：</span><br><span class="line">                    - redis-cli</span><br><span class="line">            - 执行工程：</span><br><span class="line">                - scrapy runspider xxx.py</span><br><span class="line">            - 向调度器的队列中放入一个起始的url：</span><br><span class="line">                - 调度器的队列在redis的客户端中</span><br><span class="line">                    - lpush xxx www.xxx.com</span><br><span class="line">            - 爬取到的数据存储在了redis的proName:items这个数据结构中</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="增量式爬虫"><a href="#增量式爬虫" class="headerlink" title="增量式爬虫"></a>增量式爬虫</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增量式爬虫</span><br><span class="line">    - 概念：监测网站数据更新的情况，只会爬取网站最新更新出来的数据。</span><br><span class="line">    - 分析：</span><br><span class="line">        - 指定一个起始url</span><br><span class="line">        - 基于CrawlSpider获取其他页码链接</span><br><span class="line">        - 基于Rule将其他页码链接进行请求</span><br><span class="line">        - 从每一个页码对应的页面源码中解析出每一个电影详情页的URL</span><br><span class="line"></span><br><span class="line">        - 核心：检测电影详情页的url之前有没有请求过</span><br><span class="line">            - 将爬取过的电影详情页的url存储</span><br><span class="line">                - 存储到redis的set数据结构</span><br><span class="line"></span><br><span class="line">        - 对详情页的url发起请求，然后解析出电影的名称和简介</span><br><span class="line">        - 进行持久化存储</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>职工管理系统</title>
    <url>/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>学习自黑马程序员&amp;传智教育，文档资料有修改</p>
<span id="more"></span>

<h1 id="职工管理系统"><a href="#职工管理系统" class="headerlink" title="职工管理系统"></a>职工管理系统</h1><h2 id="1、管理系统需求"><a href="#1、管理系统需求" class="headerlink" title="1、管理系统需求"></a>1、管理系统需求</h2><p>职工管理系统可以用来管理公司内所有员工的信息</p>
<p>本教程主要利用C++来实现一个基于多态的职工管理系统</p>
<p>公司中职工分为三类：普通员工、经理、老板，显示信息时，需要显示职工编号、职工姓名、职工岗位、以及职责</p>
<p>普通员工职责：完成经理交给的任务</p>
<p>经理职责：完成老板交给的任务，并下发任务给员工</p>
<p>老板职责：管理公司所有事务</p>
<p>管理系统中需要实现的功能如下：</p>
<ul>
<li>退出管理程序：退出当前管理系统</li>
</ul>
<ul>
<li>增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号、姓名、部门编号</li>
<li>显示职工信息：显示公司内部所有职工的信息</li>
<li>删除离职职工：按照编号删除指定的职工</li>
<li>修改职工信息：按照编号修改职工个人信息</li>
<li>查找职工信息：按照职工的编号或者职工的姓名进行查找相关的人员信息</li>
<li>按照编号排序：按照职工编号，进行排序，排序规则由用户指定</li>
<li>清空所有文档：清空文件中记录的所有职工信息 （清空前需要再次确认，防止误删）</li>
</ul>
<p>系统界面效果图如下：</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546511409198.png" alt="1546511409198"></p>
<p>需根据用户不同的选择，完成不同的功能！</p>
<h2 id="2、创建项目"><a href="#2、创建项目" class="headerlink" title="2、创建项目"></a>2、创建项目</h2><p>创建项目步骤如下：</p>
<ul>
<li>创建新项目</li>
<li>添加文件</li>
</ul>
<h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><p>打开vs2017后，点击创建新项目，创建新的C++项目</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544151201465.png" alt="1544151201465"></p>
<p>填写项目名称以及项目路径，点击确定</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546349209805.png" alt="1546349209805"></p>
<h3 id="2-2-添加文件"><a href="#2-2-添加文件" class="headerlink" title="2.2 添加文件"></a>2.2 添加文件</h3><p>右键源文件，进行添加文件操作</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546349360960.png" alt="1546349360960"></p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546349421496.png" alt="1546349421496"></p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546349488752.png" alt="1546349488752"></p>
<p>至此，项目已创建完毕</p>
<h2 id="3、创建管理类"><a href="#3、创建管理类" class="headerlink" title="3、创建管理类"></a>3、创建管理类</h2><p>​    管理类负责的内容如下：</p>
<ul>
<li>与用户的沟通菜单界面</li>
<li>对职工增删改查的操作</li>
<li>与文件的读写交互</li>
</ul>
<h3 id="3-1创建文件"><a href="#3-1创建文件" class="headerlink" title="3.1创建文件"></a>3.1创建文件</h3><p>在头文件和源文件的文件夹下分别创建workerManager.h 和 workerManager.cpp文件</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546349904944.png" alt="1546349904944"></p>
<h3 id="3-2-头文件实现"><a href="#3-2-头文件实现" class="headerlink" title="3.2 头文件实现"></a>3.2 头文件实现</h3><p>在workerManager.h中设计管理类</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">WorkerManager</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">WorkerManager</span>();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-源文件实现"><a href="#3-3-源文件实现" class="headerlink" title="3.3 源文件实现"></a>3.3 源文件实现</h3><p>在workerManager.cpp中将构造和析构函数空实现补全</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;workerManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">WorkerManager::<span class="built_in">WorkerManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkerManager::~<span class="built_in">WorkerManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>至此职工管理类以创建完毕</p>
<h2 id="4、菜单功能"><a href="#4、菜单功能" class="headerlink" title="4、菜单功能"></a>4、菜单功能</h2><p>功能描述：与用户的沟通界面</p>
<h3 id="4-1-添加成员函数"><a href="#4-1-添加成员函数" class="headerlink" title="4.1 添加成员函数"></a>4.1 添加成员函数</h3><p>在管理类workerManager.h中添加成员函数  <code>void Show_Menu();</code></p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546351543942.png" alt="1546351543942"></p>
<h3 id="4-2-菜单功能实现"><a href="#4-2-菜单功能实现" class="headerlink" title="4.2 菜单功能实现"></a>4.2 菜单功能实现</h3><p>在管理类workerManager.cpp中实现  Show_Menu()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Show_Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********************************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*********  欢迎使用职工管理系统！ **********&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  0.退出管理程序  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  1.增加职工信息  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  2.显示职工信息  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  3.删除离职职工  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  4.修改职工信息  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  5.查找职工信息  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  6.按照编号排序  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  7.清空所有文档  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********************************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-测试菜单功能"><a href="#4-3-测试菜单功能" class="headerlink" title="4.3 测试菜单功能"></a>4.3 测试菜单功能</h3><p>在职工管理系统.cpp中测试菜单功能</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;workerManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	WorkerManager wm;</span><br><span class="line"></span><br><span class="line">	wm.<span class="built_in">Show_Menu</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果如图：</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546352771191.png" alt="1546352771191"></p>
<h2 id="5、退出功能"><a href="#5、退出功能" class="headerlink" title="5、退出功能"></a>5、退出功能</h2><h3 id="5-1-提供功能接口"><a href="#5-1-提供功能接口" class="headerlink" title="5.1  提供功能接口"></a>5.1  提供功能接口</h3><p>在main函数中提供分支选择，提供每个功能接口</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	WorkerManager wm;</span><br><span class="line">	<span class="keyword">int</span> choice = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//展示菜单</span></span><br><span class="line">		wm.<span class="built_in">Show_Menu</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入您的选择:&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (choice)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//退出系统</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//添加职工</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//显示职工</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//删除职工</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//修改职工</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>: <span class="comment">//查找职工</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//排序职工</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>: <span class="comment">//清空文件</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-实现退出功能"><a href="#5-2-实现退出功能" class="headerlink" title="5.2 实现退出功能"></a>5.2 实现退出功能</h3><p>在workerManager.h中提供退出系统的成员函数 <code>    void exitSystem();</code></p>
<p>在workerManager.cpp中提供具体的功能实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::exitSystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;欢迎下次使用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-3测试功能"><a href="#5-3测试功能" class="headerlink" title="5.3测试功能"></a>5.3测试功能</h3><p>在main函数分支 0  选项中，调用退出程序的接口</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546353199424.png" alt="1546353199424"></p>
<p>运行测试效果如图：</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546353155490.png" alt="1546353155490"></p>
<h2 id="6、创建职工类"><a href="#6、创建职工类" class="headerlink" title="6、创建职工类"></a>6、创建职工类</h2><h3 id="6-1-创建职工抽象类"><a href="#6-1-创建职工抽象类" class="headerlink" title="6.1 创建职工抽象类"></a>6.1 创建职工抽象类</h3><p>职工的分类为：普通员工、经理、老板</p>
<p>将三种职工抽象到一个类（worker）中,利用多态管理不同职工种类</p>
<p>职工的属性为：职工编号、职工姓名、职工所在部门编号</p>
<p>职工的行为为：岗位职责信息描述，获取岗位名称</p>
<p>头文件文件夹下  创建文件worker.h  文件并且添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//职工抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示个人信息</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//获取岗位名称</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">getDeptName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_Id; <span class="comment">//职工编号</span></span><br><span class="line">	string m_Name; <span class="comment">//职工姓名</span></span><br><span class="line">	<span class="keyword">int</span> m_DeptId; <span class="comment">//职工所在部门名称编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6-2-创建普通员工类"><a href="#6-2-创建普通员工类" class="headerlink" title="6.2 创建普通员工类"></a>6.2 创建普通员工类</h3><p>普通员工类<strong>继承</strong>职工抽象类，并重写父类中纯虚函数</p>
<p>在头文件和源文件的文件夹下分别创建employee.h 和 employee.cpp文件</p>
<p>employee.h中代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> :</span><span class="keyword">public</span> Worker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Employee</span>(<span class="keyword">int</span> id, string name, <span class="keyword">int</span> dId);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示个人信息</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取职工岗位名称</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">getDeptName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>employee.cpp中代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;employee.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Employee::<span class="built_in">Employee</span>(<span class="keyword">int</span> id, string name, <span class="keyword">int</span> dId)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_DeptId = dId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Employee::showInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;职工编号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t职工姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t岗位：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getDeptName</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t岗位职责：完成经理交给的任务&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Employee::getDeptName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;员工&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="6-3-创建经理类"><a href="#6-3-创建经理类" class="headerlink" title="6.3 创建经理类"></a>6.3 创建经理类</h3><p>经理类<strong>继承</strong>职工抽象类，并重写父类中纯虚函数，和普通员工类似</p>
<p>在头文件和源文件的文件夹下分别创建manager.h 和 manager.cpp文件</p>
<p>manager.h中代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//经理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> :</span><span class="keyword">public</span> Worker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Manager</span>(<span class="keyword">int</span> id, string name, <span class="keyword">int</span> dId);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示个人信息</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取职工岗位名称</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">getDeptName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>manager.cpp中代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;manager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Manager::<span class="built_in">Manager</span>(<span class="keyword">int</span> id, string name, <span class="keyword">int</span> dId)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_DeptId = dId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;职工编号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t职工姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t岗位：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getDeptName</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t岗位职责：完成老板交给的任务,并下发任务给员工&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Manager::getDeptName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;经理&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-4-创建老板类"><a href="#6-4-创建老板类" class="headerlink" title="6.4 创建老板类"></a>6.4 创建老板类</h3><p>老板类<strong>继承</strong>职工抽象类，并重写父类中纯虚函数，和普通员工类似</p>
<p>在头文件和源文件的文件夹下分别创建boss.h 和 boss.cpp文件</p>
<p>boss.h中代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//老板类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boss</span> :</span><span class="keyword">public</span> Worker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Boss</span>(<span class="keyword">int</span> id, string name, <span class="keyword">int</span> dId);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示个人信息</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取职工岗位名称</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">getDeptName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>boss.cpp中代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;boss.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Boss::<span class="built_in">Boss</span>(<span class="keyword">int</span> id, string name, <span class="keyword">int</span> dId)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_DeptId = dId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Boss::showInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;职工编号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t职工姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t岗位：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getDeptName</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t岗位职责：管理公司所有事务&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Boss::getDeptName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;总裁&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="6-5-测试多态"><a href="#6-5-测试多态" class="headerlink" title="6.5 测试多态"></a>6.5 测试多态</h3><p>在职工管理系统.cpp中添加测试函数，并且运行能够产生多态</p>
<p>测试代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;employee.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;manager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;boss.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Worker * worker = <span class="literal">NULL</span>;</span><br><span class="line">	worker = <span class="keyword">new</span> <span class="built_in">Employee</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">1</span>);</span><br><span class="line">	worker-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">	<span class="keyword">delete</span> worker;</span><br><span class="line">	</span><br><span class="line">	worker = <span class="keyword">new</span> <span class="built_in">Manager</span>(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	worker-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">	<span class="keyword">delete</span> worker;</span><br><span class="line"></span><br><span class="line">	worker = <span class="keyword">new</span> <span class="built_in">Boss</span>(<span class="number">3</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">3</span>);</span><br><span class="line">	worker-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">	<span class="keyword">delete</span> worker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>运行效果如图：</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546398236081.png" alt="1546398236081"></p>
<p>测试成功后，测试代码可以注释保留，或者选择删除</p>
<h2 id="7、添加职工"><a href="#7、添加职工" class="headerlink" title="7、添加职工"></a>7、添加职工</h2><p>功能描述：批量添加职工，并且保存到文件中</p>
<h3 id="7-1-功能分析"><a href="#7-1-功能分析" class="headerlink" title="7.1 功能分析"></a>7.1 功能分析</h3><p>分析：</p>
<p>用户在批量创建时，可能会创建不同种类的职工</p>
<p>如果想将所有不同种类的员工都放入到一个数组中，可以将所有员工的指针维护到一个数组里</p>
<p>如果想在程序中维护这个不定长度的数组，可以将数组创建到堆区，并利用Worker **的指针维护</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546399491099.png" alt="1546399491099"></p>
<h3 id="7-2-功能实现"><a href="#7-2-功能实现" class="headerlink" title="7.2 功能实现"></a>7.2 功能实现</h3><p>在WokerManager.h头文件中添加成员属性 代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录文件中的人数个数</span></span><br><span class="line"><span class="keyword">int</span> m_EmpNum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工数组的指针</span></span><br><span class="line">Worker ** m_EmpArray;</span><br></pre></td></tr></table></figure>



<p>在WorkerManager构造函数中初始化属性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">WorkerManager::<span class="built_in">WorkerManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//初始化人数</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化数组指针</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_EmpArray = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在workerManager.h中添加成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<p>workerManager.cpp中实现该函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Add_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入增加职工数量： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> addNum = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; addNum;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addNum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//计算新空间大小</span></span><br><span class="line">		<span class="keyword">int</span> newSize = <span class="keyword">this</span>-&gt;m_EmpNum + addNum;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//开辟新空间</span></span><br><span class="line">		Worker ** newSpace = <span class="keyword">new</span> Worker*[newSize];</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将原空间下内容存放到新空间下</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				newSpace[i] = <span class="keyword">this</span>-&gt;m_EmpArray[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//输入新数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; addNum; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> id;</span><br><span class="line">			string name;</span><br><span class="line">			<span class="keyword">int</span> dSelect;</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入第 &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; 个新职工编号：&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入第 &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; 个新职工姓名：&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请选择该职工的岗位：&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;1、普通职工&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;2、经理&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;3、老板&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; dSelect;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			Worker * worker = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span> (dSelect)</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//普通员工</span></span><br><span class="line">				worker = <span class="keyword">new</span> <span class="built_in">Employee</span>(id, name, <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//经理</span></span><br><span class="line">				worker = <span class="keyword">new</span> <span class="built_in">Manager</span>(id, name, <span class="number">2</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//老板</span></span><br><span class="line">				worker = <span class="keyword">new</span> <span class="built_in">Boss</span>(id, name, <span class="number">3</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			newSpace[<span class="keyword">this</span>-&gt;m_EmpNum + i] = worker;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放原有空间</span></span><br><span class="line">		<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_EmpArray;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更改新空间的指向</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_EmpArray = newSpace;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新新的个数</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_EmpNum = newSize;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//提示信息</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;成功添加&quot;</span> &lt;&lt; addNum &lt;&lt; <span class="string">&quot;名新职工！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入有误&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在WorkerManager.cpp的析构函数中，释放堆区数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">WorkerManager::~<span class="built_in">WorkerManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_EmpArray;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="7-3-测试添加"><a href="#7-3-测试添加" class="headerlink" title="7.3 测试添加"></a>7.3 测试添加</h3><p>在main函数分支 1  选项中，调用添加职工接口</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546401705277.png" alt="1546401705277"></p>
<p>效果如图：</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546401763461.png" alt="1546401763461"></p>
<p>至此，添加职工到程序中功能实现完毕</p>
<h2 id="8、文件交互-写文件"><a href="#8、文件交互-写文件" class="headerlink" title="8、文件交互 - 写文件"></a>8、文件交互 - 写文件</h2><p>功能描述：对文件进行读写</p>
<p>​    在上一个添加功能中，我们只是将所有的数据添加到了内存中，一旦程序结束就无法保存了</p>
<p>​    因此文件管理类中需要一个与文件进行交互的功能，对于文件进行读写操作</p>
<h3 id="8-1-设定文件路径"><a href="#8-1-设定文件路径" class="headerlink" title="8.1 设定文件路径"></a>8.1 设定文件路径</h3><p>首先我们将文件路径，在workerManager.h中添加宏常量,并且包含头文件 fstream</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  FILENAME <span class="meta-string">&quot;empFile.txt&quot;</span></span></span><br></pre></td></tr></table></figure>



<h3 id="8-2-成员函数声明"><a href="#8-2-成员函数声明" class="headerlink" title="8.2 成员函数声明"></a>8.2 成员函数声明</h3><p>在workerManager.h中类里添加成员函数 <code>void save()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="8-3-保存文件功能实现"><a href="#8-3-保存文件功能实现" class="headerlink" title="8.3 保存文件功能实现"></a>8.3 保存文件功能实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::save</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(FILENAME, ios::out);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ofs &lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Id &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">			&lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Name &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">			&lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-4-保存文件功能测试"><a href="#8-4-保存文件功能测试" class="headerlink" title="8.4 保存文件功能测试"></a>8.4 保存文件功能测试</h3><p>在添加职工功能中添加成功后添加保存文件函数</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546432469465.png" alt="1546432469465"></p>
<p>再次运行代码，添加职工</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546401763461.png" alt="1546401763461"></p>
<p>同级目录下多出文件，并且保存了添加的信息</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546432343078.png" alt="1546432343078"></p>
<h2 id="9、文件交互-读文件"><a href="#9、文件交互-读文件" class="headerlink" title="9、文件交互 - 读文件"></a>9、文件交互 - 读文件</h2><p>功能描述：将文件中的内容读取到程序中</p>
<p>虽然我们实现了添加职工后保存到文件的操作，但是每次开始运行程序，并没有将文件中数据读取到程序中</p>
<p>而我们的程序功能中还有清空文件的需求</p>
<p>因此构造函数初始化数据的情况分为三种</p>
<ol>
<li>第一次使用，文件未创建</li>
<li>文件存在，但是数据被用户清空</li>
<li>文件存在，并且保存职工的所有数据</li>
</ol>
<h3 id="9-1-文件未创建"><a href="#9-1-文件未创建" class="headerlink" title="9.1 文件未创建"></a>9.1 文件未创建</h3><p>在workerManager.h中添加新的成员属性 m_FileIsEmpty标志文件是否为空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标志文件是否为空</span></span><br><span class="line"><span class="keyword">bool</span> m_FileIsEmpty;</span><br></pre></td></tr></table></figure>



<p>修改WorkerManager.cpp中构造函数代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">WorkerManager::<span class="built_in">WorkerManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(FILENAME, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//文件不存在情况</span></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在&quot;</span> &lt;&lt; endl; <span class="comment">//测试输出</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;  <span class="comment">//初始化人数</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">true</span>; <span class="comment">//初始化文件为空标志</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_EmpArray = <span class="literal">NULL</span>; <span class="comment">//初始化数组</span></span><br><span class="line">		ifs.<span class="built_in">close</span>(); <span class="comment">//关闭文件</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>删除文件后，测试文件不存在时初始化数据功能</p>
<h3 id="9-2-文件存在且数据为空"><a href="#9-2-文件存在且数据为空" class="headerlink" title="9.2 文件存在且数据为空"></a>9.2 文件存在且数据为空</h3><p>在workerManager.cpp中的构造函数追加代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件存在，并且没有记录</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">ifs &gt;&gt; ch;</span><br><span class="line"><span class="keyword">if</span> (ifs.<span class="built_in">eof</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;文件为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_EmpArray = <span class="literal">NULL</span>;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>追加代码位置如图：</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546435197575.png" alt="1546435197575"></p>
<p>将文件创建后清空文件内容，并测试该情况下初始化功能</p>
<p>我们发现文件不存在或者为空清空 m_FileIsEmpty 判断文件是否为空的标志都为真，那何时为假？</p>
<p>成功添加职工后，应该更改文件不为空的标志</p>
<p>在<code>void WorkerManager::Add_Emp() </code>成员函数中添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新职工不为空标志</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546656256176.png" alt="1546656256176"></p>
<h3 id="9-3-文件存在且保存职工数据"><a href="#9-3-文件存在且保存职工数据" class="headerlink" title="9.3 文件存在且保存职工数据"></a>9.3 文件存在且保存职工数据</h3><h4 id="9-3-1-获取记录的职工人数"><a href="#9-3-1-获取记录的职工人数" class="headerlink" title="9.3.1 获取记录的职工人数"></a>9.3.1 获取记录的职工人数</h4><p>在workerManager.h中添加成员函数 <code> int get_EmpNum();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计人数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_EmpNum</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>workerManager.cpp中实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WorkerManager::get_EmpNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(FILENAME, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> dId;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//记录人数</span></span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在workerManager.cpp构造函数中继续追加代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num =  <span class="keyword">this</span>-&gt;<span class="built_in">get_EmpNum</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;职工个数为：&quot;</span> &lt;&lt; num &lt;&lt; endl;  <span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpNum = num;  <span class="comment">//更新成员属性 </span></span><br></pre></td></tr></table></figure>



<p>手动添加一些职工数据，测试获取职工数量函数</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546436429055.png" alt="1546436429055"></p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546436385793.png" alt="1546436385793"></p>
<h4 id="9-3-2-初始化数组"><a href="#9-3-2-初始化数组" class="headerlink" title="9.3.2 初始化数组"></a>9.3.2 初始化数组</h4><p>根据职工的数据以及职工数据，初始化workerManager中的Worker ** m_EmpArray 指针</p>
<p>在WorkerManager.h中添加成员函数  <code>void init_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化员工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<p>在WorkerManager.cpp中实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::init_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(FILENAME, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> dId;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId)</span><br><span class="line">	&#123;</span><br><span class="line">		Worker * worker = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">//根据不同的部门Id创建不同对象</span></span><br><span class="line">		<span class="keyword">if</span> (dId == <span class="number">1</span>)  <span class="comment">// 1普通员工</span></span><br><span class="line">		&#123;</span><br><span class="line">			worker = <span class="keyword">new</span> <span class="built_in">Employee</span>(id, name, dId);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (dId == <span class="number">2</span>) <span class="comment">//2经理</span></span><br><span class="line">		&#123;</span><br><span class="line">			worker = <span class="keyword">new</span> <span class="built_in">Manager</span>(id, name, dId);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//总裁</span></span><br><span class="line">		&#123;</span><br><span class="line">			worker = <span class="keyword">new</span> <span class="built_in">Boss</span>(id, name, dId);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//存放在数组中</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_EmpArray[index] = worker;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在workerManager.cpp构造函数中追加代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据职工数创建数组</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpArray = <span class="keyword">new</span> Worker *[<span class="keyword">this</span>-&gt;m_EmpNum];</span><br><span class="line"><span class="comment">//初始化职工</span></span><br><span class="line"><span class="built_in">init_Emp</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_EmpNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;职工号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Id</span><br><span class="line">		&lt;&lt; <span class="string">&quot; 职工姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Name</span><br><span class="line">		&lt;&lt; <span class="string">&quot; 部门编号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行程序，测试从文件中获取的数据</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546436938152.png" alt="1546436938152"></p>
<p>至此初始化数据功能完毕，测试代码可以注释或删除掉！</p>
<h2 id="10、显示职工"><a href="#10、显示职工" class="headerlink" title="10、显示职工"></a>10、显示职工</h2><p>功能描述：显示当前所有职工信息</p>
<h4 id="10-1-显示职工函数声明"><a href="#10-1-显示职工函数声明" class="headerlink" title="10.1 显示职工函数声明"></a>10.1 显示职工函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Show_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="10-2-显示职工函数实现"><a href="#10-2-显示职工函数实现" class="headerlink" title="10.2 显示职工函数实现"></a>10.2 显示职工函数实现</h4><p>在workerManager.cpp中实现成员函数 <code>void Show_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Show_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_EmpNum; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//利用多态调用接口</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="10-3-测试显示职工"><a href="#10-3-测试显示职工" class="headerlink" title="10.3 测试显示职工"></a>10.3 测试显示职工</h4><p>在main函数分支 2  选项中，调用显示职工接口</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546497336465.png" alt="1546497336465"></p>
<p>测试时分别测试 文件为空和文件不为空两种情况</p>
<p>测试效果：</p>
<p>测试1-文件不存在或者为空情况</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546497082135.png" alt="1546497082135"></p>
<p>测试2 - 文件存在且有记录情况</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546496947671.png" alt="1546496947671"></p>
<p>测试完毕，至此，显示所有职工信息功能实现</p>
<h2 id="11、删除职工"><a href="#11、删除职工" class="headerlink" title="11、删除职工"></a>11、删除职工</h2><p>功能描述：按照职工的编号进行删除职工操作</p>
<h4 id="11-1-删除职工函数声明"><a href="#11-1-删除职工函数声明" class="headerlink" title="11.1 删除职工函数声明"></a>11.1 删除职工函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Del_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Del_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="11-2-职工是否存在函数声明"><a href="#11-2-职工是否存在函数声明" class="headerlink" title="11.2 职工是否存在函数声明"></a>11.2 职工是否存在函数声明</h4><p>很多功能都需要用到根据职工是否存在来进行操作如：删除职工、修改职工、查找职工</p>
<p>因此添加该公告函数，以便后续调用</p>
<p>在workerManager.h中添加成员函数  <code>int IsExist(int id);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照职工编号判断职工是否存在,若存在返回职工在数组中位置，不存在返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsExist</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="11-3-职工是否存在函数实现"><a href="#11-3-职工是否存在函数实现" class="headerlink" title="11.3 职工是否存在函数实现"></a>11.3 职工是否存在函数实现</h4><p>在workerManager.cpp中实现成员函数 <code>int IsExist(int id);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WorkerManager::IsExist</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Id == id)</span><br><span class="line">		&#123;</span><br><span class="line">			index = i;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="11-4-删除职工函数实现"><a href="#11-4-删除职工函数实现" class="headerlink" title="11.4 删除职工函数实现"></a>11.4 删除职工函数实现</h4><p>在workerManager.cpp中实现成员函数 <code> void Del_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Del_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//按职工编号删除</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入想要删除的职工号：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> index = <span class="keyword">this</span>-&gt;<span class="built_in">IsExist</span>(id);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (index != <span class="number">-1</span>)  <span class="comment">//说明index上位置数据需要删除</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum - <span class="number">1</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">this</span>-&gt;m_EmpArray[i] = <span class="keyword">this</span>-&gt;m_EmpArray[i + <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_EmpNum--;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">save</span>(); <span class="comment">//删除后数据同步到文件中</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;删除成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;删除失败，未找到该职工&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-5-测试删除职工"><a href="#11-5-测试删除职工" class="headerlink" title="11.5 测试删除职工"></a>11.5 测试删除职工</h4><p>在main函数分支 3  选项中，调用删除职工接口</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546502698622.png" alt="1546502698622"></p>
<p>测试1 - 删除不存在职工情况</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546500324196.png" alt="1546500324196"></p>
<p>测试2 - 删除存在的职工情况</p>
<p>删除成功提示图：</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546500350526.png" alt="1546500350526"></p>
<p>再次显示所有职工信息，确保已经删除</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546500361889.png" alt="1546500361889"></p>
<p>查看文件中信息，再次核实员工已被完全删除</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546500383570.png" alt="1546500383570"></p>
<p>至此，删除职工功能实现完毕！</p>
<h2 id="12、修改职工"><a href="#12、修改职工" class="headerlink" title="12、修改职工"></a>12、修改职工</h2><p>功能描述：能够按照职工的编号对职工信息进行修改并保存</p>
<h4 id="12-1-修改职工函数声明"><a href="#12-1-修改职工函数声明" class="headerlink" title="12.1 修改职工函数声明"></a>12.1 修改职工函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Mod_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mod_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="12-2-修改职工函数实现"><a href="#12-2-修改职工函数实现" class="headerlink" title="12.2 修改职工函数实现"></a>12.2 修改职工函数实现</h4><p>在workerManager.cpp中实现成员函数 <code> void Mod_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Mod_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入修改职工的编号：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">int</span> id;</span><br><span class="line">		cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> ret = <span class="keyword">this</span>-&gt;<span class="built_in">IsExist</span>(id);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">//查找到编号的职工</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;m_EmpArray[ret];</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">int</span> newId = <span class="number">0</span>;</span><br><span class="line">			string newName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="keyword">int</span> dSelect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;查到： &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;号职工，请输入新职工号： &quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; newId;</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入新姓名： &quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; newName;</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入岗位： &quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;1、普通职工&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;2、经理&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;3、老板&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; dSelect;</span><br><span class="line"></span><br><span class="line">			Worker * worker = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span> (dSelect)</span><br><span class="line">			&#123;</span><br><span class="line">			case1:</span><br><span class="line">				worker = <span class="keyword">new</span> <span class="built_in">Employee</span>(newId, newName, dSelect);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case2:</span><br><span class="line">				worker = <span class="keyword">new</span> <span class="built_in">Manager</span>(newId, newName, dSelect);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				worker = <span class="keyword">new</span> <span class="built_in">Boss</span>(newId, newName, dSelect);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//更改数据 到数组中</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;m_EmpArray[ret]= worker;</span><br><span class="line">			</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;修改成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//保存到文件中</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">save</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;修改失败，查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//按任意键 清屏</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="12-3-测试修改职工"><a href="#12-3-测试修改职工" class="headerlink" title="12.3 测试修改职工"></a>12.3 测试修改职工</h4><p>在main函数分支 4  选项中，调用修改职工接口</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546502651922.png" alt="1546502651922"></p>
<p>测试1 - 修改不存在职工情况</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546502759643.png" alt="1546502759643"></p>
<p>测试2 - 修改存在职工情况，例如将职工 “李四” 改为 “赵四”</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546502830350.png" alt="1546502830350"></p>
<p>修改后再次查看所有职工信息，并确认修改成功</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546502865443.png" alt="1546502865443"></p>
<p>再次确认文件中信息也同步更新</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546502898653.png" alt="1546502898653"></p>
<p>至此，修改职工功能已实现！</p>
<h2 id="13、查找职工"><a href="#13、查找职工" class="headerlink" title="13、查找职工"></a>13、查找职工</h2><p>功能描述：提供两种查找职工方式，一种按照职工编号，一种按照职工姓名</p>
<h4 id="13-1-查找职工函数声明"><a href="#13-1-查找职工函数声明" class="headerlink" title="13.1 查找职工函数声明"></a>13.1 查找职工函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Find_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="13-2-查找职工函数实现"><a href="#13-2-查找职工函数实现" class="headerlink" title="13.2 查找职工函数实现"></a>13.2 查找职工函数实现</h4><p>在workerManager.cpp中实现成员函数 <code> void Find_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Find_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入查找的方式：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1、按职工编号查找&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;2、按姓名查找&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (select == <span class="number">1</span>) <span class="comment">//按职工号查找</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> id;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入查找的职工编号：&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> ret = <span class="built_in">IsExist</span>(id);</span><br><span class="line">			<span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;查找成功！该职工信息如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">this</span>-&gt;m_EmpArray[ret]-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;查找失败，查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(select == <span class="number">2</span>) <span class="comment">//按姓名查找</span></span><br><span class="line">		&#123;</span><br><span class="line">			string name;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入查找的姓名：&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">//查找到的标志</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_EmpNum; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (m_EmpArray[i]-&gt;m_Name == name)</span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;查找成功,职工编号为：&quot;</span></span><br><span class="line">                           &lt;&lt; m_EmpArray[i]-&gt;m_Id</span><br><span class="line">                           &lt;&lt; <span class="string">&quot; 号的信息如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">					</span><br><span class="line">					flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//查无此人</span></span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;查找失败，查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入选项有误&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="13-3-测试查找职工"><a href="#13-3-测试查找职工" class="headerlink" title="13.3 测试查找职工"></a>13.3 测试查找职工</h4><p>在main函数分支 5  选项中，调用查找职工接口</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546504714318.png" alt="1546504714318"></p>
<p>测试1 - 按照职工编号查找 - 查找不存在职工</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546504767229.png" alt="1546504767229"></p>
<p>测试2 - 按照职工编号查找 -  查找存在职工</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546505046521.png" alt="1546505046521"></p>
<p>测试3 - 按照职工姓名查找 - 查找不存在职工</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546505115610.png" alt="1546505115610"></p>
<p>测试4 - 按照职工姓名查找 - 查找存在职工（如果出现重名，也一并显示，在文件中可以添加重名职工）</p>
<p>例如 添加两个王五的职工，然后按照姓名查找王五</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546507850441.png" alt="1546507850441"></p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546507760284.png" alt="1546507760284"></p>
<p>至此，查找职工功能实现完毕！</p>
<h2 id="14、排序"><a href="#14、排序" class="headerlink" title="14、排序"></a>14、排序</h2><p>功能描述：按照职工编号进行排序，排序的顺序由用户指定</p>
<h4 id="14-1-排序函数声明"><a href="#14-1-排序函数声明" class="headerlink" title="14.1 排序函数声明"></a>14.1 排序函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Sort_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="14-2-排序函数实现"><a href="#14-2-排序函数实现" class="headerlink" title="14.2 排序函数实现"></a>14.2 排序函数实现</h4><p>在workerManager.cpp中实现成员函数 <code> void Sort_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Sort_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请选择排序方式： &quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1、按职工号进行升序&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;2、按职工号进行降序&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_EmpNum; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> minOrMax = i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m_EmpNum; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (select == <span class="number">1</span>) <span class="comment">//升序</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (m_EmpArray[minOrMax]-&gt;m_Id &gt; m_EmpArray[j]-&gt;m_Id)</span><br><span class="line">					&#123;</span><br><span class="line">						minOrMax = j;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>  <span class="comment">//降序</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (m_EmpArray[minOrMax]-&gt;m_Id &lt; m_EmpArray[j]-&gt;m_Id)</span><br><span class="line">					&#123;</span><br><span class="line">						minOrMax = j;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i != minOrMax)</span><br><span class="line">			&#123;</span><br><span class="line">				Worker * temp = m_EmpArray[i];</span><br><span class="line">				m_EmpArray[i] = m_EmpArray[minOrMax];</span><br><span class="line">				m_EmpArray[minOrMax] = temp;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;排序成功,排序后结果为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">save</span>();</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">Show_Emp</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="14-3-测试排序功能"><a href="#14-3-测试排序功能" class="headerlink" title="14.3 测试排序功能"></a>14.3 测试排序功能</h4><p>在main函数分支 6  选项中，调用排序职工接口</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546510145181.png" alt="1546510145181"></p>
<p>测试：</p>
<p>首先我们添加一些职工，序号是无序的，例如：</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546658169987.png" alt="1546658169987"></p>
<p>测试 - 升序排序</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546658190479.png" alt="1546658190479"></p>
<p>文件同步更新</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546658273581.png" alt="1546658273581"></p>
<p>测试 - 降序排序</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546658288936.png" alt="1546658288936"></p>
<p>文件同步更新</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546658313704.png" alt="1546658313704"></p>
<p>至此，职工按照编号排序的功能实现完毕！</p>
<h2 id="15、清空文件"><a href="#15、清空文件" class="headerlink" title="15、清空文件"></a>15、清空文件</h2><p>功能描述：将文件中记录数据清空</p>
<h4 id="15-1-清空函数声明"><a href="#15-1-清空函数声明" class="headerlink" title="15.1 清空函数声明"></a>15.1 清空函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Clean_File();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clean_File</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>





<h4 id="15-2-清空函数实现"><a href="#15-2-清空函数实现" class="headerlink" title="15.2 清空函数实现"></a>15.2 清空函数实现</h4><p>在workerManager.cpp中实现员函数 <code> void Clean_File();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Clean_File</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;确认清空？&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、确认&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、返回&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//打开模式 ios::trunc 如果存在删除文件并重新创建</span></span><br><span class="line">		<span class="function">ofstream <span class="title">ofs</span><span class="params">(FILENAME, ios::trunc)</span></span>;</span><br><span class="line">		ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray[i] != <span class="literal">NULL</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;m_EmpArray[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_EmpArray;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_EmpArray = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;清空成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="15-3-测试清空文件"><a href="#15-3-测试清空文件" class="headerlink" title="15.3 测试清空文件"></a>15.3 测试清空文件</h4><p>在main函数分支 7  选项中，调用清空文件接口</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546511085541.png" alt="1546511085541"></p>
<p>测试：确认清空文件</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546510976745.png" alt="1546510976745"></p>
<p>再次查看文件中数据，记录已为空</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546510994196.png" alt="1546510994196"></p>
<p>打开文件，里面数据已确保清空，该功能需要慎用！</p>
<p><img src="/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546511018517.png" alt="1546511018517"></p>
<p>随着清空文件功能实现，本案例制作完毕  ^ _ ^  </p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Linux的使用和常用命令，主要是在 CentOS 8 上试验</p>
<span id="more"></span>

<h3 id="部分基础命令"><a href="#部分基础命令" class="headerlink" title="部分基础命令"></a>部分基础命令</h3><p>linux是大小写敏感，千万要注意</p>
<p>linux特殊文件名可以使用<code>\</code>进行转义，</p>
<p>如果是有 <code>-</code> 的文件如<code>-a test</code>，操作可以使用 <code>rm -- &#39;-a test&#39;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init 0		关机</span><br><span class="line">init 1		单用户</span><br><span class="line">init 2		多用户</span><br><span class="line">init 5		图形界面</span><br><span class="line">init 3 		字符界面</span><br><span class="line">init 6 		重启</span><br><span class="line"></span><br><span class="line">clear	清屏</span><br><span class="line">logout	注销 </span><br><span class="line"></span><br><span class="line">whereis</span><br><span class="line">whatis</span><br><span class="line">which</span><br></pre></td></tr></table></figure>



<p>常用工具</p>
<p>lrzsz tree screen tmux strace</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bc    <span class="comment"># 计算器， ctrl+d 退出</span></span><br><span class="line">[root@CentOS8 ~]<span class="comment">#bc</span></span><br><span class="line">bc 1.07.1</span><br><span class="line">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012-2017 Free Software Foundation, Inc.</span><br><span class="line">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="line">For details <span class="built_in">type</span> `warranty<span class="string">&#x27;. </span></span><br><span class="line"><span class="string">2^3 # 计算2的3次方</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">obase=2  # 将192按二进制输出</span></span><br><span class="line"><span class="string">192</span></span><br><span class="line"><span class="string">11000000</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com  测试网络是否连接， ctrl+c 停止</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl alt F1		图形</span><br><span class="line">ctrl alt f2		字符1</span><br><span class="line">ctrl alt f3		字符2</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install name			<span class="comment"># 下载name</span></span><br><span class="line">yum -y install nano			<span class="comment"># 下载nano编辑器</span></span><br><span class="line"></span><br><span class="line">yum remove name 			<span class="comment"># 删除name</span></span><br><span class="line">yum remove gcc				<span class="comment"># 删除gcc编译器</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname     完整主机名</span><br><span class="line">sudo -i		 切换root用户</span><br><span class="line">passwd		 设置root用户密码</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free -h		查看内存 ，-h的作用是把内存以合适的单位显示，而不全是字节</span><br><span class="line">runlevel    查看界面类型</span><br><span class="line">uname -r	查看linux内核版本</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">history		查看输入过命令</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whoami		<span class="comment"># 查看自己身份</span></span><br><span class="line">who am i	<span class="comment"># 查看系统登录者的信息：名称、终端、时间</span></span><br><span class="line">who			<span class="comment"># 查看系统的所有登录者</span></span><br><span class="line">w 			<span class="comment"># 查看所有登录用户信息，以及正在进行的操作</span></span><br><span class="line"></span><br><span class="line">tty			<span class="comment"># 查看当前终端</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps					显示系统当前的进程</span><br><span class="line">echo $&#123;SHELL&#125;		显示当前系统使用的shell</span><br><span class="line">cat /etc/shells		系统支持的shell类型</span><br></pre></td></tr></table></figure>



<p>多个命令可以用 “;” 符号分开，如：<code>ls;who</code></p>
<p>一个命令可以用 \ 分成多行，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@yanglinqi ~]<span class="comment"># ls \</span></span><br><span class="line">&gt; -l</span><br><span class="line">总用量 8</span><br><span class="line">-rw-------. 1 root root 1614 1月  25 00:28 anaconda-ks.cfg</span><br><span class="line">-rw-r--r--. 1 root root 1905 1月  25 12:21 initial-setup-ks.cfg</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><p>推荐软件，Xmanager Power Suite，这是一套软件，包含xShell等</p>
<p>字符界面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostname -I   查看ip地址</span><br><span class="line"></span><br><span class="line">在windows系统终端以下命令可以远程连接</span><br><span class="line">ssh 登录的用户@上面查看到的ip地址</span><br><span class="line">例：ssh root@192.168.79.128</span><br><span class="line"></span><br><span class="line">windows远程连接的工具</span><br><span class="line">xShell  或   MobaXterm</span><br></pre></td></tr></table></figure>

<p>使用图像化工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一步，运行Xmanager Power Suite 的 Xmanager.exe</span></span><br><span class="line">在安装Xmanager Power Suite后，桌面出现Xmanager Power Suite的文件夹，里面有Tools文件夹，Tools文件夹里面有Xmanager.exe的快捷方式 Xmanager - Passive，运行Xmanager - Passive，注意：不是Xmanager这个快捷方式，名字不同</span><br><span class="line">运行之后桌面右下角会有图标，鼠标移上去出现 Xmanager Server:0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步，查看本机的ip</span></span><br><span class="line">在windows的cmd窗口，输入 ipconfig，出现多个ip</span><br><span class="line">选择无线局域网适配器 WLAN 的 IPv4 地址：我的是 192.168.0.108</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步</span></span><br><span class="line">在xShell的会话界面输入：<span class="built_in">export</span> DISPLAY=192.168.0.108:0.0   ip换成自己的ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在xShell运行图像化工具</span></span><br><span class="line">如：firefox   gedit  </span><br><span class="line"></span><br><span class="line">注：如果出现下面情况</span><br><span class="line">Unable to init server: 无法连接：拒绝连接</span><br><span class="line"></span><br><span class="line">(gedit:3216): Gtk-WARNING **: 21:40:47.754: cannot open display: 192.168.0.108:0.0</span><br><span class="line"></span><br><span class="line">在第三步试一试ipconfig查到的其他几个ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># MobaXterm</span></span><br><span class="line">如果使用的远程控制工具是MobaXterm，需要在Centos或Ubuntu安装文件</span><br><span class="line">yum install xorg-x11-xauth xorg-x11-fonts-* xorg-x11-font-utils xorg-x11-fonts-Type1</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="查看硬件信息"><a href="#查看硬件信息" class="headerlink" title="查看硬件信息"></a>查看硬件信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看cpu信息</span></span><br><span class="line">lscpu		</span><br><span class="line">cat /proc/cpuinfo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存大小</span></span><br><span class="line">free</span><br><span class="line">cat /proc/meminfo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看硬盘和分区</span></span><br><span class="line">lsblk		</span><br><span class="line">cat /proc/partitions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核版本</span></span><br><span class="line">uname -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看操作系统发行版本</span></span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">cat /etc/os-release</span><br><span class="line">lsb_release -a</span><br><span class="line"><span class="comment"># ubuntu</span></span><br><span class="line">cat /etc/os-release</span><br><span class="line">cat /etc/is</span><br><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><p>Linux的两种时钟</p>
<ul>
<li>系统时钟：由Linux内核通过CPU的工作频率进行的</li>
<li>硬件时钟：主板</li>
</ul>
<p>相关命令</p>
<ul>
<li><p>date     显示和设置系统时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">date <span class="comment"># 显示系统时间</span></span><br><span class="line">date -s <span class="string">&#x27;1 year&#x27;</span>  <span class="comment"># 修改时间至1年后</span></span><br><span class="line">date +%s  <span class="comment"># 1643271071 # 以秒显示时间，以1970.1.1 00:00:00开始经过的秒数，1970年为Unix元年</span></span><br><span class="line">date +%F  <span class="comment"># 2022-01-27</span></span><br><span class="line">date +%T  <span class="comment"># 16:14:59</span></span><br><span class="line">date -d @1643271071   <span class="comment"># 显示从起始时间计算1643271071秒后的时间 # 2022年 01月 27日 星期四 16:11:11 CST</span></span><br></pre></td></tr></table></figure></li>
<li><p>clock ,  hwclock     显示硬件时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-s ,  --hctosys    <span class="comment"># 以硬件时钟为准，校正系统时钟</span></span><br><span class="line">-w ,  --systohc    <span class="comment"># 以系统时钟为准，校正硬件时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clock 和 hwclock 是同一个命令</span></span><br><span class="line">[root@yanglinqi ~]<span class="comment"># ll /usr/sbin/clock</span></span><br><span class="line">lrwxrwxrwx. 1 root root 7 7月  21 2021 /usr/sbin/clock -&gt; hwclock</span><br></pre></td></tr></table></figure></li>
</ul>
<p>时区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CST 	<span class="comment"># 东八区，北京时间</span></span><br><span class="line">UST 	<span class="comment"># 格林威治时间</span></span><br><span class="line">CST - UST = 8 hours <span class="comment"># 差8小时</span></span><br><span class="line">date -u   <span class="comment">#2022年 01月 27日 星期四 08:19:36 UTC </span></span><br><span class="line"></span><br><span class="line">[root@yanglinqi ~]<span class="comment"># ll /etc/localtime</span></span><br><span class="line">lrwxrwxrwx. 1 root root 35 1月  25 12:21 /etc/localtime -&gt; ../usr/share/zoneinfo/Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看时区</span></span><br><span class="line">timedatectl list-timezones  <span class="comment"># 按空格键翻页，按q停止</span></span><br><span class="line"><span class="comment"># 修改时区为 纽约时间 EST</span></span><br><span class="line">[root@yanglinqi ~]<span class="comment"># timedatectl set-timezone America/New_York</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">cat /etc/timezone</span><br></pre></td></tr></table></figure>

<p>显示日历：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cal    		<span class="comment"># 显示当月</span></span><br><span class="line">cal -y  	<span class="comment"># 显示全年</span></span><br><span class="line">cal 2022 	<span class="comment"># 显示2022年日历</span></span><br><span class="line">cal 9 1752  <span class="comment"># 显示1752年9月</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="关机和重启："><a href="#关机和重启：" class="headerlink" title="关机和重启："></a>关机和重启：</h3><p>关机：</p>
<ul>
<li><code>halt</code></li>
<li><code>poweroff</code></li>
</ul>
<p>重启：</p>
<ul>
<li><code>reboot</code><ul>
<li><code>-f</code> ：强制，不调用 <code>shutdown</code></li>
<li><code>-p</code>  ：切断电源</li>
</ul>
</li>
</ul>
<p>关机或重启：<code>shutdown</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shutdown [OPTION]... [TIME] [MESSAGE]</span><br><span class="line"></span><br><span class="line">-r		reboot</span><br><span class="line">-h		halt</span><br><span class="line">-c		cancel</span><br><span class="line">TIME：	默认为+1</span><br><span class="line">		now  立刻，相当于+0</span><br><span class="line">		+#   相对时间表示法，几分钟后，如+3</span><br><span class="line">		hh:mm  绝对时间表示，指明具体时间</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">shutdown -h +3</span><br><span class="line">shutdown -h 17:00</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#临时生效</span></span><br><span class="line">hostname NAME</span><br><span class="line"></span><br><span class="line"><span class="comment">#持久生效</span></span><br><span class="line">hostnamectl set-hostname NAME</span><br><span class="line"></span><br><span class="line"><span class="comment">#主机名不支持使用下划线，但支持横线，可使用字母、横线、数字的组合</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="提示符"><a href="#提示符" class="headerlink" title="提示符"></a>提示符</h3><ul>
<li><p>显示提示符格式：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PS1</span></span><br><span class="line"><span class="comment"># [\u@\h \W]\$</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改提示符格式范例：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS1=<span class="string">&#x27;\[\e[1;5;41;33m\][\u@\h \W]\\$\[\e[0m\]&#x27;</span></span><br><span class="line">PS1=<span class="string">&#x27;\[\e[1;41;33m\][\u@\h \W]\\$\[\e[0m\]&#x27;</span></span><br><span class="line">PS1=<span class="string">&#x27;\[\e[41;33m\][\u@\h \W]\\$\[\e[0m\]&#x27;</span></span><br><span class="line">PS1=<span class="string">&#x27;\[\e[33m\][\u@\h \W]\\$\[\e[0m\]&#x27;</span></span><br><span class="line">PS1=<span class="string">&#x27;\[\e[35m\][\u@\h \W]\\$\[\e[0m\]&#x27;</span></span><br><span class="line"><span class="comment"># 31-37字体颜色，41-47背景颜色</span></span><br><span class="line"><span class="comment"># \$ 是 $    \\$ 是 #</span></span><br><span class="line"></span><br><span class="line">PS1=<span class="string">&quot;\[\e[1;32m\][\t \[\e[1;33m\]\u\[\e[35m\]@\h\[\e[1;31m\] \W\[\e[1;32m\]]\[\e[0m\]\\$&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>提示符格式说明：</p>
<ul>
<li>\e   控制符\033</li>
<li>\u  当前用户</li>
<li>\h  主机名简称</li>
<li>\H  主机名</li>
<li>\w  当前工作目录</li>
<li>\W  当前工作目录基名</li>
<li>\t    24小时时间格式</li>
<li>\T   12小时时间格式</li>
<li>!      命令历史数</li>
<li>#    开机后命令历史数</li>
</ul>
</li>
<li><p>在CentOS系统实现持久化保存命令提示符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;PS1=&quot;\[\e[1;32m\][\t \[\e[1;33m\]\u\[\e[35m\]@\h\[\e[1;31m\] \W\[\e[1;32m\]]\[\e[0m\]\\$&quot;&#x27;</span> &gt; /etc/profile.d/env.sh</span><br><span class="line"></span><br><span class="line">. /etc/profile.d/env.sh   <span class="comment"># 执行sh脚本</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="命令分类"><a href="#命令分类" class="headerlink" title="命令分类"></a>命令分类</h3><ul>
<li>内部命令：由shell自带，而且通过某种命令形式提供</li>
<li>外部命令：在文件系统路径下有对应的可执行程序文件</li>
</ul>
<p>命令执行过程</p>
<ul>
<li>在内部命令中找</li>
<li>外部命令<ul>
<li>hash表中查找<ul>
<li>hash表中没有命令信息，继续</li>
<li>hash有命令信息，但命令的磁盘路径人为改变，报错</li>
</ul>
</li>
<li>$PATH 中的路径中查找</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ll /bin/bash -h   <span class="comment"># 集成在bash文件中的命令为内部命令</span></span><br><span class="line"><span class="comment"># 查看内部命令</span></span><br><span class="line"><span class="built_in">enable</span>   <span class="comment"># 所有启用的内部命令</span></span><br><span class="line"><span class="built_in">help</span> 	 <span class="comment"># 所有内部命令，禁用的命令前面带有*号</span></span><br><span class="line"></span><br><span class="line">ls /bin		<span class="comment"># bin文件夹下的其他命令为外部命令，在磁盘文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断命令是内部命令还是外部命令</span></span><br><span class="line"><span class="built_in">type</span> 命令名</span><br><span class="line"><span class="comment">#例</span></span><br><span class="line"><span class="built_in">type</span> <span class="built_in">help</span>  <span class="comment"># help is a shell builtin</span></span><br><span class="line"><span class="built_in">type</span> hostname  <span class="comment"># hostname is hashed (/usr/bin/hostname)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell会先在内部命令bash中查找命令，没有再在文件中查找命令，若没有找到，则报错</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span> 		<span class="comment"># 查找的路径</span></span><br><span class="line"><span class="comment"># /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 即是内部也是外部命令，优先执行内部命令，备用的效果</span></span><br><span class="line"><span class="built_in">type</span> -a <span class="built_in">echo</span></span><br><span class="line"><span class="comment"># echo is a shell builtin</span></span><br><span class="line"><span class="comment"># echo is /usr/bin/echo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用内部命令，临时生效</span></span><br><span class="line"><span class="built_in">enable</span> -n <span class="built_in">echo</span>  <span class="comment"># help查看内部命令，echo带有*号</span></span><br><span class="line"><span class="built_in">enable</span> -n		<span class="comment"># 查看禁用的内部命令</span></span><br><span class="line"><span class="built_in">enable</span> <span class="built_in">echo</span>		<span class="comment"># 启用命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hash缓存表，用于保存外部命令的路径，提高效率</span></span><br><span class="line"><span class="comment"># 例，先输入几个命令 hostname  、  who</span></span><br><span class="line"><span class="built_in">hash</span>  <span class="comment"># 查看hash表，输出如下</span></span><br><span class="line"><span class="comment"># hits	command</span></span><br><span class="line"><span class="comment"># 1 	/usr/bin/hostname</span></span><br><span class="line"><span class="comment"># 1		/usr/bin/who</span></span><br><span class="line"><span class="built_in">hash</span> -d hostname <span class="comment"># 删除hash表中保存的hostname命令路径</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="hash命令常见用法"><a href="#hash命令常见用法" class="headerlink" title="hash命令常见用法"></a>hash命令常见用法</h3><ul>
<li><code>hash</code>                                    显示hash缓存</li>
<li><code>hash -l</code>                              显示hash缓存，可作为输入使用</li>
<li><code>hash -p path name</code>         将命令全路径path起别名为name</li>
<li><code>hash -t name</code>                    打印缓存中name的路径</li>
<li><code>hash -d name</code>                     清楚name缓存</li>
<li><code>hash -r</code>                                清除缓存</li>
</ul>
<hr>
<h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><ul>
<li><code>alias</code></li>
<li><code>alias name=&#39;value&#39;</code>    定义别名</li>
<li><code>unalias name</code>                 取消别名</li>
<li><code>unalias -a</code>                      取消所有别名</li>
</ul>
<p>永久有效，要定义在配置文件中</p>
<ul>
<li>对当前用户永久有效： ~/.bashrc</li>
<li>对所有用户永久有效：/etc/bashrc</li>
</ul>
<p>如果别名同原命令同名，要执行原命令，使用</p>
<ul>
<li><code>\aliasname</code></li>
<li><code>&quot;aliasname&quot;</code></li>
<li><code>&#39;aliasname&#39;</code></li>
<li><code>command aliasname</code></li>
<li><code>/path/command  # 只适用于外部命令</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如，要执行下面三条命令，很长，设为别名scandisk，三条命令的作用：查看新添加的硬盘</span></span><br><span class="line"><span class="built_in">echo</span> - - - &gt; /sys/class/scsi_host/host0/scan</span><br><span class="line"><span class="built_in">echo</span> - - - &gt; /sys/class/scsi_host/host1/scan</span><br><span class="line"><span class="built_in">echo</span> - - - &gt; /sys/class/scsi_host/host2/scan</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义别名，临时生效</span></span><br><span class="line"><span class="built_in">alias</span> scandisk=<span class="string">&quot;echo - - - &gt; /sys/class/scsi_host/host0/scan;echo - - - &gt; /sys/class/scsi_host/host1/scan;echo - - - &gt; /sys/class/scsi_host/host2/scan&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看别名</span></span><br><span class="line"><span class="built_in">alias</span> scandisk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除别名</span></span><br><span class="line"><span class="built_in">unalias</span> scandisk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入 .bashrc文件，持久生效</span></span><br><span class="line"><span class="comment"># 可以直接在打开文件写入</span></span><br><span class="line"><span class="comment"># 也可以使用下面的命令，示例</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;alias yi=&#x27;yum -y install &#x27;&quot;</span> &gt;&gt; .bashrc</span><br><span class="line"><span class="comment"># 再运行 .bashrc 文件</span></span><br><span class="line">. .bashrc</span><br><span class="line"><span class="built_in">alias</span>  <span class="comment"># 查看yi是否生效，可以直接使用yi下载了，如 yi gcc  下载gcc编译器</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMAND [OPTIONS...] [ARGUMENTS...]</span><br><span class="line">COMMAND [COMMAND] [COMMAND] ...</span><br></pre></td></tr></table></figure>

<p>选项：用于启用或关闭命令的某个或某些功能</p>
<ul>
<li>短选项：UNIX风格选项， -c    例如： -l, -h</li>
<li>长选项：GNU风格选项，–word  例如： –all,  –human</li>
<li>BSD风格选项：一个字母，例如：a，使用相对较少</li>
</ul>
<p>参数：命令的作用对象，比如：文件名，用户名等</p>
<p>范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment">#id -u yang</span></span><br><span class="line">1000</span><br><span class="line"></span><br><span class="line">[root@CentOS8 ~]<span class="comment">#ls -a</span></span><br><span class="line">[root@CentOS8 ~]<span class="comment">#ls --all</span></span><br><span class="line"></span><br><span class="line">[root@CentOS8 ~]<span class="comment">#free -h</span></span><br><span class="line">[root@CentOS8 ~]<span class="comment">#free --huamn</span></span><br><span class="line"></span><br><span class="line">[root@CentOS8 ~]<span class="comment">#ps a</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><ul>
<li>nano  实现文本的编辑，上手容易，适合初学者</li>
<li>gedit  图形化界面编辑器</li>
<li>vi        命令较多</li>
</ul>
<hr>
<h3 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h3><p>命令行的典型使用方式是，打开个终端窗口( terminal window,以下简称”窗口”),在里面输入命令。用户与计算机的这种临时的交互，称为一次”会话”( session)<br>会话的个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完<br>一个典型的例子就是，SSH登录远程计算机，打开个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次SSH会话已经终止了，里面的进程也随之消失了。为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口</p>
<p>终端复用器软件就是会话与窗口的”解绑”工具，将它们彻底分离。<br>(1)它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用<br>(2)它可以让新窗口”接入”已经存在的会话。<br>(3)它允许每个会话有多个连接窗口，因此可以多人实时共享会话。<br>(4)它还支持窗口任意的垂直和水平拆分<br>类似的终端复用器还有 Screen,Tmux</p>
<h4 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 screen</span></span><br><span class="line"><span class="comment"># CentOS7  </span></span><br><span class="line">yum -y install screen</span><br><span class="line"><span class="comment"># CentOS8</span></span><br><span class="line">dnf -y install epel-release</span><br><span class="line">dnf -y install screen</span><br><span class="line"><span class="comment">#Ubuntu</span></span><br><span class="line">apt install screen</span><br></pre></td></tr></table></figure>

<p>screen命令常见用法：</p>
<ul>
<li><p>创建新screen会话</p>
<p><code>screen -S [SESSION]</code></p>
</li>
<li><p>加入screen会话</p>
<p><code>screen -x [SESSION]</code></p>
</li>
<li><p>退出并关闭screen会话</p>
<p><code>exit</code></p>
</li>
<li><p>剥离当前screen会话</p>
<p><code>Ctrl+a,d</code></p>
</li>
<li><p>显示所有已经打开的screen会话</p>
<p><code>screen -ls</code></p>
</li>
<li><p>恢复某screen会话</p>
<p><code>screen -r [SESSION]</code></p>
</li>
</ul>
<h4 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h4><p>是一个终端复用器 (terminal multiplexer),类似 screen,但是更易用，也更强大</p>
<p>Tmux就是会话与窗口的”解绑”工具，将它们彻底分离，功能如下</p>
<ul>
<li>它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。</li>
<li>它可以让新窗口接入”已经存在的会话。</li>
<li>它允许每个会话有多个连接窗口，因此可以多人实时共享会话。</li>
<li>它还支持窗口任意的垂直和水平拆分</li>
</ul>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install tmux</span><br></pre></td></tr></table></figure>

<p>启动与退出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>Tmux窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是ctrl+b,即先按下ctrl+b,快捷键才会生效。帮助命令的快捷键是<code>ctrl+b ?</code>然后，按下q键，就可以退出帮助</p>
<p>新建会话<br>第一个启动的Tmux窗口，编号是0,第二个窗口的编号是1,以此类推。这些窗口对应的会话，就是0号会话、1号会话。使用编号区分会话，不太直观，更好的方法是为会话起名。下面命令新建一个指定名称的会话。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux new -s &lt;session-name&gt;</span><br></pre></td></tr></table></figure>

<p>tmux Is 或 Ctrl+b,s可以查看当前所有的Tmux会话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux ls</span><br><span class="line">tmux list-session</span><br></pre></td></tr></table></figure>

<p>分离会话<br>在Tmux窗口中，按下Ctrl+b d或者输入 tmux detach命令，就会将当前会话与窗口分离</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux detach</span><br></pre></td></tr></table></figure>

<p>接入会话<br>tmux attach 命令用于重新接入某个已存在的会话。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux attach -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>

<p>范例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux attach -t 0</span><br></pre></td></tr></table></figure>

<p>杀死会话<br>tmux kill-session 命令用于杀死某个会话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x kill-session -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>

<p>切换会话<br>tmux switch 命令用于切换会话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux switch -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>

<p>可以将窗口分成多个窗格(pane)，每个窗格运行不同的命令</p>
<p>上下分窗格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux split-window</span><br><span class="line">ctrl+b,&quot;</span><br></pre></td></tr></table></figure>

<p>左右分窗格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux split-window -h</span><br><span class="line">ctrl+b,%</span><br></pre></td></tr></table></figure>

<p>窗格快捷键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctr1+b %   	划分左右两个商格</span><br><span class="line">ctr1+b &quot;   	划分上下两个窗格</span><br><span class="line">ctrl+b &lt;arrow key&gt;   光标切换到其他窗格。&lt;arrow key&gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按向下的方向键</span><br><span class="line">ctr1+b ;	光标切换到上一个窗格</span><br><span class="line">ctr1+b o 	光标切换到下一个窗格。</span><br><span class="line">ctr1+b &#123;  	当前窗格左移</span><br><span class="line">ctr1+b &#125; 	当前窗格右移</span><br><span class="line">ctr1+b Ctrl+o  	当前窗格上移</span><br><span class="line">ctr1+b A1t+o 	当前窗格下移</span><br><span class="line">ctr1+b x 		关闭当前窗格</span><br><span class="line">ctr1+b ! 		将当前窗格折分为一个独立窗口</span><br><span class="line">ctr1+b z 		当前窗格全屏显示，再使用一次会变回原来大小</span><br><span class="line">ctr1+b ctr1+&lt;arrow key&gt; 	按箭头方向调整窗格大小</span><br><span class="line">Ctr1+b q 		显示窗格编号</span><br></pre></td></tr></table></figure>

<p>列出所有Tmux命令及其参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux list-commands</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="输出信息-echo"><a href="#输出信息-echo" class="headerlink" title="输出信息 echo"></a>输出信息 echo</h3><p>echo基本用法</p>
<p>echo命令可以将后面跟的字符进行输出<br>功能：显示字符，echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开，并在最后加上换行号</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo [-neE][字符串]</span><br></pre></td></tr></table></figure>

<p>选项：</p>
<ul>
<li>-E（默认）不支持 \ 解释功能</li>
<li>-n 不自动换行</li>
<li>-e 启用 \ 字符的解释功能</li>
</ul>
<p>显示变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$VAR_NAME</span>”   # 用变量值换，弱引用</span></span><br><span class="line"><span class="string">echo &#x27;<span class="variable">$VAR_NAME</span>&#x27;   # 变量不会替换，强引用</span></span><br></pre></td></tr></table></figure>

<p>启用命令选项 -e，若字符串中出现以下字符，则特別加以处理，而不会将它当成一般文字输出</p>
<ul>
<li>\a    发出警告声</li>
<li>\b    退格键</li>
<li>\c     最后不加上换行符号</li>
<li>\e     escape，相当于\033</li>
<li>\n     换行且光标移至行首</li>
<li>\r      回车，即光标移至行首，但不换行</li>
<li>\t      插入tab</li>
<li>\ \       插入 \ 字符</li>
<li>\0nnn   插入nnn （八进制）所代表的ASCII字符</li>
<li>\xHH     插入HH（十六进制）所代表的ASCII字符（man 7 ascii）</li>
</ul>
<p>echo高级用法</p>
<p>在终端中，ANSI 定义了用于屏幕显示的 Escape.屏幕控制码</p>
<p>具有颜色的字符，其格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;033[字符背景色;字体色m字符串\033[0m&quot;</span><br></pre></td></tr></table></figure>

<p>\033[30m …  \033[37m      设置前景色<br>\033[40m …  \033[47m      设置背景色</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符背景色苑围：40-47</span></span><br><span class="line">40:黑</span><br><span class="line">41:红</span><br><span class="line">42:绿</span><br><span class="line">43:黄</span><br><span class="line">44:蓝</span><br><span class="line">45:紫</span><br><span class="line">46:深绿</span><br><span class="line">47:白色</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字体颜色：30-37  和字符背景颜色对应</span></span><br></pre></td></tr></table></figure>

<p>加颜色只是以下控制码中的一种，下面是常见的一些 ANSI 控制码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\033[0m		关闭所有属性</span><br><span class="line">\033[1m		设置高亮度</span><br><span class="line">\033[4m		下划线</span><br><span class="line">\033[5m		闪烁</span><br><span class="line">\033[7m		反显</span><br><span class="line">\033[8m		消隐</span><br><span class="line">\033[nA		光标上移n行</span><br><span class="line">\033[nB		光标下移n行</span><br><span class="line">\033[nC		光标右移n列</span><br><span class="line">\033[nD		光标左移n列</span><br><span class="line">\033[x;yH	设置光标位置x行y列</span><br><span class="line">\033[2J		清屏</span><br><span class="line">\033[K		清除从光标到行尾的内客</span><br><span class="line">\033[s		保存光标位置</span><br><span class="line">\033[u		恢复光标位置</span><br><span class="line">\033[?25l	隐藏光标</span><br><span class="line">\033[?25h	显示光标</span><br><span class="line">\033[2J\033[0;0H 	清屏且将光标置顶</span><br></pre></td></tr></table></figure>



<p>范例：显示文件的十六进制编码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@yanglinqi ~]<span class="comment"># cat &gt; myfile</span></span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br><span class="line">[root@yanglinqi ~]<span class="comment"># hexdump -C myfile</span></span><br><span class="line">00000000  41 0a 42 0a 43 0a 44 0a                           |A.B.C.D.|</span><br><span class="line">00000008</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="字符集和编码"><a href="#字符集和编码" class="headerlink" title="字符集和编码"></a>字符集和编码</h3><p>许多场合下，字符集与编码这两个概念常被混为一谈，但两者是有差別的。字符集与字符集编码是两个不同层面的概念。</p>
<p>charset是 character set的简写，即字符集，即二进制和字符的对应关系，不关注最终的存储形式</p>
<p>encoding是 charset encoding的简写，即字符集编码，简称编码，实现如何将字符转化为实际的二进制进行存储或相反，编码决定了空间的使用的大小</p>
<p>UTF-8是目前互联网上使用最广泛的一种 Unicode编码方式，可变长存储。使用1-4个字节表示一个字符，根据字符的不同变换长度，编码规则如下：</p>
<blockquote>
<p>对于单个字节的字符，第一位设为0,后面的7位对应这个字符的 Unicode码。因此，对于英文中的0-127号字符，与ASCI码完全相同。这意味着ASC码的文档可用UTF-8编码打开<br>对于需要使用N个字节来表示的字符(N&gt;1),第一个字节的前N位都设为1,第N+1位设为0,剩余的N-1个字节的前两位都设为10，剩下的二进制位则使用这个字符的 Unicode码来填充</p>
</blockquote>
<p><a href="https://unicode.yunser.com/unicode">Unicode 查询 (yunser.com)</a></p>
<p><a href="https://home.unicode.org/">Unicode – The World Standard for Text and Emoji</a></p>
<p><a href="http://www.chi2ko.com/tool/CJK.htm">http://www.chi2ko.com/tool/CJK.htm</a></p>
<p><a href="https://javawind.net/tools/native2ascii.jsp?action=transform">https://javawind.net/tools/native2ascii.jsp?action=transform</a></p>
<p><a href="http://tool.oschina.net/encode">http://tool.oschina.net/encode</a></p>
<p><a href="http://web.chacuo.net/charsetescape">http://web.chacuo.net/charsetescape</a></p>
<p>Unicode和UTF-8</p>
<table>
<thead>
<tr>
<th>Unicode符号范围（十六进制）</th>
<th>UTF-8編码方式二进制）</th>
</tr>
</thead>
<tbody><tr>
<td>0000 0000-0000 007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080-0000 07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800-0000 FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000-0010 FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx10xxxxxx</td>
</tr>
</tbody></table>
<p>范例： Unicode转换为UTF-8</p>
<blockquote>
<p>汉”的 Unicode码 0x6C49 (110 110001 001001),需要三个字节存储，格式カ:1110xxxx 10xxxxxx 10xxxxxx，从后向前依次填充对应格式中的x，多出的x用0补，得出UTF-8编码为11100110 10110001 10001001</p>
<p>“马”的 Unicode码 0x9A6C (1001 101001 101100),需要三个字节存储，格式为：1110xxxx 10xxxxxx 10xxxxxx,从后向前依次填充对应格式中的x，多出的x用0补，得出UTF-8编码为11101001 10101001 10101100</p>
</blockquote>
<p>范例：修改LANG变量来实现中文语言提示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$LANG</span> 		<span class="comment"># 查看语言</span></span><br><span class="line">LANG=zh_CN.UTF-8	<span class="comment"># 设置中文</span></span><br><span class="line">LANG=en_US.UTF-8	<span class="comment"># 设置英文，默认</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="命令行及括号扩展"><a href="#命令行及括号扩展" class="headerlink" title="命令行及括号扩展"></a>命令行及括号扩展</h3><p>` ` 和 $()</p>
<p>把一个命令的输出打印给另一个命令的参数，放在``中的一定是有输出信息的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(COMMAND) 或 `COMMAND`</span><br></pre></td></tr></table></figure>

<p>范例：比较 “ “，’ ‘，``三者区别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@yanglinqi ~]<span class="comment"># echo &quot;echo $HOSTNAME&quot;</span></span><br><span class="line"><span class="built_in">echo</span> yanglinqi.local</span><br><span class="line">[root@yanglinqi ~]<span class="comment"># echo &#x27;echo $HOSTNAME&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$HOSTNAME</span></span><br><span class="line">[root@yanglinqi ~]<span class="comment"># echo `echo $HOSTNAME`</span></span><br><span class="line">yanglinqi.local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结论</span></span><br><span class="line">单引号：强引用，变量和命令都不识别，都当成普通的字符串</span><br><span class="line">双引号：弱引用，不能识别命令，可以识别变量</span><br><span class="line">反向单引号：里面的内容必须是能执行的命令并且有输出信息，变量和命令都识别，并且会将反向单引号的内容当成命令进行执行后，在交给调用反向单引号的命令继续</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">date +%F        <span class="comment"># 显示今天日期 2022-01-28</span></span><br><span class="line">touch 2022-01-28.log	<span class="comment"># 创建 2022-01-28.log文件</span></span><br><span class="line">date `date +%F`.<span class="built_in">log</span>     <span class="comment"># 也是创建 2022-01-28.log文件，先执行``内的命令，使用``输出作为文件名</span></span><br><span class="line">等价于</span><br><span class="line">date $(date +%F).<span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>括号扩展：{}</p>
<p>{}可以实现打印重复字符串的简化形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;元素1,元素2,元素3&#125;</span><br><span class="line">&#123;元素1..元素2&#125;</span><br></pre></td></tr></table></figure>

<p>范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> file&#123;1,3,5&#125; <span class="comment"># 结果为：file1 file2 file3</span></span><br><span class="line"><span class="built_in">echo</span> &#123;1..10&#125; </span><br><span class="line"><span class="built_in">echo</span> &#123;a..z&#125;</span><br><span class="line"><span class="built_in">echo</span> &#123;1..10..2&#125; <span class="comment"># 1 3 5 7 9  # 1 到 10 是范围， 2 是递增</span></span><br><span class="line"><span class="built_in">echo</span> &#123;000..20..2&#125;</span><br></pre></td></tr></table></figure>

<p>范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@yanglinqi ~]<span class="comment"># echo &#123;000..20..2&#125;</span></span><br><span class="line">000 002 004 006 008 010 012 014 016 018 020</span><br><span class="line">[root@yanglinqi ~]<span class="comment"># echo &#123;a..z..2&#125;</span></span><br><span class="line">a c e g i k m o q s u w y</span><br><span class="line">[root@yanglinqi ~]<span class="comment"># echo &#123;A..z&#125;</span></span><br><span class="line">A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [  ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure>

<p>范例：关闭和启用{}的扩展功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@yanglinqi ~]<span class="comment"># echo $-</span></span><br><span class="line">himBHs</span><br><span class="line">[root@yanglinqi ~]<span class="comment"># echo &#123;1..10&#125;</span></span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">[root@yanglinqi ~]<span class="comment"># set +B</span></span><br><span class="line">[root@yanglinqi ~]<span class="comment"># echo $-</span></span><br><span class="line">himHs</span><br><span class="line">[root@yanglinqi ~]<span class="comment"># echo &#123;1..10&#125;</span></span><br><span class="line">&#123;1..10&#125;</span><br><span class="line">[root@yanglinqi ~]<span class="comment"># set -B</span></span><br><span class="line">[root@yanglinqi ~]<span class="comment"># echo $-</span></span><br><span class="line">himBHs</span><br><span class="line">[root@yanglinqi ~]<span class="comment"># echo &#123;1..10&#125;</span></span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="tab键补全"><a href="#tab键补全" class="headerlink" title="tab键补全"></a>tab键补全</h3><p>tab键可以实现命令及路径等补全，提高输入效率避免出错</p>
<p>命令补全</p>
<ul>
<li>内部命令</li>
<li>外部命令：bash根据PATH环境变量定义的路径，自左而右在每个路径搜寻以给定命令名命名的文件，第一次找到的命令即为要执行的命令</li>
<li>命令的子命令补全，需要安装<code>bash-completion</code></li>
</ul>
<p>注意：用户给定的字符串只有一条唯一对应的命令，直接补全，否则，再次tab会给出列表</p>
<p>范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@yanglinqi ~]<span class="comment"># nmcli connection 2TAB</span></span><br><span class="line">add      delete   edit     <span class="built_in">help</span>     load     monitor  show     </span><br><span class="line"><span class="built_in">clone</span>    down     <span class="built_in">export</span>   import   modify   reload   up  </span><br></pre></td></tr></table></figure>

<p>路径补全</p>
<blockquote>
<p>把用户给出的字符串当做路径开头，并在其指定的上级目录下搜索以指定的字符串开头的文件名</p>
<p>如果唯一：则直接补全</p>
<p>否则：再次Tab给出列表</p>
</blockquote>
<p>双击Tab键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command 2TAB   	所有子命令或文件补全</span><br><span class="line">string2TAB		以string开头命令</span><br><span class="line">/2TAB			显示所有根目录下一级目录，包括隐藏目录</span><br><span class="line">./2TAB			当前目录下子目录，包括隐藏目录</span><br><span class="line">*2TAB			当前目录下子目录，不包括隐藏目录</span><br><span class="line">~2TAB			所有用户列表</span><br><span class="line">$2TAB			所有变量</span><br><span class="line">@2TAB			/etc/hosts记录</span><br><span class="line">=2TAB			相当于ls -A</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="命令行历史-history"><a href="#命令行历史-history" class="headerlink" title="命令行历史 history"></a>命令行历史 history</h3><p>当执行命令后，系统默认会在内存记录执行过的命令</p>
<p>当用户正常退出时，会将内存的命令历史存放对应历史文件中，默认是<code>~/.bash_ history</code></p>
<p>登录shell时，会读取命令历史文件中记录下的命令加载到内存中</p>
<p>登录进shel后新执行的命令只会记录在内存的缓存区中；这些命令会用户正常退出时“追加”至命令历史文件中</p>
<p>利用命今历史。可以用它来重复执行命令，提高输入效率</p>
<p>命令： history</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">history</span> [-c] [-d offset] [n]</span><br><span class="line"><span class="built_in">history</span> -anrw [filename]</span><br><span class="line"><span class="built_in">history</span> -ps arg [arg...]</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c				清空命令历史</span><br><span class="line">-d offset		删除历史中指定的第offset个命令</span><br><span class="line">n				显示最近的n条历史</span><br><span class="line">-a				追加本次会话新执行的命令历史列表至历史文件</span><br><span class="line">-r 				读历史文件附加到历史列表</span><br><span class="line">-w				保存历史列表到指定的历史文件</span><br><span class="line">-n				读历史文件中未读过的行到历史列表</span><br><span class="line">-p				展开历史参数成多行，但不存在历史列表中</span><br><span class="line">-s				展开历史参数成一行，附加在历史列表后</span><br></pre></td></tr></table></figure>

<p>命令历史相关环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HISTSIZE		命令历史记录的条数</span><br><span class="line">HISTFILE		指定历史文件，默认为~/.bash_history</span><br><span class="line">HISTFILESIZE	命令历史文件记录历史的条数</span><br><span class="line">HISTTIMEFORMAT=&quot;%F %T `whoami`&quot;  显示时间和用户</span><br><span class="line">HISTIGNORE=&quot;str1:str2*:...&quot;      忽略str1命令，str2开头的历史</span><br><span class="line">HISTCONTROL		控制命令历史的记录方式</span><br><span class="line">		ignoredups    默认值，可忽略重复部分，连续且相同为“重复”</span><br><span class="line">		ignorespace   忽略所有以空白开头的命令</span><br><span class="line">		ignoreboth 	  相当于ignoredups，ignorespace的组合</span><br><span class="line">		erasedups     删除重复命令</span><br></pre></td></tr></table></figure>

<p>持久保存变量</p>
<p>以上变量可以 <code>export 变量名=&quot;值&quot;</code> 形式存放在 <code>/etc/profile</code> 或 <code>~./bash_profile</code></p>
<p>调用命令行历史</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 重复前一个命令方法</span></span><br><span class="line"> 按上方向键，并回车执行</span><br><span class="line"> 输入 !!  并回车执行</span><br><span class="line"> 输入 !-1 并回车执行</span><br><span class="line"> 按 ctrl+p  并回车执行</span><br><span class="line"> </span><br><span class="line"> !:0 	执行前一条命令（去除参数）</span><br><span class="line"> !n		执行<span class="built_in">history</span>命令输出的历史命令中对应序号n的命令</span><br><span class="line"> !string	重复前一个以<span class="string">&quot;string&quot;</span>开头的命令</span><br><span class="line"> !?string 	重复前一个包含string的命令</span><br><span class="line"> !string:p	仅打印命令历史，不执行</span><br><span class="line"> !$:P		打印输出 !$ （上一条命令的最后一个参数）的内容</span><br><span class="line"> !*:p		打印输出 !* （上一条命令的所有参数）的内容</span><br><span class="line"> ^string	删除上一条命令中的第一个string</span><br><span class="line"> ^string1^string2	将上一条命令中的第一个string1替换成string2</span><br><span class="line"> !:gs/string1/string2	将上一条命令中所有的string1替换成string2</span><br><span class="line"> 使用up (向上) 和down（向下）键来上下浏览从前输入的命令</span><br><span class="line"> ctrl+r  在命令历史中搜索命令</span><br><span class="line"> (reverse-i-search)`<span class="string">&#x27;: </span></span><br><span class="line"><span class="string">ctrl+g	 从历史搜索模式退出</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 要重新调用前一个命令中最后一个参数</span></span><br><span class="line"><span class="string">!$		表示前一个命令中最后一个参数</span></span><br><span class="line"><span class="string">Esc,.	点击Esc键后松开，然后点击 . 键</span></span><br><span class="line"><span class="string">alt+.	按住alt键的同时点击 . 键</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">command !^		利用上一个命令的第一个参数做command的参数</span></span><br><span class="line"><span class="string">command !$  	利用上一个命令的最后一个参数做command的参数</span></span><br><span class="line"><span class="string">command !*		利用上一个命令的全部参数做command的参数</span></span><br><span class="line"><span class="string">command !:n		利用上一个命令的第n个参数做command的参数</span></span><br><span class="line"><span class="string">command !n:^	调用第n条命令的第一个参数</span></span><br><span class="line"><span class="string">command !n:$	调用第n条命令的最后一个参数</span></span><br><span class="line"><span class="string">command !n:m	调用第n条命令的第m个参数</span></span><br><span class="line"><span class="string">command !n:*	调用第n条命令的所有参数</span></span><br><span class="line"><span class="string">command !string:^	从命令历史中搜索以 string 开头的命令，并获取它的第一个参数</span></span><br><span class="line"><span class="string">command !string:$	从命令历史中搜索以 string 开头的命令，并获取它的最后一个参数</span></span><br><span class="line"><span class="string">command !string:n	从命令历史中搜索以 string 开头的命令，并获取它的第n个参数</span></span><br><span class="line"><span class="string">command !string:*	从命令历史中搜索以 string 开头的命令，并获取它的所有参数</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="bash的快捷键"><a href="#bash的快捷键" class="headerlink" title="bash的快捷键"></a>bash的快捷键</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl+l		清屏，相当于c1ear命令</span><br><span class="line">Ctrl+o		执行当前命令，并重新显示本命令</span><br><span class="line">Ctrl+s		阻止屏出输出，锁定</span><br><span class="line">Ctrl+q		允许屏幕输出，解锁</span><br><span class="line">Ctrl+c		终止命令</span><br><span class="line">Ctrl+z		挂起命令</span><br><span class="line">Ctrl+a		光标移到命令行首，相当于Home</span><br><span class="line">Ctrl+e		光标移到命令行尾，相当于End</span><br><span class="line">Ctrl+f		光标向右移动一个字符</span><br><span class="line">Ctrl+b		光标向左移动一个字符</span><br><span class="line">Ctrl+xx		光标在命令行首和光标之间移动</span><br><span class="line">Alt+f		光标向右移动一个单词尾</span><br><span class="line">Alt+b		光标向左移动一个单词首</span><br><span class="line">Ctrl+u		从光标处册除至命令行首</span><br><span class="line">Ctrl+k		从光标处册除至命令行尾</span><br><span class="line">Alt+r		删除当前整行</span><br><span class="line">Ctrl+w		从光标处向左册除至单词首</span><br><span class="line">Alt+d		从光标处向右册除至单词尾</span><br><span class="line">Alt+Backspace	删除左边单词</span><br><span class="line">Ctrl+d		删除光标处的一个字符</span><br><span class="line">Ctrl+h		删除光标前的一个字符</span><br><span class="line">Ctrl+y		将删除的字符粘贴至光标后</span><br><span class="line">Alt+c		从光标处开始向右更改为首字母大写的单词</span><br><span class="line">Alt+u		从光标处开始，将右边一个单词更改为大写</span><br><span class="line">Alt+l		从光标处开始，将右边一个单词更改为小写</span><br><span class="line">Ctrl+t		交换光标处和之前的字符位置</span><br><span class="line">Alt+t		交换光标处和之前的单词位置</span><br><span class="line">Alt+数字n		提示输入指定字符后，重复显示该字符n次</span><br></pre></td></tr></table></figure>

<p>注意：Alt组合快捷键经常和其它软件冲突</p>
<p>例：xShell   会话的属性 =》终端 =》键盘 =》将和Alt有关的选项全部勾上  </p>
<hr>
<h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><p>多层次的帮助</p>
<ul>
<li>whatis</li>
<li>command –help</li>
<li>man and info</li>
<li>/usr/share/doc/</li>
<li>Red Hat documentation、Ubuntu documentation</li>
<li>软件项目网站</li>
<li>其他网站</li>
<li>搜索</li>
</ul>
<h4 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h4><p>whatis 使用数据库来显示命令的简短描述</p>
<p>此工具在系统刚安装后，不可立即使用，需要制作数据库后才可使用</p>
<p>执行下面命令生成数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CentOS 7 版本以后</span></span><br><span class="line">mandb</span><br><span class="line"><span class="comment"># CentOS 6 版本之前</span></span><br><span class="line">makewhatis</span><br></pre></td></tr></table></figure>

<p>范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># whatis cal</span></span><br><span class="line">cal (1)              - display a calendar</span><br><span class="line">cal (1p)             - <span class="built_in">print</span> a calendar</span><br><span class="line">命令名 章节			描述</span><br><span class="line">搭配man使用</span><br><span class="line">man 1 cal	 <span class="comment"># 看display a calendar的内容</span></span><br><span class="line">man 1p cal	 <span class="comment"># 看print a calendar的内容</span></span><br><span class="line"></span><br><span class="line">查看man章节划分，man类似一个小手册</span><br><span class="line">[root@CentOS8 ~]<span class="comment"># man man</span></span><br><span class="line">....省略...</span><br><span class="line">下表显示了手册的 章节 号及其包含的手册页类型。</span><br><span class="line"></span><br><span class="line">       1   可执行程序或 shell 命令</span><br><span class="line">       2   系统调用(内核提供的函数)</span><br><span class="line">       3   库调用(程序库中的函数)</span><br><span class="line">       4   特殊文件(通常位于 /dev)</span><br><span class="line">       5   文件格式和规范，如 /etc/passwd</span><br><span class="line">       6   游戏</span><br><span class="line">       7   杂项(包括宏包和规范，如 man(7)，groff(7))</span><br><span class="line">       8   系统管理命令(通常只针对 root 用户)</span><br><span class="line">       9   内核例程 [非标准</span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure>



<h4 id="查看命令的帮助"><a href="#查看命令的帮助" class="headerlink" title="查看命令的帮助"></a>查看命令的帮助</h4><p>内部命令帮助</p>
<ul>
<li><code>help COMMAND</code></li>
<li><code>man bash</code></li>
</ul>
<p>外部命令帮助</p>
<ul>
<li><code>COMMAND --help</code> 或 <code>COMMAND -h</code></li>
<li>使用man手册( manual): <code>man COMMAND</code></li>
<li>信息页： <code>info COMMAND</code></li>
<li>程序自身的帮助文档： README、 INSTALL、 ChangeLog</li>
<li>程序官方文档</li>
<li>相关网站，如：技术论坛</li>
<li>搜索引擎</li>
</ul>
<p>外部命令的 –help 或 -h 选项</p>
<p>显示用法总结和参数列表，大多数命令使用，但并非所有的</p>
<p>格式说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[]			表示可选项</span><br><span class="line">CAPS或&lt;&gt;		表示变化的数据</span><br><span class="line">...			表示一个列表</span><br><span class="line">x|y|z		x或y或z</span><br><span class="line">-abc		-a -b -c</span><br><span class="line">&#123;&#125;			分组</span><br></pre></td></tr></table></figure>

<p>用 <code>whatis</code> 确定章节，再用 <code>man</code> 查看想要知道的某部分的详细介绍</p>
<p>范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># whatis passwd</span></span><br><span class="line">openssl-passwd (1ssl) - compute password hashes</span><br><span class="line">passwd (1)           - update user<span class="string">&#x27;s authentication tokens</span></span><br><span class="line"><span class="string">passwd (5)           - password file</span></span><br><span class="line"><span class="string">[root@CentOS8 ~]# man 5 passwd</span></span><br><span class="line"><span class="string">省略...</span></span><br><span class="line"><span class="string">[root@CentOS8 ~]# man 1 passwd</span></span><br><span class="line"><span class="string">省略...</span></span><br></pre></td></tr></table></figure>



<h4 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a>man命令</h4><p>man提供命令帮助的文件，手册页存放在 /usr/share/man</p>
<p>几乎每个命令都有man的页面</p>
<p>中文man需安装包</p>
<ul>
<li>man-pages</li>
<li>man-pages-zh-CN</li>
</ul>
<p>man页面分组</p>
<p>不同类型的帮助称为不同的章节，统称为Linux手册，man 1 man</p>
<ul>
<li><p> 1   可执行程序或 shell 命令       </p>
</li>
<li><p>2   系统调用(内核提供的函数)</p>
</li>
<li><p> 3   库调用(程序库中的函数)      </p>
</li>
<li><p>4   特殊文件(通常位于 /dev)</p>
</li>
<li><p>5   文件格式和规范，如 /etc/passwd</p>
</li>
<li><p>6   游戏</p>
</li>
<li><p>7   杂项(包括宏包和规范，如 man(7)，groff(7))</p>
</li>
<li><p>8   系统管理命令(通常只针对 root 用户)</p>
</li>
<li><p>9   Linux内核API </p>
</li>
</ul>
<p>man命令的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CentOS 6 之前 man 的配置文件</span></span><br><span class="line">/etc/man.config</span><br><span class="line"><span class="comment"># CentOS 7 之后 man 的配置文件</span></span><br><span class="line">/etc/man_db.conf</span><br><span class="line"><span class="comment"># Ubuntu man 的配置文件</span></span><br><span class="line">/etc/manpath.config</span><br></pre></td></tr></table></figure>

<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MANPATH /PATH/TO/SOMEWHERE		#指明man文件搜索位置</span><br></pre></td></tr></table></figure>

<p>也可以指定位置下搜索 COMMAND命令的手册页并显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">man -M /PATH/TO/SOMEWHERE COMMAND</span><br></pre></td></tr></table></figure>

<p>查看man手册页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">man [OPTION...] [SECTION] PAGE...</span><br><span class="line">man [章节] keyword</span><br></pre></td></tr></table></figure>


<p>man帮助段落说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME			名称及简要说明</span><br><span class="line">SYNOPSIS		用法格式说明</span><br><span class="line">[]				可选内容</span><br><span class="line">&lt;&gt;				必选内容</span><br><span class="line">a|b				二选一</span><br><span class="line">&#123;&#125;				分组</span><br><span class="line">...				同一内容可出现多次</span><br><span class="line">DESCRIPTION		详细说明</span><br><span class="line">OPTIONS			选项说明</span><br><span class="line">EXAMPLES		示例</span><br><span class="line">FILES				相关文件</span><br><span class="line">AUTHOR				作者</span><br><span class="line">COPYRIGHT			版本信息</span><br><span class="line">REPORTING BUGS 		bug信息</span><br><span class="line">SEE ALSO		其它帮助参考</span><br></pre></td></tr></table></figure>

<p>man 命令的操作方法：使用 less 命令实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">space,^v,^f,^F		向文件尾翻屏</span><br><span class="line">b,^b				向文件首部翻屏</span><br><span class="line">d,^d				向文件尾部翻半屏</span><br><span class="line">u,^u				向文件首部翻半屏</span><br><span class="line">RETURN,^N,e,^E or j or ^J	向文件尾部翻一行</span><br><span class="line">y or ^Y or ^P or k or ^K	向文件首部翻一行</span><br><span class="line">q		退出</span><br><span class="line">#		跳转至第#行</span><br><span class="line">1G		回到文件首部</span><br><span class="line">G		翻至文件尾部</span><br><span class="line">/KEYWORD	以 KEYWORD指定的字符串为关键字，从当前位置向文件尾部搜索：不区分字符大小写</span><br><span class="line">				n:下一个</span><br><span class="line">				N:上一个</span><br><span class="line">?KEYWORD	以 KEYWORD指定的字符串为关键字，从当前位置向文件首部搜索：不区分字符大小写</span><br><span class="line">				n:跟搜索命令同方向，下一个</span><br><span class="line">				N:跟搜索命令反方向</span><br></pre></td></tr></table></figure>

<p>常用选项</p>
<ul>
<li><p>列出所有帮助</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">man -a keyword</span><br></pre></td></tr></table></figure></li>
<li><p>搜索man手册</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有匹配的页面，使用 whatis 数据库</span></span><br><span class="line">man -k keyword   <span class="comment"># 相当于 whatis</span></span><br></pre></td></tr></table></figure></li>
<li><p>打印 man 帮助文件路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">man -w [章节] keyword</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><blockquote>
<p>man常用于命令参考，GNU工具info适合通用文档参考<br>没有参数，列出所有的页面<br>info 页面的结构就像一个网站<br>每一页分为“节点”<br>链接节点之前*</p>
</blockquote>
<p>info命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info [命令]</span><br></pre></td></tr></table></figure>

<p>导航info页</p>
<ul>
<li>方向键，Pgup,PgDn 导航</li>
<li>Tab键  移动到下一个链接</li>
<li>d  显示主题目录</li>
<li>Home     显示主题首部</li>
<li>Enter   进入选定链接</li>
<li>n/p/u/l   进入下/前/上一层/最后一个 链接</li>
<li>5 文字 文本搜索</li>
<li>q  退出 info</li>
</ul>
<p>命令自身提供的官方使用指南</p>
<p><code>/usr/share/doc</code>目录</p>
<blockquote>
<p>多数安装了的软件包的子目录，包括了这些软件的相关原理说明<br>常见文档：README  INSTALL  CHANGES<br>不适合其它地方的文档的位置<br>配置文件范例<br>HTML/PDF/PS  格式的文档<br>授权书详情</p>
</blockquote>
<h4 id="系统及第三方应用官方文档"><a href="#系统及第三方应用官方文档" class="headerlink" title="系统及第三方应用官方文档"></a>系统及第三方应用官方文档</h4><p>通过在线文档获取帮助</p>
<p><a href="http://www.github.com/">http://www.github.com</a></p>
<p><a href="https://www.kernel.org/doc/html/latest/">https://www.kernel.org/doc/html/latest/</a></p>
<p><a href="http://httpd.apache.org/">http://httpd.apache.org</a></p>
<p><a href="http://www.nginx.org/">http://www.nginx.org</a></p>
<p><a href="https://mariadb.com/kb/en">https://mariadb.com/kb/en</a></p>
<p><a href="https://dev.mysql.com/doc/">https://dev.mysql.com/doc/</a></p>
<p><a href="http://tomcat.apache.org/">http://tomcat.apache.org</a></p>
<p><a href="https://jenkins.io/zh/doc/">https://jenkins.io/zh/doc/</a></p>
<p><a href="https://kubernetes.io/docs/home/">https://kubernetes.io/docs/home/</a></p>
<p><a href="https://docs.openstack.org/train/">https://docs.openstack.org/train/</a></p>
<p><a href="http://wwwpython.org/">http://wwwpython.org</a></p>
<p><a href="http://php.net/">http://php.net</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>git基本教程</title>
    <url>/git%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>学习自菜鸟教程<a href="https://www.runoob.com/git/git-tutorial.html%EF%BC%8C%E6%9C%89%E4%BF%AE%E6%94%B9">https://www.runoob.com/git/git-tutorial.html，有修改</a></p>
<p>其它学习链接：<a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">http://marklodato.github.io/visual-git-guide/index-zh-cn.html</a></p>
<span id="more"></span>

<h3 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h3><p>Git 各平台安装包下载地址为：<a href="http://git-scm.com/downloads">http://git-scm.com/downloads</a></p>
<p><code>Ubuntu</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install git</span><br></pre></td></tr></table></figure>



<h3 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h3><p>Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。</p>
<p>这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<ul>
<li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。</li>
<li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</li>
<li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li>
</ul>
<p>在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 <code>C:\用户\你的用户名</code>。</p>
<p>此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p>
<h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>配置个人的用户名称和电子邮件地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;runoob&quot;</span></span><br><span class="line">$ git config --global user.email <span class="built_in">test</span>@runoob.com</span><br></pre></td></tr></table></figure>

<ul>
<li><code>user.name github的用户名</code></li>
<li><code>user.email github的注册邮箱</code> </li>
</ul>
<p>如果用了 <strong>–global</strong> 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。</p>
<p>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328155821836.png" alt="image-20220328155821836"></p>
<h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><p>要检查已有的配置信息，可以使用 git config –list 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">http.postbuffer=2M</span><br><span class="line">user.name=runoob</span><br><span class="line">user.email=test@runoob.com</span><br></pre></td></tr></table></figure>

<p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。</p>
<p>这些配置我们也可以在 <strong>~/.gitconfig</strong> 或 <strong>/etc/gitconfig</strong> 看到，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.gitconfig </span><br></pre></td></tr></table></figure>

<p>显示内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[http]</span><br><span class="line">    postBuffer = 2M</span><br><span class="line">[user]</span><br><span class="line">    name = runoob</span><br><span class="line">    email = test@runoob.com</span><br></pre></td></tr></table></figure>

<p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">runoob</span><br></pre></td></tr></table></figure>



<h3 id="工作区、index、HEAD"><a href="#工作区、index、HEAD" class="headerlink" title="工作区、index、HEAD"></a>工作区、index、HEAD</h3><ul>
<li><strong>工作区Work Space：</strong>就是你在电脑里能看到的目录。</li>
<li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li>
</ul>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220327192220570.png" alt="image-20220327192220570"></p>
<ul>
<li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。</li>
<li>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li>
<li>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</li>
<li>当对工作区修改（或新增）的文件执行 <strong>git add</strong> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li>
<li>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li>
<li>当执行 <strong>git reset HEAD</strong> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li>
<li>当执行 **git rm –cached ** 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li>
<li>当执行 <strong>git checkout .</strong> 或者 **git checkout – ** 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。</li>
<li>当执行 <strong>git checkout HEAD .</strong> 或者 **git checkout HEAD ** 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li>
</ul>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>使用当前目录作为 Git 仓库，我们只需使它初始化。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>该命令执行完后会在当前目录生成一个 <code>.git</code> 目录（是隐藏文件夹）。</p>
<p>使用我们指定目录作为Git仓库。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git init newrepo</span><br></pre></td></tr></table></figure>

<p>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p>
<h3 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h3><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 <code>git add</code> 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m <span class="string">&#x27;初始化项目版本&#x27;</span></span><br></pre></td></tr></table></figure>

<p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p>
<p><code>git add *</code> 把当前目录的所有文件和文件夹都添加到暂存区</p>
<p><strong>注：</strong> 在 Linux 系统中，commit 信息使用单引号 **’**，Windows 系统，commit 信息使用双引号 **”**。所以在 git bash 中 <strong>git commit -m ‘提交说明’</strong> 这样是可以的，在 Windows 命令行中就要使用双引号 **git commit -m “提交说明”**。</p>
<h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p><strong>克隆远端仓库</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo&gt;</span><br><span class="line">git <span class="built_in">clone</span> &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li>**repo:**Git 仓库，可以是远端仓库，也可以是本地仓库</li>
<li>**directory:**本地目录，目录可以不为空（最好是空目录），目录不存在会创建</li>
</ul>
<p><strong>示例：</strong></p>
<p>1、克隆远端仓库到<code>mytest</code>目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:yanglinqi107/LifeGame.git mytest </span><br></pre></td></tr></table></figure>

<p>2、克隆克隆远端仓库到当前目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/yanglinqi107/LifeGame.git</span><br></pre></td></tr></table></figure>

<p><strong>克隆本地仓库</strong>：同样是上面的命令<code>git clone &lt;repo&gt; &lt;directory&gt;</code></p>
<p>例：要将<code>E:\code</code>里面的所有文件克隆到另一个目录<code>mytest</code>中</p>
<p>法一：直接将<code>E:\code</code>里面的内容手动复制过去</p>
<p>法二：</p>
<ul>
<li>1）将<code>E:\code</code>设为仓库<code>git init E:/code</code></li>
<li>2）将<code>E:\code</code>的所有文件添加到暂存区 <code>git add *</code></li>
<li>3）将暂存区的所有文件添加到HEAD <code>git commit -m &quot;本地克隆测试&quot;</code></li>
<li>4）将<code>E:\code</code>克隆过去 <code>git clone e:/code mytest</code> </li>
<li>注意：前3步必要，不然克隆不过去</li>
</ul>
<h3 id="git基本操作"><a href="#git基本操作" class="headerlink" title="git基本操作"></a>git基本操作</h3><p>Git 常用的是以下 6 个命令：<strong>git clone</strong>、<strong>git push</strong>、<strong>git add</strong> 、<strong>git commit</strong>、<strong>git checkout</strong>、<strong>git pull</strong>。</p>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220327210917927.png" alt="image-20220327210917927"></p>
<p><strong>说明：</strong></p>
<ul>
<li>workspace：工作区</li>
<li>staging area：暂存区/缓存区</li>
<li>local repository：版本库或本地仓库</li>
<li>remote repository：远程仓库</li>
</ul>
<p>一个简单的操作步骤：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init    </span><br><span class="line">$ git add .    </span><br><span class="line">$ git commit  </span><br></pre></td></tr></table></figure>

<ul>
<li>git init - 初始化仓库。</li>
<li>git add . - 添加文件到暂存区。</li>
<li>git commit - 将暂存区内容添加到仓库中。</li>
</ul>
<h4 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h4><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p>
<p>下表列出了有关创建与提交你的项目的快照的命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git add</code></td>
<td align="left">添加文件到暂存区</td>
</tr>
<tr>
<td align="left"><code>git status</code></td>
<td align="left">查看仓库当前的状态，显示有变更的文件。</td>
</tr>
<tr>
<td align="left"><code>git diff</code></td>
<td align="left">比较文件的不同，即暂存区和工作区的差异。</td>
</tr>
<tr>
<td align="left"><code>git commit</code></td>
<td align="left">提交暂存区到本地仓库。</td>
</tr>
<tr>
<td align="left"><code>git reset</code></td>
<td align="left">回退版本。</td>
</tr>
<tr>
<td align="left"><code>git rm</code></td>
<td align="left">删除工作区文件。</td>
</tr>
<tr>
<td align="left"><code>git mv</code></td>
<td align="left">移动或重命名工作区文件。</td>
</tr>
</tbody></table>
<h4 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h4><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git log</code></td>
<td align="left">查看历史提交记录</td>
</tr>
<tr>
<td align="left"><code>git blame </code></td>
<td align="left">以列表形式查看指定文件的历史修改记录</td>
</tr>
</tbody></table>
<h4 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h4><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git remote</code></td>
<td align="left">远程仓库操作</td>
</tr>
<tr>
<td align="left"><code>git fetch</code></td>
<td align="left">从远程获取代码库</td>
</tr>
<tr>
<td align="left"><code>git pull</code></td>
<td align="left">下载远程代码并合并</td>
</tr>
<tr>
<td align="left"><code>git push</code></td>
<td align="left">上传远程代码并合并</td>
</tr>
</tbody></table>
<h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h4><p>添加一个或多个文件到暂存区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<p>添加指定目录到暂存区，包括子目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add [dir]</span><br></pre></td></tr></table></figure>

<p>添加当前目录下的所有文件到暂存区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>可以使用<code>git status</code>或<code>git status -s</code>查看状态</p>
<h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ touch 测试5.txt</span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ touch 测试6.txt</span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git status -s</span><br><span class="line">A  <span class="string">&quot;\346\265\213\350\257\2255.txt&quot;</span>  <span class="comment"># 这是乱码，看最后的5和6</span></span><br><span class="line">A  <span class="string">&quot;\346\265\213\350\257\2256.txt&quot;</span></span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        new file:   <span class="string">&quot;\346\265\213\350\257\2255.txt&quot;</span></span><br><span class="line">        new file:   <span class="string">&quot;\346\265\213\350\257\2256.txt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ vi 测试6.txt   <span class="comment"># 修改 测试6.txt 文件，也可以外部修改</span></span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git status -s</span><br><span class="line">A  <span class="string">&quot;\346\265\213\350\257\2255.txt&quot;</span></span><br><span class="line">AM <span class="string">&quot;\346\265\213\350\257\2256.txt&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>AM</strong> 状态的意思是这个文件在我们将它添加到缓存之后又有改动。改动后我们再执行 <strong>git add .</strong> 命令将其添加到缓存中。</p>
<h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><p>git diff 命令比较文件的不同，即比较文件在暂存区和工作区的差异。</p>
<p>git diff 命令显示已写入暂存区和已经被修改但尚未写入暂存区文件的区别。</p>
<p>git diff 有两个主要的应用场景。</p>
<ul>
<li>尚未缓存的改动（工作区和暂存区）：<strong>git diff</strong></li>
<li>查看已缓存的改动（暂存区和版本库）： <strong>git diff –cached</strong></li>
<li>查看已缓存的与未缓存的所有改动：<strong>git diff HEAD</strong></li>
<li>显示摘要而非整个 diff：<strong>git diff –stat</strong></li>
</ul>
<p><strong>显示暂存区和工作区的差异:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff [file]</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong>在<code>测试6.txt</code>文件中追加内容，并和暂存区的<code>测试6.txt</code>比较</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ vi 测试6.txt   </span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git diff 测试6.txt</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> 测试6.txt.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line">diff --git a/测试6.txt b/测试6.txt</span><br><span class="line">index e69de29..ecb7222 100644</span><br><span class="line">--- a/测试6.txt</span><br><span class="line">+++ b/测试6.txt</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+这是测试</span><br><span class="line">+git diff 测试</span><br></pre></td></tr></table></figure>

<p><strong>显示暂存区和上一次提交(commit)的差异:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git diff --cached [file]</span><br><span class="line">或</span><br><span class="line">$ git diff --staged [file]</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong>将修改后的<code>测试6.txt</code>检入暂存区，并和HEAD的<code>测试6.txt</code>比较</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git add .</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> 测试6.txt.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git diff --cached</span><br><span class="line">diff --git a/测试5.txt b/测试5.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..e69de29</span><br><span class="line">diff --git a/测试6.txt b/测试6.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..265e175</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/测试6.txt</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+这是测试</span><br><span class="line">+git diff --cached 测试</span><br></pre></td></tr></table></figure>

<p><strong>显示两次提交之间的差异:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git diff [first-branch]...[second-branch]</span><br></pre></td></tr></table></figure>



<h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h4><p>git commit 命令将暂存区内容添加到本地仓库中。</p>
<p>提交暂存区到本地仓库中:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m [message]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>message</code>现在是必要的，可以写一些备注信息，如<code>git commit -m &quot;这是依次测试&quot;</code> </li>
</ul>
<p>提交暂存区的指定文件到仓库区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br></pre></td></tr></table></figure>

<p><strong>-a</strong> 参数设置修改文件后不需要执行 git add 命令，直接来提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -a</span><br></pre></td></tr></table></figure>

<p>暂存区的文件全部提交后，使用<code>git status</code>查看显示<code>working tree clean</code> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p><strong>设置提交代码时的用户信息</strong>：</p>
<p>开始前我们需要先设置提交的用户信息，包括用户名和邮箱：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &#x27;runoob&#x27;</span><br><span class="line">$ git config --global user.email test@runoob.com</span><br></pre></td></tr></table></figure>

<ul>
<li><font color="#ff0000">如果去掉 –global 参数只对当前仓库有效</font></li>
</ul>
<h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><p><code>git rese</code>t 命令用于回退版本，可以指定退回某一次提交的版本。</p>
<p><code>git reset</code> 命令语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset [--soft | --mixed | --hard] [HEAD]</span><br></pre></td></tr></table></figure>

<p>1、**–mixed** 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，<strong>工作区文件内容保持不变</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset [HEAD] </span><br></pre></td></tr></table></figure>

<p><font color="#ff0000">注意：直接使用<code>git reset HEAD</code>或<code>git reset</code><strong>版本库并不会回退</strong></font></p>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD^            <span class="comment"># 回退所有内容到上一个版本  </span></span><br><span class="line">$ git reset HEAD^ hello.php  <span class="comment"># 回退 hello.php 文件的版本到上一个版本  </span></span><br><span class="line">$ git reset 052e             <span class="comment"># 回退到指定版本</span></span><br></pre></td></tr></table></figure>

<p>2、**–soft** 参数用于<strong>回退到某个版本</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --soft HEAD~3 <span class="comment"># 回退上上上一个版本</span></span><br></pre></td></tr></table></figure>

<p>3、**–hard** 参数<strong>撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本</strong>，并删除之前的所有信息提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset –hard HEAD~3  <span class="comment"># 回退上上上一个版本  </span></span><br><span class="line">$ git reset –hard bae128  <span class="comment"># 回退到某个版本回退点之前的所有信息。 </span></span><br><span class="line">$ git reset --hard origin/master    <span class="comment"># 将本地的状态回退到和远程的一样</span></span><br></pre></td></tr></table></figure>

<p><font color="#ff0000"><strong>注意：</strong>谨慎使用 –hard 参数，它会删除回退点之前的所有信息</font></p>
<p>4、<strong>HEAD 说明：</strong></p>
<ul>
<li>HEAD 表示当前版本</li>
<li>HEAD^ 上一个版本</li>
<li>HEAD^^ 上上一个版本</li>
<li>HEAD^^^ 上上上一个版本</li>
<li>以此类推…</li>
</ul>
<p>可以使用 ～数字表示</p>
<ul>
<li>HEAD~0 表示当前版本</li>
<li>HEAD~1 上一个版本</li>
<li>HEAD^2 上上一个版本</li>
<li>HEAD^3 上上上一个版本</li>
<li>以此类推…</li>
</ul>
<p>5、<strong>git reset HEAD 或 git reset</strong>：用于取消已缓存的内容。（?暂存区）</p>
<p>使用<code>git reset</code>或<code>git reset HEAD</code>会将暂存区的内容清除</p>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328135315448.png" alt="image-20220328135315448"></p>
<p><strong>实例：</strong>1）创建目录<code>e:/git</code>并初始化为仓库，创建<code>test1.txt</code></p>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328121119244.png" alt="image-20220328121119244"></p>
<p>2）track和commit <code>test1.txt</code> 到版本库</p>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328121228020.png" alt="image-20220328121228020"></p>
<p>3）同样的步骤提交 <code>test2.txt</code>到版本库</p>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328121325131.png" alt="image-20220328121325131"></p>
<p>4）当前版本库有<code>test1.txt,test2.txt</code>两个文件，回退上一版本有<code>test1.txt</code>一个文件；回退后克隆当前版本库至<code>test3</code>文件夹，可以看到确实只有<code>test1.txt</code>一个文件</p>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328133821034.png" alt="image-20220328133821034"></p>
<h4 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h4><p>git rm 命令用于删除文件</p>
<p>1、如果工作目录有文件<code>A</code>添加到<strong>暂存区</strong>（没有add的话直接手动删除），再<strong>手工删除</strong>文件<code>A</code>的话，运行 <strong>git status</strong> 时就会在 <strong>Changes not staged for commit</strong> 的提示，但是我测试<code>commit</code>是成功的</p>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328140517067.png" alt="image-20220328140517067"></p>
<p>2、**<code>git rm &lt;file&gt;</code>** 将文件从暂存区和工作区中删除</p>
<p>如果文件<code>A</code>在暂存区后，<code>A</code>修改过且再<code>git add</code>更新暂存区，需要使用<code>git rm -f A</code>来删除工作区和暂存区的文件<code>A</code></p>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328141440592.png" alt="image-20220328141440592"></p>
<p>3、如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <strong>–cached</strong> 选项即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;file&gt;</span><br></pre></td></tr></table></figure>



<h4 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h4><p>git mv 命令用于移动或重命名一个文件、目录或软连接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git mv [file] [newfile]</span><br></pre></td></tr></table></figure>

<ul>
<li>注：源文件<code>file</code>必须add到版本控制中才能使用<code>git mv</code> </li>
</ul>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328143028516.png" alt="image-20220328143028516"></p>
<p>如果新文件名已经存在，但还是要重命名它，可以使用 <strong>-f</strong> 参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git mv -f [file] [newfile]  <span class="comment"># file同样要add到暂存区</span></span><br></pre></td></tr></table></figure>

<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328143955435.png" alt="image-20220328143955435"></p>
<h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><p><code>git log</code>：查看历史提交记录</p>
<img src="/git%E5%85%A5%E9%97%A8/image-20220328144805666.png" alt="image-20220328144805666" style="zoom:80%;">

<p><strong><code>--oneline</code></strong> 选项来查看历史记录的简洁的版本</p>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328144906544.png" alt="image-20220328144906544"></p>
<p><strong><code>--graph</code></strong> 选项，查看历史中什么时候出现了分支、合并</p>
<img src="/git%E5%85%A5%E9%97%A8/image-20220328145011081.png" alt="image-20220328145011081" style="zoom: 80%;">

<p><strong><code>--reverse</code></strong> 参数来逆向显示所有日志</p>
<img src="/git%E5%85%A5%E9%97%A8/image-20220328145108643.png" alt="image-20220328145108643" style="zoom:80%;">



<ul>
<li><p>如果只想查找指定用户的提交日志可以使用命令：**<code>git log --author</code> **， 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p>
</li>
<li><p>```<br>$ git log –author=Linus –oneline -5<br>81b50f3 Move ‘builtin-*’ into a ‘builtin/‘ subdirectory<br>3bb7256 make “index-pack” a built-in<br>377d027 make “git pack-redundant” a built-in<br>b532581 make “git unpack-file” a built-in<br>112dd51 make “mktag” a built-in</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 如果你要指定日期，可以执行几个选项：`--since` 和 `--before`，但是你也可以用 `--until` 和 `--after`。</span><br><span class="line"></span><br><span class="line">- 例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 `--no-merges`选项以隐藏合并提交）：</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  $ git log --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges</span><br><span class="line">  5469e2d Git 1.7.1-rc2</span><br><span class="line">  d43427d Documentation/remote-helpers: Fix typos and improve language</span><br><span class="line">  272a36b Fixup: Second argument may be any arbitrary string</span><br><span class="line">  b6c8d2d Documentation/remote-helpers: Add invocation section</span><br><span class="line">  5ce4f4e Documentation/urls: Rewrite to accomodate transport::address</span><br><span class="line">  00b84e9 Documentation/remote-helpers: Rewrite description</span><br><span class="line">  03aa87e Documentation: Describe other situations where -z affects git diff</span><br><span class="line">  77bc694 rebase-interactive: silence warning when no commits rewritten</span><br><span class="line">  636db2c t3301: add tests to use --format=&quot;%N&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><h3 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h3></li>
<li><p>如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：</p>
</li>
<li><p>```<br>git blame <file></file></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- git blame 命令是以列表形式显示修改记录，如下实例：</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  $ git blame README </span><br><span class="line">  ^d2097aa (tianqixin 2020-08-25 14:59:25 +0800 1) # Runoob Git 测试</span><br><span class="line">  db9315b0 (runoob    2020-08-25 16:00:23 +0800 2) # 菜鸟教程 </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h4><p>显示所有远程仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">或</span><br><span class="line">git remote</span><br></pre></td></tr></table></figure>

<p>添加远程版本库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com yourname/yourRepo</span><br></pre></td></tr></table></figure>

<ul>
<li><code>origin</code>为远程地址的别名</li>
</ul>
<p>显示某个远程仓库的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show [remote]</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">git remote show https://github.com/tianqixin/runoob-git-test</span><br><span class="line">git remote show origin</span><br></pre></td></tr></table></figure>

<p>删除和远程仓库的连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm repo_name</span><br></pre></td></tr></table></figure>

<p>修改仓库别名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rename old_name new_name</span><br></pre></td></tr></table></figure>



<h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p><strong>git pull</strong> 命令用于从远程获取代码并合并本地的版本。</p>
<p><strong>git pull</strong> 其实就是 <strong>git fetch</strong> 和 <strong>git merge FETCH_HEAD</strong> 的简写。 命令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong>：</p>
<p>将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin master:brantest</span><br></pre></td></tr></table></figure>

<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<p>上面命令表示，取回 origin/master 分支，再与本地的 brantest 分支合并。</p>
<h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><p><strong>git push</strong> 命用于从将本地的分支版本上传到远程并合并。</p>
<p>命令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>

<p>如果本地分支名与远程分支名相同，则可以省略冒号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>

<p>如果本地版本与远程版本有差异，但又要强制推送可以使用 –force 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure>

<p>删除远程仓库的分支：使用 –delete 参数，以下命令表示删除 origin 主机的 master 分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin --delete master</span><br></pre></td></tr></table></figure>

<ul>
<li>如果github仓库只有<code>master</code>分支，删除不了</li>
</ul>
<h3 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h3><p><strong>管理的是仓库本地分支</strong></p>
<p>1、<strong>创建分支命令：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch branch_name</span><br></pre></td></tr></table></figure>

<p>2、<strong>切换分支命令:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout branchname</span><br></pre></td></tr></table></figure>

<ul>
<li>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支<strong>不需要多个目录</strong>。</li>
<li>当前分支下文件有修改但没<code>commit</code>时，切换分支会失败，除了创建新分支切换</li>
</ul>
<p>3、<strong>合并分支命令:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge </span><br></pre></td></tr></table></figure>

<ul>
<li>可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支</li>
</ul>
<p>4、<strong>列出分支：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p><strong>创建分支实例：</strong></p>
<p>手动创建一个分支<code>testing</code> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch testing</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>

<p>如你所见，我们创建了一个分支，在该分支上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。</p>
<p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">README</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;runoob.com&#x27;</span> &gt; test.txt</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&#x27;add test.txt&#x27;</span></span><br><span class="line">[master 3e92c19] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br><span class="line">$ git checkout testing</span><br><span class="line">Switched to branch <span class="string">&#x27;testing&#x27;</span></span><br><span class="line">$ ls</span><br><span class="line">README</span><br></pre></td></tr></table></figure>

<p>当我们切换到 <strong>testing</strong> 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 <strong>master</strong> 分支的时候，它们又重新出现了。</p>
<p><font color="#ff0000"><strong>注意：分支关系测试（不仅仅是这样，有点问题）</strong></font></p>
<ul>
<li>若在分支<code>A</code>创建分支<code>B</code>，则相当于将分支<code>A</code>复制了一份成分支<code>B</code>，即分支<code>A</code>和<code>B</code>的HEAD一样。</li>
<li>所有分支共享<strong>工作区</strong>和<strong>暂存区</strong>，但当某个工作区的文件<code>f1</code>添加到分支<code>A</code>中后，其它分支就看不到该文件了</li>
</ul>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328192446225.png" alt="image-20220328192446225"></p>
<p><strong>实操：</strong></p>
<img src="/git%E5%85%A5%E9%97%A8/image-20220328193248453.png" alt="image-20220328193248453" style="zoom:80%;">

<img src="/git%E5%85%A5%E9%97%A8/image-20220328193946293.png" alt="image-20220328193946293" style="zoom:80%;">

<img src="/git%E5%85%A5%E9%97%A8/image-20220328194338923.png" alt="image-20220328194338923" style="zoom:80%;">

<p>5、<strong>创建新分支并切换</strong> <code>git checkout -b branch_name</code></p>
<p>6、<strong>删除分支</strong>：在<code>A</code>分支下不能删除<code>A</code>分支，必须先切换到其它分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d branch_name</span><br><span class="line">或</span><br><span class="line">git branch -D branch_name</span><br></pre></td></tr></table></figure>

<p>7、<strong>分支合并</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge branch_name</span><br></pre></td></tr></table></figure>

<ul>
<li>不能合并没有历史关系的分支 <code>fatal: refusing to merge unrelated histories</code></li>
</ul>
<p>8、<strong>合并冲突</strong>：</p>
<p>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改</p>
<ul>
<li>1）冲突要手动修改 </li>
<li>2）修改后要<code>add</code>和<code>commit</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ vi test2_t.txt   <span class="comment"># 修改test2_t.txt文件</span></span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git checkout test2 <span class="comment"># 切换已存在的分支test2报错，提示修改的内容未commit</span></span><br><span class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by checkout:</span><br><span class="line">        test2_t.txt</span><br><span class="line">Please commit your changes or stash them before you switch branches.</span><br><span class="line">Aborting</span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git checkout -b test3  <span class="comment"># 新建分支test3并切换，没有问题</span></span><br><span class="line">Switched to a new branch <span class="string">&#x27;test3&#x27;</span></span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (test3)</span><br><span class="line">$ cat test2_t.txt  <span class="comment"># 查看test2_t.txt的内容</span></span><br><span class="line">这是master下的修改</span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (test3)</span><br><span class="line">$ git commit -am <span class="string">&quot;test3&quot;</span>   <span class="comment"># 将test2_t.txt提交到test3分支中</span></span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> test2_t.txt.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line">[test3 077c5d7] test3</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (test3)</span><br><span class="line">$ git checkout master    <span class="comment"># 切换回master分支</span></span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ ls                   <span class="comment"># 目录下test2_t.txt还存在，？</span></span><br><span class="line">test1.txt  test10.txt  test2.txt  test2_t.txt  test3.txt</span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ cat test2_t.txt          <span class="comment"># 但test2_t.txt回到修改前</span></span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ vi test2_t.txt，         <span class="comment"># 修改test2_t.txt，   这是master下第2次修改</span></span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git commit -am <span class="string">&quot;master&quot;</span>         <span class="comment"># 将test2_t.txt提交到master分支中</span></span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> test2_t.txt.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line">[master 43b7ee7] master</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git merge test3       <span class="comment"># 合并test3分支，发生冲突</span></span><br><span class="line">Auto-merging test2_t.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> test2_t.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master|MERGING)</span><br><span class="line">$ cat test2_t.txt                <span class="comment"># 查看test2_t.txt文件</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">这是master下第2次修改</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">这是master下的修改</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; test3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">MLZ107@YangLinQi MINGW64 /e/git (master|MERGING)</span></span><br><span class="line"><span class="string">$ vi test2_t.txt             # 需要手动去修改</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">MLZ107@YangLinQi MINGW64 /e/git (master|MERGING)</span></span><br><span class="line"><span class="string">$ cat test2_t.txt            # 例子就随便改改</span></span><br><span class="line"><span class="string">这是master下第2次修改</span></span><br><span class="line"><span class="string">这是master下的修改</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">最后再add和commit</span></span><br></pre></td></tr></table></figure>



<h3 id="git-标签"><a href="#git-标签" class="headerlink" title="git 标签"></a>git 标签</h3><p>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。</p>
<p><strong>添加标签</strong></p>
<p>比如说，我们想为我们的 runoob 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。</p>
<p><strong>-a</strong> 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.0 </span><br></pre></td></tr></table></figure>

<p>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p>
<p>使用<code>git log --oneline --decorate --graph</code>命令查看，可以看到标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git <span class="built_in">log</span> --oneline --decorate --graph</span><br><span class="line">*   6098fd1 (HEAD -&gt; master, tag: v1.0) Merge branch <span class="string">&#x27;test3&#x27;</span></span><br><span class="line">|\</span><br><span class="line">| * 077c5d7 (test3) test3</span><br><span class="line">* | 43b7ee7 master</span><br><span class="line">|/</span><br><span class="line">* dca4fd6 test2_t.txt</span><br><span class="line">* b3d9b43 (origin/test2, origin/master, test2) Update test1.txt</span><br><span class="line">* 4c190bd Update test1.txt</span><br><span class="line">* 0f31cba 删除提交测试</span><br><span class="line">* 2c81853 第3次commit</span><br><span class="line">* c16838a 第1次commit</span><br></pre></td></tr></table></figure>

<p><strong>追加标签</strong>：如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</p>
<p>例如，我们要给上例<code>dca4fd6</code>追加标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git tag -a v0.9 dca4fd6</span><br><span class="line"></span><br><span class="line">MLZ107@YangLinQi MINGW64 /e/git (master)</span><br><span class="line">$ git <span class="built_in">log</span> --decorate --graph --oneline</span><br><span class="line">*   6098fd1 (HEAD -&gt; master, tag: v1.0) Merge branch <span class="string">&#x27;test3&#x27;</span></span><br><span class="line">|\</span><br><span class="line">| * 077c5d7 (test3) test3</span><br><span class="line">* | 43b7ee7 master</span><br><span class="line">|/</span><br><span class="line">* dca4fd6 (tag: v0.9) test2_t.txt</span><br><span class="line">* b3d9b43 (origin/test2, origin/master, test2) Update test1.txt</span><br><span class="line">* 4c190bd Update test1.txt</span><br><span class="line">* 0f31cba 删除提交测试</span><br><span class="line">* 2c81853 第3次commit</span><br><span class="line">* c16838a 第1次commit</span><br></pre></td></tr></table></figure>

<p><strong>查看所有标签</strong>：<code>git tag</code></p>
<p><strong>删除便签：</strong><code>git tag -d v1.0</code></p>
<p><strong>查看此版本所修改的内容：</strong><code>git show v1.0</code> </p>
<p><strong>指定标签信息命令：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m &quot;runoob.com标签&quot;</span><br></pre></td></tr></table></figure>

<p><strong>PGP签名标签命令：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -s &lt;tagname&gt; -m &quot;runoob.com标签&quot;</span><br></pre></td></tr></table></figure>











<h3 id="git-status出现乱码"><a href="#git-status出现乱码" class="headerlink" title="git status出现乱码"></a>git status出现乱码</h3><p><a href="https://blog.csdn.net/u012145252/article/details/81775362">git status 显示中文和解决中文乱码_铁乐与猫的博客-CSDN博客_git status 中文乱码</a></p>
<p><a href="https://mounui.com/186.html">git status中文文件名乱码 | 木凡博客 (mounui.com)</a></p>
<h3 id="git帮助"><a href="#git帮助" class="headerlink" title="git帮助"></a>git帮助</h3><p><code>D:xxxx\Git\mingw64\share\doc\git-doc</code> 在<code>git</code>安装路径下有html类型的帮助文档</p>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328114745391.png" alt="image-20220328114745391"></p>
<p>也可以使用<code>--help</code>打开，如<code>git reset --help</code>，但是是<strong>纯英文</strong>的，看的好难受</p>
<h3 id="Git和Github"><a href="#Git和Github" class="headerlink" title="Git和Github"></a>Git和Github</h3><p>由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：</p>
<p>在本地创建<code>SSH Key</code>；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your_email@youremail.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>后面的<code>your_email@youremail.com</code>改为你在github上注册的邮箱，之后会要求确认路径和输入密码，我们这<strong>使用默认的一路回车就行</strong>。成功的话会在<code>~/</code>下生成<code>.ssh</code>文件夹，进去，打开<code>id_rsa.pub</code>，复制里面的<code>key</code>。（Windows路径：<code>C:\用户\自己的用户名\.ssh</code>）</p>
<p>回到github上，进入 <code>Settings</code>（账户配置），左边选择<code>SSH and GPG keys</code>，右边：<code>New SSH key</code>，title随便填，粘贴在你电脑上生成的key。</p>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328153809005.png" alt="image-20220328153809005"></p>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328153927384.png" alt="image-20220328153927384"></p>
<p>为了验证是否成功，在<code>git bash</code>下输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>如果是第一次的会提示是否<code>continue</code>，输入<code>yes</code>就会看到：<code>You&#39;ve successfully authenticated, but GitHub does not provide shell access</code> 。这就表示已成功连上github。</p>
<p>接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置<code>username</code>和<code>email</code>，因为<code>github</code>每次<code>commit</code>都会记录他们。</p>
<p>进入要上传的仓库，右键<code>git bash</code>，添加远程地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:yourName/yourRepo.git</span><br></pre></td></tr></table></figure>

<p>后面的<code>yourName</code>和<code>yourRepo</code>表示你在github的用户名和刚才新建的仓库，加完之后进入<code>.git</code>，打开<code>config</code>，这里会多出一个remote “origin”内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。</p>
<p><img src="/git%E5%85%A5%E9%97%A8/image-20220328160158267.png" alt="image-20220328160158267"></p>
<p>然后的一般流程就是</p>
<ul>
<li><code>git add .</code> 将所有文件添加到暂存区</li>
<li><code>git commit -m &quot;这是一次提交测试&quot;</code> 将改动添加到HEAD本地版本库</li>
<li><code>git push  origin master</code>  推送到github上，<code>master</code>是分支，可以换成别的分支（其它分支要先创建）</li>
</ul>
<h3 id="查看当前的远程库"><a href="#查看当前的远程库" class="headerlink" title="查看当前的远程库"></a>查看当前的远程库</h3><p>要查看当前配置有哪些远程仓库，可以用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:yanglinqi107/<span class="built_in">test</span> (fetch)</span><br><span class="line">origin  git@github.com:yanglinqi107/<span class="built_in">test</span> (push)</span><br></pre></td></tr></table></figure>

<ul>
<li>执行时加上 -v 参数，你还可以看到每个别名的实际链接地址</li>
</ul>
<h3 id="提取远程仓库"><a href="#提取远程仓库" class="headerlink" title="提取远程仓库"></a>提取远程仓库</h3><p>Git 有两个命令用来提取远程仓库的更新。</p>
<p>1、从远程仓库下载新分支与数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch [alias]</span><br></pre></td></tr></table></figure>

<p>该命令执行完后需要执行 git merge 远程分支到你所在的分支。</p>
<p>2、从远端仓库提取数据并尝试合并到当前分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge [alias]/[branch]</span><br></pre></td></tr></table></figure>

<ul>
<li>该命令就是在执行 <strong>git fetch</strong> 之后紧接着执行 <strong>git merge</strong> 远程分支到你所在的任意分支</li>
</ul>
<p>补充：</p>
<ul>
<li>执行 <code>git fetch origin master</code> 时，它的意思是从名为 <strong>origin</strong> 的远程上拉取名为 <strong>master</strong> 的分支到本地分支 <strong>origin/master</strong> 中。既然是拉取代码，当然需要同时指定远程名与分支名，所以分开写。</li>
<li>执行 <code>git merge origin/master</code> 时，它的意思是合并名为 <strong>origin/master</strong> 的分支到当前所在分支。既然是分支的合并，当然就与远程名没有直接的关系，所以没有出现远程名。需要指定的是被合并的分支。</li>
<li>执行 <code>git push origin master</code> 时，它的意思是推送本地的 <strong>master</strong> 分支到远程 <strong>origin</strong>，涉及到远程以及分支，当然也得分开写了。</li>
<li>还可以一次性拉取多个分支的代码：<code>git fetch origin master stable oldstable</code>；</li>
<li>也还可以一次性合并多个分支的代码：<code>git merge origin/master hotfix-2275 hotfix-2276 hotfix-2290</code></li>
</ul>
<h3 id="删除远程仓库"><a href="#删除远程仓库" class="headerlink" title="删除远程仓库"></a>删除远程仓库</h3><p>删除远程仓库你可以使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm [别名]</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong>：<code>github</code>上的仓库并不会被删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加仓库 origin2</span></span><br><span class="line">$ git remote add origin2 git@github.com:tianqixin/runoob-git-test.git</span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br><span class="line">origin2    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin2    git@github.com:tianqixin/runoob-git-test.git (push)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除仓库 origin2</span></span><br><span class="line">$ git remote rm origin2</span><br><span class="line">$ git remote -v</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br></pre></td></tr></table></figure>



<h3 id="Git和Gitee"><a href="#Git和Gitee" class="headerlink" title="Git和Gitee"></a>Git和Gitee</h3><p>国内访问 Github 速度比较慢，使用国内的 Git 托管服务———<a href="https://gitee.com/?utm_source=remote_blog_cnjc">Gitee（gitee.com）</a>。</p>
<p><strong>1、我们先在 <a href="https://gitee.com/?utm_source=remote_blog_cnjc">Gitee</a> 上注册账号并登录后，然后上传自己的 SSH 公钥</strong></p>
<p>设置-》SSH公钥-》将之前生成的SSH公钥<code>~/.ssh/id_rsa.pub</code>粘贴上去</p>
<p><strong>2、验证是否能成功访问</strong> <code>ssh -T git@gitee.com</code> 和连接github的操作差不多</p>
<p><strong>3、在Gitee上创建仓库，复制SSH链接</strong></p>
<p><strong>4、将本地仓库和远程库连接</strong></p>
<ul>
<li><p>在本地库上使用命令 <strong>git remote add</strong> 把它和 Gitee 的远程库关联：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:imnoob/runoob-test.git</span><br></pre></td></tr></table></figure></li>
<li><p>在使用命令 <code>git remote add</code> 时报错 <code>fatal: remote origin already exists.</code></p>
</li>
<li><p>说明本地库已经关联了一个名叫 origin 的远程库，可以先用 <code>git remote -v</code> 查看远程库信息</p>
</li>
<li><p>可以先删除已有的远程库连接 <code>git remote rm origin</code> </p>
</li>
</ul>
<p><strong>5、进行推送文件测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch README.md</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>



<h3 id="关联多个远程库"><a href="#关联多个远程库" class="headerlink" title="关联多个远程库"></a>关联多个远程库</h3><p>Q：一个本地库能不能既关联 GitHub，又关联 Gitee 呢？</p>
<p>A：可以，因为 git 本身是分布式版本控制系统</p>
<p>使用多个远程库时，git 给远程库起的默认名称是 <code>origin</code>，如果有多个远程库，我们需要用<strong>不同的名称来标识不同的远程库</strong>。</p>
<p>1、关联 GitHub 的远程库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add github git@github.com:tianqixin/runoob-git-test.git</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，远程库的名称叫 <code>github</code>，不叫 <code>origin </code>了</li>
</ul>
<p>2、关联 Gitee 的远程库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add gitee git@gitee.com:imnoob/runoob-test.git</span><br></pre></td></tr></table></figure>

<ul>
<li>远程库的名称叫 <code>gitee</code>，不叫 <code>origin</code></li>
</ul>
<p>3、验证是否连接成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">ssh -T git@gitee.com</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p><strong>推送：</strong></p>
<p>推送到 GitHub，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></table></figure>

<p>推送到 Gitee，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push gitee master</span><br></pre></td></tr></table></figure>

<p><img src="/git%E5%85%A5%E9%97%A8/image-20220329113937775.png" alt="image-20220329113937775"></p>
<h3 id="Git服务器搭建"><a href="#Git服务器搭建" class="headerlink" title="Git服务器搭建"></a>Git服务器搭建</h3><p>菜鸟教程Git服务器搭建<a href="https://www.runoob.com/git/git-server.html">https://www.runoob.com/git/git-server.html</a></p>
<p>前置条件：一台服务器，没有服务器在电脑上用虚拟机安装Centos或Ubuntu来试一下</p>
<p>1、在Centos安装git，然后创建一个git用户组和用户，用来运行git服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel</span><br><span class="line">$ yum install git</span><br><span class="line"></span><br><span class="line">$ groupadd git  <span class="comment"># 创建用户组git</span></span><br><span class="line">$ useradd git -g git   <span class="comment"># Ubuntu： useradd -m git </span></span><br></pre></td></tr></table></figure>

<p>2、创建证书登录</p>
<p>收集所有需要登录的用户的公钥，公钥位于<code>id_rsa.pub</code>文件中，把我们的公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p>
<p>如果没有该文件创建它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home/git/ </span><br><span class="line">$ mkdir .ssh             <span class="comment"># 创建.ssh文件夹，linux中 . 开头的文件夹是隐藏文件</span></span><br><span class="line">$ chmod 755 .ssh          <span class="comment"># 赋予权限 rwxr-xr-x</span></span><br><span class="line">$ touch .ssh/authorized_keys       <span class="comment"># 创建文件</span></span><br><span class="line">$ chmod 644 .ssh/authorized_keys    <span class="comment"># 赋予权限</span></span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>：</p>
<img src="/git%E5%85%A5%E9%97%A8/image-20220329145611237.png" alt="image-20220329145611237" style="zoom:80%;">

<img src="/git%E5%85%A5%E9%97%A8/image-20220329145908985.png" alt="image-20220329145908985" style="zoom:80%;">



<p>3、初始化Git仓库</p>
<p>首先我们选定一个目录作为Git仓库，假定是<code>/home/gitrepo/runoob.git</code>，在<code>/home/gitrepo</code>目录下输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home        </span><br><span class="line">$ mkdir gitrepo        <span class="comment"># 创建gitrepo文件夹</span></span><br><span class="line">$ chown git:git gitrepo/    <span class="comment"># 设置 gitrepo 的 属主 为用户组git的用户git</span></span><br><span class="line">$ <span class="built_in">cd</span> gitrepo              </span><br><span class="line">$ git init --bare runoob.git   <span class="comment"># 创建一个裸库 runoob.git</span></span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/gitrepo/runoob.git/</span><br></pre></td></tr></table></figure>

<p>服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chown -R git:git runoob.git</span><br></pre></td></tr></table></figure>

<img src="/git%E5%85%A5%E9%97%A8/image-20220329142903738.png" alt="image-20220329142903738" style="zoom:80%;">

<p>4、克隆仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@192.168.45.4:/home/gitrepo/runoob.git</span><br><span class="line">Cloning into <span class="string">&#x27;runoob&#x27;</span>...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>

<p><code>192.168.45.4</code> 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。这样我们的 Git 服务器安装就完成。</p>
<p><strong>示例：</strong></p>
<img src="/git%E5%85%A5%E9%97%A8/image-20220329150319147.png" alt="image-20220329150319147" style="zoom:80%;">

<p><img src="/git%E5%85%A5%E9%97%A8/image-20220329150745566.png" alt="image-20220329150745566"></p>
<img src="/git%E5%85%A5%E9%97%A8/image-20220329152319559.png" alt="image-20220329152319559" style="zoom:80%;">



<p>注：使用 <code>--bare</code> 参数初始化的仓库，我们一般称之为裸仓库， 因为这样创建的仓库并不包含 工作区 ， 也就是说，我们并不能在这个目录下执行我们一般使用的 Git 命令。<a href="https://www.cnblogs.com/irockcode/p/8761954.html">https://www.cnblogs.com/irockcode/p/8761954.html</a></p>
<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>1、<code>Connection closed by ::1 port 22</code></p>
<p>重新生成密钥或<strong>网络问题</strong>，因为国内访问Github可能很慢</p>
<p>2、<code>fatal: refusing to merge unrelated histories</code></p>
<p><code>git pull</code>或<code>git push</code>或<code>git merge</code>等命令可能会遇到，</p>
<p>在操作命令后面加<code>--allow-unrelated-histories</code></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux编程实验</title>
    <url>/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>学自电子科技大学</p>
<span id="more"></span>

<h2 id="实验一-开发环境实验"><a href="#实验一-开发环境实验" class="headerlink" title="实验一 开发环境实验"></a>实验一 开发环境实验</h2><h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><p><strong>GNU Compiler Collection</strong></p>
<p>包括：</p>
<ul>
<li>cpp(预处理器)</li>
<li>gcc(c 编译器)、g++(c++编译器)等编译器</li>
<li>binutils等二进制工具，含【as(汇编器)、 ld(链接器)等等】</li>
</ul>
<img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220411132146964.png" alt="image-20220411132146964" style="zoom:67%;">

<p>gcc [调试选项] &lt;文件名&gt;</p>
<ul>
<li><code>-g</code>：以操作系统的本地格式(stabs, COFF, XCOFF,或DWARF)。产生调试信息. GDB能够使用这些调试信息. </li>
<li><code>-ggdb</code>：ggdb选项可以插入的更为丰富的调试信息，但是生成的可执行文件有可能无法用其它调试器调试</li>
</ul>
<p>注：调试选项的启动会让二进制文件的大小急剧增长</p>
<p>gcc [优化选项] &lt;文件名&gt;</p>
<ul>
<li><code>-O</code> 或者 <code>–O1</code> 优化选项：编译器会试图减少目标码的大小和执行时间</li>
<li><code>-O2</code>：除了涉及空间和速度交换的优化选项,执行几乎所有的优化工作，但不进行循环展开和函数内嵌</li>
<li><code>-O3</code>：乱序执行，循环展开的优化</li>
</ul>
<p>注：调试时不能用优化选项，否则变量值和源代码无法对应</p>
<h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p>GDB是GNU计划开发的程序调试工具<br>包括：</p>
<ul>
<li>启动程序，可以按照自定义的要求运行程序</li>
<li>指定断点停住（断点可以是条件表达式）</li>
<li>程序停住时，可以检查当前程序中的情况</li>
<li>动态的改变程序的执行环境</li>
</ul>
<p><code>watchpoint</code>命令（观察对象值变化，则程序立即停止）：</p>
<table>
<thead>
<tr>
<th>语句格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>watch &lt;expr&gt;</code></td>
<td>为表达式（变量）expr设置一个观察点。一旦表达式值有变化时，马上停住程序</td>
</tr>
<tr>
<td><code>rwatch &lt;expr&gt;</code></td>
<td>当表达式（变量）expr被读时，停住程序</td>
</tr>
<tr>
<td><code>awatch &lt;expr&gt;</code></td>
<td>当表达式（变量）的值被读或被写时，停住程序</td>
</tr>
<tr>
<td><code>info watchpoints</code></td>
<td>列出当前所设置了的所有观察点</td>
</tr>
</tbody></table>
<p>清除禁止断点或者观察点：</p>
<table>
<thead>
<tr>
<th>语句格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>clear [linenum] [function name]</code></td>
<td>清除所有断点,不会清除watchpoints</td>
</tr>
<tr>
<td><code>delete &lt;num&gt;</code></td>
<td>清除编号为num的断点或者watchpoint</td>
</tr>
<tr>
<td><code>disable &lt;num&gt;</code></td>
<td>禁止某个断点</td>
</tr>
<tr>
<td><code>enable &lt;num&gt;</code></td>
<td>开启某个断点</td>
</tr>
</tbody></table>
<p>其他常用命令：</p>
<table>
<thead>
<tr>
<th>语句格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>Info [**]</code></td>
<td>查看设置的断点，函数名称，类名，例：info b查看已经设置的断点名称</td>
</tr>
<tr>
<td><code>dir</code></td>
<td>源代码路径 gdb默认有$cdir和$cwd两个源代码搜索路径，如果你要调试程序的源代码不在这两个路径中，可用dir命令增加</td>
</tr>
<tr>
<td><code>r [[参数1]…[参数n]]</code></td>
<td>在gdb中运行已经装载的可执行文件，参数为程序所需的参数</td>
</tr>
</tbody></table>
<p><code>list</code>命令（简写l，调试过程中打印源码）：</p>
<table>
<thead>
<tr>
<th>语句格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>list</code></td>
<td>当前行的上5行和下5行，默认10行</td>
</tr>
<tr>
<td><code>list &lt;linenum&gt;</code></td>
<td>打印Linenum行的代码</td>
</tr>
<tr>
<td><code>list &lt;+offset&gt;| list &lt;-offset&gt;</code></td>
<td>当前行号的正偏移量|当前行号的负偏移量</td>
</tr>
<tr>
<td><code>list &lt;filename:linenum&gt;</code></td>
<td>Filename文件的linenum行</td>
</tr>
<tr>
<td><code>list &lt;filename:function&gt;</code></td>
<td>Filename文件的function函数</td>
</tr>
<tr>
<td><code>list &lt;*address&gt;</code></td>
<td>运行时语句在内存中的地址</td>
</tr>
</tbody></table>
<p>搜索代码命令：</p>
<table>
<thead>
<tr>
<th>语句格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>forward-search &lt;regexp&gt;</code></td>
<td>向前搜索</td>
</tr>
<tr>
<td><code>search &lt;regexp&gt;</code></td>
<td>向后搜索</td>
</tr>
<tr>
<td><code>reverse-search &lt;regexp&gt;</code></td>
<td>全文搜索</td>
</tr>
</tbody></table>
<p>注：<code>&lt;regexp&gt;</code>：正则表达式，匹配字符串的模式</p>
<p>GDB调试命令：</p>
<table>
<thead>
<tr>
<th>调试命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>step</code></td>
<td>单步调试命令，一次执行一行程序</td>
</tr>
<tr>
<td><code>next</code></td>
<td>单步调试命令，但跳过函数调用</td>
</tr>
<tr>
<td><code>finish</code></td>
<td>单步调试时直接从一个函数中返回</td>
</tr>
<tr>
<td><code>disassemble</code></td>
<td>显示汇编代码</td>
</tr>
<tr>
<td><code>Backtrace</code>或者<code>bt</code></td>
<td>查看目前程序的堆栈情况</td>
</tr>
<tr>
<td><code>whre</code></td>
<td>查看目前程序的堆栈情况</td>
</tr>
<tr>
<td><code>up/down</code></td>
<td>向上或者向下移动一个堆栈</td>
</tr>
<tr>
<td><code>frame&lt;num&gt;</code>或者<code>f</code></td>
<td>移动到第num个堆栈</td>
</tr>
</tbody></table>
<p>注：当移动到某个堆栈时，可以用<code>gdb</code>命令查看在此堆栈中的局部变量。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在Linux下通过C语言程序设计链表应用程序</p>
<ul>
<li>定义单向链表的数据结构</li>
<li>创建链表</li>
<li>插入结点</li>
<li>遍历结点等</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//预定义数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stuInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> stuName[<span class="number">10</span>];	<span class="comment">//学生姓名</span></span><br><span class="line">	<span class="keyword">int</span> Age;	<span class="comment">//年龄</span></span><br><span class="line">&#125;ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;ListNode, *ListPtr;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">CreateList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> ListNode *head;</span><br><span class="line">	head = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error! please create list first\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode *tail = head-&gt;next;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;姓名\t年龄\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(tail != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\n&quot;</span>, tail-&gt;data.stuName, tail-&gt;data.Age);</span><br><span class="line">		tail = tail-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error! please create list first\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode *tail = head;</span><br><span class="line">	<span class="keyword">while</span>(tail-&gt;next != <span class="literal">NULL</span>) tail = tail-&gt;next;</span><br><span class="line">	tail-&gt;next = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;input name: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tail-&gt;next-&gt;data.stuName);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;input age: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(tail-&gt;next-&gt;data.Age));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* tmp = head;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ListNode *ListHead = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;1 Create List\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;2 Printf List\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;3 Insert List\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;4 Quit\n&quot;</span>);</span><br><span class="line">		<span class="keyword">char</span> command = getchar();</span><br><span class="line">		<span class="keyword">switch</span>(command)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: </span><br><span class="line">			&#123;</span><br><span class="line">				ListHead = CreateList();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">			&#123;</span><br><span class="line">				PrintList(ListHead);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">			&#123;</span><br><span class="line">				InsertList(ListHead);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">			&#123;</span><br><span class="line">				deleteList(ListHead);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;input error\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 清楚键盘缓冲区</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220411144433433.png" alt="image-20220411144433433"></p>
<h2 id="实验二-文件I-O实验"><a href="#实验二-文件I-O实验" class="headerlink" title="实验二 文件I/O实验"></a>实验二 文件I/O实验</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>目的一：掌握Linux应用程序命令行参数传递方法</p>
<p>目的二：掌握POSIX API中文件I/O操作方法</p>
<p>仿写cp命令的部分功能（编写mycp程序）：</p>
<ul>
<li>1、将源文件复制到另外一个文件（将test1.text复制成test2.txt）<br><code>[test@linux test]$ ./mycp /home/test1.txt /usr/test2.txt</code></li>
<li>2、将源文件复制到另外一个目录（将test1.txt复制到/tmp目录）<br><code>[test@linux test]$ ./mycp /home/test1.txt /tmp</code><br>源文件路径和目标文件路径通过命令行参数来指定</li>
</ul>
<img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220411144742688.png" alt="image-20220411144742688" style="zoom:67%;">

<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><strong>代码：<code>mycp.c</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> *sourcePath = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="comment">//printf(&quot;%s %s\n&quot;, argv[1], argv[2]);</span></span><br><span class="line">	<span class="keyword">int</span> sfd = open(sourcePath, O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(sfd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s:&quot;</span>, sourcePath);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> *targetPath = argv[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> tfd = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(opendir(targetPath) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> *fname = <span class="literal">NULL</span>;</span><br><span class="line">		ptr = <span class="built_in">strrchr</span>(sourcePath, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span>(!ptr)</span><br><span class="line">		&#123;</span><br><span class="line">			ptr = sourcePath;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			fname = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(ptr));</span><br><span class="line">			<span class="built_in">memcpy</span>(fname, ptr + <span class="number">1</span>, <span class="built_in">strlen</span>(ptr+<span class="number">1</span>));</span><br><span class="line">			ptr = fname;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">strlen</span>(targetPath);</span><br><span class="line">		<span class="keyword">if</span>(targetPath[len - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			targetPath = <span class="built_in">strcat</span>(targetPath, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		targetPath = <span class="built_in">strcat</span>(targetPath, ptr);</span><br><span class="line">        <span class="built_in">free</span>(fname);</span><br><span class="line">        ptr = <span class="literal">NULL</span>;</span><br><span class="line">        fname = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">//tfd = open(filename, O_RDWR | O_CREAT | O_EXCL, 0766);</span></span><br><span class="line">	&#125; </span><br><span class="line">	tfd = open(targetPath, O_RDWR | O_CREAT | O_EXCL, <span class="number">0766</span>);</span><br><span class="line">	<span class="keyword">if</span>(tfd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s:%s\n&quot;</span>, targetPath, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		size = read(sfd, buf, READ_SIZE);</span><br><span class="line">		<span class="keyword">if</span>(size == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		write(tfd, buf, size);</span><br><span class="line">	&#125; <span class="keyword">while</span>(size == READ_SIZE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s --&gt; %s\n&quot;</span>, sourcePath, targetPath);</span><br><span class="line">	close(sfd);</span><br><span class="line">	close(tfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220411163412553.png" alt="image-20220411163412553"></p>
<p>还有一个套娃操作(^-^)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	execl(<span class="string">&quot;/bin/cp&quot;</span>, argv[<span class="number">1</span>], argv[<span class="number">2</span>], <span class="literal">NULL</span>); <span class="comment">//调用/bin/cp可执行文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实验三-文件与目录操作"><a href="#实验三-文件与目录操作" class="headerlink" title="实验三 文件与目录操作"></a>实验三 文件与目录操作</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>目的一：掌握Linux目录操作方法</p>
<ul>
<li>打开目录、关闭目录</li>
<li>读取目录文件</li>
<li>获取Linux文件属性的函数</li>
</ul>
<p>目的二：掌握Linux文件属性获取方法</p>
<p>目的三：掌握文件属性解析相关的重要数据结构、函数、宏和文件掩码等</p>
<p>具体内容：仿写<code>ls -l</code>的功能（编写<code>myls</code>程序）,参数通过命令行传入：</p>
<p>1、获取当前工作目录路径并对该目录实现遍历</p>
<p>2、仿<code>ls -l</code>以列表形式出当前工作目录下的所有文件（包括子目录)</p>
<p>需显示的文件属性有：</p>
<p><strong>文件类型 权限 硬链接数 所有者用户名 所有者所在组用户名 文件大小 最后修改时间</strong></p>
<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220411165916173.png" alt="image-20220411165916173"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><strong>代码：myls.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_type</span><span class="params">(<span class="keyword">mode_t</span> st_mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_perm</span><span class="params">(<span class="keyword">mode_t</span> st_mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_link</span><span class="params">(<span class="keyword">nlink_t</span> st_nlink)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_usrname</span><span class="params">(<span class="keyword">uid_t</span> st_uid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_grname</span><span class="params">(<span class="keyword">gid_t</span> st_gid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_size</span><span class="params">(<span class="keyword">off_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_time</span><span class="params">(<span class="keyword">time_t</span> mtime)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_filename</span><span class="params">(<span class="keyword">char</span> *fname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *dirPath = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dirPath = get_current_dir_name();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		dirPath = argv[<span class="number">1</span>];</span><br><span class="line">		chdir(dirPath);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DIR *dir = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> *<span class="title">currentstat</span>;</span></span><br><span class="line">	currentstat = (struct stat *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">	<span class="keyword">if</span> ((dir = opendir(dirPath)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> ((dp = readdir(dir)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// printf(&quot;%s\n&quot;, dirent-&gt;d_name);</span></span><br><span class="line">			<span class="keyword">if</span> (stat(dp-&gt;d_name, currentstat) == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;get stat error\n&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			print_type(currentstat-&gt;st_mode);</span><br><span class="line">			print_perm(currentstat-&gt;st_mode);</span><br><span class="line">			print_link(currentstat-&gt;st_nlink);</span><br><span class="line">			print_usrname(currentstat-&gt;st_uid);</span><br><span class="line">			print_grname(currentstat-&gt;st_gid);</span><br><span class="line">			print_size(currentstat-&gt;st_size);</span><br><span class="line">			print_time(currentstat-&gt;st_mtime);</span><br><span class="line">			print_filename(dp-&gt;d_name);</span><br><span class="line">		&#125;</span><br><span class="line">		closedir(dir);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (stat(dirPath, currentstat) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		print_type(currentstat-&gt;st_mode);</span><br><span class="line">		print_perm(currentstat-&gt;st_mode);</span><br><span class="line">		print_link(currentstat-&gt;st_nlink);</span><br><span class="line">		print_usrname(currentstat-&gt;st_uid);</span><br><span class="line">		print_grname(currentstat-&gt;st_gid);</span><br><span class="line">		print_size(currentstat-&gt;st_size);</span><br><span class="line">		print_time(currentstat-&gt;st_mtime);</span><br><span class="line">		print_filename(dirPath);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s:Not a directory or file\n&quot;</span>, dirPath);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(currentstat);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_type</span><span class="params">(<span class="keyword">mode_t</span> st_mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S_ISREG(st_mode))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(st_mode))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S_ISCHR(st_mode))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S_ISBLK(st_mode))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S_ISFIFO(st_mode))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(st_mode))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;l&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S_ISSOCK(st_mode))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;s&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_perm</span><span class="params">(<span class="keyword">mode_t</span> st_mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//文件所有者</span></span><br><span class="line">	<span class="keyword">if</span> ((st_mode &amp; S_IRUSR) == S_IRUSR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((st_mode &amp; S_IWUSR) == S_IWUSR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((st_mode &amp; S_IXUSR) == S_IXUSR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//同组用户</span></span><br><span class="line">	<span class="keyword">if</span> ((st_mode &amp; S_IRGRP) == S_IRGRP)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((st_mode &amp; S_IWGRP) == S_IWGRP)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((st_mode &amp; S_IXGRP) == S_IXGRP)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//其他用户</span></span><br><span class="line">	<span class="keyword">if</span> ((st_mode &amp; S_IROTH) == S_IROTH)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((st_mode &amp; S_IWOTH) == S_IWOTH)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((st_mode &amp; S_IXOTH) == S_IXOTH)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_link</span><span class="params">(<span class="keyword">nlink_t</span> st_nlink)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%ld\t&quot;</span>, st_nlink);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_usrname</span><span class="params">(<span class="keyword">uid_t</span> st_uid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">usr</span> =</span> getpwuid(st_uid);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>, usr-&gt;pw_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_grname</span><span class="params">(<span class="keyword">gid_t</span> st_gid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">grp</span> =</span> getgrgid(st_gid);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>, grp-&gt;gr_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_size</span><span class="params">(<span class="keyword">off_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%ld\t&quot;</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_time</span><span class="params">(<span class="keyword">time_t</span> mtime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// char *time = ctime(&amp;mtime); //返回的字符串 如： Sun Apr 10 16:34:37 2022\n</span></span><br><span class="line">	<span class="comment">// printf(&quot;%s&quot;, time);</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">time</span> =</span> localtime(&amp;mtime);</span><br><span class="line">	<span class="keyword">char</span> *months[<span class="number">12</span>] = &#123;<span class="string">&quot;Jan&quot;</span>, <span class="string">&quot;Feb&quot;</span>, <span class="string">&quot;Mar&quot;</span>, <span class="string">&quot;Apr&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;Jun&quot;</span>, <span class="string">&quot;Jul&quot;</span>, <span class="string">&quot;Aug&quot;</span>, <span class="string">&quot;Sept&quot;</span>, <span class="string">&quot;Oct&quot;</span>, <span class="string">&quot;Nov&quot;</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s %2d %02d:%02d\t&quot;</span>, months[time-&gt;tm_mon], time-&gt;tm_mday, time-&gt;tm_hour, time-&gt;tm_min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_filename</span><span class="params">(<span class="keyword">char</span>* fname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, fname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220412124611665.png" alt="image-20220412124611665"></p>
<h2 id="实验四-进程控制实验"><a href="#实验四-进程控制实验" class="headerlink" title="实验四 进程控制实验"></a>实验四 进程控制实验</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>目的一：掌握Linux系统创建进程的方法</p>
<p>目的二：掌握在代码中如何区别父子进程的方法</p>
<p>目的三：掌握父子进程之间的资源共享与异同</p>
<p>目的四：掌握等待子进程执行结束的方法</p>
<p>目的五：掌握在进程中执行另外一个可执行文件的方法</p>
<p>创建一个子进程 <code>pid_t fork(void)</code></p>
<p>exec系列函数</p>
<p>等待子进程 <code>pid_t waitpid(pid_t pid, int *statloc, int options)</code></p>
<p><strong>实验内容：</strong></p>
<p>基于已经实现的实验二文件拷贝（mycp）以及实验三目录遍历（myls）的内容：</p>
<ol>
<li>改造myls程序作为父进程，其在遍历目录时，对非目录文件创建子进程运行mycp程序。</li>
<li>mycp源文件路径是父进程myls遍历所获取的文件的路径名（通过命令行参数传递给子进程mycp），并将源文件拷贝到指定目录下（在/home目录下以自己的名字的汉语拼音创建一个目录）。</li>
<li>父进程myls等待子进程mycp运行结束，回收其内核空间资源，直到父进程遍历完成</li>
</ol>
<p>程序流程：</p>
<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220411204021338.png" alt="image-20220411204021338"></p>
<p>在实现基本功能实现的基础上，对程序功能进行扩展，以支持对目录的递归遍历并将所有目录及子目录中的文件拷贝到一个目录中</p>
<ul>
<li>如果没有命令行参数则通过getcwd获取当前工作目录</li>
<li>如果包含一个命令行参数则通过该参数传递需要遍历的目录</li>
<li>如果有超过一个命令行参数则出错</li>
<li>拷贝文件及子目录下的文件</li>
</ul>
<p>扩展内容程序流程：</p>
<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220411204036494.png" alt="image-20220411204036494"></p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p><strong>代码：<code>mydircp.c</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TARGET_PATH <span class="meta-string">&quot;/home/yang/test&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYCP_PATH <span class="meta-string">&quot;/home/yang/Documents/Cprogram/Linux系统编程学习/mycp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYDIRCP_PATH <span class="meta-string">&quot;/home/yang/Documents/Cprogram/Linux系统编程学习/mydircp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *dirPath = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dirPath = get_current_dir_name();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dirPath = argv[<span class="number">1</span>];</span><br><span class="line">        chdir(dirPath);</span><br><span class="line">        dirPath = get_current_dir_name();</span><br><span class="line">    &#125;</span><br><span class="line">    dirPath = <span class="built_in">strcat</span>(dirPath, <span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (access(TARGET_PATH, F_OK) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mkdir(TARGET_PATH, <span class="number">0775</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DIR *dir = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> *<span class="title">currentstat</span>;</span></span><br><span class="line">    currentstat = (struct stat *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">    <span class="keyword">if</span> ((dir = opendir(dirPath)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> ((dp = readdir(dir)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">strcmp</span>(dp-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(dp-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stat(dp-&gt;d_name, currentstat) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;get stat error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (S_ISDIR(currentstat-&gt;st_mode))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">pid_t</span> pid_child;</span><br><span class="line">                pid_child = fork();</span><br><span class="line">                <span class="keyword">if</span> (pid_child &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Error occuredon forking.\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pid_child == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (execl(MYDIRCP_PATH, <span class="string">&quot;./mydircp&quot;</span>, <span class="built_in">strcat</span>(dirPath, dp-&gt;d_name), <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;mydircp fork error\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">pid_t</span> pid_child;</span><br><span class="line">                pid_child = fork();</span><br><span class="line">                <span class="keyword">if</span> (pid_child &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Error occuredon forking.\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pid_child == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (execl(MYCP_PATH, <span class="string">&quot;./mycp&quot;</span>, <span class="built_in">strcat</span>(dirPath, dp-&gt;d_name), TARGET_PATH, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;mycp fork error\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// pid_t pid_return;</span></span><br><span class="line">                <span class="comment">//  do</span></span><br><span class="line">                <span class="comment">//  &#123;</span></span><br><span class="line">                <span class="comment">//      pid_return = waitpid(pid_child, NULL, WNOHANG);</span></span><br><span class="line">                <span class="comment">//      sleep(1);</span></span><br><span class="line">                <span class="comment">//      printf(&quot;%d\n&quot;, pid_child);</span></span><br><span class="line">                <span class="comment">//  &#125; while (pid_return == 0);</span></span><br><span class="line">            &#125;</span><br><span class="line">            wait(<span class="literal">NULL</span>); <span class="comment">//阻塞 等待子进程结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        closedir(dir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (stat(dirPath, currentstat) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:Not a directory or file\n&quot;</span>, dirPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(currentstat);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220412162210943.png" alt="image-20220412162210943"></p>
<h2 id="实验五-线程控制实验"><a href="#实验五-线程控制实验" class="headerlink" title="实验五 线程控制实验"></a>实验五 线程控制实验</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>目的一：掌握UNIX/Linux系统创建线程的方法</p>
<p>目的二：理解线程启动例程的设计思想</p>
<p>目的三：掌握线程终止的方式</p>
<p>目的四：掌握线程之间共享数据的方法</p>
<p>目的五：掌握等待线程终止的方法</p>
<p><strong>线程设计思想</strong>：</p>
<p>多线程程序主要用于需要并发执行的场合</p>
<ul>
<li>游戏场景中：玩家通过鼠标键盘输入操作指令，控制游戏进行无多线程，则程序等待玩家指令输入，程序的动画效果停止</li>
<li>在线视频播放存在同样的问题</li>
</ul>
<img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220412165725398.png" alt="image-20220412165725398" style="zoom:50%;">

<p><strong>相关函数：</strong></p>
<p>创建线程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *<span class="keyword">restrict</span> tidp,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">void</span> *(*start_rtn)(<span class="keyword">void</span> *), </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">void</span> *<span class="keyword">restrict</span> arg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>头文件 <code>pthread.h</code></li>
<li>作用：创建一个线程</li>
<li>返回值：出错返回错误码；成功返回0</li>
</ul>
<p>线程的终止：<code>void pthread_exit(void *rval_ptr);</code></p>
<ul>
<li>头文件：<code>pthread.h</code></li>
<li>作用：线程调用后将会终止自身</li>
<li>参数：<code>rval_ptr</code>指针将会传递给等待线程终止函数</li>
</ul>
<p><code>int pthread_join(pthread_t thread, void **rval_ptr);</code></p>
<ul>
<li>头文件：<code>pthread.h</code></li>
<li>作用：父进程阻塞直到<code>thread</code>子线程终止</li>
<li>返回值：成功返回0，出错返回错误编号</li>
<li><code>rval_ptr</code>：线程结束的返回值<ul>
<li>线程从启动例程返回，<code>rval_ptr</code>将指向返回值</li>
<li>线程被其他线程取消，<code>rval_ptr</code>指向的值置为<code>PTHREAD_CANCELED</code></li>
<li>线程通过调用<code>pthread_exit</code>终止，<code>rval_ptr</code>就是<code>pthread_exit</code>函数中指定的参数</li>
<li>不关注返回值，则该参数使用时使用<code>NULL</code> </li>
</ul>
</li>
</ul>
<p><strong>实验内容</strong>：</p>
<p>基于已经实现的实验二文件拷贝（<code>mycp</code>）以及实验三目录遍历（<code>myls</code>）的内容（与实验四的区别为并发单位变为线程）</p>
<ol>
<li>改造<code>myls</code>程序作为从属子线程，其在遍历目录时，对非目录文件再次创建子线程运行<code>mycp</code>程序。</li>
<li><code>mycp</code>源文件路径是父主体线程<code>myls</code>遍历所获取的文件的路径名（通过命令行参数传递给子进程<code>mycp</code>），并将源文件拷贝到指定目录下（在<code>/home</code>目录下以自己的名字的汉语拼音创建一个目录）。</li>
<li>线程<code>myls</code>等待线程<code>mycp</code>运行结束，回收其内核空间资源，<code>main</code>线程等待<code>myls</code>遍历完成，程序结束</li>
</ol>
<p><strong>程序流程</strong></p>
<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220412172540388.png" alt="image-20220412172540388"></p>
<p><strong>扩展一</strong>：在实现基本功能实现的基础上，对程序功能进行扩展，以支持对目录的递归遍历并将所有目录及子目录中的文件拷贝到一个目录中</p>
<ul>
<li>如果没有命令行参数则通过getcwd获取当前工作目录</li>
<li>如果包含一个命令行参数则通过该参数传递需要遍历的目录</li>
<li>如果有超过一个命令行参数则出错</li>
<li>拷贝文件及子目录下的文件</li>
</ul>
<p><strong>扩展二：</strong></p>
<ul>
<li><code>myls</code>与<code>mycp</code>线程并发执行（线程不等待所创建线程运行终止）遍历同时则创建多个<code>mycp</code>线程拷贝文件</li>
<li>增加源文件目录结构，观察文件较多的情况下，是否能提升程序运行效率</li>
</ul>
<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220412173029952.png" alt="image-20220412173029952"></p>
<p><strong>编译</strong></p>
<p>多个源文件编译为一个可执行文件：<code>gcc file1.c file2.c -o objfile.o</code></p>
<p><strong>外部库的链接：</strong>线程控制API实现在线程库中<code>lpthread</code></p>
<ul>
<li><code>gcc file1.c file2.c –o objfile.o -lpthread</code></li>
</ul>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p><strong>代码：</strong><code>gcc mydircpt.h mydircpt.c mycpt.c mydirt.c -o mydircpt -lpthread</code></p>
<p><strong><code>mydircpt.h</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TARGET_PATH <span class="meta-string">&quot;/home/yang/test&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">mycpt</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">mydirt</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><code>mydircpt.c</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mydircpt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *dirPath = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dirPath = get_current_dir_name();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dirPath = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (chdir(dirPath) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s : Not a directory\n&quot;</span>, dirPath);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dirPath = get_current_dir_name();</span><br><span class="line">    &#125;</span><br><span class="line">    dirPath = <span class="built_in">strcat</span>(dirPath, <span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (access(TARGET_PATH, F_OK) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mkdir(TARGET_PATH, <span class="number">0775</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> child;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;child, <span class="literal">NULL</span>, mydirt, dirPath) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(child, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>mycpt.c</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mydircpt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mycpt</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *sourcePath = (<span class="keyword">char</span> *)arg;</span><br><span class="line">    <span class="comment">//printf(&quot;mycpt %s\n&quot;, sourcePath);</span></span><br><span class="line">    <span class="keyword">int</span> sfd = open(sourcePath, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (sfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:&quot;</span>, sourcePath);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// char *targetPath = TARGET_PATH;</span></span><br><span class="line">    <span class="keyword">char</span> *targetPath = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(TARGET_PATH) + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(targetPath, TARGET_PATH);</span><br><span class="line">    <span class="keyword">int</span> tfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (opendir(targetPath) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> *fname = <span class="literal">NULL</span>;</span><br><span class="line">        ptr = <span class="built_in">strrchr</span>(sourcePath, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = sourcePath;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            fname = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(ptr));</span><br><span class="line">            <span class="built_in">memcpy</span>(fname, ptr + <span class="number">1</span>, <span class="built_in">strlen</span>(ptr + <span class="number">1</span>));</span><br><span class="line">            ptr = fname;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(targetPath);</span><br><span class="line">        <span class="keyword">if</span> (targetPath[len - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            targetPath = <span class="built_in">strcat</span>(targetPath, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        targetPath = (<span class="keyword">char</span>*)<span class="built_in">realloc</span>(targetPath, <span class="built_in">strlen</span>(targetPath) + <span class="built_in">strlen</span>(ptr) + <span class="number">1</span>);</span><br><span class="line">        targetPath = <span class="built_in">strcat</span>(targetPath, ptr);</span><br><span class="line">        <span class="built_in">free</span>(fname);</span><br><span class="line">        ptr = <span class="literal">NULL</span>;</span><br><span class="line">        fname = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// tfd = open(filename, O_RDWR | O_CREAT | O_EXCL, 0766);</span></span><br><span class="line">    &#125;</span><br><span class="line">    tfd = open(targetPath, O_RDWR | O_CREAT | O_EXCL, <span class="number">0766</span>);</span><br><span class="line">    <span class="keyword">if</span> (tfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:%s\n&quot;</span>, targetPath, strerror(errno));</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        size = read(sfd, buf, READ_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(tfd, buf, size);</span><br><span class="line">    &#125; <span class="keyword">while</span> (size == READ_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s --&gt; %s\n&quot;</span>, sourcePath, targetPath);</span><br><span class="line">    close(sfd);</span><br><span class="line">    close(tfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>mydirt.c</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mydircpt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mydirt</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *dirPath = (<span class="keyword">char</span> *)arg;</span><br><span class="line">    chdir(dirPath);</span><br><span class="line">    dirPath = get_current_dir_name();</span><br><span class="line">    DIR *dir = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> *<span class="title">currentstat</span>;</span></span><br><span class="line">    currentstat = (struct stat *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">    <span class="keyword">if</span> ((dir = opendir(dirPath))) <span class="comment">// 打开目录</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> ((dp = readdir(dir)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(dp-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(dp-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stat(dp-&gt;d_name, currentstat) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;A : %s \n&quot;</span>, dirPath);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, get_current_dir_name());</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s : get stat error  %s \n&quot;</span>, dp-&gt;d_name, strerror(errno));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">pthread_t</span> thread_child;</span><br><span class="line">            <span class="keyword">char</span> *tmp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(dirPath) + <span class="built_in">strlen</span>(dp-&gt;d_name) + <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">strcpy</span>(tmp, dirPath);</span><br><span class="line">            <span class="built_in">strcat</span>(tmp, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(tmp, dp-&gt;d_name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (S_ISDIR(currentstat-&gt;st_mode)) <span class="comment">// 判断是不是目录</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pthread_create(&amp;thread_child, <span class="literal">NULL</span>, mydirt, tmp) != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;location A : Error pthread create.\n&quot;</span>);</span><br><span class="line">                    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 文件</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pthread_create(&amp;thread_child, <span class="literal">NULL</span>, mycpt, tmp) != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;location B : Error pthread create.\n&quot;</span>);</span><br><span class="line">                    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_join(thread_child, <span class="literal">NULL</span>); <span class="comment">//阻塞 等待线程结束</span></span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            chdir(dirPath);</span><br><span class="line">        &#125;</span><br><span class="line">        closedir(dir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s : Not a directory\n&quot;</span>, dirPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220412230003981.png" alt="image-20220412230003981"></p>
<h2 id="实验六-线程同步实验"><a href="#实验六-线程同步实验" class="headerlink" title="实验六 线程同步实验"></a>实验六 线程同步实验</h2><h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><p>目的一：了解临界资源、哲学家进餐问题、死锁等经典的操作系统同步互斥问题的基本概念</p>
<p>目的二：掌握利用互斥量机制实现多线程对临界资源互斥访问的方法</p>
<p>目的三：掌握互斥量非阻塞加锁的操作方法</p>
<p>目的四：掌握在保证对临界资源互斥访问的基础上通过让权等待的方式预防死锁的编程思想</p>
<p><strong>哲学家进餐问题：</strong></p>
<p>进餐问题主函数流程</p>
<img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220413140109410.png" alt="image-20220413140109410" style="zoom: 80%;">

<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220413140123853.png" alt="image-20220413140123853"></p>
<p>哲学家任务用线程实现，并对哲学家和筷子进行编号，并通过参数传递各种编号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;<span class="comment">//线程例程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(“philosopher %d is thinking\n”,number);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        takechopstick(number);</span><br><span class="line">        takechopstick((number+<span class="number">1</span>)%<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(“philosopher %d is eating\n”,number);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        putchopstick(number);</span><br><span class="line">        putchopstick((number+<span class="number">1</span>)%<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>筷子（临界资源），各个哲学家（不同任务）对其进行互斥访问临界资源的访问与释放，Linux中有多种实现机制：</p>
<ul>
<li>互斥量（加锁，解锁）</li>
<li>XSI信号量集（P，V操作）</li>
<li>POSIX信号量（P，V操作）</li>
</ul>
<p>互斥量（加锁，解锁）的使用步骤</p>
<ol>
<li>定义一个互斥量变量（ pthread_mutex_t 类型）</li>
<li>初始化互斥量</li>
<li>访问临界资源前对互斥量加锁</li>
<li>访问临界资源后对互斥量解锁</li>
<li>销毁互斥量</li>
</ol>
<p>互斥量初始化：</p>
<ul>
<li>头文件：<code>pthread.h</code></li>
<li>定义和静态初始化互斥量变量：</li>
<li><code>pthread_mutex_t mlock = PTHREAD_MUTEX_INITIALIZER</code></li>
</ul>
<p>动态初始化：</p>
<ul>
<li>函数原型：<code>int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);</code></li>
<li>参数与返回值： mutex：互斥变量指针</li>
<li>attr：设置互斥量的属性，通常采用默认属性，将attr设为NULL。成功返回0，出错返回错误码</li>
</ul>
<p>互斥量销毁：</p>
<ul>
<li>头文件：<code>pthread.h</code></li>
<li>互斥量销毁：<code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></li>
<li>作用：互斥量在使用完毕后，必须要对互斥量进行销毁，以释放资源参数与返回值</li>
<li>mutex：互斥量变量指针</li>
<li>成功返回0，出错返回错误码</li>
</ul>
<p>加锁：</p>
<ul>
<li>头文件：<code>pthread.h</code></li>
<li>函数：<code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></li>
<li>作用：对共享资源访问之前需要加锁互斥量</li>
<li>当调用pthread_mutex_lock时，若互斥量已被加锁，则调用线程将被阻塞（哲学家线程进入阻塞状态，等待操作系统唤醒）</li>
<li>成功返回0，出错返回错误码</li>
</ul>
<p>解锁：</p>
<ul>
<li>函数：<code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></li>
<li>作用：对共享资源访问之前需要加锁互斥量</li>
<li>成功返回0，出错返回错误码</li>
</ul>
<p>拿筷子操作导致死锁的原因</p>
<ul>
<li>筷子需要互斥访问（临界资源）</li>
<li>任务无法抢占其他任务已经拿起的筷子</li>
<li>任务拿起筷子直到进餐完毕后才放下（长时间占有资源）</li>
<li>圆桌导致可能出现循环等待</li>
</ul>
<p>预防死锁的实现方法一： 破坏请求和保持条件</p>
<ul>
<li>任务如果无法同时拿起两支筷子，则放下已经拿起的筷子，等待一段时间再尝试</li>
<li>利用POSIX API中的非阻塞操作实现能否拿起筷子的判断<ul>
<li><code>pthread_mutex_trylock</code>操作</li>
<li><code>sem_trywait</code>操作</li>
</ul>
</li>
<li>XSI信号量集P操作设置IPC_NOWAIT参数</li>
</ul>
<p>头文件：<code>pthread.h</code></p>
<p>函数：<code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></p>
<p>调用该函数时，若互斥量未加锁，则锁住该互斥量，返回0；</p>
<p>若互斥量已加锁，则函数直接返回失败（哲学家线程进入代码安排的下一步活动，思考或者饥饿）</p>
<p>预防死锁的实现方法二 ： 破坏“循环等待条件”</p>
<ul>
<li>对哲学家编号，奇偶号哲学家拿起筷子的顺序不同</li>
<li>创建一个服务生任务，哲学家拿起筷子时向该任务发起申请，由该任务根据当前筷子的分配情况判断系统是否由安全状态向不安全状态转换，从而允许或拒绝该次申请</li>
</ul>
<p><strong>实验内容</strong>：</p>
<p>利用POSIX API在Linux系统上编写应用程序，通过多线程和互斥量机制实现哲学家进餐问题（哲学家的数量可以通过简单的配置进行修改）</p>
<ol>
<li>首先通过阻塞加锁的操作方式实现哲学家之间（线程）对筷子（临界资源）的互斥访问，观察程序运行一段时间以后会出现的死锁状态。如果未出现死锁状态的可以通过修改哲学家数量以及修改延时设置来增大出现死锁的机率。</li>
<li>将互斥量的加锁操作从阻塞方式修改为非阻塞方式，通过让权等待的思想预防死锁状态的出现。</li>
</ol>
<p>基本功能实现的基础上鼓励尝试多种思路预防死锁，包括并不限于以下思路：</p>
<ul>
<li>对哲学家编号，奇偶号哲学家拿起筷子顺序不同</li>
<li>再创建一个任务，哲学家拿起筷子时向该任务发起申请，由该任务对当前筷子的分配情况进行判断，判定系统是否由安全状态向不安全状态转换，从而允许或拒绝该次申请</li>
</ul>
<p><strong>线程局部存储</strong>：</p>
<p>线程局部存储：对于某个全局变量想做出本线程范围内的修改和读取例： <code>errorno</code></p>
<p><code>static int buf[100];</code></p>
<ul>
<li>__thread说明符让线程拥有自己对该全局变量的拷贝</li>
<li>终止时自动释放该存储</li>
<li>例：每个线程有自己的errorno拷贝，防止被其他线程干扰</li>
</ul>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>1、有死锁情况（这是加锁阻塞的情况）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 5  <span class="comment">// 修改NUM可以改变哲学家和筷子的数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// static int chopstick[NUM];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> chopstick_lock[NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">philosopher</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>; <span class="comment">//线程例程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">takechopstick</span><span class="params">(<span class="keyword">char</span> name, <span class="keyword">int</span> number)</span></span>; <span class="comment">// 拿筷子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchopstick</span><span class="params">(<span class="keyword">char</span> name, <span class="keyword">int</span> number)</span></span>; <span class="comment">// 放筷子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> pt[NUM];</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(NUM);</span><br><span class="line">    <span class="keyword">char</span> tmp = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = tmp + i;</span><br><span class="line">        pthread_create(&amp;pt[i], <span class="literal">NULL</span>, philosopher, &amp;p[i]);</span><br><span class="line">        pthread_mutex_init(&amp;chopstick_lock[i], <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// chopstick[i] = 0;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(pt[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">philosopher</span><span class="params">(<span class="keyword">void</span> *arg)</span> <span class="comment">//线程例程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name = *((<span class="keyword">char</span> *)arg);</span><br><span class="line">    <span class="keyword">int</span> number = name - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;philosopher %c is thinking\n&quot;</span>, name);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// pthread_mutex_lock(&amp;chopstick_lock);</span></span><br><span class="line">        takechopstick(name, number);</span><br><span class="line">        sleep(<span class="number">1</span>);  <span class="comment">// 注释掉这行，大概率碰不到死锁的情况</span></span><br><span class="line">        takechopstick(name, (number + <span class="number">1</span>) % NUM);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;philosopher %c is eating\n&quot;</span>, name);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        putchopstick(name, number);</span><br><span class="line">        putchopstick(name, (number + <span class="number">1</span>) % NUM);</span><br><span class="line">        <span class="comment">// pthread_mutex_unlock(&amp;chopstick_lock);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">takechopstick</span><span class="params">(<span class="keyword">char</span> name, <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;chopstick_lock[number]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philosopher %c fetches chopstick %d\n&quot;</span>, name, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchopstick</span><span class="params">(<span class="keyword">char</span> name, <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philosopher %c release chopstick %d\n&quot;</span>, name, number);</span><br><span class="line">    pthread_mutex_unlock(&amp;chopstick_lock[number]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220413163654676.png" alt="image-20220413163654676"></p>
<p>2、无死锁情况（非阻塞情况）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// static int chopstick[NUM];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> chopstick_lock[NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">philosopher</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>; <span class="comment">//线程例程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">takechopstick</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchopstick</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> pt[NUM];</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(NUM);</span><br><span class="line">    <span class="keyword">char</span> tmp = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = tmp + i;</span><br><span class="line">        pthread_create(&amp;pt[i], <span class="literal">NULL</span>, philosopher, &amp;p[i]);</span><br><span class="line">        pthread_mutex_init(&amp;chopstick_lock[i], <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// chopstick[i] = 0;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(pt[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">philosopher</span><span class="params">(<span class="keyword">void</span> *arg)</span> <span class="comment">//线程例程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name = *((<span class="keyword">char</span> *)arg);</span><br><span class="line">    <span class="keyword">int</span> number = name - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;philosopher %c is thinking\n&quot;</span>, name);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// pthread_mutex_lock(&amp;chopstick_lock);</span></span><br><span class="line">        <span class="keyword">if</span> (!takechopstick(number))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;philosopher %c fetches chopstick %d\n&quot;</span>, name, number);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!takechopstick((number + <span class="number">1</span>) % NUM))</span><br><span class="line">        &#123;</span><br><span class="line">            putchopstick(number);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;philosopher %c failed and release chopstick %d\n&quot;</span>, name, number);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;philosopher %c fetches chopstick %d\n&quot;</span>, name, (number + <span class="number">1</span>) % NUM);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;philosopher %c is eating\n&quot;</span>, name);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        putchopstick(number);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;philosopher %c release chopstick %d\n&quot;</span>, name, number);</span><br><span class="line">        putchopstick((number + <span class="number">1</span>) % NUM);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;philosopher %c release chopstick %d\n&quot;</span>, name, (number + <span class="number">1</span>) % NUM);</span><br><span class="line">        <span class="comment">// pthread_mutex_unlock(&amp;chopstick_lock);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">takechopstick</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_trylock(&amp;chopstick_lock[number]) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchopstick</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;chopstick_lock[number]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220413171407370.png" alt="image-20220413171407370"></p>
<h2 id="实验七-综合实验"><a href="#实验七-综合实验" class="headerlink" title="实验七 综合实验"></a>实验七 综合实验</h2><h3 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h3><p>目的一：了解生产者消费者问题中同步互斥的基本概念</p>
<p>目的二：掌握XSI信号量集机制</p>
<p>目的三：掌握XSI共享内存机制</p>
<p>目的四：掌握Linux中多进程协同工作的程序设计思想</p>
<p>生产者消费者问题：</p>
<p>若干任务通过共享缓冲池（包含一定数量的缓冲区）交换数据</p>
<ul>
<li>“生产者”任务不断写入，而“消费者”任务不断读出</li>
<li>任何时刻只能有一个任务可对共享缓冲池进行操作</li>
</ul>
<p>生产者：从源（文件、网络等）读取数据放入未使用的缓冲区</p>
<p>消费者：从已有数据的缓冲区取走数据进行处理（计算、变换等）</p>
<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220413172441448.png" alt="image-20220413172441448"></p>
<p><strong>实验内容</strong></p>
<ul>
<li>综合运用所学知识在Linux系统上编写应用程序，要求至少支持<strong>2个生产者任务（进程）和2个消费者任务（进程）</strong>的同时运行</li>
<li>生产者任务和消费者任务之间通过<strong>XSI共享内存机制</strong>实现跨进程的<strong>共享缓冲池</strong></li>
<li>生产者任务和消费者任务之间通过<strong>XSI信号量集机制</strong>实现对缓冲池的<strong>互斥访问</strong></li>
<li>生产者与消费者之间的<strong>同步</strong>通过修改缓冲池结构中的<strong>缓冲区状态变量</strong>来实现</li>
</ul>
<p>缓冲池结构（5个缓冲区）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="keyword">char</span> Buffer[<span class="number">5</span>][<span class="number">100</span>]; <span class="comment">//5个缓冲区</span></span><br><span class="line">	<span class="keyword">int</span> Index[<span class="number">5</span>]; <span class="comment">//缓冲区状态</span></span><br><span class="line">    <span class="comment">// 0 对应的缓冲区未被生产者使用，可分配但不可消费</span></span><br><span class="line">	<span class="comment">// 1 表示对应的缓冲区以被生产者使用，不可分配但可消费</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同步如何做到：</p>
<ul>
<li>通过缓冲池结构中的状态变量来指示（当前实验要求）</li>
<li>通过信号量来指示未被使用缓冲区数量和已被使用缓冲区数量</li>
</ul>
<p>互斥机制：</p>
<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220413172954742.png" alt="image-20220413172954742"></p>
<ul>
<li>XSI信号量集（包含1个信号量，初始值为1）</li>
<li>POSIX信号量</li>
</ul>
<p>生产者的程序实现流程：</p>
<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220413173154916.png" alt="image-20220413173154916"></p>
<p>消费者的程序实现流程：</p>
<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220413173236575.png" alt="image-20220413173236575"></p>
<p>至少2个生产者任务（进程）和2个消费者任务（进程）的同时运行</p>
<p>Q：各个进程拥有自己的数据区域，如何访问struct BufferPool？</p>
<p>A：采用进程间通信的方式<strong>消息队列</strong>或者<strong>共享内存（本次实验要求）</strong></p>
<p>共享内存：</p>
<ul>
<li>允许两个或更多进程访问同一块内存。当一个进程改变了这块内存中的内容的的时候，其他进程都会察觉到这个更改。</li>
<li>但是，系统内核<strong>没有</strong>对访问共享内存的进程进行<strong>同步机制</strong></li>
<li>共享内存在各种进程间通信方式中具有最高的效率</li>
</ul>
<p>共享内存相关函数：</p>
<p><code>int shmget(key_t key, size_t size, int shmflg);</code></p>
<ul>
<li>头文件<code>&lt;sys/ipc.h&gt; &lt;sys/shm.h&gt;</code></li>
<li>得到一个共享内存标识符或创建一个共享内存对象并返回共享内存标识符</li>
<li>返回值：成功返回与key相关的共享内存标识符，出错返回-1，并设置error</li>
<li>key 标识共享内存的键值： 非零键值/IPC_PRIVATE</li>
<li>size 大于0的整数，新建的共享内存大小，以字节为单位，获取已存在的共享内存块标识符时，该参数为0,</li>
<li>shmflg IPC_CREAT||IPC_EXCL 执行成功，保证返回一个新的共享内存标识符，附加参数指定IPC对象存储权限，如|0666</li>
</ul>
<p><code>int shmat(int shm_id, const void *shm_addr, int shmflg);</code></p>
<ul>
<li>头文件：<code>&lt;sys/types.h&gt; &lt;sys/shm.h&gt;</code></li>
<li>连接共享内存标识符为shm_id的共享内存，连接成功后把共享内存区对象映射到调用进程的地址空间</li>
<li>返回值：成功返回所附加的共享内存地址，出错返回-1，并设置error</li>
<li>shm_id： 共享内存标识符</li>
<li>shm_addr： 指定共享内存出现在进程内存地址的什么位置，通常指定为NULL，让内核自己选择一个合适的地址位置</li>
<li>shmflg： SHM_RDONLY 为只读模式，其他参数为读写模式</li>
</ul>
<p><code>void *shmdt(const void* shmaddr);</code></p>
<ul>
<li>头文件：<code>&lt;sys/types.h&gt; &lt;sys/shm.h&gt;</code></li>
<li>断开与共享内存附加点的地址，禁止本进程访问此片共享内存(不做删除操作)</li>
<li>返回值：成功返回0，出错返回-1，并设置error</li>
<li>shmaddr： shmddr 连接共享内存的起始地址</li>
</ul>
<p><code>int shmctl(int shmid, int cmd, struct shmid_ds* buf);</code></p>
<ul>
<li>头文件：<code>&lt;sys/types.h&gt; &lt;sys/shm.h&gt;</code></li>
<li>作用：控制共享内存块</li>
<li>返回值：成功返回0，出错返回-1，并设置error</li>
<li>shmid：共享内存标识符</li>
<li>cmd：<ul>
<li>IPC_STAT：得到共享内存的状态，把共享内存的shmid_ds结构赋值到buf所指向的buf中</li>
<li>IPC_SET：改变共享内存的状态，把buf所指向的shmid_ds结构中的uid、gid、mode赋值到共享内存的shmid_ds结构内</li>
<li>IPC_RMID：删除这块共享内存</li>
</ul>
</li>
<li>buf：共享内存管理结构体</li>
</ul>
<p><strong>实验内容（扩展）</strong>:</p>
<ul>
<li>完善生产者和消费者程序的结束流程。例：生产者在读取完文件内容后结束自身执行，消费者在一段时间之后如果无法从缓冲池读取数据则给出提示信息，用户输入决定继续等待或退出</li>
</ul>
<p><strong>实验内容（选做）</strong>：</p>
<ul>
<li>在信号量集中支持<strong>两个信号量</strong>，一个信号量实现对共享缓冲区的<strong>互斥访问</strong>，另外一个信号量实现对缓冲区的<strong>分配计数管理</strong></li>
</ul>
<p><strong>实现多进程工作：</strong></p>
<p>① 分别编写、编译生产者程序和消费者程序：在shell中分别执行生产者程序或消费者程序，每执行一次产生一个生产者任务（进程）或消费者任务（进程）</p>
<p>② 编写一个应用程序，通过fork创建子进程，在子进程中执行生产者的代码或消费者的代码</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><p>生产者：</p>
<ul>
<li>从**<code>producer_input.txt</code><strong>文件中读取数据放入</strong>共享内存**</li>
</ul>
<p>消费者：</p>
<ul>
<li>从<strong>共享内存</strong>中读取数据写入**<code>consumer_output.txt</code>**文件中</li>
</ul>
<p>使用信号量使进程对共享内存的访问互斥</p>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p><code>consumer7.c</code>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_KEY 107</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEM_KEY 0x107</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTPUT_PATH <span class="meta-string">&quot;/home/yang/Documents/Cprogram/Linux系统编程学习/consumer_output.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;               <span class="comment">/* value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>  <span class="comment">/* buffer for IPC_STAT &amp; IPC_SET */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>; <span class="comment">/* array for GETALL &amp; SETALL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span> <span class="comment">/* buffer for IPC_INFO */</span></span><br><span class="line">    <span class="keyword">void</span> *__pad;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> Buffer[<span class="number">5</span>][<span class="number">100</span>]; <span class="comment">// 5个缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> Index[<span class="number">5</span>];        <span class="comment">// 缓冲区状态</span></span><br><span class="line">    <span class="keyword">int</span> finish;          <span class="comment">// 是否结束</span></span><br><span class="line">    <span class="comment">//int fd_out;              //输出文件描述符</span></span><br><span class="line">    <span class="comment">// int fd_in;  //输入文件描述符</span></span><br><span class="line">    <span class="keyword">off_t</span> in_pos;    <span class="comment">// 输入文件偏移量</span></span><br><span class="line">    <span class="keyword">int</span> read_Index;</span><br><span class="line">    <span class="keyword">int</span> write_Index;</span><br><span class="line">    <span class="comment">// 0 对应的缓冲区未被生产者使用，可分配但不可消费</span></span><br><span class="line">    <span class="comment">// 非0 为index对应Buffer的数据大小 表示对应的缓冲区已被生产者使用，不可分配但可消费</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配资源</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> semid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;        <span class="comment">//信号量编号，单个信号量的编号为0</span></span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>;        <span class="comment">//信号量操作，-1 为 P操作</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO; <span class="comment">//在进程没释放信号量而退出时，系统自动释放该进程中未释放的信号量</span></span><br><span class="line">    <span class="keyword">return</span> (semop(semid, &amp;sem_b, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> semid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;        <span class="comment">//信号量编号，单个信号量的编号为0</span></span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;         <span class="comment">//信号量操作，1 为 V操作</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO; <span class="comment">//在进程没释放信号量而退出时，系统自动释放该进程中未释放的信号量</span></span><br><span class="line">    <span class="keyword">return</span> (semop(semid, &amp;sem_b, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> semid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">    <span class="keyword">return</span> (semctl(semid, <span class="number">0</span>, IPC_RMID, sem_union));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget((<span class="keyword">key_t</span>)SHM_KEY, <span class="keyword">sizeof</span>(struct BufferPool), <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;consumer : shmget error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将共享内存连接到进程</span></span><br><span class="line">    <span class="keyword">void</span> *shmaddr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (*((<span class="keyword">int</span> *)shmaddr) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;consumer : shmat error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义执行共享内存的结构体，取数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span> *<span class="title">shared</span> =</span> (struct BufferPool *)shmaddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建信号量集，信号量数量为1</span></span><br><span class="line">    <span class="keyword">int</span> semid;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">    semid = semget(SEM_KEY, <span class="number">1</span>, <span class="number">0666</span> | IPC_CREAT | IPC_EXCL);</span><br><span class="line">    <span class="keyword">if</span> (semid == <span class="number">-1</span> &amp;&amp; errno == EEXIST)</span><br><span class="line">    &#123;</span><br><span class="line">        semid = semget(SEM_KEY, <span class="number">1</span>, <span class="number">0666</span>); <span class="comment">//信号量已存在，获取信号量id</span></span><br><span class="line">        <span class="comment">// int s_tmp = semctl(semid, 0, GETVAL, sem_union);</span></span><br><span class="line">        <span class="comment">// printf(&quot;sem : %d\n&quot;, s_tmp);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//信号量刚创建，初始化信号量</span></span><br><span class="line">    &#123;</span><br><span class="line">        sem_union.val = <span class="number">1</span>;</span><br><span class="line">        semctl(semid, <span class="number">0</span>, SETVAL, sem_union);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //打开文件，用于输出</span></span><br><span class="line">    <span class="comment">// int fd = 0;</span></span><br><span class="line">    <span class="comment">// sem_p(semid);</span></span><br><span class="line">    <span class="comment">// if (shared-&gt;fd_out != 0)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     fd = shared-&gt;fd_out;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// else</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     fd = open(OUTPUT_PATH, O_WRONLY | O_CREAT | O_APPEND, 0766);</span></span><br><span class="line">    <span class="comment">//     if (fd == -1)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         perror(&quot;producer : open file error\n&quot;);</span></span><br><span class="line">    <span class="comment">//         exit(-1);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     shared-&gt;fd_out = dup(fd);;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// sem_v(semid);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(OUTPUT_PATH, O_WRONLY | O_CREAT | O_APPEND, <span class="number">0766</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;producer : open file error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_p(semid);</span><br><span class="line">        index = shared-&gt;write_Index;</span><br><span class="line">        <span class="keyword">if</span> (shared-&gt;Index[index] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = shared-&gt;Index[index];</span><br><span class="line">            write(fd, shared-&gt;Buffer[index], size);</span><br><span class="line">            shared-&gt;Index[index] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;consumer %s\n&quot;, shared-&gt;Buffer[index]);</span></span><br><span class="line">            shared-&gt;write_Index = (index + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shared-&gt;finish &amp;&amp; shared-&gt;Index[shared-&gt;write_Index] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_v(semid);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sem_v(semid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;consumer over\n&quot;</span>);</span><br><span class="line">    <span class="comment">//sleep(5);</span></span><br><span class="line">    <span class="keyword">if</span> (del_sem(semid) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Delete sem error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shmdt(shared) == <span class="number">-1</span>) <span class="comment">//解除共享内存映射</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>) <span class="comment">//删除共享内存</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Delete shm error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p><code>producer7.c</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_KEY 107</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEM_KEY 0x107</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_PATH <span class="meta-string">&quot;/home/yang/Documents/Cprogram/Linux系统编程学习/producer_input.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;               <span class="comment">/* value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>  <span class="comment">/* buffer for IPC_STAT &amp; IPC_SET */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>; <span class="comment">/* array for GETALL &amp; SETALL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span> <span class="comment">/* buffer for IPC_INFO */</span></span><br><span class="line">    <span class="keyword">void</span> *__pad;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> Buffer[<span class="number">5</span>][<span class="number">100</span>]; <span class="comment">// 5个缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> Index[<span class="number">5</span>];        <span class="comment">// 缓冲区状态</span></span><br><span class="line">    <span class="keyword">int</span> finish;          <span class="comment">// 是否结束</span></span><br><span class="line">    <span class="comment">//int fd_out;              //输出文件描述符</span></span><br><span class="line">    <span class="comment">// int fd_in;  //输入文件描述符</span></span><br><span class="line">    <span class="keyword">off_t</span> in_pos;    <span class="comment">// 输入文件偏移量</span></span><br><span class="line">    <span class="keyword">int</span> read_Index;</span><br><span class="line">    <span class="keyword">int</span> write_Index;</span><br><span class="line">    <span class="comment">// 0 对应的缓冲区未被生产者使用，可分配但不可消费</span></span><br><span class="line">    <span class="comment">// 非0 为index对应Buffer的数据大小 表示对应的缓冲区已被生产者使用，不可分配但可消费</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配资源</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> semid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;        <span class="comment">//信号量编号，单个信号量的编号为0</span></span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>;        <span class="comment">//信号量操作，-1 为 P操作</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO; <span class="comment">//在进程没释放信号量而退出时，系统自动释放该进程中未释放的信号量</span></span><br><span class="line">    <span class="keyword">return</span> (semop(semid, &amp;sem_b, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> semid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;        <span class="comment">//信号量编号，单个信号量的编号为0</span></span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;         <span class="comment">//信号量操作，1 为 V操作</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO; <span class="comment">//在进程没释放信号量而退出时，系统自动释放该进程中未释放的信号量</span></span><br><span class="line">    <span class="keyword">return</span> (semop(semid, &amp;sem_b, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_sem</span><span class="params">(<span class="keyword">int</span> semid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">    <span class="keyword">return</span> (semctl(semid, <span class="number">0</span>, IPC_RMID, sem_union));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget((<span class="keyword">key_t</span>)SHM_KEY, <span class="keyword">sizeof</span>(struct BufferPool), <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;producer : shmget error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将共享内存连接到进程</span></span><br><span class="line">    <span class="keyword">void</span> *shmaddr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (*((<span class="keyword">int</span> *)shmaddr) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;producer : shmat error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义执行共享内存的结构体，取数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span> *<span class="title">shared</span> =</span> (struct BufferPool *)shmaddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建信号量集，信号量数量为1</span></span><br><span class="line">    <span class="keyword">int</span> semid;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">    semid = semget(SEM_KEY, <span class="number">1</span>, <span class="number">0666</span> | IPC_CREAT | IPC_EXCL);</span><br><span class="line">    <span class="keyword">if</span> (semid == <span class="number">-1</span> &amp;&amp; errno == EEXIST)</span><br><span class="line">    &#123;</span><br><span class="line">        semid = semget(SEM_KEY, <span class="number">1</span>, <span class="number">0666</span>); <span class="comment">//信号量已存在，获取信号量id</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//信号量刚创建，初始化信号量</span></span><br><span class="line">    &#123;</span><br><span class="line">        sem_union.val = <span class="number">1</span>;</span><br><span class="line">        semctl(semid, <span class="number">0</span>, SETVAL, sem_union);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //打开文件，用于输入</span></span><br><span class="line">    <span class="comment">// sem_p(semid);</span></span><br><span class="line">    <span class="comment">// if (shared-&gt;fd_in == 0)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     int fd = open(INPUT_PATH, O_RDONLY);</span></span><br><span class="line">    <span class="comment">//     // printf(&quot;%d\n&quot;, fd);</span></span><br><span class="line">    <span class="comment">//     // sleep(100);</span></span><br><span class="line">    <span class="comment">//     if (fd == -1)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         perror(&quot;producer : open file error\n&quot;);</span></span><br><span class="line">    <span class="comment">//         exit(-1);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     shared-&gt;fd_in = dup2(fd, 107);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\n&quot;, shared-&gt;fd_in);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// sem_v(semid);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(INPUT_PATH, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;producer : open file error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;, shared-&gt;Index[0]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;, shared-&gt;Index[1]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;, shared-&gt;Index[2]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;, shared-&gt;Index[3]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;, shared-&gt;Index[4]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;, shared-&gt;finish);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_p(semid);</span><br><span class="line">        <span class="keyword">int</span> index = shared-&gt;read_Index;</span><br><span class="line">        <span class="keyword">if</span> (shared-&gt;Index[index] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lseek(fd, shared-&gt;in_pos, SEEK_SET);</span><br><span class="line">            <span class="keyword">int</span> size = read(fd, shared-&gt;Buffer[index], <span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                shared-&gt;finish = <span class="number">1</span>;</span><br><span class="line">                sem_v(semid);</span><br><span class="line">                close(fd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">off_t</span> currpos = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line">            shared-&gt;in_pos = currpos;</span><br><span class="line">            shared-&gt;Index[index] = size;</span><br><span class="line">            shared-&gt;read_Index = (index + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">            <span class="comment">//printf(&quot;%s&quot;, shared-&gt;Buffer[index]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        sem_v(semid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;producer over\n&quot;);</span></span><br><span class="line">    <span class="comment">//sleep(5);</span></span><br><span class="line">    <span class="keyword">if</span> (del_sem(semid) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Delete sem error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shmdt(shared) == <span class="number">-1</span>) <span class="comment">//解除共享内存映射</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>) <span class="comment">//删除共享内存</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Delete shm error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建多进程"><a href="#创建多进程" class="headerlink" title="创建多进程"></a>创建多进程</h4><p><code>pd_cs7.c</code> 创建3个生产者进程和3个消费者进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRODUCER <span class="meta-string">&quot;/home/yang/Documents/Cprogram/Linux系统编程学习/producer7&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSUMER <span class="meta-string">&quot;/home/yang/Documents/Cprogram/Linux系统编程学习/consumer7&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> producer[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> consumer[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        producer[i] = fork();</span><br><span class="line">        <span class="keyword">if</span>(producer[i] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;producer fork error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(producer[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            execl(PRODUCER, <span class="string">&quot;./producer7&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        consumer[i] = fork();</span><br><span class="line">        <span class="keyword">if</span>(consumer[i] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;consumer fork error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(consumer[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            execl(CONSUMER, <span class="string">&quot;./consumer7&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h4><p><code>producer_input.txt</code>文件内容</p>
<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220415153341103.png" alt="image-20220415153341103"></p>
<p>运行<code>pd_cs</code>创建3个生产者和3个消费者（图中有报错，没有影响）</p>
<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220415153705171.png" alt="image-20220415153705171"></p>
<p><code>consumer_output.txt</code>文件中写入的内容和<code>producer_input.txt</code>一致</p>
<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220415153753914.png" alt="image-20220415153753914"></p>
<p>创建的共享内存和信号量都在程序运行完时删除掉了（上面的报错就是因为重复删除）</p>
<p><img src="/03Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/image-20220415153920400.png" alt="image-20220415153920400"></p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><code>producer7.c</code> 和 <code>consumer7.c</code> 的 首尾是相似的</p>
<ul>
<li>创建共享内存（如果已存在则返回id）<code>shmget</code></li>
<li>连接共享内存和进程<code>shmat</code></li>
<li>创建信号量（如果已存在则返回id）<code>semget</code></li>
<li>初始化信号量为1<code>semctl</code></li>
<li>……</li>
<li>删除信号量</li>
<li>解除共享内存连接</li>
<li>删除共享内存</li>
</ul>
<p>Q1：因为进程创建多个，则初始化信号变量会有多次，这就会导致问题出现（如A进程进行了P操作，<code>semval</code>从1变为0，而B进程刚开始运行并初始化信号量<code>semval</code>为1，则A进程进行V操作后，<code>semval</code>就变为2了）</p>
<p>A1：创建信号量时使用<code>IPC_EXCL</code>，信号量已存在会直接返回并报错</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建信号量集，信号量数量为1</span></span><br><span class="line">   <span class="keyword">int</span> semid;</span><br><span class="line">   <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">   semid = semget(SEM_KEY, <span class="number">1</span>, <span class="number">0666</span> | IPC_CREAT | IPC_EXCL);</span><br><span class="line">   <span class="keyword">if</span> (semid == <span class="number">-1</span> &amp;&amp; errno == EEXIST)</span><br><span class="line">   &#123;</span><br><span class="line">       semid = semget(SEM_KEY, <span class="number">1</span>, <span class="number">0666</span>); <span class="comment">//信号量已存在，获取信号量id</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="comment">//信号量刚创建，初始化信号量</span></span><br><span class="line">   &#123;</span><br><span class="line">       sem_union.val = <span class="number">1</span>;</span><br><span class="line">       semctl(semid, <span class="number">0</span>, SETVAL, sem_union);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>Q2：使用<code>dup</code>或<code>dup2</code>实现不同进程间共享一个文件发现并不能成功，准确的说不能共享一张文件表，所以文件的偏移量不能同步</p>
<p>A2：每回从<code>producer_input.txt</code>读取数据前，从共享内存读取当前的偏移量<code>in_pos</code>，读取数据后，用<code>lseek</code>函数获取当前偏移量，更新到共享内存的<code>in_pos</code>，初始的偏移量为0，输出文件是末尾追加内存，不需要保存偏移量。</p>
<p>Q3：共享内存使用<code>char Buffer[5][100];</code>保存读取的数据，<code>int Index[5];</code>保存对应字符数组数据量的大小。但读取数据放入<code>Buffer</code>，和从<code>Buffer</code>读取数据写入文件需要同步，不然会导致顺序错乱。</p>
<p>A3：<code>read_Index</code>保存当前读取的数据要放入的<code>Buffer</code>，<code>write_Index</code>保存当前从哪个<code>Buffer</code>读取数据写入<code>consumer_output.txt</code></p>
<p>Q4：怎样确保生产者读完数据但消费者还没写完数据时，生产者不会把共享内存删除。</p>
<p>A4：？？？不清楚。上面的代码没有这方面的处理，但是好像没出问题？猜测是因为引用计数的原因，必须所有的引用都释放掉，才能删除？</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux入门</title>
    <url>/Linux%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Linux入门学习，介绍了Linux常用命令，Linux文件系统权限，进程，软件包管理，Shell编程的基础</p>
<p>学习自华为iLearnX官网</p>
<span id="more"></span>

<hr>
<h3 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h3><hr>
<h4 id="Linux内核版本"><a href="#Linux内核版本" class="headerlink" title="Linux内核版本"></a>Linux内核版本</h4><p><img src="/Linux%E5%85%A5%E9%97%A8/image-20220121152327120.png" alt="image-20220121152327120"></p>
<hr>
<h4 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h4><ul>
<li>安装程序的引导方式<ul>
<li>RHEL支持从光盘和USB存储设备引导安装程序</li>
</ul>
</li>
<li>安装程序包读取软件包的方式<ul>
<li>从光盘读取软件包进行安装是RHEL提供的缺省安装方式</li>
<li>安装程序可读取硬盘中保存的安装光盘镜像文件(ISO文件)进行安装</li>
<li>安装程序可从NFS、FTP和HTTP网络服务器中读取文件进行安装</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Linux安装过程"><a href="#Linux安装过程" class="headerlink" title="Linux安装过程"></a>Linux安装过程</h4><ul>
<li>启动安装程序<ul>
<li>设置主机引导设备为光盘驱动器</li>
<li>从安装光盘启动主机</li>
</ul>
</li>
<li>检测安装光盘的完整性</li>
<li>安装程序的配置过程<ul>
<li>安装包选择全部安装</li>
<li>划分分区，划分一个swap（物理内存两倍），个/boot(100M)和个/即可</li>
</ul>
</li>
<li>文件复制过程</li>
<li>安装过程结束</li>
</ul>
<hr>
<h4 id="Linux发行版本"><a href="#Linux发行版本" class="headerlink" title="Linux发行版本"></a>Linux发行版本</h4><ul>
<li>Linux发行版的名称和版本号是由发行版的维护者決定的<ul>
<li>RHEL4,5,6是由 Red Hat公司发布的</li>
<li>Suse Linux10是由 Novell松司发布的</li>
<li>Debian Linux3.1是由 Debian维护社区发布的</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Linux在企业中的应用"><a href="#Linux在企业中的应用" class="headerlink" title="Linux在企业中的应用"></a>Linux在企业中的应用</h4><ul>
<li>Linux作为 Internet网络服务器的应用<ul>
<li>提供Web、DNS、FTP和E-mai服务</li>
</ul>
</li>
<li>Linux作为中小企业内部服务器的应用<ul>
<li>提供网络代理、网络防火墙、DHCP和文件共享服务</li>
</ul>
</li>
<li>Linux作为桌面环境的应用<ul>
<li>可选择使用KDE、 GNOME等多种桌面环境</li>
</ul>
</li>
<li>Linux1作为软件开发环境的应用<ul>
<li>支持C、C++、PERL、PHP、JAVA和 Python语言的开发</li>
</ul>
</li>
</ul>
<hr>
<h4 id="常用shell分类"><a href="#常用shell分类" class="headerlink" title="常用shell分类"></a>常用shell分类</h4><ul>
<li>Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。是在 Linux内核与用户之间的解释器程序，现在 Linux通常指/bin/bash解释器来负责向内核翻译以及传达用户/程序指令，sheIl相当于操作系统的“外壳“</li>
<li>ksh             .profile</li>
<li>bash          .bash profile</li>
</ul>
<hr>
<h3 id="Linux常见命令介绍"><a href="#Linux常见命令介绍" class="headerlink" title="Linux常见命令介绍"></a>Linux常见命令介绍</h3><hr>
<h4 id="Linux常见命令格式"><a href="#Linux常见命令格式" class="headerlink" title="Linux常见命令格式"></a>Linux常见命令格式</h4><ul>
<li>命令名称【命令参数】【命令对象】注意，命令名称、命令参数、命令对象用空格键分割开</li>
<li>Linux命令及其参数是严格区分大小写</li>
<li>Linux文件名严格区分大小写</li>
<li>查看指令用法 man/help 命令</li>
</ul>
<hr>
<h4 id="查看文件和文件夹"><a href="#查看文件和文件夹" class="headerlink" title="查看文件和文件夹"></a>查看文件和文件夹</h4><ul>
<li><p>Is命令</p>
<ul>
<li>Is命令的功能是显示指定目录下的文件目录清单</li>
<li>相当于dos下的di命令，而且其参数更加丰富多样</li>
</ul>
</li>
<li><p>Is示例一    不带参数</p>
<ul>
<li><code>ls</code></li>
<li>功能：显示指定目录中的文件清单，如果没有指定任何目录，则默认为当前目录。</li>
</ul>
</li>
<li><p>Is示例二     显示隐含文件</p>
<ul>
<li><code>Is -a</code></li>
<li>参数-a的功能：显示隐含文件</li>
<li>说明：若文件名以 “.” 开头，则认为是隐含的，进而普通的ls命令不显示以 “.” 开头的文件；所以要完全显示某目录下的文件清单，必须加上 -a 参数オ行。</li>
</ul>
</li>
<li><p>Is示例三       长格式输出</p>
<ul>
<li><code>Is -l</code></li>
<li>参数 -l 的功能是：以长格式列表输出指定目录中的文件清单。</li>
<li>解释长格式输出的内容如下:</li>
<li>文件类型  文件权限    连接数  属主  属组  大小  日期  时间  文件名<pre><code>        d   rwxrwxr-x   2        user1 user1 4096 Aug 17 09:10  abc
</code></pre>
</li>
</ul>
</li>
<li><p>ls示例四     递归显示</p>
</li>
<li><p><code>ls -R</code></p>
</li>
<li><p>参数-R的功能是：递归显示指定目录下的文件清单，即会显示指定目录分支内各子目录中的文件清单。</p>
</li>
</ul>
<p>ls -la</p>
<p>ls -Ra /</p>
<p>ls -Ral /etc</p>
<hr>
<h4 id="查看命令使用"><a href="#查看命令使用" class="headerlink" title="查看命令使用"></a>查看命令使用</h4><p><code>name --help</code></p>
<hr>
<h4 id="显示当前路径"><a href="#显示当前路径" class="headerlink" title="显示当前路径"></a>显示当前路径</h4><ul>
<li>pwd命令</li>
<li>功能：显示当前目录</li>
</ul>
<hr>
<h4 id="新建目录"><a href="#新建目录" class="headerlink" title="新建目录"></a>新建目录</h4><ul>
<li>mkdir</li>
<li>示例一：<code>mkdir abc</code><ul>
<li>功能：在当前目录下创建目录abc</li>
</ul>
</li>
<li>示例二：创建多级目录<ul>
<li><code>mkdir -p a/b/c</code></li>
<li>功能：参数 -p 功能是如果要创建的目录的父目录，则先创建其父目录，再创建该目录；</li>
<li>如果指定的目录存在，则不影响原目录，也不会报错。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><ul>
<li><p>touch</p>
</li>
<li><p>示例一：创建空文件</p>
<ul>
<li><code>touch myfile</code></li>
<li>功能：如果myfile不存在，则创建一个大小为0字节名为myfile的空文件</li>
</ul>
</li>
<li><p>示例二：改变文件的最后修改时间</p>
<ul>
<li><code>touch myfile</code></li>
<li>功能：如果myfile已存在，则将改变myfile的最后修改时间。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h4><ul>
<li>cp</li>
<li>示例一：复制文件<ul>
<li><code>cp /etc/php.* abc</code></li>
<li>功能：将 /etc 目录下以 php. 开头的文件复制到目录abc中</li>
<li>说明：”*” 是通配符，可以匹配多个字符；”?”只能匹配一个字符</li>
<li>增加参数 -r 忽略文件夹</li>
</ul>
</li>
<li>示例二：复制目录<ul>
<li><code>cp -R /etc abc</code></li>
<li>功能：增加了参数-R，就能将目录 /etc 下面的所有子目录和文件都能复制到目录abc中</li>
</ul>
</li>
</ul>
<hr>
<h4 id="文件移动"><a href="#文件移动" class="headerlink" title="文件移动"></a>文件移动</h4><ul>
<li><p>mv</p>
</li>
<li><p>示例一：将文件移动到目录中</p>
<ul>
<li><code>mv myfile mydir1</code></li>
<li>功能：如果mydir1存在且是个目录，则将文件myfile移动到目录mydir1中</li>
</ul>
</li>
<li><p>示例二：修改文件名</p>
<ul>
<li><code>mv myfile myfile2</code></li>
<li>功能：将文件（或目录）myfile改名为myfile2</li>
</ul>
</li>
</ul>
<hr>
<h4 id="删除空目录"><a href="#删除空目录" class="headerlink" title="删除空目录"></a>删除空目录</h4><ul>
<li>rmdir</li>
<li><code>rmdir -p mydir</code><ul>
<li>功能：删除指定的空目录</li>
<li>-p 递归删除目录mydir1，当子目录删除后其父目录为空是，也一并删除。如果整个路径被删除或由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul>
<li><p>rm</p>
</li>
<li><p>示例一：删除文件</p>
<ul>
<li><code>rm php.ini</code></li>
<li>功能：删除指定的文件php.ini</li>
</ul>
</li>
<li><p>示例二：删除目录</p>
<ul>
<li><code>rm -rf abc</code></li>
<li>功能：参数 -r 是递归的意思，即可以删除非空目录；参数 -f 是强制的意思。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="显示文件内容"><a href="#显示文件内容" class="headerlink" title="显示文件内容"></a>显示文件内容</h4><ul>
<li><p>cat</p>
</li>
<li><p>示例一：显示文件内容</p>
<ul>
<li><code>cat myfile</code></li>
<li>功能：显示指定文件myfile的内容</li>
</ul>
</li>
<li><p>示例二：创建文件</p>
<ul>
<li><code>cat &gt; myfile2</code></li>
<li>Welcome to Linux World!</li>
<li>按 ctrl+d 结束输入</li>
<li>功能：利用输出重定向符 “&gt;” 来创建简短的文本文件 myfile2 。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="分屏显示"><a href="#分屏显示" class="headerlink" title="分屏显示"></a>分屏显示</h4><ul>
<li>more 和 less 命令<ul>
<li><code>more /etc/httpd/conf/httpd.conf</code></li>
<li>功能：分屏显示指定问津 httpd.conf 的内容，非常适合显示超过一屏的文本文件。每按一下空格键，向后翻一屏；每按一下回车键，向后翻一行。</li>
<li>说明：与more功能很相似，只不过less功能更强大，支持PageUp键向前翻屏，及PageDown向后翻屏，按q退出</li>
</ul>
</li>
</ul>
<hr>
<h4 id="显示文件头内容"><a href="#显示文件头内容" class="headerlink" title="显示文件头内容"></a>显示文件头内容</h4><ul>
<li>head</li>
<li>示例一：显示文件头10行内容<ul>
<li><code>head /etc/httpd/conf/httpd.conf</code></li>
<li>功能：默认显示指定文件的头10行的内容</li>
</ul>
</li>
<li>示例二：显示文件头n行内容<ul>
<li><code>head -n 19 /etc/httpd/conf/httpd.conf</code></li>
<li>功能：参数-n设置显示指定行数</li>
</ul>
</li>
</ul>
<hr>
<h4 id="显示文件最后内容"><a href="#显示文件最后内容" class="headerlink" title="显示文件最后内容"></a>显示文件最后内容</h4><ul>
<li>tail</li>
<li>示例一：显示文件最后10行<ul>
<li><code>tail /etc/httpd/conf/httpd.conf</code></li>
<li>功能：默认显示指定文件的末尾10行内容</li>
</ul>
</li>
<li>示例二：显示文件末尾n行内容<ul>
<li><code>tail -n 19 /etc/httpd/conf/httpd.conf</code></li>
<li>功能：参数-n设置显示指定行数</li>
</ul>
</li>
</ul>
<hr>
<h4 id="建立硬连接和软连接"><a href="#建立硬连接和软连接" class="headerlink" title="建立硬连接和软连接"></a>建立硬连接和软连接</h4><ul>
<li><p>ln    建立硬连接</p>
<ul>
<li><code>ln myfile myfile.hlink</code></li>
<li>功能：为文件myfile创建名为myfile.hlink的硬连接</li>
</ul>
</li>
<li><p>ls -il</p>
</li>
<li><p>说明：通过 ls -il 命令可以看出myfile与myfile.hlink的i节点号（最左边的数）是一样的，即硬连接与原文件共用同一个i节点，请注意两个文件的连接数。</p>
</li>
<li><p>ln     建立软连接</p>
<ul>
<li><code>ln -s myfile myfile.slink</code></li>
<li>功能：为文件myfile创建名为myfile.slink的软连接</li>
<li>说明：试试用rm命令删除myfile文件，注意观察连接数的变化，再分别访问myfile.hlink和myfile.slink，看看是否能够正常访问。</li>
<li>软连接myfile.slink无效了</li>
</ul>
</li>
</ul>
<hr>
<h4 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h4><ul>
<li>which</li>
<li>示例<ul>
<li><code>which cp</code></li>
<li><code>which updatedb</code></li>
<li>功能：显示命令的绝对路径</li>
<li>注意：该命令只能在命令搜索路径指定的目录中去查找命令或程序</li>
</ul>
</li>
<li>whereis</li>
<li>示例<ul>
<li><code>whereis ln</code></li>
<li>功能：查询指定命令所在目录以及帮助文档所在目录</li>
</ul>
</li>
</ul>
<hr>
<h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><ul>
<li>su</li>
<li>示例：<ul>
<li><code>su - root</code></li>
<li>功能：切换当前用户的身份</li>
<li>su命令带有参数 “-” ，其含义是改变身份的同时也改变了工作环境</li>
</ul>
</li>
</ul>
<hr>
<h4 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h4><ul>
<li>find</li>
<li>示例——按文件名查找<ul>
<li><code>find / -name &quot;dhcpd*&quot;</code></li>
<li>功能：参数 -name 指明按文件名进行查找，即从 / 目录开始查找以”dhcpd”开头的所有文件</li>
</ul>
</li>
<li>示例——按文件大小查找<ul>
<li><code>find /etc -size 8</code></li>
<li>功能：从 /etc 下开始查找大小为8块的文件，此处默认512字节为1块。若认为块大小为1k，则应写为8k。</li>
<li>其它可以使用的单位有 c（字节）、w（双字节）、M（兆字节）、和 G（吉字节）。</li>
</ul>
</li>
<li>示例——按文件类型查找<ul>
<li><code>find /var -type d -print</code></li>
<li>功能：从 /var 目录下开始查找类型为目录的文件，其中参数 -print 是显示到屏幕上，经常省略</li>
</ul>
</li>
<li>示例——按文件的修改时间查找<ul>
<li><code>find . -cmin -5</code></li>
<li>功能：从当前目录下查找5分钟之内修改过的文件</li>
<li>如果把 “-5” 改为 “+5” ，则表示查找5分钟以前修改过的文件。不带 ”+“ 或 ”-“ ，则认为整5分钟。</li>
<li>如果把时间单位改为天，则使用参数 “-ctime” ， 如：<code>find . -ctime -5</code></li>
</ul>
</li>
<li>示例——按文件的权限查找<ul>
<li><code>find mytmp -perm 755</code></li>
<li>功能：查找mytmp目录下的权限恰为755的文件</li>
<li><code>find mytmp -perm -755</code></li>
<li>功能：查号mytmp目录下的满足755中任何一种权限的文件，即符合任何一个指定的权限位即可</li>
<li><code>find mytmp -perm +755</code></li>
<li>查找mytmp目录下的权限至少满足755的文件，即指定的所有权限位必须符合才算满足查询条件</li>
</ul>
</li>
<li>示例——多条件查询<ul>
<li><code>find / -ctime -5 -a -name &quot;*.conf&quot;</code></li>
<li>功能：查找5天以内修改过的所有 .conf 的文件</li>
<li>说明：默认情况下各查询条件之间是“与”的关系，也可用 -a 或 -and 来表示；-o表示“或”；! 表示“非”。</li>
<li><code>find . \(-type f -or type | \) -ok rm &#123;&#125; \;</code></li>
<li>功能：从当前目录下开始查找普通文件或符号连接文件，针对找到的每个文件，在执行rm命令之前提问是否要执行该命令。</li>
<li>其中 <code>\(\)</code>是优先符号，参数 “-ok” 比 ”-exec” 多了交互功能 </li>
</ul>
</li>
</ul>
<hr>
<h4 id="文件内容操作"><a href="#文件内容操作" class="headerlink" title="文件内容操作"></a>文件内容操作</h4><ul>
<li><code>grep</code></li>
<li>示例——在指定文件中查找包含特定的字符串的行<ul>
<li><code>grep &quot;bind&quot; host.conf</code></li>
<li>功能：在文件host.conf中查找包含字符串 “bind” 行。</li>
<li><code>grep &quot;network&quot; /etc/*.conf</code></li>
<li>功能：利用通配符可在多个文件中查找包含特定的字符串的行。</li>
</ul>
</li>
<li>示例——查找不包括指定字符串的行<ul>
<li> <code>grep -v &quot;network&quot; /etc/nsswitch.conf</code></li>
<li>功能：查找 /etc/nsswitch.conf 文件中不包含字符串 “network” 的行。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="统计指令"><a href="#统计指令" class="headerlink" title="统计指令"></a>统计指令</h4><ul>
<li><code>wc</code>   </li>
<li>示例——统计指定文件的行数、单词数和字符数<ul>
<li><code>wc /etc/nsswitch.conf</code></li>
<li>功能：统计出文件 /etc/nswwitch.conf 共有行数、单词数、字符数。</li>
</ul>
</li>
<li>示例——参数使用<ul>
<li><code>wc -l /etc/nsswitch.conf</code></li>
<li>功能：参数 <code>-l</code> 的功能可统计出指定文件的行数。另外，利用参数 <code>-w</code> 统计单词，利用 <code>-c</code> 统计字符数</li>
</ul>
</li>
</ul>
<hr>
<h4 id="按正序逆序输出"><a href="#按正序逆序输出" class="headerlink" title="按正序逆序输出"></a>按正序逆序输出</h4><ul>
<li><code>sort</code></li>
<li>示例——按正序输出<ul>
<li><code>sort mytest</code></li>
<li>功能：将指定文件以行为单位按正序输出</li>
</ul>
</li>
<li>示例——按逆序输出<ul>
<li><code>sort -r mytest</code></li>
<li>功能：将指定文件以行为单位按逆序输出</li>
</ul>
</li>
</ul>
<hr>
<h4 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h4><ul>
<li><code>diff</code></li>
<li>示例<ul>
<li><code>diff test mytest</code></li>
<li>功能：比较文件 test 与 mytest 是否相同，将不同之处输出到屏幕上</li>
</ul>
</li>
</ul>
<hr>
<h4 id="压缩打包命令和解压缩"><a href="#压缩打包命令和解压缩" class="headerlink" title="压缩打包命令和解压缩"></a>压缩打包命令和解压缩</h4><ul>
<li><p><code>tar</code></p>
</li>
<li><p>tar命令是经典的备份/还原命令，几乎所有最新的软件包都是通过tar包发布的</p>
</li>
<li><p>示例——打包（备份）</p>
<ul>
<li><code>tar -cvf myetc.tar /etc</code></li>
<li>参数 -c    打包（创建）</li>
<li>参数 -v   显示处理过程</li>
<li>参数 -f    指定文档名</li>
<li>功能：将目录 /etc 打包为一个名为myetc.tar的文档</li>
</ul>
</li>
<li><p>示例——打包（备份）并压缩</p>
<ul>
<li><code>tar -zcvf myetc.tar.gz /etc</code></li>
<li>功能：将目录 /etc 打包并压缩为一个名为 myetc.tar.gz 的文档</li>
<li>参数 -z    调用 gzip 命令压缩，扩展名为gz</li>
<li>参数 -Z    调用 compress 命令来压缩，扩展名为Z</li>
<li>参数 -j      调用 bzip2 命令来压缩，扩展名为bz2</li>
</ul>
</li>
<li><p>示例——解压缩还原</p>
<ul>
<li><code>tar -zxvf myetc.tar.gz</code></li>
<li>功能：参数 -c 换成 -x 即可实现还原释放的功能</li>
<li>说明：未指明还原位置，将会还原在当前目录下</li>
<li><code>tar -zxvf myetc.tar.gz -C /tmp</code></li>
<li>参数 -C 可指明还原位置</li>
</ul>
</li>
</ul>
<p>gzip 命令</p>
<ul>
<li>示例<ul>
<li><code>gzip myetc.tar</code></li>
<li>功能：将文件 myetc.tar 压缩为 myetc.tar.gz</li>
</ul>
</li>
</ul>
<p>gunzip 命令</p>
<ul>
<li>示例<ul>
<li><code>gunzip myetc.tar.gz</code></li>
<li>功能：将文件 myetc.tar.gz 解压缩为 myetc.tar</li>
</ul>
</li>
</ul>
<hr>
<h4 id="挂载与卸载命令"><a href="#挂载与卸载命令" class="headerlink" title="挂载与卸载命令"></a>挂载与卸载命令</h4><ul>
<li>mount 命令</li>
<li>示例——挂载光盘<ul>
<li><code>mount -t iso9660 /dev/cdrom /mnt/cdrom</code></li>
<li>功能：参数 -t 指明要挂载的文件系统的类型，设备文件，挂载点</li>
<li>本例：将光盘挂载到 /mnt/cdrom 目录下，其中光盘文件系统类型是 iso9660</li>
</ul>
</li>
<li>示例——挂载U盘<ul>
<li><code>mount -t vfat /dev/sda1 /mnt/myusb</code></li>
<li>功能：将文件系统类型为 vfat 的U盘 挂载到 /mnt/myusb 目录下</li>
<li>说明：vfat 针对的是 FAT32、FAT16文件系统；U盘采用与 SCSI 硬盘相同的设备文件；</li>
<li>注意：一般在挂载U盘前，先执行  <code>fdisk -l</code> 命令</li>
</ul>
</li>
<li>示例——挂载软盘<ul>
<li><code>mount -t msdos /dev/fd0 /mnt/floppy</code></li>
<li>功能：将软盘挂载到 /mnt/floppy 目录下，软盘的文件系统类型一般为 msdos</li>
<li>说明：挂载点不一定必须在 /mnt 下，它可以是任意一个空目录</li>
</ul>
</li>
<li>umount 命令</li>
<li>示例<ul>
<li><code>umount /mnt/cdrom</code></li>
<li>功能：卸载光盘文件系统</li>
<li>说明：在卸载文件系统时可以使用设备文件或挂载点。</li>
<li>切记，一定要在挂载点之外，才能卸载相应的设备（文件系统）</li>
</ul>
</li>
</ul>
<hr>
<h4 id="网卡配置命令"><a href="#网卡配置命令" class="headerlink" title="网卡配置命令"></a>网卡配置命令</h4><ul>
<li><code>ifconfig</code> </li>
<li>示例——显示接口（网卡）配置参数<ul>
<li><code>ifconfig</code></li>
<li>功能：显示网卡参数的配置情况，包括IP地址、子网掩码、广播地址等</li>
</ul>
</li>
<li>示例——设置接口（网卡）配置参数<ul>
<li><code>ifconfig eth0 10.22.1.103 netmask 255.255.255.0</code></li>
<li>功能：设置网卡 eth0 的IP地址为 10.22.1.103、掩码为255.255.255.0</li>
<li>说明：eth0 是系统中第1块以太网卡的名称，eth1是系统中第2块以太网卡的名称，以此类推。 Io 是环回测试网卡的名称</li>
</ul>
</li>
<li>示例——禁用某块网卡<ul>
<li><code>ifconfig eth0 down</code></li>
<li>功能：禁用网卡 eth0</li>
<li>说明：此时再用不带参数的ifconfig命令是不能显示 eth0 的信息，需要加上参数 -a 才可显示被禁用的网卡信息</li>
</ul>
</li>
<li>示例——激活某张网卡<ul>
<li><code>ifconfig eth0 up</code></li>
<li>功能：激活网卡 eth0</li>
</ul>
</li>
</ul>
<hr>
<h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4><ul>
<li>man</li>
<li>示例——查看指定命令的帮助<ul>
<li><code>man rpm</code></li>
<li>功能：查看 rpm 命令的帮助手册</li>
<li>说明：按q键退出man环境</li>
</ul>
</li>
<li>示例——查询指定关键字的所有分类<ul>
<li><code>man -a chroot</code></li>
<li>功能：查看关于chroot的所有分类帮助手册</li>
</ul>
</li>
<li>示例——查询特定分类的帮助<ul>
<li><code>man 5 named.conf</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="定时任务命令"><a href="#定时任务命令" class="headerlink" title="定时任务命令"></a>定时任务命令</h4><ul>
<li>crontab</li>
<li>示例——查看任务列表<ul>
<li><code>crontab -l</code></li>
<li>功能：查看crontab的任务列表</li>
</ul>
</li>
<li>示例——编辑任务列表<ul>
<li><code>crontab -e</code></li>
<li>功能：利用参数 -e 可以进入crontab的编辑环境，可以设置任务列表</li>
<li>说明：crontab任务列表的格式</li>
<li>分         时           日          月         星期           命令</li>
<li>10         2             *           *               *            /root/bin/mybackup.sh</li>
<li>含义：每天的凌晨2:10 执行 /root/bin/mybackup.sh程序</li>
</ul>
</li>
<li> 使用 crontab 之前首先得确保服务是开启的</li>
<li><code>service crond status</code>  查看状态</li>
<li><code>service crond start</code>    开启服务</li>
<li>监控执行  <code>tail -f /var/log/cron</code><ul>
<li>如果发现 cron 文件为空，那服务可能没有开启</li>
<li><code>service rsyslog status</code>   查看状态</li>
<li><code>service rsyslog start</code>     开启服务</li>
</ul>
</li>
<li>如果rsyslog没有开启，还可以通过邮件查看<ul>
<li><code>tail -f /var/spool/mail/root</code></li>
<li>linux 系统邮件功能：/var/spool/mail/root   如果写不进去，可能root文件内容过多，删除以下就好</li>
</ul>
</li>
</ul>
<hr>
<h4 id="反引号命令"><a href="#反引号命令" class="headerlink" title="反引号命令"></a>反引号命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill `cat /var/run/xinetd.pid`</span><br></pre></td></tr></table></figure>

<ul>
<li><p>功能：杀掉xinetd进程</p>
</li>
<li><p>说明：该命令行由两个命令组成，首先要执行的是反引号内的命令，这里解释一下文件/var/run/ xinetd.pid中存放的是 xinetd的进程号，cat的执行结果就是显示该文件的内容，即进程号；然后，再执行kill命令来杀掉相应的进程。</p>
</li>
</ul>
<hr>
<h4 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h4><ul>
<li>date命令</li>
<li>示例——显示时间日期<ul>
<li><code>date</code></li>
<li>功能：显示系统当前的时间日期。</li>
</ul>
</li>
<li>date命令的参数很多</li>
<li><code>date +%y</code></li>
<li>示例——设置时间日期<ul>
<li><code>date -s&quot;20060901 13:41&quot;</code></li>
<li>功能：将系统的日期设置为2006年9月1日，时间设置为13:41。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="显示磁盘空间情况"><a href="#显示磁盘空间情况" class="headerlink" title="显示磁盘空间情况"></a>显示磁盘空间情况</h4><ul>
<li><p>df 命令</p>
</li>
<li><p>示例一一显示文件系统使用磁盘空间的情况</p>
<ul>
<li><code>df</code></li>
<li>功能：显示系统中每个文件系统使用磁盘空间的情況。</li>
</ul>
</li>
<li><p>示例——以习惯的阅读方式显示文件系统使用磁盘空间的情况</p>
<ul>
<li><code>df -h</code></li>
<li>功能：加上参数-h,则可以按照人们习惯的阅读方法来显示系统中每个文件系统使用磁盘空间的情况</li>
</ul>
</li>
<li><p>du命令</p>
</li>
<li><p>示例——显示指定目录中每个文件占用的磁盘空间的大小</p>
<ul>
<li><code>du /etc</code></li>
<li>功能：显示出/etc目录中每个文件占用磁盘空间的大小</li>
</ul>
</li>
<li><p>示例——显示指定目录总共占用的磁盘空间大小</p>
<ul>
<li><code>du -sh /etc</code></li>
<li>功能：参数-s表示汇总，本例的功能为按照人们习惯的阅读方法显示/etc目录中所用文件总共占用的磁盘空间大小。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道 |"></a>管道 |</h4><ul>
<li>管道示例—— 一级管道<ul>
<li><code>ls -l | grep &quot;^l&quot;</code></li>
<li>功能：以长格式显示当前目录下的符号连接文件。该命令行首先执行 ls -l,并把其结果当作grep “^l”命令的输入文件，其中 “^l” 表示以1开头。</li>
</ul>
</li>
<li>管道示例—— 多级管道<ul>
<li><code>ls -la | grep &quot;^1&quot; | wc -l</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h4><ul>
<li>示例——覆盖方式<ul>
<li><code>sort -r a.txt &gt; b.txt</code></li>
<li>功能：把a.txt文件按行逆序排序并重定向输出到文件b.txt中；若b.txt已存在，则覆盖掉原内容，若不存在，则创建之。</li>
</ul>
</li>
<li>示例——追加方式<ul>
<li><code>sort -r a.txt &gt;&gt; b.txt</code></li>
<li>功能：”&gt;&gt;”的功能是按追加方式进行输出重定向；若b.txt已存在，则在该文件末尾追加新内容，若不存在，则创建之。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h4><ul>
<li><p>示例—— “&lt;” </p>
<ul>
<li><code>more &lt; /etc/httpd/conf/httpd.conf</code></li>
<li>功能：上述命令与 <code>more /etc/httpd/conf/httpd.conf</code> 的结果是一样。</li>
<li>说明：很多命令与more一样可以使用输入重定向符，也可以不用，如cat、wc、less等。</li>
</ul>
</li>
<li><p>示例—— “&lt;&lt;”</p>
<ul>
<li>```<br>cat &lt;&lt;! &gt;a.txt<blockquote>
<p>hello<br>world<br>!</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 功能：将 &quot;!&quot;之间的内容重定向到a.txt文件中去，不包括 &quot;!&quot;。</span><br><span class="line"></span><br><span class="line">  - 说明：这是一个组合使用输入输出重定向的例子，其中 &quot;!&quot; 是定界符，其它字符也可以充当定界符。</span><br><span class="line"></span><br><span class="line">  - 注意：&quot;!&quot; 与后面的 &quot;&gt;&quot; 之间至少要有一个空格。这是一种非常经典的用法，可以用在she‖编程环境中。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### vi 编辑器</span><br><span class="line"></span><br><span class="line">ⅵ编辑器是 Linux和Unix上最基本的文本编辑器，工作在字符模式下。由于不需要图形界面，vi是效率很高的文本编辑器。尽管在 Linux上也有很多图形界面的编辑器可用，但vi在系统和服务器管理中的功能是那些图形编辑器所无法比拟的。</span><br><span class="line"></span><br><span class="line">vi 有三种工作方式：命令模式 (Command mode) ，输入模式 (Insert mode) 和 底线命令模式 (Last line mode)</span><br><span class="line"></span><br><span class="line">![image-20220129164752774](Linux入门/image-20220129164752774.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 光标相对移动n行</span><br><span class="line">  - 光标从当前位置下移 n 行，直接敲数字  `n ENTER`，或者输入 `n +` </span><br><span class="line">  - 上移 n 行，输入 `n -`</span><br><span class="line">- d命令——删除行</span><br><span class="line">  -  `dd` 删除当前行</span><br><span class="line">  - `n dd`从当前行开始连续删除 n 行，包括当前行</span><br><span class="line">- y命令——复制行</span><br><span class="line">  - `yy` 复制当前行</span><br><span class="line">  - `n yy` 从当前开始连续复制 n 行，包括当前行</span><br><span class="line">- p命令——粘贴</span><br><span class="line">  - `p` 粘贴在当前行的下方</span><br><span class="line">  - `n p` 在当前行的下方连续粘贴 n 遍</span><br><span class="line">- 显示/隐藏行号</span><br><span class="line">  - `:set number`   显示行号</span><br><span class="line">  - `:set nonumber`  隐藏行号</span><br><span class="line">- 存盘</span><br><span class="line">  - `:w`     存盘</span><br><span class="line">  - `ZZ` 或 `:wq`    存盘并退出</span><br><span class="line"></span><br><span class="line">- 退出——q命令</span><br><span class="line"></span><br><span class="line">  - `:q`  退出</span><br><span class="line">  - `:q!`   不保存修改退出</span><br><span class="line"></span><br><span class="line">- 查找</span><br><span class="line"></span><br></pre></td></tr></table></figure>
/字符串 ENTER        向后查找指定的字符串<br>/ ENTER             向后查找上一次查找的内容<br>?字符串              向前查找字符串<br>?                   向后查找上一次查找的内容</li>
</ul>
<p>n                    查找方向的下一个字符串<br>N                    查找方向反向的下一个字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- vi光标移动与翻页</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>光标移动<br>h    向左移动<br>l    向右<br>k    向上<br>j    向下</p>
<p>翻页<br>ctrl+f        向前翻整页<br>ctrl+b        向后翻整页<br>ctrl+u        向前翻半页<br>ctrl+d        向后翻半页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- vi进入输入模式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>i    当前光标处 进入插入状态<br>a    当前光标后 进入插入状态<br>A    光标移动到当前行末，进入插入状态<br>o    当前行下面插入新行，进入插入状态<br>O    当前行上面插入新行，进入插入状态<br>cw    删除当前光标至所在单词尾部的字符，进入插入状态<br>c$    删除当前光标至行尾的字符，进入插入状态<br>c^    删除当前光标之前至行首的字符，进入插入转态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- vi 删除操作</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>x    删除光标处的单个字符<br>dd    删除光标所在行<br>dw    删除当前字符至单词尾的所有字符，包括空格<br>de    删除当前字符至单词尾的所有字符，不包括空格<br>d$    删除当前字符至行尾的所有字符<br>d^    删除当前字符至行首的所有字符<br>J    删除行尾的换行符，相当于合并当前行和下一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### Linux文件系统权限</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 文件系统</span><br><span class="line"></span><br><span class="line">文件系统用来存放和管理所有系统使用的文件和数据，其载体是软盘或硬盘分区。一个软盘或硬盘分区在作为文件系统使用时，必须进行初始化，并将如何组织文件的数据结构写到这些介质上，这个过程就是建立文件系统过程。</span><br><span class="line"></span><br><span class="line">Linux的文件系统是树形结构，所有的文件和目录都是树上的节点，树的根就是整</span><br><span class="line">个文件系统的最顶层目录，即根目录。文件连接到目录，目录再连接到上一层目录，所有的文件和目录最终都归结到根目录，形成整个文件系统。</span><br><span class="line"></span><br><span class="line">Linux使用一个统一的接口支持多种文件系统，每种文件系统都有各自的格式和特征(如文件名长度、最大文件大小等)。目前， Linux支持的文件系统类型MINIX、EXT、EXT2、EXT3、proc、hpfs、nfs、 isofs、 msdos fat、vfat、ntfs、</span><br><span class="line">umsdos、 xiafs 及 sysv 等。 Red Hat Linux默认的文件系统是 ext3。</span><br><span class="line"></span><br><span class="line">第一个专门为 Linux设计的文件系统被称为扩展文件系统( Extended File System)或EXT。它出现于1992年4月，但性能不太好。1993年扩展文件系统第二版ext2被设计出来并添加 Linux中。ext2是一个强大的可扩展文件系统，被认为是当时最成功的 Linux文件系统。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### ext3文件系统的特性</span><br><span class="line"></span><br><span class="line">- 可用性</span><br><span class="line">  - 除非发生硬件故障，即使非法关机，ext3也不需要文件系统校验</span><br><span class="line">- 数据完整性</span><br><span class="line">  - ext3文件系统在非法关机是，数据完整性能得到可靠的保障</span><br><span class="line"></span><br><span class="line">- 速度</span><br><span class="line">  - 尽管ext3写入数据的次数多于ext2，但是ext3常常快于ext2</span><br><span class="line"></span><br><span class="line">- 简易转换</span><br><span class="line">  - ext可以容易地不经格式化把ext2转换为ext3系统，体现了可靠的日志文件系统的优越性</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### Linux的文件系统结构</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20220129213503119](Linux入门/image-20220129213503119.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- `/home` 用户的主目录，比如说有个用户叫`wang`,那他的主目录就是 `/home/wang`</span><br><span class="line">- `/lib` 这个目录里存放着系统最基本的动态链接共享库，其作用类似于 `Windows` 里的 `.dll`文件。几乎所有的应用程序都需要用到这些共享库。</span><br><span class="line">- `/mnt` 这个目录是空的，系统提供这个目录是让用户临时挂载别的文件系统。</span><br><span class="line">- `/proc` 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访可这个目录来获取系统信息</span><br><span class="line">- `/root` 系统管理员，超级权限者的用户主目录</span><br><span class="line">- `/sbin`  s 就是Super User的意思，也就是说这里存放的是一些系统管理员使用的系统管理程序</span><br><span class="line">- `/tmp` 用来存放一些临时文件的地方</span><br><span class="line">- `/usr` 这是个最庞大的目录，我们要用到的很多应用程序和文件几乎都存放在这个目录下。</span><br><span class="line">- `/var` 这个目录中存放着经常变动的文件，为了保持`/usr`的相对稳定，那些经常被修改的目录可以放在这个目录下。系统的日志文件就在`/var/log`目录中。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 常见文件所在目录</span><br><span class="line"></span><br><span class="line">- hosts                                    `/etc`</span><br><span class="line">- 全局profile                          `/etc`</span><br><span class="line">- 日志文件                               `/var/log/message`</span><br><span class="line">- 用户环境变量                        `~/.bash_profile`或者`~/.profile`等</span><br><span class="line">- 用户文件                                `/etc/passwd`</span><br><span class="line">- 组对应文件                            `/etc/group`</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 文件名与文件类型</span><br><span class="line"></span><br><span class="line">文件名是一个文件的标识。 Red Hat Linux系统中的文件名的命名规则与 Windows系统基本相同。它同样是由字母、数字、下划线、圆点等组成，最长不能超过255个字符。在 Red Hat Linux系统中，没有像 Windows系统那样明显的扩展名，但它对字母大小写是严格区分的。</span><br><span class="line"></span><br><span class="line">Linux有四种基本文件系统类型：</span><br><span class="line"></span><br><span class="line">- 普通文件：如文本文件、C语言源代码、Shel脚本、二进制的可执行文件等。</span><br><span class="line">- 目录文件：包括文件名、子目录名及其指针。它是 Linux储存文件名的唯一地方。</span><br><span class="line">- 链接文件：它是一个文件的第二个名字，这是针对多用户共享同一文件而产生的文件。</span><br><span class="line">- 特殊文件：Linux的一些设备如磁盘、终端、打印机等都在文件系统中表示出来，这类文件就是特殊文件，常放在`/dev`目录内。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>[user1@server1 ~]$ ls -l<br>drwxrwxr-x 2 user1 user1 4096 Aug 17 09:10 abc</p>
</li>
<li><p>：普通文件<br>d ：目录文件，在Linux中目录也是文件，不仅如此，实际上在Linux中任何设备也可以被当作文件处理<br>l ：符号连接文件<br>b ：快设备文件<br>  如硬盘的设备文件/dev/hda，其中字母a表示第一块，h表示IDE类型的硬盘，SCSI类型的硬盘用s表示<br>  分区也有相对应的设备文件，如/dev/sdb3，表示第2块SCSI硬盘上的第三个分区<br>  U盘也采用SCSI硬盘的设备文件名来命名<br>c ：表示字符设备文件，如/dev/tty1<br>p ：表示管道文件<br>s ：表示套接字文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 文件权限</span><br><span class="line"></span><br><span class="line">Linux文件有三种典型的权限 `rwx`</span><br><span class="line"></span><br><span class="line">- r（读权限 4）</span><br><span class="line">- w（写权限 2），</span><br><span class="line">- x（执行权限 1）</span><br><span class="line"></span><br><span class="line">示例说明：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>[user1@server1 ~]$ ls -l<br>drwxrwxr-x 2 user1 user1 4096 Aug 17 09:10 abc</p>
</li>
</ul>
<p>在长格式输出中文件类型的后面有9位权限位，实际上这是针对不同用户而设定的，如下所示。</p>
<p>属主的权限    属组的权限    其他用户的权限<br>  rwx         rwx          r-x<br>4+2+1=7        4+2+1=7        4+0+1=5</p>
<p>所以abc这个文件夹（d 表明abc是文件夹）的权限就是775</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**修改权限**</span><br><span class="line"></span><br><span class="line">- `chmod`命令</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<pre><code>chmod [who] operator [permission] filename
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `who`的含义：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<p>  u  文件属主权限<br>  g   同组用户权限<br>  o   其他用户权限<br>  a   所有用户权限（文件属主、同组用户、其他用户），默认值<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `operator` 的含义：</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li>   增加权限，原权限基础上增加指定权限</li>
</ul>
<ul>
<li>取消权限，原权限基础上去掉指定权限<br>=    设定权限，会覆盖原权限<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `permission` 的含义：</span><br><span class="line"></span><br><span class="line">  - r 读权限</span><br><span class="line">  - w 写权限</span><br><span class="line">  - x 执行权限</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">[root@CentOS8 ~]# ls -l myfile</span><br><span class="line">-rwxr-xr-x. 1 root root 225 1月  29 17:20 myfile</span><br><span class="line">[root@CentOS8 ~]# chmod -x myfile</span><br><span class="line">[root@CentOS8 ~]# ls -l myfile</span><br><span class="line">-rw-r--r--. 1 root root 225 1月  29 17:20 myfile</span><br><span class="line">[root@CentOS8 ~]# chmod u+x myfile</span><br><span class="line">[root@CentOS8 ~]# ls -l myfile</span><br><span class="line">-rwxr--r--. 1 root root 225 1月  29 17:20 myfile</span><br><span class="line"></span><br><span class="line">[root@CentOS8 ~]# chmod g-w,o=x host.conf</span><br><span class="line">[root@CentOS8 ~]# chmod 764 host.conf</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>文件属主和修改</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看属主</span><br><span class="line"></span><br><span class="line">[root@CentOS8 ~]<span class="comment"># ls -al test</span></span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 2 oracle dba  256 Mar 05 15:09 .</span><br><span class="line">drwxr-xr-x 5 oracle dba 4096 Mar 05 15:02 ..</span><br><span class="line">-rwxr-xr-x 1 oracle dba    0 Mar 05 15:09 1.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>文件夹属主为 oracle:dba</span><br><span class="line"></span><br><span class="line">修改属主</span><br><span class="line"></span><br><span class="line">若把<span class="built_in">test</span>文件属主修改为 ta4:dba，命令如下</span><br><span class="line">[root@CentOS8 ~]<span class="comment"># chown ta4:dba test</span></span><br><span class="line"></span><br><span class="line">若把<span class="built_in">test</span>文件夹所有文件以及文件夹属主修改为 ta4:dba，命令如下</span><br><span class="line">[root@CentOS8 ~]<span class="comment"># chown -R ta4:dba test</span></span><br><span class="line">-R  表示递归，即可以深入到指定目录中的每一层</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Linux用户和用户组"><a href="#Linux用户和用户组" class="headerlink" title="Linux用户和用户组"></a>Linux用户和用户组</h3><hr>
<h4 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h4><p>Linux用户只有两个等级：<code>root</code> 及 <code>非root</code></p>
<p>Linux中还有一部分用户，如： <code>apache</code>、 <code>mysql</code>、 <code>nobody</code>、<code>ftp</code>等，这些也都是非root用户，即普通用户。 Linux的权限实际是上不同用户所能访问的文件的不同产生的假象。而这些假象的造成，还要涉及到另外一个概念：用户组</p>
<blockquote>
<p>一个用户至少要属于个用户组<br>一个用户可以属于多个用户组</p>
</blockquote>
<ul>
<li><p>Linux采用组来组织和管理用户</p>
</li>
<li><p>在 Linux中每个用户有唯一的用户标识符UID，该UID是一个无符号整数</p>
</li>
<li><p>每个用户也必须至少属于一个组，也有组标识符GID.</p>
</li>
<li><p>其中UD与GID独立编号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UID  0      root用户</span><br><span class="line">UID	 1~999	占坑用户，即一些无法登录的用户</span><br><span class="line">UID	 &gt;=1000	正常的可登录用户</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="创建用户账号"><a href="#创建用户账号" class="headerlink" title="创建用户账号"></a>创建用户账号</h4><p><code>useradd</code> 命令</p>
<p>示例一：创建用户</p>
<ul>
<li><p><code>[root@CentOS8 ~]# useradd user1</code></p>
</li>
<li><p>功能：创建一个用户<code>user1</code>，同时在 <code>/etc/passwd</code>文件和 <code>/etc/shadow</code> 文件增加一行，并自动为用户创建相应的主目录：<code>/home/user1</code></p>
</li>
<li><p>说明：<code>/etc/passwd</code> 文件记录了系统中每个用户的用户名、UID号、GID号、主目录、shell等信息</p>
</li>
<li><p>注意：用户的口令原来也存放在此文件中，现在为了保证安全采用了影子口令文件 <code>/etc/shadow</code> 来保存每个用户的口令。</p>
</li>
</ul>
<p>示例二：创建用户账号并设置相应属性值</p>
<ul>
<li><code>[root@CentOS8 ~]# useradd -u 600 -g mygroup1 -G mygroup2 -d /home/student1 s1</code><ul>
<li>功能：创建用户s1，参数：</li>
<li>-u 指定 UID号 为 600</li>
<li>-g 指定 用户的主要组 为 <code>mygroup1</code></li>
<li>-G 指定 用户的附加组 为 <code>mygroup2</code>，每个用户可以有多个附加组</li>
<li>-d 指定 用户的主目录 为  <code>/home/student1</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="删除用户账号"><a href="#删除用户账号" class="headerlink" title="删除用户账号"></a>删除用户账号</h4><p><code>userdel</code> 命令</p>
<p>示例一：删除用户</p>
<ul>
<li><code>[root@CentOS8 ~]# userdel user1</code></li>
<li>功能：删除指定用户<code>user1</code></li>
</ul>
<p>示例二：删除用户并删除主目录</p>
<ul>
<li><code>[root@CentOS8 ~]# userdel -r user1</code></li>
<li>功能：删除指定用户<code>user1</code>，同时删除其主目录</li>
</ul>
<hr>
<h4 id="创建组账号"><a href="#创建组账号" class="headerlink" title="创建组账号"></a>创建组账号</h4><p><code>groupadd</code> 命令</p>
<p>示例一：创建组账号</p>
<ul>
<li><code>[root@CentOS8 ~]# groupadd mygroup1</code></li>
<li>功能：创建一个新组<code>mygroup1</code>，其中GID号为已存在GID号的下一个顺序编号</li>
<li>说明：创建一个组的同时会在 <code>/etc/group</code> 文件中为改组增加相应的一行，用来记录该组的名称、GID号及成员等信息</li>
</ul>
<p>示例二：创建组账号并设置其GID号</p>
<ul>
<li><code>[root@CentOS8 ~]# groupadd -g 500 mygroup2</code></li>
<li>功能：创建一个新组<code>mygroup2</code>，并指定其GID号为5000</li>
<li>-g 用来设置新组的GID号</li>
</ul>
<hr>
<h4 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h4><p><code>groupdel</code> 命令</p>
<ul>
<li><code>[root@CentOS8 ~]# groupdel mygroup2</code></li>
<li>功能：删除指定的组</li>
<li>注意：当某个组是某现有用户的主要组时，则不能被删除</li>
</ul>
<hr>
<h4 id="改变口令"><a href="#改变口令" class="headerlink" title="改变口令"></a>改变口令</h4><p><code>passwd</code>命令</p>
<ul>
<li>普通用户只能修改自己的密码，<code>root</code>用户可以修改所有用户的密码</li>
<li>密码长度需要 &gt;= 8，且不能太简单，不然修改或设置失败</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># useradd test1			# 增加用户 user1</span></span><br><span class="line">[root@CentOS8 ~]<span class="comment"># passwd test1			# 用root身份设置test1的密码 </span></span><br><span class="line">更改用户 test1 的密码 。</span><br><span class="line">新的 密码：</span><br><span class="line">重新输入新的 密码：</span><br><span class="line">passwd：所有的身份验证令牌已经成功更新。</span><br><span class="line">[root@CentOS8 ~]<span class="comment"># su - test1			# 切换成 test1 用户登录</span></span><br><span class="line">[test1@CentOS8 ~]$ passwd				<span class="comment"># 使用test1身份修改自身密码</span></span><br><span class="line">更改用户 test1 的密码 。</span><br><span class="line">Current password: 			</span><br><span class="line">新的 密码：</span><br><span class="line">重新输入新的 密码：</span><br><span class="line">passwd：所有的身份验证令牌已经成功更新。</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="禁止和恢复用户登录"><a href="#禁止和恢复用户登录" class="headerlink" title="禁止和恢复用户登录"></a>禁止和恢复用户登录</h4><p><code>passwd</code>命令</p>
<ul>
<li><p>参数 <code>-l</code> 可以给指定的用户加锁，禁止该用户登录</p>
</li>
<li><p>注意：root 身份下仍能登录 <code>su - username</code>，但用户不能直接登录了</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># passwd -l test1</span></span><br><span class="line">锁定用户 test1 的密码 。</span><br><span class="line">passwd: 操作成功</span><br></pre></td></tr></table></figure></li>
<li><p>参数 <code>-u</code> 可以给指定的用户解锁，恢复用户登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]# passwd -u test1</span><br><span class="line">解锁用户 test1 的密码。</span><br><span class="line">passwd: 操作成功</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="删除用户口令"><a href="#删除用户口令" class="headerlink" title="删除用户口令"></a>删除用户口令</h4><p><code>passwd</code>命令</p>
<ul>
<li><p>参数 <code>-d</code> 可以删除指定用户的口令，只有<code>root</code>用户可以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># passwd -d test1</span></span><br><span class="line">清除用户的密码 test1。</span><br><span class="line">passwd: 操作成功</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="显示用户信息"><a href="#显示用户信息" class="headerlink" title="显示用户信息"></a>显示用户信息</h4><p><code>id</code>命令</p>
<ul>
<li><p>格式  <code>id username</code></p>
</li>
<li><p>显示用户的UID、GID及所属的组信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># id root</span></span><br><span class="line">uid=0(root) gid=0(root) 组=0(root)</span><br><span class="line">[root@CentOS8 ~]<span class="comment"># id test1</span></span><br><span class="line">uid=1001(test1) gid=1001(test1) 组=1001(test1)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h4><p><code>usermod</code></p>
<hr>
<h3 id="Linux进程管理"><a href="#Linux进程管理" class="headerlink" title="Linux进程管理"></a>Linux进程管理</h3><hr>
<h4 id="查看进程命令"><a href="#查看进程命令" class="headerlink" title="查看进程命令"></a>查看进程命令</h4><p><code>ps</code> 命令</p>
<ul>
<li><p>示例一：不带参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># ps</span></span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">   2367 pts/0    00:00:00 bash</span><br><span class="line">   2413 pts/0    00:00:00 ps</span><br><span class="line">[root@CentOS8 ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure></li>
<li><p>示例二：查看所有运行的进程，包括后台进程</p>
<ul>
<li><code>-a</code>  所有进程</li>
<li><code>-u</code> 显示用户</li>
<li><code>-x</code> 包括不占用控制台的进程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># ps -aux</span></span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           1  0.7  0.7 175500 13704 ?        Ss   17:27   0:02 /usr/lib/systemd/systemd --switched</span><br><span class="line">root           2  0.0  0.0      0     0 ?        S    17:27   0:00 [kthreadd]</span><br><span class="line">root           3  0.0  0.0      0     0 ?        I&lt;   17:27   0:00 [rcu_gp]</span><br><span class="line">省略....</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER 	所属用户</span><br><span class="line">PID 	进程ID</span><br><span class="line">%CPU	占用CPU百分比</span><br><span class="line">%MEM	占用内存百分比</span><br><span class="line">VSZ		虚拟内存占用大小</span><br><span class="line">RSS		实际内存占用大小</span><br><span class="line">TTY		终端类型</span><br><span class="line">STAT	进程状态</span><br><span class="line">START	进程启动时刻</span><br><span class="line">TIME	进程运行时长</span><br><span class="line">COMMAND	启动进程的命令</span><br></pre></td></tr></table></figure></li>
<li><p>示例三：查看所有运行的进程，包括后台进程，显示每个进程的父进程号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># ps -ef</span></span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           1       0  0 17:27 ?        00:00:02 /usr/lib/systemd/systemd --switched-root --system </span><br><span class="line">root           2       0  0 17:27 ?        00:00:00 [kthreadd]</span><br><span class="line">root           3       2  0 17:27 ?        00:00:00 [rcu_gp]</span><br><span class="line">省略....</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>top</code> 命令</p>
<ul>
<li><p>动态地显示系统中的进程，<code>ctrl+c</code>退出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># top</span></span><br><span class="line">top - 17:44:26 up 16 min,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks: 216 total,   1 running, 215 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.2 si,  0.0 st</span><br><span class="line">MiB Mem :   1790.0 total,    651.4 free,    563.8 used,    574.8 buff/cache</span><br><span class="line">MiB Swap:   4096.0 total,   4096.0 free,      0.0 used.   1064.3 avail Mem </span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">    940 root      20   0  366260  12004  10220 S   0.3   0.7   0:01.38 vmtoolsd</span><br><span class="line">   2522 root      20   0   65752   5200   4292 R   0.3   0.3   0:00.08 top</span><br><span class="line">   省略。。。</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>free</code> 命令</p>
<ul>
<li><p>显示系统中的内存空闲情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># free</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        1832972      576388      667956       10616      588628     1090860</span><br><span class="line">Swap:       4194300           0     4194300</span><br><span class="line">[root@CentOS8 ~]<span class="comment"># free -h</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          1.7Gi       562Mi       652Mi        10Mi       574Mi       1.0Gi</span><br><span class="line">Swap:         4.0Gi          0B       4.0Gi</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="杀掉指定进程"><a href="#杀掉指定进程" class="headerlink" title="杀掉指定进程"></a>杀掉指定进程</h4><p><code>kill</code> 命令</p>
<ul>
<li><p>示例一：杀掉指定进程</p>
<ul>
<li>功能：<code>kill</code> 命令可以杀掉一个进程，普通用户只能杀掉自己的进程</li>
<li>说明：一般在执行<code>kill</code>命令前，先用<code>ps</code>或<code>pstree</code>来查询一下将要被杀掉的进程的进程号</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># ps</span></span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">   2367 pts/0    00:00:00 bash</span><br><span class="line">   2696 pts/0    00:00:00 ps</span><br><span class="line">[root@CentOS8 ~]<span class="comment"># ps -ef|grep bash</span></span><br><span class="line">root         957       1  0 17:27 ?        00:00:00 /bin/bash /usr/sbin/ksmtuned</span><br><span class="line">root        2367    2361  0 17:31 pts/0    00:00:00 -bash</span><br><span class="line">root        2698    2367  0 18:01 pts/0    00:00:00 grep --color=auto bash</span><br><span class="line">[root@CentOS8 ~]<span class="comment"># kill 957</span></span><br><span class="line">[root@CentOS8 ~]<span class="comment"># ps -ef|grep bash</span></span><br><span class="line">root        2367    2361  0 17:31 pts/0    00:00:00 -bash</span><br><span class="line">root        2710    2367  0 18:02 pts/0    00:00:00 grep --color=auto bash</span><br><span class="line">[root@CentOS8 ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure></li>
<li><p>示例二：强制杀掉指定进程</p>
<ul>
<li><code>[root@CentOS8 ~]# kill -9 3029</code></li>
<li>功能：强制终止3029号进程的运行，其中参数-9代表强制的意思</li>
<li>说明：实际上<code>kill</code>命令是向该进程发送信号，该进程收到信号后决定是否停止运行，有些进程必须要收到参数9才终止运行</li>
<li><code>kill -l</code> 命令了解有关信号的情况</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Linux软件包管理"><a href="#Linux软件包管理" class="headerlink" title="Linux软件包管理"></a>Linux软件包管理</h3><hr>
<h4 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h4><p>与Windows安装各种应用程序相似，在linux下也可以安装各种需要的应用程序，通常称为软件包。目前，在linux系统下常见的软件包管理工具为<code>RPM</code>。</p>
<p><code>rpm</code> – Redhat Package Management</p>
<p>软件包文件名中 i386, noarch 等含义</p>
<ul>
<li>i386.rpm                   适用于 80386及以上的cpu</li>
<li>i596.rpm                   适用于 pentium及以上cpu</li>
<li>i686.rpm                   适用于 pentium pro及以上cpu</li>
<li>noarch.rpm              指该软件包与硬件平台无关</li>
<li>src.rpm                     软件包源码</li>
</ul>
<hr>
<h4 id="rpm-命令"><a href="#rpm-命令" class="headerlink" title="rpm 命令"></a><code>rpm</code> 命令</h4><ul>
<li><p>示例一：查询系统中安装的软件包</p>
<ul>
<li><code>[root@CentOS8 ~]# rpm -qa</code></li>
<li>功能：查询系统中安装的软件包列表</li>
<li><code>-q</code>是 查询</li>
<li><code>-a</code>是 所有的</li>
</ul>
</li>
<li><p>示例二：查询软件包中 文件清单</p>
<ul>
<li><code>[root@CentOS8 ~]# rpm -ql php</code></li>
<li>功能：查询已安装的软件包php中的文件列表</li>
<li><code>-l</code> 是 列出指定软件包中的文件</li>
</ul>
</li>
<li><p>示例三：卸载指定的软件包</p>
<ul>
<li><code>[root@CentOS8 ~]# rpm -e php</code></li>
<li>功能：卸载已安装的软件包php</li>
<li><code>-e</code>是 卸载</li>
<li>说明：执行上述命令是，采用的身份是不同的，普通用户只能执行查询操作</li>
</ul>
</li>
<li><p>示例四：安装软件包</p>
<ul>
<li><code>[root@CentOS8 ~]# rpm -ivh php-4.3.9-3.1-i386.rpm</code></li>
<li>功能：安装软件包php</li>
<li><code>-i</code> 是 安装</li>
<li><code>-v</code> 是 显示处理过程</li>
<li><code>-h</code> 是 显示#表示进度</li>
</ul>
</li>
<li><p>示例五：忽略依赖关系安装软件包</p>
<ul>
<li><code>[root@CentOS8 ~]# rpm -ivh --nodeps php-4.3.9-3.1-i386.rpm</code></li>
<li>功能：安装软件包php时，忽略与其它软件包的依赖关系</li>
<li><code>--nodeps</code> 表示 忽略依赖关系</li>
<li>说明：在安装或卸载软件时经常会遇到提示 ”该软件包与某某软件包存在依赖关系“，只有加上参数 <code>--nodeps</code>忽略掉依赖关系才能进行安装或卸载</li>
</ul>
</li>
<li><p><code>rpm</code>管理</p>
</li>
<li><p>安装：</p>
</li>
<li><p>通过源代码安装软件包</p>
<ul>
<li><code>rpmbuild --rebuild software-version.src.rpm</code></li>
<li><code>rpm -ivh /usr/src/redhat/RPMS/i386/software-version.i386.rpm</code></li>
</ul>
</li>
<li><p>升级：</p>
<ul>
<li><code>rpm -U software-version.i386.rpm</code></li>
<li><code>rpm -Uvh software-version.i386.rpm</code></li>
<li><code>rpm --force -Uvh software-version.i386.rpm</code></li>
</ul>
</li>
<li><p>删除：</p>
<ul>
<li><code>rpm -e software</code></li>
</ul>
</li>
<li><p>查询：</p>
<ul>
<li><code>rpm -qi software</code></li>
<li><code>rpm -qpi software-version.i386.rpm</code></li>
<li><code>rpm -qf /dir/file</code></li>
<li><code>rpm -ql software</code></li>
<li><code>rpm -qpl software-version.i386.rpm</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h3><hr>
<h4 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h4><p>Shell是用户与Linux操作系统沟通的桥梁</p>
<p>Linux的Shell种类众多，这里的是<code>bash</code>，也就是<code>Bourne Again Shell</code></p>
<ul>
<li>由于易用和免费，<code>bash</code>在日常工作中被广泛使用</li>
<li><code>bash</code>是大多数Linux系统默认的Shell</li>
</ul>
<hr>
<h4 id="Shell执行方式"><a href="#Shell执行方式" class="headerlink" title="Shell执行方式"></a>Shell执行方式</h4><p><code>a.sh</code></p>
<ul>
<li>保证脚本具有执行权限并且在环境变量PATH中有(.)，这样在执行的时候会从当前目录查找</li>
</ul>
<p><code>./a.sh</code></p>
<ul>
<li>保证这个脚本具有执行权限</li>
</ul>
<p><code>bash a.sh</code></p>
<ul>
<li>直接可以执行，甚至这个脚本文件中的第一行都可以不引用<code>/bin/bash</code>，它是将<code>hello.sh</code>作为参数传给 sh(bash) 命令执行的</li>
</ul>
<hr>
<h4 id="后台模式运行脚本"><a href="#后台模式运行脚本" class="headerlink" title="后台模式运行脚本"></a>后台模式运行脚本</h4><p>在脚本后面加一个 <code>&amp;</code></p>
<ul>
<li><code>tesh.sh &amp;</code></li>
<li>在后台运行，但是当前会话窗口关闭之后这个脚本也会停止运行</li>
</ul>
<p><code>nohup</code>命令</p>
<ul>
<li>不间断的运行命令，忽略所有挂断（SIGHUP）信号</li>
</ul>
<p><code>nohup tesh.sh &amp;</code></p>
<ul>
<li><code>nohup</code>命令将进程和终端分开，所以关闭当前会话窗口不会影响这个进程的执行</li>
<li><code>nohup</code>会在当前执行的目录生成一个<code>nohup.out</code>日志文件</li>
</ul>
<hr>
<h4 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h4><p>标准输入、输出、错误可以使用文件描述符 0、1、2 引用</p>
<ul>
<li><code>ls &gt;file</code> 或者 <code>ls 1&gt;file(ls &gt;&gt;file)</code> </li>
<li><code>ls &gt;file 2&gt;&amp;1</code></li>
<li><code>ls &gt; /dev/null</code>，把输出信息重定向到无底洞</li>
</ul>
<p>使用重定向可以把信息转换到其他位置</p>
<hr>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li><p>变量不需要声明，初始化不需要指定类型</p>
</li>
<li><p>变量命名</p>
<ul>
<li>不能使用程序中关键字（保留字）</li>
<li>只能使用数字、字母和下划线，且不能以数字开头</li>
<li>建议命令要通俗易懂</li>
</ul>
</li>
<li><p>显示变量值使用 <code>echo $变量名</code> 或者 <code>$&#123;变量名&#125;</code></p>
<ul>
<li><code>echo $JAVA_HOME</code></li>
<li><code>echo $&#123;JAVA_HOME&#125;</code></li>
</ul>
</li>
</ul>
<p><strong>本地变量</strong></p>
<ul>
<li>只对当前shell进程有效，对当前进程的子进程和其他shell进程无效</li>
<li>定义： <code>VAR_NAME=VALUE</code></li>
<li>变量引用：${VAR_NAME}</li>
<li>取消变量：<code>unset VAR_NAME</code></li>
</ul>
<p><strong>环境变量</strong></p>
<ul>
<li>自定义的环境变量对当前shell进程及其子shell进程有效，对其它的shell进程无效</li>
<li>定义：export VAR_NAME=VALUE</li>
<li>对所有shell进程都有效需要配置到配置文件中<ul>
<li><code>vi /etc/profile</code></li>
<li><code>source /etc/profile</code></li>
</ul>
</li>
</ul>
<p><strong>局部变量</strong></p>
<ul>
<li>在函数中调用，函数执行结束，变量就会消失</li>
<li>对shell脚本中某代码片段有效</li>
<li>定义：<code>local VAR_NAME=VALUE</code></li>
</ul>
<p><strong>位置变量</strong></p>
<ul>
<li><code>$1,$2,...,$&#123;10&#125;,...</code></li>
<li><code>test.sh 3 89</code><ul>
<li><code>$0</code> 脚本自身</li>
<li><code>$1</code> 脚本的第一个参数</li>
<li><code>$2</code> 脚本的第二个参数</li>
</ul>
</li>
<li>相当于java中main函数中的args参数，可以获取外部参数</li>
</ul>
<p><strong>特殊变量</strong></p>
<ul>
<li><code>$?</code> 接收到上一条命令的返回状态码，返回状态在 <code>0~255</code> 之间</li>
<li><code>$#</code> 脚本执行时，输入的参数的个数</li>
<li><code>$*</code> 或 <code>$@</code> 输入的参数的具体内容（将输入的参数作为一个多个对象，即是所有参数的一个列表）</li>
</ul>
<p><strong>Linux退出状态代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0		命令成功完成</span><br><span class="line">1		通常的未知错误	</span><br><span class="line">2		误用shell命令</span><br><span class="line">126		命令无法执行</span><br><span class="line">127		没有找到命令</span><br><span class="line">128		无效的退出参数</span><br><span class="line">128+x	使用Linux信号x的致命错误</span><br><span class="line">130		使用ctrl+c终止的命令</span><br><span class="line">255		规范外的退出命令</span><br></pre></td></tr></table></figure>



<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># cat test.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;script name is :&quot;</span><span class="variable">$0</span></span><br><span class="line">n=1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Use \$@ list is: &quot;</span> <span class="variable">$@</span></span><br><span class="line"><span class="keyword">for</span> temstr <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$n</span> number is &quot;</span><span class="variable">$temstr</span></span><br><span class="line">	<span class="built_in">let</span> n+=1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">[root@CentOS8 ~]<span class="comment"># ls -l test.sh</span></span><br><span class="line">-rw-r--r--. 1 root root 124 1月  30 19:45 test.sh</span><br><span class="line">[root@CentOS8 ~]<span class="comment"># chmod +x test.sh</span></span><br><span class="line">[root@CentOS8 ~]<span class="comment"># ./test.sh 1 2 3 4 5</span></span><br><span class="line">script name is :./test.sh</span><br><span class="line">Use <span class="variable">$@</span> list is:  1 2 3 4 5</span><br><span class="line">1 number is 1</span><br><span class="line">2 number is 2</span><br><span class="line">3 number is 3</span><br><span class="line">4 number is 4</span><br><span class="line">5 number is 5</span><br><span class="line">[root@CentOS8 ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>通过使用一个变量去遍历给定列表中的每个元素，在每个变量赋值时执行一次循环体，直至复制完成所有元素退出循环。</p>
<ul>
<li><p>格式一</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=0;i&lt;10;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
<li><p>格式二</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 0 1 2 3 4 5 8 9</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
<li><p>格式三</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..9&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="while-until循环"><a href="#while-until循环" class="headerlink" title="while/until循环"></a>while/until循环</h4><p>适用于循环次数未知，或不便用for直接生成较大的列表时</p>
<ul>
<li><p>格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 测试条件;<span class="keyword">do</span></span><br><span class="line">	循环体</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试条件为真，进入循环；测试条件为假，退出循环</p>
</li>
<li><p><code>until</code> 循环和 <code>while</code> 循环格式一致，但是和 <code>while</code> 循环的意思相反，测试条件为假，进入循环；测试条件为真，退出循环。</p>
</li>
</ul>
<hr>
<h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><ul>
<li><p>单分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 测试条件; <span class="keyword">then</span></span><br><span class="line">	选择分支</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
<li><p>双分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 测试条件; <span class="keyword">then</span></span><br><span class="line">	选择分支1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	选择分支2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="循环控制命令"><a href="#循环控制命令" class="headerlink" title="循环控制命令"></a>循环控制命令</h4><p><strong><code>break</code> 命令</strong></p>
<p>在处理过程中跳出循环的一种简单方法，可以使用 <code>break</code> 命令退出任何类型的循环，包括 <code>while</code> 循环和 <code>until</code> 循环</p>
<ul>
<li>跳出单循环</li>
<li>跳出内循环<ul>
<li>使用多循环时 <code>break</code> 自动跳出当前所在的循环，注意，当内循环被 <code>break</code> 命令终止，外循环会继续执行</li>
</ul>
</li>
<li>跳出外循环</li>
</ul>
<p>处于内循环但需要终止外循环，<code>break</code> 命令后面需要指定参数</p>
<ul>
<li><code>break n</code></li>
<li>n 表面要跳出的循环等级，默认为1，跳出当前循环，n=2，停止外面一层循环</li>
</ul>
<p><strong><code>continue</code>命令</strong></p>
<p>提前停止当前循环内命令，而不完全终止循环的方法，这就需要在循环内设置shell不执行命令的条件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># nano test2.sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..5&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  	<span class="keyword">if</span> [ <span class="variable">$i</span> -eq 2 ]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">continue</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">[root@CentOS8 ~]<span class="comment"># chmod +x test2.sh</span></span><br><span class="line">[root@CentOS8 ~]<span class="comment"># ./test2.sh</span></span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">[root@CentOS8 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 函数名() &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>引用自定义函数文件时，使用 <code>source func.sh</code></p>
</li>
<li><p>有利于代码的重用性</p>
</li>
<li><p>函数传递参数</p>
</li>
<li><p>函数的返回值，只能是数字</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@CentOS8 ~]<span class="comment"># nano test3.sh</span></span><br><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;		<span class="comment"># 定义函数</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;param is <span class="variable">$1</span>&quot;</span>	<span class="comment"># 输出参数</span></span><br><span class="line">	<span class="built_in">return</span> 99			<span class="comment"># 返回99</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span> hello				<span class="comment"># 调用函数，参数是hello</span></span><br><span class="line"><span class="built_in">echo</span> $?					<span class="comment"># 输出函数返回的状态码，99</span></span><br><span class="line"></span><br><span class="line">[root@CentOS8 ~]<span class="comment"># ls -l test3.sh</span></span><br><span class="line">-rw-r--r--. 1 root root 81 1月  30 20:43 test3.sh</span><br><span class="line">[root@CentOS8 ~]<span class="comment"># chmod +x test3.sh</span></span><br><span class="line">[root@CentOS8 ~]<span class="comment"># ./test3.sh</span></span><br><span class="line">param is hello</span><br><span class="line">99</span><br><span class="line">[root@CentOS8 ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Shell样例"><a href="#Shell样例" class="headerlink" title="Shell样例"></a>Shell样例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line">d=`date +%H`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$d</span> -ge 0 -a <span class="variable">$d</span> -lt 7 ]; <span class="keyword">then</span></span><br><span class="line">	tag=1</span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$d</span> -ge 7 -a <span class="variable">$d</span> -lt 12 ]; <span class="keyword">then</span></span><br><span class="line">	tag=2</span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$d</span> -ge 12 -a <span class="variable">$d</span> -lt 18 ]; <span class="keyword">then</span></span><br><span class="line">	tag=3</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	tag=4</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$tag</span> <span class="keyword">in</span></span><br><span class="line">	1)</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Good morning&quot;</span></span><br><span class="line">    ;;</span><br><span class="line">	2)</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Morning&quot;</span></span><br><span class="line">    ;;</span><br><span class="line">	3)</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Good Afternoon&quot;</span></span><br><span class="line">    ;;</span><br><span class="line">	4)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Good Evening&quot;</span></span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Scrip Error&quot;</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@CentOS8 ~]<span class="comment"># chmod +x test1.sh</span></span><br><span class="line">[root@CentOS8 ~]<span class="comment"># ./test1.sh</span></span><br><span class="line">Good Evening</span><br></pre></td></tr></table></figure>





<h3 id="创建用户问题"><a href="#创建用户问题" class="headerlink" title="创建用户问题"></a>创建用户问题</h3><p><code>Ubuntu</code>创建用户时，默认不会创建家目录</p>
<p><img src="/Linux%E5%85%A5%E9%97%A8/image-20220329122538336.png" alt="image-20220329122538336"></p>
<p>使用<code>useradd -D</code>查看该命令的默认设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -D</span><br><span class="line">GROUP=100   <span class="comment"># 默认的群组</span></span><br><span class="line">HOME=/home  <span class="comment"># 默认家目录所在目录</span></span><br><span class="line">INACTIVE=-1  <span class="comment"># 口令失效日，在shadow的第7栏</span></span><br><span class="line">EXPIRE=      <span class="comment"># 账号失效日，在shadow的第8栏</span></span><br><span class="line">SHELL=/bin/sh  <span class="comment"># 默认的shell</span></span><br><span class="line">SKEL=/etc/skel   <span class="comment"># 家目录里面的内容，从这个目录拷贝过去的</span></span><br><span class="line">CREATE_MAIL_SPOOL=no  <span class="comment"># 是否创建邮件信箱</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>/etc/default/useradd</code> 文件可以更改这些默认值</li>
</ul>
<p>1、使用<code>useradd</code> 创建用户时可以加上<code>-m</code>来强制创建家目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -m username</span><br></pre></td></tr></table></figure>

<p>2、也可以修改useradd的默认设置,让他默认创建家目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/login.defs</span><br><span class="line">在后面加上一行</span><br><span class="line">CREATE_HOME yes</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构上</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/</url>
    <content><![CDATA[<p>线性表，栈和队列，串，数组，广义表，树，二叉树，图</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h3><p>1、按某种逻辑关系组织起来的一批数据（逻辑结构）例如：线性表、树、图</p>
<p>2、以一定的方式存于计算机中（存储结构）例如：数组、链表等</p>
<p>3、在这组数据上定义了运算的集合。例如：插入、删除、查找、排序等   </p>
<p><strong>程序 = 数据结构 + 算法</strong></p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p><strong>数据 data</strong>：能够输入到计算机中并被计算机程序处理的信息，包括文字、表格、图像等，都称为数据。</p>
<p><strong>数据元素 data element</strong>：数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素包含若干个<strong>数据项data item</strong>。</p>
<p>数据元素、数据项和数据的逻辑结构在计算机中的表示又称为结点、数据域和存储（物理）结构。</p>
<p><strong>数据对象</strong>：性质相同的数据元素的集合，是数据的一个子集。</p>
<p><strong>数据类型</strong>：一个值的集合及定义在这个值集上的一组操作的总称。</p>
<p>**抽象数据类型 ADT(Abstract Data Type)**：一个数学模型以及定义在此数学模型上的一组操作。</p>
<p><strong>数据的逻辑结构</strong>：数据元素之间的逻辑关系。</p>
<ul>
<li><strong>线性结构</strong>：元素之间的关系是一对一的。表，栈，队列，串等</li>
<li><strong>非线性结构</strong><ul>
<li><strong>树型结构</strong>：元素之间的关系是一对多的。二叉树，Huffman树等</li>
<li><strong>图状结构</strong>：元素之间的关系是多对多的。有向图，无向图等</li>
</ul>
</li>
</ul>
<p><strong>数据的存储结构</strong>：数据在计算机中的存储表示。逻辑结构到物理存储的映射。</p>
<ul>
<li><p><strong>顺序存储</strong>：数组</p>
</li>
<li><p><strong>非顺序存储</strong>：链式</p>
</li>
<li><p><strong>索引存储</strong>：</p>
</li>
<li><p><strong>散列存储</strong>：hash</p>
</li>
</ul>
<h3 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h3><p><strong>算法 algorithm</strong>：算法是对特定问题求解步骤的一种描述，是指令的有限序列。也即解决问题的一种方法（策略）或一个过程。</p>
<p><strong>程序</strong>：用计算机语言实现算法。</p>
<p><strong>算法的五个特性</strong>：有穷性，可行性，确定性，输入和输出。 </p>
<p><strong>算法分析（设计）的要求</strong>：正确性 correctness，可读性 readability，健壮性 robustness，高效率与低存储</p>
<p><strong>算法分析</strong>：</p>
<ul>
<li><strong>时间复杂度 time complexity</strong>：算法中各语句执行时间的总和。</li>
<li><strong>空间复杂度 space complesity</strong>：算法中所需占用的==辅助==空间。</li>
</ul>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><strong>线性表逻辑结构</strong></p>
<p>$(a_1,a_2,…,a_n)$  $n(n&gt;=0)$ 个元素的有限集。 每个元素的类型是相同的，元素之间的位置关系是一维(线性)的。</p>
<p><strong>线性表存储结构</strong></p>
<ul>
<li>顺序存储——顺序表</li>
<li>链式存储——链表</li>
</ul>
<p><strong>线性表的操作</strong></p>
<p>插入，删除，定位，查找，排序等</p>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>线性表的顺序存储</p>
<p>注意：有容量和表长，容量是线性表的最多保存的数据元素的个数，表长是当前顺序表保存的数据元素个数。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>线性表的链式存储。</p>
<p><strong>单向链表</strong></p>
<p>头指针，尾指针，空指针，数据域，指针域，空表，带表头节点的单向链表</p>
<p><font color="#ff000">注意：头指针可能包含数据，也可能置空。类似于数组的第0位可能不用，也可能存数据</font></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220220153401793.png" alt="image-20220220153401793"></p>
<p><strong>单向循环链表</strong></p>
<p>只有尾指针，尾指针就是头指针</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220220153555966.png" alt="image-20220220153555966"></p>
<p><strong>双向链表</strong></p>
<p>两个指针域和一个数据域，  <code>prior data next</code></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220220153643987.png" alt="image-20220220153643987"></p>
<p><strong>双向循环链表</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220220153836405.png" alt="image-20220220153836405"></p>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈和队列是特殊的线性表，是<strong>操作受限</strong>的线性表。</p>
<p>对于栈，所有的插入和删除操作都限制在线性表的同一端进行，是一种后进先出的线性表。</p>
<p>对于队列，所有的插入操作限制在线性表的一端进行，所有的删除操作限制在线性表的另一端进行，是一种先进先出的线性表。</p>
<p><strong>栈</strong>是限定在一端（表尾）进行插入或删除操作的线性表。<strong>表尾端称栈顶</strong>，表头端称栈底</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220220190949091.png" alt="image-20220220190949091"></p>
<p>栈对应线性表的两种类型</p>
<p><strong>顺序栈</strong></p>
<p>栈满：<code>top == MAXSIZE - 1</code></p>
<p>栈空：<code>top == -1</code></p>
<p><strong>链式栈</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220220193032534.png" alt="image-20220220193032534"></p>
<p><strong>队列</strong>是限定在表的一端（队尾）进行插入，另一端（队头）进行删除的线性表。<strong>出队列的一端称队头</strong>，进队列的一端称队尾。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220220191822593.png" alt="image-20220220191822593"></p>
<p><strong>循环队列</strong>——顺序存储</p>
<p>1）解决假溢出问题。2）提高效率。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220220192606716.png" alt="image-20220220192606716"></p>
<p><strong>链式队列</strong>——非顺序存储</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220220192406216.png" alt="image-20220220192406216"></p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为<strong>字符集</strong>。</p>
<p>但是串的基本操作和线性表却有很大差别。<font color="#ff000">在线性表的基本操作中，大多以“单个元素”作为操作对象</font>。如：在线性表中查找某个元素、求取某个元素、在某个位置上插入一个元素和删除一个元素等；而<font color="#ff000">在串的基本操作中，通常以“串的整体”作为操作对象</font>，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。</p>
<h3 id="串的基本概念"><a href="#串的基本概念" class="headerlink" title="串的基本概念"></a>串的基本概念</h3><p>**串(string)**也称字符串，是由零个或多个字符组成的有限序列。一般记为$S$ = “$a_1a_2…a_n$”。</p>
<ul>
<li>$S$是串的名字</li>
<li>引号里面是串的内容</li>
<li>$a_i$是串的第$i$个字符</li>
<li>串中字符个数$n$为串长，$n=0$为空串</li>
</ul>
<p>**子串(substring)**：一个串中任意个连续字符组成的子序列（含空串）称为该串的子串。</p>
<p><strong>真字串</strong>：非空且不为自身的字串。</p>
<p><strong>字符在串中的位置</strong>：</p>
<p><strong>子串在主串中的位置</strong>：以子串的第一个字符在主串中出现的位置表示。</p>
<p><strong>前缀</strong>：起始于位置1的字串</p>
<p><strong>后缀</strong>：终止于位置n的字串</p>
<p><strong>真前缀和真后缀</strong>：字符串本身之外的所有非空前缀和后缀，分别称为真前缀和真后缀。</p>
<p><strong>串相等</strong>：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。</p>
<p><strong>C标准函数库</strong> #include &lt;string. h&gt;  <strong>C++</strong> #include &lt;cstring&gt;</p>
<ul>
<li>求串长 <code>int strlen(char *s);</code></li>
<li>串复制 <code>char* strcpy(char*s1,char*s2);</code></li>
<li>串拼接 <code>char* strcat(char*s1,char*s2);</code></li>
<li>串比较 <code>int strcmp(char*s1,char*s2;</code></li>
<li>定位 <code>char* strchr(char*s, char c);</code></li>
<li>右定位 <code>char* strrchr(char*s, char c);</code></li>
<li>求子串 <code>char* strstr(const char*str1, const char*str2);</code></li>
</ul>
<h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><hr>
<p><strong>行结构</strong></p>
<p><strong>定长顺序存储</strong>：按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，通常用定长字符数组来实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSTRLEN 1000		<span class="comment">// 定义最长串长1000</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[MAXSTRLEN]; <span class="comment">// 存放字符</span></span><br><span class="line">    <span class="keyword">int</span> length;				<span class="comment">// 串的实际长度</span></span><br><span class="line">&#125;SqString;</span><br></pre></td></tr></table></figure>

<p><font color="#00f">注意：隐式存储：在串值后面加一个不计入串长的结東标记字符，如C语言中的”0”。此时串长为隐含值，不便于实现涉及串长的操作</font></p>
<hr>
<p><strong>堆结构</strong></p>
<p><strong>堆分配存储</strong>：仍以一组地址连续的存储单元存放串值，但存储空间是在程序执行过程中动态分配而得。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* data;		<span class="comment">//若是非空串，则按串实际长度分配存储区，否则data为NULL</span></span><br><span class="line">    <span class="keyword">int</span> length;		<span class="comment">//串长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>块链存储</strong></p>
<p>串采用链式存储结构存储时称为<strong>链串</strong>。链串中的一个结点可以存储多个字符。通常将链串中<strong>每个结点所存储的字符个数称为结点大小</strong>。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220220210247787.png" alt="image-20220220210247787"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE 80	<span class="comment">//可由用户定义的结点大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>	//自定义结点（数据元素）</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data[CHUNKSIZE];	<span class="comment">//存放字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>* <span class="title">next</span>;</span>		<span class="comment">//指针域</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Chunk *head, *tail;		<span class="comment">//串的头指针和尾指针</span></span><br><span class="line">    <span class="keyword">int</span> length;				<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure>



<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p><strong>模式匹配</strong>：子串在主串中的定位运算(index)。设S和T是给定的两个串，在主串S中查找子串T (T也称为模式串) 的过程称为模式匹配。</p>
<p><strong>匹配结果</strong></p>
<ul>
<li>匹配成功：即在主串S中找到一个模式串T。T是S的子串，返回T在S中第一次出现的位置。</li>
<li>匹配不成功：即主串S中不存在模式串T。T不是S的子串，返回0</li>
</ul>
<p><strong>模式匹配的算法</strong></p>
<ul>
<li>朴素算法——<strong>BF(Brute- Force)算法</strong></li>
<li>快速算法——<strong>KMP算法</strong></li>
</ul>
<hr>
<h4 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h4><p>采用穷举策略，基本思想：</p>
<ul>
<li><p>从主串S的第1个字符开始和模式串T的第1个字符进行比较</p>
</li>
<li><p>若相等，继续比较两者的后续字符；</p>
</li>
<li><p>若不等，从主串S的下ー字符开始和模式T的第一个字符进行比较</p>
</li>
<li><p>直到T中的每个字符依次和S中的一个连续的字符序列相等，则匹配成功，返回T在S中第一次出现的位置，否则匹配失败，返回0。</p>
</li>
</ul>
<p>主串指针回溯，效率低。</p>
<p><strong>BF算法</strong>的**C/C++**实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// S：主串  T：模式串  sLen：S的长度  tLen：T的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BF</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">char</span> T[], <span class="keyword">int</span> sLen, <span class="keyword">int</span> tLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; sLen &amp;&amp; j &lt; tLen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == T[j]) &#123; ++i; ++j; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; i = i - j + <span class="number">1</span>; j = <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == tLen) <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>设计思想：</p>
<p>每当出现失配时，指针不回溯，而是利用已经得到的“部分匹配”结果将模式串向右“滑动”尽可能远的一段距离后，继续<br>比较。从而提高算法的效率。</p>
<p><strong>示例</strong>：主串 $S=$ “$ababcabcacbab$” ，模式串$T=$ “$abcac$” 。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220220215002839.png" alt="image-20220220215002839"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220220215715609.png" alt="image-20220220215715609"></p>
<p><font color="#00f">问题一：某趟在 $S_i$ 和 $T_j$ “失配”时，模式串”向右滑动”的可行距离有多远，即下一步 $S_i$ 应该与模式串中的哪个字符比较？</font></p>
<p>设模式串最远滑动到第 $k$ 个字符，此时要满足：（下面字符串下标从1开始，在程序中一般下标一般是0开始）</p>
<p>$T_1$ ~ $T_{k-1}$ $=$ $S_{i-k+1}$ ~ $S_{i-1}$   和    $T_{j-k+1}$ ~ $T_{j-1}$ $=$ $S_{i-k+1}$ ~ $S_{i-1}$ </p>
<p>联立得：$T_1$ ~ $T_{k-1}$ $=$ $T_{j-k+1}$ ~ $T_{j-1}$  $k=max{k|1&lt;k&lt;j且T_1…T_{k-1}=T_{j-k+1}…T_{j-1}}$</p>
<p>即：模式中的前$k-1$个字符（最大真前缀）与模式中$T_j$字符前面的$k-1$个字符（最大真后缀）相等时，模式$T$就可以向右”滑动”至使$T_k$和$S_i$对准，继续向右进行比较即可。</p>
<p><font color="#00f">问题二：求$k$值?</font></p>
<ol>
<li><p>$k$和$j$存在函数关系，模式串中的每一个$T_j$都对应一个$k$值，由当前失配位置$j$,可以计算出滑动位置$k$;</p>
</li>
<li><p>滑动位置$k$仅与模式串$T$有关，因此可以预先为模式串设定一个next数组，若令<code>next[j]=k</code>,则<code>next[j]</code>表明当模式串中的第$j$个字符与主串中相应字符“失配”时，模式串中需要重新和主串中该字符进行比较的字符的位置。</p>
</li>
</ol>
<p>$$ next[j]=\begin{cases} -1 \quad\quad\quad j=0 \ max{k|0&lt;k&lt;j且T_0…T_{k-1}=T_{j-k+1}…T_{j-1}} \ 0 \quad\quad\quad 其他情况 \end{cases}$$</p>
<p>计算<code>next[j]</code></p>
<ul>
<li><p><code>next[0] = -1</code> ，第0个字符不等时，前面没有字符，$i$后移，$j$还是0</p>
</li>
<li><p><code>next[1] = 0</code>，第1个字符不等时，前面只有第0个字符，$i$不变，$j$变1</p>
</li>
<li><p><code>next[j] = k</code>，说明$T_0…T_{k-1}=T_{j-k+1}…T_{j-1}$，则<code>next[j+1]</code>有两种可能</p>
<ul>
<li><p>1、$T_k = T_j$ ：<code>next[j+1] = next[j] + 1 = k + 1</code></p>
</li>
<li><p>2、$T_k\neq T_j$：此时可以把求next函数值问题看成是一个模式匹配问题，整个模式串即是主串又是模式串。设$k’=next[k]$，将模式向右滑动，将$T_j$与$T_k’$进行比较。此时仍会出现两种情况</p>
<ul>
<li>$T_k’ = T_j$ ：与情况①类似，$next[j+1]=k’+1$ </li>
<li>$T_k’\neq T_j$：与情况②类似，重复②的过程，直到$T_j$与模式中某个字符匹配成功或者不存在可匹配的子串，则$next[j+1]=0$。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例：模式$T =$ “$abaababc$”</p>
<table>
<thead>
<tr>
<th>sub</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>T</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>b</td>
<td>c</td>
</tr>
<tr>
<td>next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>2</td>
</tr>
</tbody></table>
<p>求<strong>next</strong>的**C/C++**实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T是模式串，tLen是T的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">char</span> T[], <span class="keyword">int</span> next[], <span class="keyword">int</span> tLen)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; tLen - <span class="number">1</span>)	<span class="comment">// 第j个数决定j+1，所以tLen减1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || T[j] == T[k]) &#123;</span><br><span class="line">			++k; ++j;</span><br><span class="line">			next[j] = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>C++<strong>测试</strong>next</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> T[] = <span class="string">&quot;abaababc&quot;</span>;  <span class="comment">// -1 0 0 1 1 2 3 2</span></span><br><span class="line">    <span class="comment">// 计算T的大小，注意：动态数组无法用sizeof()计算大小</span></span><br><span class="line">	<span class="keyword">int</span> tLen = <span class="built_in"><span class="keyword">sizeof</span></span>(T) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) - <span class="number">1</span>; <span class="comment">// C风格字符串尾还有一个&#x27;\0&#x27;，所以长度是9不是8，要减1</span></span><br><span class="line">	<span class="comment">//int next[8] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="keyword">int</span>* next = <span class="keyword">new</span> <span class="keyword">int</span>[tLen];</span><br><span class="line">	<span class="built_in">getnext</span>(T, next, tLen);	<span class="comment">// 上面的next函数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">		cout &lt;&lt; next[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] next;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>KMP算法</strong>的**C/C++**实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// S：主串  T：模式串  next：滑动到的字符下标  sLen：S的长度  tLen：T的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">char</span> T[], <span class="keyword">int</span> next[], <span class="keyword">int</span> sLen, <span class="keyword">int</span> tLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; tLen)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == T[j]) &#123;</span><br><span class="line">			++i; ++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j == tLen) <span class="keyword">return</span> i - j;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>C++<strong>测试</strong>KMP算法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> T[] = <span class="string">&quot;abaababc&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> S[] = <span class="string">&quot;abacabaababcabc&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> tLen = <span class="built_in"><span class="keyword">sizeof</span></span>(T) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> sLen = <span class="built_in"><span class="keyword">sizeof</span></span>(S) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>* next = <span class="keyword">new</span> <span class="keyword">int</span>[tLen];</span><br><span class="line">	<span class="built_in">getnext</span>(T, next, tLen);		<span class="comment">// 前面的getnext函数</span></span><br><span class="line">	<span class="keyword">int</span> pos = <span class="built_in">KMP</span>(S, T, next, sLen, tLen);	<span class="comment">// 前面的KMP函数</span></span><br><span class="line">	cout &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] next;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>next函数的改进</strong></p>
<p>如果<code>next[j]=k</code>且$T_k=T_j$，当 $S_i≠T_j$失配时，不需要再和$T_k$进行比较，而直接和$T_{next[k]}$进行比较，即应使<code>next[j]=next[k]</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T是模式串，tLen是T的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">char</span> T[], <span class="keyword">int</span> next[], <span class="keyword">int</span> tLen)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; tLen - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || T[j] == T[k]) &#123;</span><br><span class="line">			++k; ++j;</span><br><span class="line">            <span class="keyword">if</span>(T[j] != T[k]) next[j] = k;</span><br><span class="line">            <span class="keyword">else</span> next[j] = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p><strong>数组(Array)<strong>：是元素数量和元素类型固定的有序序列，可以将它看成是</strong>线性表的推广</strong>。</p>
<p><strong>一维数组</strong>：是$n(n&gt;1)$个相同类型数据元素构成的有限序列，其逻辑表示为 $A = (a_0,a_1,…,a_{n-1})$ 。</p>
<p><strong>二维数组</strong>：可以看成是每个数据元素都是相同类型的一维数组的一维数组。</p>
<p>$$A_{mn}\left[<br>\begin{matrix}<br>a_{0,0} &amp; a_{0,1} &amp;\cdots &amp; a_{0,n-1} \ a_{1,0} &amp; a_{1,1} &amp;\cdots &amp; a_{1,n-1} \ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \ a_{m-1,0} &amp; a_{m-1,1} &amp;\cdots &amp; a_{m-1,n-1} \end{matrix} \right]$$</p>
<p>$$可以看成长度为m的线性表$$ </p>
<p>$$B = (b_0,b_2,…b_{m-1}) \quad\quad 其中b_i = (a_{i,0},…a_{i,n-1})$$</p>
<p><strong>n维数组</strong>：可以看成是数据元素为$n-1$维数组的一维数组。</p>
<h3 id="数组的顺序存储"><a href="#数组的顺序存储" class="headerlink" title="数组的顺序存储"></a>数组的顺序存储</h3><p><strong>数组的顺序存储</strong>：由于数组一般不做插入或刪除操作，因此，通常采用顺序存储结构，将数组的所有元素存储在一块地址连续的内存单元中。</p>
<ul>
<li><p><strong>一维数组的顺序存储</strong>：对于一维数组$A=(a_0,a_1,…a_{n-1})$可以直接按照元素顺序依次存储到一块地址连续的内存单元中。</p>
<p><strong>数据元素存储位置计算公式</strong>：一旦$a_0$的存储地址$LOC(a_0)$确定，并假设每个数据元素占用$L$个存储单元，则任一数据元素$a_i$的存储地址$LOC(a_i)$就可由以下公式求出：$LOC(a_i)=LOC(a_0)+i*L \quad (0&lt;=i&lt;n)$ </p>
</li>
<li><p><strong>二维数组的顺序存储</strong>：对于一个$m$行$n$列的二维数组$A_{m,n}$,其存储方式有两种</p>
<ul>
<li><p><strong>行优先</strong>——以行序为主序的存储： $$A=((\underbrace{a_{0,0},a_{0,1},…a_{0,n-1}}<em>{第0行}),(\underbrace{a</em>{1,0},a_{1,1},…a_{1,n-1}}<em>{第1行}),…,(\underbrace{a</em>{m-1,0},a_{m-1,1},…a_{m-1,n-1}}_{第m-1行}))$$ </p>
<p><strong>数据元素存储位置计算公式</strong>：$LOC(a_{i,j})=LOC(a_{0,0})+(i*n+j)*L \quad (0&lt;=i&lt;m,0&lt;=j&lt;n)$  </p>
</li>
<li><p><strong>列优先</strong>——以列序为主序的存储 $$A=((\underbrace{a_{0,0},a_{1,0},…a_{m-1,0}}<em>{第0列}),(\underbrace{a</em>{0,1},a_{1,1},…a_{m-1,1}}<em>{第1列}),…,(\underbrace{a</em>{0,n-1},a_{1,n-1},…a_{m-1,n-1}}_{第n-1行}))$$ </p>
<p><strong>数据元素存储位置计算公式</strong>：$LOC(a_{i,j})=LOC(a_{0,0})+(j*m+i)*L \quad (0&lt;=i&lt;m,0&lt;=j&lt;n)$  </p>
</li>
</ul>
</li>
</ul>
<h3 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h3><p><strong>矩阵的压缩存储</strong>：</p>
<ul>
<li>为多个值相同的非零元只分配一个存储空间</li>
<li>对零元不分配空间</li>
</ul>
<p><strong>需压缩存储的两类矩阵</strong>：</p>
<ul>
<li><p><strong>特殊矩阵</strong>：值相同的元素或零元素在矩阵中的分布有一定规律。如：<strong>对称矩阵、三角矩阵、对角矩阵</strong></p>
</li>
<li><p><strong>稀疏矩阵</strong>：非零元较零元少，且分布没有一定规律。</p>
</li>
</ul>
<h4 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h4><p><strong>对称矩阵</strong>：若一个$n$阶方阵$A$中的元素满足$a_{i,j}=a_{j,i}(0≤i,j&lt;n)$,则称其为$n$阶对称矩阵。</p>
<ul>
<li><p><strong>压缩存储</strong>：以行序为主序存储下三角+主对角线的元素。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221144919380.png" alt="image-20220221144919380"></p>
<p><strong>压缩地址计算公式</strong>：$a_{i,j} = B_k \quad k = i*(i+1)/2+j \quad (i&lt;=j)$ </p>
</li>
</ul>
<p><strong>三角矩阵</strong>：分为上三角矩阵和下三角矩阵。</p>
<ul>
<li><p><strong>上三角矩阵</strong>是指矩阵的下三角（不包括对角线）中的元素均为常数$c$或$0$的$n$阶方阵。</p>
</li>
<li><p><strong>下三角矩阵</strong>是指矩阵的上三角（不包括对角线）中的元素均为常数$c$或$0$的$n$阶方阵。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221145944262.png" alt="image-20220221145944262"></p>
<p><strong>下三角矩阵的压缩存储方法</strong>：以行序为主序存储下三角+主对角线的元素，最后用一个存储单元存储常数$c$,并<br>将压缩结果存储在一维数组$B$中。</p>
<p><strong>压缩地址计算公式</strong>：$k=\begin{cases} i*(i+1)/2+j &amp; i&lt;=j \ n*(n+1)/2 &amp; i&gt;j \quad常数c\end{cases}$</p>
</li>
</ul>
<p><strong>对角矩阵</strong>：若一个$n$阶方阵$A$满足其所有的非零元素集中在以主对角线为中心的带状区域中，则称其为$n$阶对角矩阵。其主对角线上、下方各有$b$条非零元素构成的次对角线，称$b$为矩阵半带宽，$(2b+1)$为矩阵的带宽。</p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221151234876.png" alt="image-20220221151234876" style="zoom:80%;">

<ul>
<li><p><strong>三对角矩阵</strong>：当$b=1$时</p>
<p><strong>压缩存储</strong>：以行序为主序将$A$带宽中的数据存入一维数组中。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221151615976.png" alt="image-20220221151615976"></p>
<p><strong>压缩地址计算公式</strong>：$k=2*i+j$ </p>
</li>
</ul>
<h4 id="稀疏矩阵的压缩存储"><a href="#稀疏矩阵的压缩存储" class="headerlink" title="稀疏矩阵的压缩存储"></a>稀疏矩阵的压缩存储</h4><p><strong>稀疏矩阵</strong>：假设在一个$m\times n$的矩阵中有$t$个非零元，令$δ=t/(m\times n)$,$δ$称为稀疏因子，通常认为$δ≤0.05$时该矩阵为稀疏矩阵。</p>
<p><strong>压缩存储方法</strong>：只存储非零元素。稀疏矩阵中的每一个非零元素需由<strong>三元组</strong>$(i,j,a_{i,j})$唯一确定，所有非零元素（通常以行序为主序顺序排列）构成<strong>三元组线性表</strong>（筒称<strong>三元组表</strong>）。</p>
<p>稀疏矩阵可由表示非零元的<strong>三元组表</strong>以及其<strong>行列数</strong>来唯一确定。</p>
<p><strong>三元组表的两种存储方法</strong>：顺序表表示法、十字链表表示法。</p>
<p><strong>三元组顺序表存储表示</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j; 	<span class="comment">// 第i行j列</span></span><br><span class="line">    ElemType e;	<span class="comment">// e:非0值</span></span><br><span class="line">&#125;Triple;	<span class="comment">//三元组类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Triple data[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> mu, nu, tu;	<span class="comment">// mu行，nu列，tu个非0元</span></span><br><span class="line">&#125;TSMarix;	<span class="comment">//稀疏矩阵</span></span><br></pre></td></tr></table></figure>



<p><strong>十字链表</strong>：每个非零元用一个结点表示，结点中除了<font color="#00f">表示非零元所在的行、列和值的三元组$(i,j,e)$</font>外，增加<font color="#00f">两个指针域</font>。<font color="#00f">行指针域(right)</font>：用来指向本行中下一个非零元素；<font color="#00f">列指针域(down)</font>：用来指向本列中下一个非零元素。稀疏矩阵中同一行的非零元通过向右的 right指针链接成了一个线性链表。同一列的非零元也通过down指针链接成了ー个线性链表。每个非零元既是第$i$行链表中的一个结点，又是第$j$列链表中的一个结点，相当于处在一个十字交叉路口，故称这样的存储结构为十字链表。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221154547201.png" alt="image-20220221154547201"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j;	<span class="comment">// 该非0元素的行和列下标</span></span><br><span class="line">    ElemType e;	<span class="comment">// 同上面的自定义，就是int型</span></span><br><span class="line">    stuct OLNode *right, *down;	<span class="comment">// 非0元素所在行表和列表的后继</span></span><br><span class="line">&#125;OLNode, *OLink;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    OLink *rhead, *chead;	<span class="comment">// 行和列链表头指针向量</span></span><br><span class="line">    <span class="keyword">int</span> mu, nu, tu;	<span class="comment">// 稀疏矩阵的行数、列数、非0元个数</span></span><br><span class="line">&#125;CrossList;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221155156147.png" alt="image-20220221155156147"></p>
<h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><h3 id="广义表的基本概念"><a href="#广义表的基本概念" class="headerlink" title="广义表的基本概念"></a>广义表的基本概念</h3><p>**广义表(Generalized Lists)**：广义表是线性表的推广，是$n$个数据元素$(a_1,a_2,…,a_i,…,a_n)$的有限序列，但不同的是，广义表中的$a$既可以是单个元素，还可以是一个广义表，通常记作：$LS=(a_1,a_2,…,a_i,…,a_n)$ </p>
<ul>
<li>LS是广义表的名字</li>
<li>$n$是广义表的长度，$n=0$时称为空表</li>
<li>若$a$是单个元素，则称$a$为广义表$LS$的<strong>原子(atom)<strong>，若$a$是一个广义表，则称$a$是广义表$LS$的</strong>子表(sublist)</strong></li>
<li>为了区别原子和子表，通常用大写字母表示广义表的名称，用小写字母表示原子。</li>
</ul>
<p><strong>广义表的长度</strong>：广义表最外层包含的元素个数</p>
<p><strong>广义表的深度</strong>：广义表中所含括号的重数</p>
<p><strong>广义表的表头和表尾</strong>：当广义表<strong>非空</strong>时，即$LS=(a_1,a_2,…,a_n)$，第一个表元素$a_1$称为广义表的**表头(head)<strong>，其余元素组成的表$(a_2,…,a_n)$称为广义表的</strong>表尾(tail)**。</p>
<p>示例：</p>
<ul>
<li>$A=(a,(b,c,(d)),d,(d))$：长度4，深度3，$head=(a)$，$tail=((b,c,(d)),d,(d))$</li>
<li>$B=()$：长度0，深度1，空表无表头表尾</li>
<li>$C=(e)$：长度1，深度1，$head=(e)$，$tail=()$ </li>
<li>$E=(a,E)$：递归的表，长度2，深度无穷值，$head=()$，$tail=(E)$  </li>
</ul>
<h3 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h3><p><strong>广义表的存储结构</strong>：由于广义表$(a_1,a_2,…,a_n)$是一种<strong>递归的数据结构</strong>，且其中的数据元素可以具有不同的结构(或是原子，或是列表)，因此难以用顺序存储结构表示，通常采用<strong>链式存储结构</strong>，每个数据元素可用一个结点表示，分别为表结点和原子结点。</p>
<p><strong>链式存储方法</strong>：1）头尾链表表示法  2）扩展线性链表表示法</p>
<p><strong>头尾链表表示法</strong>：</p>
<ul>
<li><p>存储方法：任一非空列表可以分解为表头和表尾，反之，一对确定的表头和表尾可以唯一确定一个广义表。</p>
</li>
<li><p>原子结点：由标志域和值域组成。</p>
</li>
<li><p>表结点：由标志域、指示表头的指针域和指示表尾的指针域组成</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221165024995.png" alt="image-20220221165024995"></p>
<p>$tag=0$，原子结点；$tag=1$，表/子表结点</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>ATOM, LIST&#125; ElemTag;	<span class="comment">// 0 原子 1 子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemTag tag;	<span class="comment">// 标志域，公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="comment">//union类似于enum。不同的是enum实质上是int类型的，而union可以用于所有类型</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>	// 原子结点和表结点的联合部分</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        AtomType atom;	<span class="comment">//atom是原子结点的值域，AtomType由用户自定义</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>, *<span class="title">tp</span>;</span> &#125;ptr;	<span class="comment">// 表结点的表头和表尾指针域</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;*GList;	<span class="comment">//广义表类型</span></span><br></pre></td></tr></table></figure>

<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221170301844.png" alt="image-20220221170301844"></p>
<p>除空表的表头指针为空外，任何非空广义表的表头指针均指向一个表结点，且其hp指向该表的表头，tp指向该表的表尾</p>
<p><strong>扩展线性链表表示法</strong>：</p>
<ul>
<li><p>表结点：由标志域、指示表头的指针域和指示下一元素的指针域组成。</p>
</li>
<li><p>原子结点：由标志域、值域和指示下一元素的指针域组成。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221170919342.png" alt="image-20220221170919342"></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>ATOM, LIST&#125; ElemTag; <span class="comment">// 0 原子  1 子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemTag tag;	<span class="comment">// 标志域，分原子结点和表结点</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>		// 原子结点和表结点的联合部分</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        AtomType atom; <span class="comment">//atom是原子结点的值域，AtomType由用户自定义</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>;</span> <span class="comment">// 表结点的表头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">tp</span>;</span>	<span class="comment">//相当于线性链表的next,指向下一个元素结点</span></span><br><span class="line">&#125;*GList;</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221171457502.png" alt="image-20220221171457502"></p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>**树(Tree)**是$n(n&gt;=0)$个结点的有限集。</p>
<p>在任意一棵非空树中<br>(1)有且仅有一个根结点<br>(2)除根结点外，其余结点可分为$m(m&gt;=0)$个互不相交的有限集$T_1,T_2,…,T_m$,其中每个集合本身又是一棵树，称为根的子树。</p>
<p><strong>基本术语</strong>：</p>
<ul>
<li>结点<ul>
<li>父结点、子结点</li>
<li>兄弟、堂兄弟</li>
<li>分枝结点、叶子</li>
</ul>
</li>
<li>结点的度：一个结点拥有子树的个数</li>
<li>树的度</li>
<li>祖先、子孙</li>
<li>层数</li>
<li>树的高度或深度</li>
<li>路径和路径长度</li>
<li>有序树与无序树</li>
</ul>
<p><strong>森林</strong>是$m(m&gt;=0)$棵互不相交的树的集合。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>双亲数组存储表示</p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222145320646.png" alt="image-20220222145320646" style="zoom:80%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n0 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dataType char</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> &#123;</span></span><br><span class="line">    dataType data;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> <span class="title">t</span>[<span class="title">n0</span>+1];</span></span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>孩子链表存储表示</p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222150000605.png" alt="image-20220222150000605" style="zoom:80%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dataType char</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sub;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> &#123;</span></span><br><span class="line">    dataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">children</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> <span class="title">t</span>[<span class="title">n</span> + 1];</span></span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>孩子——兄弟链存储表示</p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222152052142.png" alt="image-20220222152052142" style="zoom:80%;">





<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树分类"><a href="#二叉树分类" class="headerlink" title="二叉树分类"></a>二叉树分类</h3><p><strong>二叉树</strong>：由一个根结点和两棵互不相交的、分别称为这个根的<strong>左子树</strong>和<strong>右子树</strong>的二叉树组成。</p>
<p><strong>满二叉树</strong>：有$2^k-1 \quad(k&gt;0)$ 个结点的二叉树，即所有的叶子都在同一层。</p>
<p><strong>完全二叉树</strong>：至多只有最下面的两层结点度数可以小于2，并且最下面一层的结点都集中在该层最左边的若干位置上</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221212456927.png" alt="image-20220221212456927"></p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul>
<li>在二叉树的第$i(i&gt;0)$层上至多有$2^{i-1}$个结点。</li>
<li>深度为$k$的二叉树中至多有$2^k-1$个结点$(k&gt;0)$</li>
<li>对任何二叉树，若其终端结点数为$n0$，度数为2的结点数为$n2$，则$n0 = n2 + 1$。</li>
<li>有$n$个结点的完全二叉树的深度为 $d+1 \quad d为&lt;=log_2n的最大整数$ </li>
<li>对有$n$个结点的完全二叉树按层序从$1$开始编号，对任一结点$i$ $(1&lt;=i&lt;=n)$：<ul>
<li>$i=1$是根结点；$i&gt;1$，父节点是$i/2$ </li>
<li>$2<em>i&lt;=n$，左孩子是$2</em>i$</li>
<li>$2<em>i+1&lt;=n$，左孩子是$2</em>i$，右孩子是$2*i+1$ </li>
</ul>
</li>
</ul>
<h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><ul>
<li>顺序存储</li>
<li>二叉链存储<ul>
<li>静态二叉链</li>
<li>动态二叉链</li>
</ul>
</li>
</ul>
<p><strong>顺序存储</strong>：用数组，按完全二叉树的顺序存储；对于一般的二叉树，在二叉树中补上虚拟结点使其成为完全二叉树。注意数组空出第0位。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221222838480.png" alt="image-20220221222838480"></p>
<p><strong>二叉链存储</strong>：每个结点包括数据域和指针域。数据域存储结点的数据，指针域有两个分别指向左孩子和右孩子的指针。</p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221223915686.png" alt="image-20220221223915686" style="zoom:80%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">btnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    dataType data;	<span class="comment">// 用户定义的数据类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">btnode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTnode, *BiTree;</span><br></pre></td></tr></table></figure>

<p><strong>静态二叉链</strong></p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221225133876.png" alt="image-20220221225133876" style="zoom:80%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbtnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    dataType data;		<span class="comment">//数值字段</span></span><br><span class="line">    <span class="keyword">int</span> llink, rlink;	<span class="comment">//指针字段</span></span><br><span class="line">&#125;tree[n + <span class="number">1</span>];	<span class="comment">// n：二叉树的结点个数，不能这样直接创建数组tree[n+1]</span></span><br></pre></td></tr></table></figure>



<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p><strong>二叉树的遍历</strong>：按某条搜索路径访问二叉树中每一个结点，使得每个结点被访问一次且仅被访问一次。</p>
<p>遍历方法：<strong>先序遍历、中序遍历、后序遍历、层次遍历</strong>。</p>
<p><strong>先序遍历</strong>：根——&gt;左子树——&gt;右子树</p>
<p><strong>中序遍历</strong>：左子树——&gt;根——&gt;右子树</p>
<p><strong>后序遍历</strong>：左子树——&gt;右子树——&gt;根</p>
<p><strong>层次遍历</strong>：按层次，每层从左到右遍历</p>
<p>示例：</p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220221230924269.png" alt="image-20220221230924269" style="zoom:80%;">

<p>注：已知二叉树的先序遍历和中序遍历，则该二叉树能唯一确定</p>
<h3 id="遍历算法实现"><a href="#遍历算法实现" class="headerlink" title="遍历算法实现"></a><strong>遍历算法实现</strong></h3><p><strong>层次遍历</strong>伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initqueue(q);	<span class="comment">// 创建一个空队列</span></span><br><span class="line">    enqueue(q, T);		<span class="comment">// T入队</span></span><br><span class="line">    <span class="keyword">while</span>(!empty(q))</span><br><span class="line">    &#123;</span><br><span class="line">        dequeue(q, T);	<span class="comment">// q的队首结点出队给T</span></span><br><span class="line">     	visite(T-&gt;data);	<span class="comment">//访问结点T;</span></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;lchild) enqueue(q, T-&gt;lchild); <span class="comment">//如果T存在左孩子，左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;rchild) enqueue(q, T-&gt;rchild); <span class="comment">//如果T存在右孩子，右孩子入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归实现</strong></p>
<ul>
<li><p><strong>先序遍历</strong>递归伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先序遍历以T为根的二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        visite(T-&gt;data);		<span class="comment">//访问根结点</span></span><br><span class="line">        preOrder(T-&gt;lchild);	<span class="comment">//先序遍历左子树</span></span><br><span class="line">        preOrder(T-&gt;rchild);	<span class="comment">//先序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>中序遍历</strong>递归伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历以T为根的二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(T) &#123;</span><br><span class="line">        inOrder(T-&gt;lchild);	<span class="comment">//中序遍历左子树</span></span><br><span class="line">        visite(T-&gt;data);	<span class="comment">//访问根节点</span></span><br><span class="line">        inOrder(T-&gt;rchild);	<span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>后序遍历</strong>递归伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 后序遍历以T为根的二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(T) &#123;</span><br><span class="line">        postOrder(T-&gt;lchild);	<span class="comment">//后序遍历左子树</span></span><br><span class="line">        postOrder(T-&gt;rchild);	<span class="comment">//后序遍历右子树</span></span><br><span class="line">        visite(T-&gt;data);		<span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>非递归实现</strong></p>
<ul>
<li><p><strong>先序遍历</strong>的非递归伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initstack(s);	<span class="comment">// 创建一个空栈s</span></span><br><span class="line">    <span class="keyword">while</span>(T || !empty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T) &#123;	<span class="comment">// 若T不空，访问T</span></span><br><span class="line">        	visite(T-&gt;data);	<span class="comment">//访问根结点</span></span><br><span class="line">            push(s, T);			<span class="comment">//T入栈</span></span><br><span class="line">            T = T-&gt;lchild;		<span class="comment">//沿左子树遍历</span></span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pop(s, T);			<span class="comment">//栈顶元素出栈给T</span></span><br><span class="line">            T = T-&gt;rchild;		<span class="comment">//沿右子树遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>中序遍历</strong>的非递归伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initstack(s);	<span class="comment">// 创建一个空栈s</span></span><br><span class="line">    <span class="keyword">while</span>(T || !empty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T) &#123; 	<span class="comment">// 若T不空，T入栈，出栈的时候访问</span></span><br><span class="line">            push(s,T);	</span><br><span class="line">            T = T-&gt;lchild;	<span class="comment">//沿左子树遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pop(s, T);		<span class="comment">//栈顶元素出栈给T</span></span><br><span class="line">            visite(T-&gt;data);</span><br><span class="line">            T = T-&gt;rchild;	<span class="comment">//沿右子树遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>后序遍历</strong>的非递归伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initstack(s);</span><br><span class="line">    initstack(tag);	<span class="comment">// 存放0和1，用于判断是否读取s出栈结点的data，1表示从左子树回退，0表示从右子树回退</span></span><br><span class="line">    <span class="keyword">while</span>(T || !empty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T) &#123;</span><br><span class="line">            push(s, T);</span><br><span class="line">            push(tag, LEFT);	<span class="comment">//LEFT是1</span></span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        pop(s, T);				<span class="comment">//将s中的栈顶结点弹给T</span></span><br><span class="line">        pop(tag, flag);			<span class="comment">//将T对应的标识弹出</span></span><br><span class="line">        <span class="keyword">if</span>(flag == LEFT) &#123;		<span class="comment">//如果从左子树回来</span></span><br><span class="line">            push(tag, RIGHT);	<span class="comment">//标识改为右子树入栈</span></span><br><span class="line">            push(s, T);			<span class="comment">//T也入栈</span></span><br><span class="line">            T = T-&gt;rchild;		<span class="comment">//T指向右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;					<span class="comment">//如果从右子树回来</span></span><br><span class="line">            visite(T-&gt;data);	<span class="comment">//读取数据</span></span><br><span class="line">            T = <span class="literal">NULL</span>;			<span class="comment">// T值空，继续弹栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><strong>遍历二叉树</strong>是按一定的规则将二叉树中结点排列成一个线性序列；这实际上是把一个非线性结构进行线性化的操作。</p>
<p><strong>线索二叉树</strong>也是一种用来表示二叉树的二叉链表。在这种二叉链表中，每个结点的空的左孩子指针域中放入了在某种遍历次序下该结点的前驱结点的地址；每个结点的空的右孩子指针域中放入了在这种遍历次序下该结点的后继结点的地址。这种附加的指针值称为<strong>线索</strong>。给二叉树的二叉链表存储结构加上线索的过程称为<strong>线索化</strong>二叉树。这个过程可通过对二叉树进行相应次序的遍历来实现。根据遍历方法的不同，线索二叉树一般分<strong>前序线索二叉树</strong>、<strong>中序线索二叉树</strong>和<strong>后序线索二叉树</strong>三种。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222202712310.png" alt="image-20220222202712310"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThrTreeNode</span> &#123;</span></span><br><span class="line">   	<span class="comment">// 线索二叉树中每个结点的结构 </span></span><br><span class="line">   	TElemType data;</span><br><span class="line">   	ThrTreeNode *lchild,*rchild;</span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>先序线索二叉树</strong>和<strong>先序线索二叉树链</strong> （先序遍历序列：$abcdfge$）</p>
<p>前驱和后继是按先序的规则来确定的，如图中的$g$前驱指向$f$，后继指向$e$，对应顺序$gfe$</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222203008574.png" alt="image-20220222203008574"></p>
<ul>
<li>以上结构构成的二叉链表作为二叉树的存储结构，叫做<strong>线索二叉链</strong></li>
<li>指向结点前驱或后继的指针叫做<strong>线索</strong> </li>
<li>加上线索的二叉树叫<strong>线索二叉树</strong></li>
<li>对二叉树以某种次序遍历使其变为线索二叉树的过程叫做<strong>线索化</strong></li>
</ul>
<p><strong>中序线索二叉树</strong>（中序遍历序列：DGBAEHCF）</p>
<p>前驱和后继是按中序的规则来确定的，如图中的$H$前驱指向$E$，后继指向$C$，对应顺序$EHC$</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222203352488.png" alt="image-20220222203352488"></p>
<p><strong>先序遍历</strong>伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(struct ThrTreeNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先序遍历以p为根的线索二叉树</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        visite(p-&gt;data);	<span class="comment">//访问根结点</span></span><br><span class="line">        p = p-&gt;lchild;		<span class="comment">//p指向左孩子或前驱结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中序遍历</strong>伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(struct ThrTreeNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历以p为根的线索二叉树</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild;	<span class="comment">//从根开始找到一个无前驱的结点p</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     	visite(p-&gt;data);	<span class="comment">// 访问根结点</span></span><br><span class="line">        p = p-&gt;rchild;		<span class="comment">// p指向右孩子或后继结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>静态线索二叉链</strong>：$+$：左、右孩子；$-$：前驱、后继线索</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222210752113.png" alt="image-20220222210752113"></p>
<h3 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h3><p><strong>二叉树的带权路径长度</strong>：$WPL=\sum_{k=1}^nw_kl_k$ ，其中:</p>
<ul>
<li>$n$：树叶结点的个</li>
<li>$w_k$：第$k$个结点的权</li>
<li>$l_k$：第$k$个叶子到根的路径长度</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222161238235.png" alt="image-20220222161238235"></p>
<p><strong>Huffman树</strong>是一个带权路径长度最小的二叉树，又称<strong>最优二叉树</strong>。构建方法：</p>
<ul>
<li>将${w_1,w_2,…,w_n}$看成$n$个二叉树</li>
<li>选择2个根结点最小的二叉树，构造新的二叉树，重复至剩1个树</li>
</ul>
<p>例：$Z:2,K:7,M:24,C:32,U:37,D:42,L:42,E:120$ </p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222162202306.png" alt="image-20220222162202306"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222162223523.png" alt="image-20220222162223523"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222162328619.png" alt="image-20220222162328619"></p>
<p><strong>静态三叉链</strong>：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222195332551.png" alt="image-20220222195332551"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 5</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">htnode</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> weight;</span><br><span class="line">    <span class="keyword">int</span> llink, rlink, plink; <span class="comment">// 左孩子 右孩子 双亲</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>Huffman编码</strong></p>
<p>Huffman编码是广泛地用于数据文件压缩的十分有效的编码方法。其压缩率通常在20%~90%之间。Huffman编码算法用字符在文件中出现的频率表来建立一个用0,1串表示各字符的最优表示方式。给出现频率高的字符较短的编码，出现频率较低的字符以较长的编码，可以大大缩短总码长。</p>
<p><strong>前缀码</strong>：对每一个字符规定一个0,1串作为其代码，并要求任一字符的代码都不是其它字符代码的前缀，这种编码称为前缀码。</p>
<p>二叉树C的Huffman编码是：$E:0,U:100,D:101,L:110,C:1110,Z:111100,K:111101,F:11111$ </p>
<h3 id="树、森林转换二叉树"><a href="#树、森林转换二叉树" class="headerlink" title="树、森林转换二叉树"></a>树、森林转换二叉树</h3><p><strong>树转换成二叉树</strong></p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222153139457.png" alt="image-20220222153139457">

<p><strong>森林转换成二叉树</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222154146235.png" alt="image-20220222154146235"></p>
<p>树A的先序遍历：oabcdfeg   对应   二叉树B的先序遍历：oabcdfeg</p>
<p>树A的后序遍历：bafdecgo   对应   二叉树B的中序遍历：bafdecgo</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p>**图(Graph)**是一种较线性结构和树更为复杂的数据结构。对于图来说，图中任意两个结点之间都可以直接相关。</p>
<p>图是一个二元组，$G=(V,E)$。其中，  $V$：顶点的有限集, $E$：关系(边)的有限集。</p>
<p>例：<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222214654118.png" alt="image-20220222214654118"></p>
<p>无向图  $G1=(V,E)\quad V＝{v_1, v_2, v_3, v_4, v_5}\quad E＝{(v_1,v_2), (v_1,v_4),  (v_2,v_3), (v_2,v_5),  (v_3,v_4), (v_3,v_5)}$ </p>
<p>有向图  $G2=(V,E)\quad V＝{v_1, v_2, v_3, v_4}\quad E＝{&lt;v_1,v_2&gt;, &lt;v_1,v_3&gt;,  &lt;v_3,v_4&gt;, &lt;v_4,v_1&gt;}$ </p>
<p>图是一种网状的数据结构，其中的结点之间的关系是任意的，即图中任何两个结点之间都可能直接相关。</p>
<p><strong>顶点</strong>：图中的数据元素</p>
<p><strong>边</strong>：两个顶点之间的关系。</p>
<ul>
<li>对于无向图，图中的顶点偶对（边）是无序的</li>
<li>而对于有向图，图中的顶点偶对（弧）是有序的<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222215421328.png" alt="image-20220222215421328" style="zoom: 67%;"></li>
</ul>
<p><strong>完全图</strong>：有$n(n-1)/2$条边的无向图，即每个结点之间都有且只有一条边。</p>
<p><strong>有向完全图</strong>：有$n(n-1)$条边的有向图。</p>
<p><strong>稠密图</strong>：有很少的边或弧的图。</p>
<p><strong>稀疏图</strong>：有很多的边或弧的图。</p>
<p><strong>权</strong>：与图的边相关的数值。</p>
<p><strong>网</strong>：带权的图。</p>
<p><strong>子图</strong>：设两个图$G＝(V, E)$和$G’=(V’,E’)$，如果$V’\subseteq V$且$E’\subseteq  E$，则称$G’$为$G$的子图。</p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222222143650.png" alt="image-20220222222143650" style="zoom:67%;">

<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222220552674.png" alt="image-20220222220552674"></p>
<p><strong>邻接点</strong>：</p>
<ul>
<li>对于无向图$G＝(V,E)$，若存在顶点对$(x,y)\in E$，则称顶点$x$和$y$互为邻接顶点。即$x$和$y$相邻接（相关联）。</li>
<li>对于有向图$G＝(V,E)$，若存在顶点对$&lt;x,y&gt;\in E$，则称顶点$x$邻接到顶点$y$，顶点$y$邻接于到顶点$x$。</li>
</ul>
<p><strong>顶点的度</strong>：</p>
<ul>
<li>在无向图中，和该顶点相关联的边的数目称为顶点的度。</li>
<li>在有向图中，若$&lt;x,y&gt;$是一条弧，以$x$为尾的弧的数目称为顶点$x$的<strong>出度</strong>；以$x$为头的弧的数目称为顶点$x$<br>的<strong>入度</strong>。<strong>顶点的度等于该顶点的入度与出度之和</strong>。</li>
</ul>
<p><strong>路径</strong>：  在图$G＝( V, E )$中, 若从顶点 $x$ 出发，经过一些顶点 $v_1, v_2, … , v_m$ 到达顶点$y$。则称顶点序列 $(x,v_1,v_2, … ,V_m, y)$ 为从顶点 $x$ 到顶点 $y$ 的路径。</p>
<p><strong>路径长度</strong>：</p>
<ul>
<li>非带权图的路径长度是指此路径上边的条数。</li>
<li>带权图的路径长度是指路径上各边的权之和。</li>
</ul>
<p><strong>简单路径</strong>：序列中顶点不重复出现的路径。</p>
<p>**回路(环)**：第一个顶点和最后一个顶点相同的路径。</p>
<p>**简单回路(环)**：除第一个和最后一个顶点，其余顶点不重复出现的路径。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222230204252.png" alt="image-20220222230204252"></p>
<p><strong>连通</strong>：在无向图中，如果从$x$到$y$存在路径，则称$x$和$y$是连通的。</p>
<p><strong>连通图</strong>：无向图$G$中如果任意两个顶点$x,y$之间都是连通的，则称图$G$是连通图。</p>
<p><strong>强连通图</strong>：有向图$G$中任意两个顶点$x,y$之间都是相互可达的。称图$G$是强连通图。</p>
<p><strong>连通分量</strong>：无向图中的<strong>极大连通子图</strong>（即把原图中任意一个不在子图中顶点加进去，子图从连通变为不连通，则为极大连通子图）。</p>
<p><strong>强连通分量</strong>：有向图中的极大连通子图。</p>
<p><strong>树图</strong>：极小连通子图（无环图），在$n$个顶点的情形下，有$n-1$条边。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222232125649.png" alt="image-20220222232125649"></p>
<h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>数组表示法（邻接矩阵）</strong></p>
<p>图需要存储的信息：顶点和边。</p>
<p><strong>邻接矩阵</strong>：表示顶点之间相邻关系的矩阵。$a_{ij}=\begin{cases}1\quad &lt;v_i,v_j&gt;\in E \ 0\quad others \end{cases}$ </p>
<p><strong>网的邻接矩阵</strong>：$A[i][j]=\begin{cases}W_{i,j}\quad &lt;v_i,v_j&gt;\in E \ 0\quad i=j \ \infty \quad others \end{cases}$</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220222234321262.png" alt="image-20220222234321262"></p>
<p>邻接矩阵的特点：</p>
<ul>
<li>无向图的邻接矩阵一定是一个对称矩阵。</li>
<li>无向图的邻接矩阵的第$i$行（或第$i$列）非零元素（或非$\infty$元素）个数为第$i$个顶点的度$D(v_i)$。</li>
<li>有向图的邻接矩阵的第$i$行非零元素（或非$\infty$元素）个数为第$i$个顶点的出度$OD(v_i)$，第$i$列非零元素（或非$\infty$元素）个数就是第$i$个顶点的入度$ID(v_i)$。</li>
</ul>
<p><strong>邻接表（邻接链表）</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220223000152339.png" alt="image-20220223000152339"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220223001012587.png" alt="image-20220223001012587"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220223002436155.png" alt="image-20220223002436155"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220223001557967.png" alt="image-20220223001557967"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> info;</span><br><span class="line">    <span class="keyword">int</span> vertex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span>* <span class="title">nextarc</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> degree;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">acrnode</span>* <span class="title">firstarc</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历：从图中某一顶点出发访遍图中其余结点，使每一个结点被访问且仅被访问一次。</p>
<p>图的遍历通常有两种方法：<strong>深度优先搜索</strong>和<strong>广度优先搜索</strong>。它们对有向图和无向图都适用。</p>
<h4 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索(Depth First Search)"></a><strong>深度优先搜索(Depth First Search)</strong></h4><blockquote>
<p>类似于树的先根遍历，是树的先根遍历的推广。</p>
</blockquote>
<pre><code>  从图中某个顶点v出发，访问此顶点，然后依次从v的未被访问的邻接点出发深度优先遍历图,   直至所有与v有通路的顶点都被访问到；若此时图中还有顶点未被访问到，则另选图中未被访问的顶点作起点，重复上述过程，直到图中所有顶点都被访问到为止。
</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(graph g, vtxptr v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从v0出发深度优先遍历图g,</span></span><br><span class="line">    <span class="comment">// g是连通图 或 非连通图中的一个连通分量访问v0;</span></span><br><span class="line">    w = v0的第一个连接点;</span><br><span class="line">    <span class="keyword">while</span>(当邻接点w存在时) &#123;</span><br><span class="line">        <span class="keyword">if</span>(w未访) dfs(g, w);</span><br><span class="line">        w = 下一邻接点;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="广度优先搜索-Breadth-First-Search"><a href="#广度优先搜索-Breadth-First-Search" class="headerlink" title="广度优先搜索(Breadth First Search)"></a><strong>广度优先搜索(Breadth First Search)</strong></h4><blockquote>
<p>类似于树的层次遍历。</p>
</blockquote>
<pre><code>  从图中某个顶点v出发，在访问了v之后，依次访问v的各个未曾访问过的邻接点(并保证先被访问的顶点的邻接点“要先于”后被访问的顶点的邻接点被访问),     直至图中所有已被访问的顶点的邻接点都被访问到。若此时图中还有未被访问的顶点，则任选其中之一作为起点，重新开始上述过程，直至图中所有顶点都被访问到。
</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(graph g, vtxptr v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从v0出发广度优先遍历图g（g是连通图或连通分量）</span></span><br><span class="line">    visite(v0); mark[v0] = <span class="number">1</span>;</span><br><span class="line">    initqueue(Q);</span><br><span class="line">    enqueue(Q, v0); <span class="comment">// v0进队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!empty(Q)) &#123;</span><br><span class="line">        dequeue(Q, v);</span><br><span class="line">        w = v的第一个邻接点;</span><br><span class="line">        <span class="keyword">while</span>(w存在) &#123;</span><br><span class="line">            <span class="keyword">if</span>(w未访) &#123;</span><br><span class="line">            	visite(w); mark[w] = <span class="number">1</span>; enqueue(Q, w);</span><br><span class="line">                w = 下一邻接点;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220228104959785.png" alt="image-20220228104959785"></p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><strong>生成树</strong>：按深度遍历得到的生成树称为深度优先生成树；按广度遍历得到的生成树称为广度优先生成树。</p>
<p>连通图或有根有向图可以生成树。</p>
<p><strong>有根的图</strong>：存在一个顶点X,从该顶点出发可以沿着有向路径到达图中其余各顶点的有向图。顶点X为图的根。</p>
<p><strong>生成树林</strong>：从非连通图中任意一个顶点出发，或者从非强连通图中任意一个非根顶点出发，都不可能沿着边<br>访问到图中的所有顶点。</p>
<p><strong>最小生成树</strong>：生成树中边的权值（代价）之和最小的树。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220228110032759.png" alt="image-20220228110032759"></p>
<h4 id="Kruscal算法"><a href="#Kruscal算法" class="headerlink" title="Kruscal算法"></a><strong>Kruscal算法</strong></h4><p>基本思想：设$T=(U,TE)$是$G=(V,E)$的最小生成树，$U$的初值等于$V$，$TE$的初值为空集。将图中的<font color="#ff0000">边按权值从小到大的顺序依次选取</font>，若选取的边使生成树$T$不形成回路，则把它并入$TE$中，保留作为$T$的一条边；若选取的边使生成树T形成回路，则将其舍去。如此进行下去，直到$TE$中包含有$n-1$条边为止。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220228111700867.png" alt="image-20220228111700867"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">T = &#123;V, E&#125;;</span><br><span class="line"><span class="keyword">while</span>(T的边数 &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">    在E中选择代价最小的边(u, v);</span><br><span class="line">    并置 E = E - (u, v);</span><br><span class="line">    <span class="keyword">if</span>(不构成回路) &#123;</span><br><span class="line">        T = T + &#123;u, v&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a><strong>prim算法</strong></h4><p>从某一顶点开始，找$n-1$条不构成回路的最小边（顶点偶对）。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220228112316673.png" alt="image-20220228112316673"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minispantree_prim</span><span class="params">(graph g, <span class="keyword">int</span> u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从u出发构造网g的最小生成树</span></span><br><span class="line">	<span class="keyword">for</span>(v = <span class="number">1</span>; v &lt;= vtxnum; v++) &#123; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">if</span>(v != u) &#123;</span><br><span class="line">            closedge[v].vex = u;</span><br><span class="line">            closedge[v].lowcost = g[u][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= vtxnum - <span class="number">1</span>; ++i) &#123; </span><br><span class="line">        k=最小边所在下标位置;输出生成树的边;</span><br><span class="line">        closedge[k].lowcost = <span class="number">0</span>; <span class="comment">////顶点k并入U集</span></span><br><span class="line">        <span class="keyword">for</span>(v = <span class="number">1</span> ; v &lt;= vtxnum; ++v) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(g[k][v] &lt; closedge[v].lowcost) &#123; <span class="comment">// 选择具有最小代价的边</span></span><br><span class="line">   				closedge[v].lowcost=g[k][v]; </span><br><span class="line">                closedge[v].vex=k;  </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>用顶点边表示活动的网络，简称<strong>AOV网络(Activity On Vertices)</strong></p>
<p><strong>顶点</strong>：一个工程中的活动(Activity)</p>
<p><strong>边</strong>：活动的顶点间的优先关系(Relation)</p>
<p>可以用有向图表示一个工程。在这种有向图中，用顶点表示活动。有向边$&lt;V_i,V_j&gt;$表示：$V_i$必须先于活动$V_j$进行。这种有向图叫做顶点表示活动的<strong>AOV网络(Activity On Vertices)</strong></p>
<p>在AOV网络中，如果活动$V_i$，必须在活动$V_j$，之前进行，则存在有向边$&lt;V_i,V_j&gt;$，AOV网络中不能出现有向回路，即有向环。在AOV网络中如果出现了有向环，则意味着某项活动应以自己作为先决条件。因此，对给定的AOV网络，必须先判断它是否存在有向环。</p>
<p>将各个顶点（代表各个活动）排列成一个线性有序的序列，使得AOV网络中所有应存在的前驱和后继关系<br>都能得到满足——<strong>拓扑序列</strong>。</p>
<p>这种构造AOV网络全部顶点的拓扑有序序列的运算就叫做<strong>拓扑排序</strong>。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220228165540390.png" alt="image-20220228165540390"></p>
<p><strong>存储结构（邻接表）：</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220228170107169.png" alt="image-20220228170107169"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;</span><br><span class="line">    arcnode *nextarc;</span><br><span class="line">&#125;* pointer;	<span class="comment">// 表结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> vexdata;</span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">// 顶点的入度</span></span><br><span class="line">    pointer firstarc;</span><br><span class="line">&#125;dig[<span class="number">100</span>];	<span class="comment">//一组头结点</span></span><br></pre></td></tr></table></figure>



<p><strong>拓扑排序的方法</strong>：</p>
<p>首先建立(n个顶点的)AOV网。</p>
<p>1、在AOV网络中选一个没有直接前驱的项点（入度为0的顶点），并输出之；</p>
<p>2、从图中删去该顶点，同时删去所有它发出的边；</p>
<p>重复(1)和(2)，直到全部顶点均已输出，</p>
<p>拓扑有序序列形成，拓扑排序完成：</p>
<p>若图中还有未输出的顶点，但已跳出处理循环。这说明图中存在环</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220228170619932.png" alt="image-20220228170619932"></p>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>用边表示活动的网络，简称 **AOE网络 (Activity On Edges) **</p>
<p><strong>边</strong>：一个工程中的活动(Activity)</p>
<p><strong>边上权值</strong>：活动持续时间(Duration)</p>
<p><strong>顶点</strong>：事件 (Event)</p>
<p>完成整个工程所需的时间取决于从源点到汇点的最长路径长度，即在这条路径上所有活动的持续时间之和。这条路径长度最长的路径就叫做**关键路径(Critical Path)**。</p>
<p>1）先求所有事件的$Ve$ $\quad$  2）通过$Ve$反向求所有事件$Vl$</p>
<p>事件$V_j$的最早可能开始时间$Ve[j]$——从源点$V1$ 到顶点$V_j$的最长路径长度。</p>
<ul>
<li>$Ve(1)=0$                             </li>
<li>$Ve(j)=max{Ve(i)+&lt;i,j&gt;的权} $</li>
</ul>
<p>事件$V_i$ 的最迟允许开始时间$Vl[i]$ ——在保证汇点$Vn$ 在$Ve[n]$时刻完成的前提下，事件$V_i$的允许的最迟开始时间。</p>
<ul>
<li> $Vl(n)=Ve(n)$</li>
<li> $Vl(i)=min{Vl(j)-&lt;i,j&gt;的权}$</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220228172012931.png" alt="image-20220228172012931"></p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>最短路径问题：如果从图中某一顶点(称为源点)到达另一顶点（称为终点）的路径可能不止一条，如何找到一条路径使得<br>沿此路径上各边上的权值总和达到最小。</p>
<p>解法：</p>
<ul>
<li>单源最短路径问题——Dijkstra算法</li>
<li>所有顶点之间的最短路径——Floyd算法</li>
</ul>
<h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p><strong>单源最短路径问题</strong>：给定一个带权有向图D与源点v，求从v到D中其它顶点的最短路径（限定各边上的权值大于或等于0） 。</p>
<p>按路径长度的递增次序，逐步产生最短路径。首先求出长度最短的一条最短路径，再参照它求出长度次短的一条最短路径，依次类推，直到从顶点v到其它各顶点的最短路径全部求出为止。</p>
<ul>
<li>引入一个辅助数组$dist$。它的每一个分量$dist[i]$表示当前找到的从源点$v_0$到终点$v_i$的最短路径的长度。初始状态：<ul>
<li>若从源点$v_0$到顶点$v_i$有边，则$dist[i]$为该边上的权值</li>
<li>若从源点$v_0$到顶点$v_i$没有边，则$dist[i]$为$+\infty$</li>
</ul>
</li>
<li>假设 $S$ 是已求得的最短路径的终点的集合。</li>
<li>首先，在 $dist$ 数组中求最小值$v_k(v_k\in V-S)$ ，将$v_k$加入集合 $S$</li>
<li>然后，对所有的$v_i\in V-S$，修改其$dist[i]$值（$v_0-&gt;v_i$短，还是$v_0-&gt;v_k-&gt;v_i$更短）</li>
<li>重复上述过程</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//a[i][j]:(vi,vj)的权，dist[j]:当前求到的从顶点v 到顶点j的最短路径长度, </span></span><br><span class="line">	<span class="comment">//同时用数组path[j]:存放求到的最短路径, 0 &lt;= j &lt; n</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dist[i] = a[v][i];	<span class="comment">// dist数组初始化</span></span><br><span class="line">        S[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i != v &amp;&amp; dist[i] &lt; MAXNUM) path[i] = v;</span><br><span class="line">        <span class="keyword">else</span> path[i] = <span class="number">-1</span>;	<span class="comment">//path数组初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    S[v] = <span class="number">1</span>; 	<span class="comment">// 顶点v加入顶点集合</span></span><br><span class="line">    dist[v] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ ) &#123;			</span><br><span class="line">		u = 当前不在集合S中且具有最短路径的顶点;</span><br><span class="line">		S[u] = <span class="number">1</span>;  <span class="comment">//将顶点u加入集合S</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++)  &#123;  <span class="comment">//修改 </span></span><br><span class="line">			<span class="keyword">if</span> ( !S[w] &amp;&amp; a[u][w] &lt; MAXNUM &amp;&amp; dist[u] + a[u][w] &lt; dist[w] ) &#123;</span><br><span class="line">				dist[w] = dist[u] + a[u][w]; </span><br><span class="line">				path[w] = u;</span><br><span class="line">            &#125; </span><br><span class="line">      	&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220228180249428.png" alt="image-20220228180249428"></p>
<h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><p><strong>所有顶点之间的最短路径</strong>：对每一对顶点$v_i\neq v_j$，要求求出$v_i$与$v_j$之间的最短路径和最短路径长度。</p>
<p><strong>Floyd算法的基本思想</strong>：</p>
<p>定义一个$n$阶方阵序列：$A^{(0)},A^{(1)},…,A^{(n)}$ </p>
<p>其中 $A^{(0)}[i][j] = a[i][j] \ A^{(k)}[i][j] = min{A^{(k-1)}[i][j],A^{(k-1)}[i][k] + A^{(k-1)}[k][j]} \quad k = 1,2,…, n $   </p>
<p>$A^{(k)}[i][j]$是从顶点$v_i$到$v_j$，中间顶点的序号不大于$k$的最短路径的长度，$A^{(n)}[i][j]$是从顶点$v_i$到$v_j$的最短路径长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>, i &lt;= n; ++i) &#123;	<span class="comment">//矩阵a与path初始化</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != j &amp;&amp; a[i][j] &lt; MAXINT) &#123;</span><br><span class="line">                path[i][j] = i;	<span class="comment">// i到j有路径</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                path[i][j] = <span class="number">0</span>;	<span class="comment">// i到j无路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; ++k) &#123; <span class="comment">//产生a(k)及path(k)</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( a[i][k] + a[k][j] &lt; a[i][j] ) &#123; </span><br><span class="line">					a[i][j] = a[i][k] + a[k][j];</span><br><span class="line">		  			path[i][j] = k;</span><br><span class="line">                &#125;   <span class="comment">//缩短路径长度(i-- k -- j )</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/image-20220302104402103.png" alt="image-20220302104402103"></p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构下</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/</url>
    <content><![CDATA[<p>查找，内部排序，外排序，Trie结构，红黑树，伸展树</p>
<span id="more"></span>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><strong>查找表</strong>是由同一类型的数据元素（或记录）构成的集合。</p>
<p><strong>关键字</strong>：记录中某一数据项的值。</p>
<p><strong>主关键字</strong>：能唯一确定一个元素的关键字（如学号、商品号）。</p>
<p><strong>查找</strong>：根据给定的关键字，在查找表中确定一个其关键字等于给定值的数据元素（记录）的过程</p>
<p>**平均查找长度(ASL)**：查找一个结点所作的平均比较次数（ASL是衡量一个查找算法优劣的主要标准）</p>
<h3 id="静态表的查找"><a href="#静态表的查找" class="headerlink" title="静态表的查找"></a>静态表的查找</h3><p>静态表——以顺序结构存储的表(顺序表)</p>
<p>在表上所作的操作—— 查询某个数据元素是否在查找表中</p>
<h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>算法思想：</p>
<ul>
<li>从表的一端开始，用给定值k与表中各个结点的关键字逐个比较。<ul>
<li>查找成功——找出相等的值；</li>
<li>查找失败——已到达表的另一端，即表中所有结点的关键字值都不等于k。</li>
</ul>
</li>
<li>可在此设置一个监视哨，作为下标越界的条件</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302111152734.png" alt="image-20220302111152734"></p>
<p><strong>监视哨的作用</strong>：作为越界（即已查完）的检测条件省去在循环中每次均要判定是否越界，从而节省比较的时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    keytype key;</span><br><span class="line">    datatype info;</span><br><span class="line">&#125;sstable;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(elemtype r[], <span class="keyword">int</span> n, keytype k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在n个结点的顺序表r[1]..r[n]中查找关键字 k</span></span><br><span class="line">	<span class="keyword">int</span> i = n; <span class="comment">// 从表尾开始向前查找</span></span><br><span class="line">    r[<span class="number">0</span>].key = k;	<span class="comment">//设置监视哨</span></span><br><span class="line">    <span class="keyword">while</span>(r[i].key != k) i--;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">//若r[i].key==k , 则返回i （i≠0） , 否则返回0(未找到）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong></p>
<ul>
<li>查找成功的平均查找长度（在等概率的前提下）$ASL=(1+2+……+n)/n =(n+1)/2$ </li>
<li>查找失败的平均查找长度 $n+1$  </li>
</ul>
<h4 id="二分-折半-查找"><a href="#二分-折半-查找" class="headerlink" title="二分(折半)查找"></a>二分(折半)查找</h4><p>二分查找的先决条件：表中结点按关键字有序，且顺序（一维数组）存储。</p>
<p>二分法思想：<strong>取中，比较</strong> </p>
<ul>
<li>求有序表的中间位置$mid$，若$r[mid].key==k$，查找成功； </li>
<li>若$r[mid].key&gt;k$，在左子表中继续进行二分查找；</li>
<li>若$r[mid].key&lt;k$，则在右子表中继续进 行二分查找。</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302113132985.png" alt="image-20220302113132985"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302113310417.png" alt="image-20220302113310417"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_bin</span><span class="params">(elemtype r[], <span class="keyword">int</span> n, keytype k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  r[1]..r[n] 是按key排序的n个元素，在表中查找 k</span></span><br><span class="line">    i = <span class="number">1</span>; j = n;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">        mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == r[mid].key) <span class="keyword">return</span> mid;	<span class="comment">//查找成功</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; r[mid].key) j = mid - <span class="number">1</span>;	<span class="comment">//在左半部分继续查找</span></span><br><span class="line">        <span class="keyword">else</span> i = mid + <span class="number">1</span>;	<span class="comment">//在右半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//k不在该有序表中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>二分查找判定树</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302114323609.png" alt="image-20220302114323609"></p>
<p>折半查找算法的执行时间为$O(log_2n)$，比顺序查找速度快。</p>
<p>与顺序查找方法相比，折半查找方法的缺点是需要对n个元素预先进行排序，而且只能用顺序方法存储这些元素。</p>
<h4 id="索引顺序表的查找"><a href="#索引顺序表的查找" class="headerlink" title="索引顺序表的查找"></a>索引顺序表的查找</h4><p><strong>分块查找</strong>，又称索引顺序查找。它是顺序查找的一种改进。在此查找方法中，需要建立一个“索引表”。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302114743820.png" alt="image-20220302114743820"></p>
<p><strong>查找方法</strong>：先确定待查记录所在的块（子表）；然后在块中顺序查找。</p>
<h4 id="静态树表的查找"><a href="#静态树表的查找" class="headerlink" title="静态树表的查找"></a>静态树表的查找</h4><p><strong>建立静态树表</strong>：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302115007153.png" alt="image-20220302115007153"></p>
<h3 id="动态表的查找"><a href="#动态表的查找" class="headerlink" title="动态表的查找"></a>动态表的查找</h3><p>动态表的查找，也即树表的查找。一种以树的形式来组织查找表的方法，以实现动态高效率的查找</p>
<ul>
<li>二叉排序树 BST: Binary Sort(Seachar) Tree</li>
<li>平衡二叉树</li>
<li>B-树</li>
<li>B+树</li>
</ul>
<h4 id="二叉排序树BST"><a href="#二叉排序树BST" class="headerlink" title="二叉排序树BST"></a>二叉排序树BST</h4><p><strong>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree）</strong></p>
<p>二叉排序树或空，或满足如下性质：</p>
<ul>
<li>有一个根，若根的左子树非空，则左子树上所有结点的关键字值均小于根结点的值。若根的右子树非空，则右子树上的所有结点的关键字值均大于根结点的值。</li>
<li>左右子树同样是二叉排序树。</li>
</ul>
<p>二叉排序树的特点</p>
<ul>
<li>中序遍历得一有（升）序序列</li>
</ul>
<p>查找方法</p>
<ul>
<li>若根结点的关键字值等于查找的关键字，查找成功。</li>
<li>若小于根结点的关键字值，查其左子树。</li>
<li>若大于根结点的关键字的值，则查其右子树。</li>
<li>在左右子树上的操作类似。</li>
</ul>
<p>结点结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bnode</span> &#123;</span></span><br><span class="line">    keytype key;</span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bnode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bnode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bnode</span> <span class="title">bstnode</span>;</span></span><br></pre></td></tr></table></figure>

<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302120937056.png" alt="image-20220302120937056"></p>
<p>算法伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">bstnode *<span class="title">bstsearch</span><span class="params">(bstnode *t, keytype k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  t:指向根结点, k:待查找关键字</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span> || t-&gt;key == K) <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;key &gt; k) <span class="keyword">return</span> bstsearch(t-&gt;lchild, k); <span class="comment">// 在左子树上查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> bstsearch(t-&gt;rchild, k); <span class="comment">// 在右子树上查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉排序树的插入</p>
<ul>
<li>若二叉树为空。则生成根结点。</li>
<li>若二叉树非空<ul>
<li>首先找到被插结点的父结点。</li>
<li>判断被插结点是其父结点的左、右儿子，将其作为叶子结点插入。</li>
</ul>
</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302121452066.png" alt="image-20220302121452066"></p>
<p>二叉排序树的删除</p>
<ul>
<li><p>删除叶子结点：直接删除。如删除24</p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302122725653.png" alt="image-20220302122725653" style="zoom:67%;"></li>
<li><p>删除子树的根结点：若被删结点的左儿子为空或者右儿子为空。如删除100</p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302122932730.png" alt="image-20220302122932730" style="zoom:67%;"></li>
<li><p>删除子树的根结点且被删结点的左子树和右子树均不空。如删除12</p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302141220666.png" alt="image-20220302141220666" style="zoom:67%;"></li>
<li><p>一般情况</p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302141922103.png" alt="image-20220302141922103" style="zoom:80%;"></li>
</ul>
<h4 id="平衡二叉树AVL"><a href="#平衡二叉树AVL" class="headerlink" title="平衡二叉树AVL"></a>平衡二叉树AVL</h4><p><strong>平衡二叉树(Balanced Binary Tree)又称AVL树</strong>。它或是空树，或是具有下列性质的二叉排序树。</p>
<ul>
<li>它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。</li>
</ul>
<p><strong>平衡因子(Balance Factor)</strong></p>
<ul>
<li>左子树的深度 - 右子树的深度</li>
<li> 即平衡二叉树中每一结点的平衡因子为：0，1，-1。</li>
</ul>
<p>平衡二叉树的查找</p>
<ul>
<li>与二叉排序树查找方法相同。</li>
</ul>
<p>平衡二叉树的插入</p>
<ul>
<li>找插入位置并插入结点</li>
<li>若插入后导致不平衡，则进行调整</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302143707289.png" alt="image-20220302143707289"></p>
<p><strong>平衡旋转</strong></p>
<ul>
<li><p><strong>LL旋转</strong>（LL：表示新插入的结点在危机结点的左子树的左子树上）</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302144157948.png" alt="image-20220302144157948"></p>
</li>
<li><p><strong>LR旋转</strong>（LR：表示新插入的结点在为危机结点的左子树的右子树上）</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302144811362.png" alt="image-20220302144811362"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302145017958.png" alt="image-20220302145017958"></p>
</li>
<li><p><strong>RR旋转</strong>（RR：表示新插入的结点在为危机结点的右子树的右子树上）</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302151745811.png" alt="image-20220302151745811"></p>
</li>
<li><p><strong>RL旋转</strong>（RL：表示新插入的结点在为危机结点的右子树的左子树上）</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302151404708.png" alt="image-20220302151404708"></p>
</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302152456758.png" alt="image-20220302152456758"></p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h4><p>$m$阶B-树或空，或满足</p>
<ul>
<li>树中每个结点最多有$m$个子树 ；</li>
<li>若根结点不是叶子结点，则至少有2个子树；       </li>
<li>除根结点外的所有非叶子结点至少有<code>ceil((double)m/2)</code> 个子树，<code>ceil</code>是向上取整，如：4阶则至少2个，5阶至少3个   </li>
<li>所有的非叶子结点中包含的数据信息为：$(n,A0,K1,R1,A1,K2,R2,A2, ………,Kn,Rn,An,parent)$，其中<ul>
<li>$n$：关键字的个数</li>
<li>$Ki$：关键字</li>
<li>$Ai$：$&gt; Ki$ 且 $&lt; Ki+1$ 的结点地址（A0： &lt;K1 的结点的地址）</li>
<li>$Ri$：关键字 $= Ki$ 的数据记录在硬盘中的地址 $K1 &lt;=K2 &lt;= …… &lt;= Kn$, </li>
<li>$Parent$：父结点的地址，这个可以没有</li>
</ul>
</li>
<li>所有的叶子结点都出现在同一层上，且不带信息</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302154030624.png" alt="image-20220302154030624"></p>
<p>B-树是一个$m$叉平衡排序树</p>
<p><strong>B-树的查找</strong></p>
<ul>
<li><p>类似于二叉树的查找</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302154540083.png" alt="image-20220302154540083"></p>
</li>
</ul>
<p><strong>B-树查找算法伪代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">result <span class="title">srch_mbtree</span><span class="params">(mblink t; keytype k)</span> <span class="comment">//在B-树中查找k</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p=t; q=<span class="literal">NULL</span>; i=<span class="number">0</span>;  <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        i = Search(p, k);</span><br><span class="line">        <span class="comment">//在p-&gt;key[1...n]中查找</span></span><br><span class="line">        <span class="comment">//直至p-&gt;key[i] &lt;= k &lt; p-&gt;key[i+1] 止, 0&lt;=i&lt;=n</span></span><br><span class="line">		<span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; p-&gt;key[i] = k ) <span class="keyword">return</span> (p, i, <span class="number">1</span>);	<span class="comment">//查找成功</span></span><br><span class="line">        <span class="keyword">else</span> &#123; q = p; p = p-&gt;ptr[i]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (q, i, <span class="number">0</span>);	<span class="comment">//查找不成功，返回插入位置信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>B-树的插入</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302155419209.png" alt="image-20220302155419209"></p>
<p>问题：若插入一元素时，使得某一结点&gt;m叉？例如插入60</p>
<p>解决方法：分裂！将一个结点分成两个结点</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302161846561.png" alt="image-20220302161846561"></p>
<p><strong>B-树的删除</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302162714219.png" alt="image-20220302162714219"></p>
<h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h4><p>B+树是 B-树的变形树。</p>
<p>m 阶 B+树与m阶B-树的差异在于：</p>
<ul>
<li>有n个子树的结点中含有n个关键字</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302163033512.png" alt="image-20220302163033512"></p>
<p><strong>B+树的查找</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302170240833.png" alt="image-20220302170240833"></p>
<p><strong>B+树的插入</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302170918508.png" alt="image-20220302170918508"></p>
<p><strong>B+树的删除</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302171154195.png" alt="image-20220302171154195"></p>
<h3 id="hash-散列-查找"><a href="#hash-散列-查找" class="headerlink" title="hash(散列)查找"></a>hash(散列)查找</h3><p><strong>hash表</strong>：根据设定的散列函数和相应解决冲突的方法为一组结点建立的一张表，表中的结点的存储位置依赖于设定的散列函数和处理冲突的方法。</p>
<p><strong>hash（又称散列、杂凑）的基本思想</strong>：以结点的关键值$k$为自变量，通过一定的函数关系 $h$ 计算出对应的函数值 $h(k)$，把这个值解释为结点的存储地址（散列地址）， 将结点存入该地址中去。</p>
<p>设计1个hash函数，计算 Hash函数， 其函数值恰好是 key 在 hash 表中的地址 $hash(key)=i (0..m-1)$</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302172909868.png" alt="image-20220302172909868"></p>
<p><strong>冲突</strong></p>
<p>若对于不同的键值$k1$和$k2$，且$k1\neq k2$，但$h(k1)=h(k2)$，即具有相同的散列地址，这种现象称为<strong>冲突</strong>。称 $k1$、$k2$称为同义词</p>
<p>例：$key={3,15,20,24}$，$m=5$（表长），$hash(k)=k%5$<br>则：$hash(15)=hash(20)=0$ 产生冲突。</p>
<p><strong>表长m的选取</strong></p>
<p>参考：$n / m≈ 3 / 4$  </p>
<ul>
<li>m: hash表的表长</li>
<li>n: hash表中关键字个数</li>
</ul>
<p><strong>装填（负载）因子</strong></p>
<p>$\alpha=表中填入的记录数\div hash表的长度$</p>
<h4 id="构造hash函数"><a href="#构造hash函数" class="headerlink" title="构造hash函数"></a>构造hash函数</h4><p><strong>构造hash函数需要考虑的因素</strong></p>
<ul>
<li>计算hash函数的效率；</li>
<li>关键字的长度（包括是否等长）；</li>
<li>hash表的大小；</li>
<li>关键字的公布情况；</li>
<li>记录的查找频率。</li>
</ul>
<p>1、<strong>直接定址法</strong></p>
<p>哈希函数为关键字的线性函数。$H(key) = key$ 或者 $H(key) = a\times key+b$ </p>
<p>仅限于：地址集合的大小 = 关键字集合的大小。如：$H(key)=key-1949$ </p>
<p>2、<strong>数字分析法</strong></p>
<p>假设关键字集合中的每个关键字都是由$s$位数字组成$(k1, k2, …, kn)$，分析关键字集中的全体，并从中提取分布均匀的若干位或它们的组合作为地址。</p>
<p>仅限于：能预先估计出全体关键字的每一位上各种数字出现的频度。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220303103412677.png" alt="image-20220303103412677"></p>
<p>3、<strong>平方取中法</strong></p>
<p>若关键字的每一位都有某些数字重复出现频度很高的现象，则先求关键字的平方值，以通过“平方”扩大差别，同时平方值的中间几位受到整个关键字中各位的影响。</p>
<p>例如：$a=0100$, 则 $a^2=0010000$<br>            $i =1100$, 则 $i^2 =1210000$<br>            $j =1200$, 则 $j^2 =1440000$</p>
<p>若超出范围时，可再取模</p>
<p><strong>问题</strong>：在数字分析法和平方取中法，取哪几位作为hash地址？“中间几位”由表长决定。如表长为1000,Hash表的地址空间为000-999，所以取中间3位。</p>
<p>4、<strong>折叠法</strong></p>
<p>若关键字的位数比较长，则可将其分割成几部分，然后取它们的叠加和为哈希地址。</p>
<p>两种处理方法：<strong>移位叠加和间界叠加</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220302174432637.png" alt="image-20220302174432637"></p>
<p>5、<strong>除留余数法</strong></p>
<p>选择一个适当的正整数 $p$，用$p$去除关键值，取其余数作为散列地址，即：$hash(key)=key%p$    $p≤m(表长)$</p>
<p>$p$ 应为不大于$m$ 的最大质数</p>
<p>例：设表长 $m=8，16，32，64，128，1001$<br>               则 $p=7，13，31，61，127，1001$</p>
<p>6、<strong>随机数法</strong></p>
<p>$H(key) = Random(key)$ </p>
<p>采用何种构造哈希函数的方法取决于关键字集合的情况(包括关键字的范围和形)，总的原则是使产生冲突的可能性降到尽可能<br>的小。</p>
<h4 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h4><p>1、<strong>链地址法</strong></p>
<p>将具有相同散列地址的记录都存储在同一个线性链表中。</p>
<p>例：以${14,1,68,27,55,23,11,10,19,20,79,84}$构造hash表。<br>分析： $n=12\quad n/m=3/4$ ,  所以 $m=16$ ,  则 $p=13 \quad hash(key)=key % 13$</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220303095239166.png" alt="image-20220303095239166"></p>
<p>2、<strong>开放定址法</strong></p>
<p>当冲突发生时，使用某种方法在散列表中形成一个探查序列，沿着此序列逐个地址去探查，直到找到一个开放的地址（空位置），将发生冲突的键值放到该地址中。$H_i=(H(key)+d_i)%m$</p>
<ul>
<li>线性探查法 $d_i = 1,2,3,…,m-1$</li>
<li>二次探查法 $d_i=1^2,-1^2,2^2,-2^2,…,k^2,-k^2$ </li>
<li>伪随机探测法 $d_i = 伪随机数序列$ </li>
<li>再散列探测法</li>
</ul>
<p>2.1 <strong>线性探测法</strong></p>
<p>对给定的关键值 $k$，若地址$d$ (即$h(k)=d$)的单元发生冲突，则依次探查下述地址单元（设$m$为表长）：$d+1,d+2,…,m-1, 0 ,1,…d-1$</p>
<p>设增量函数为$d(i)=1,2,3,……m-1$ （$i$: 为探测次数）</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220303100445354.png" alt="image-20220303100445354"></p>
<p>2.2 <strong>二次探测法</strong></p>
<p>对给定的关键值 $k$，若地址$d$ (即$h(k)=d$)的单元发生冲突，则探查下述地址单元：$d+1,d-1,d+4,d-4,d+9,d-9,…$</p>
<p>设增量函数为 $d(i)=1^2,-1^2,2^2,-2^2,……,k^2,-k^2\quad (k&lt;=m/2)$ </p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220303101203785.png" alt="image-20220303101203785" style="zoom:80%;">

<p>2.3 <strong>伪随机探测法</strong></p>
<p>2.4  <strong>再散列探测法</strong></p>
<p>设$m$为表长，当 $h1(k1)=h2(k2)=d$ 时，</p>
<p>使探查序列为： $(d+h2(k))%m \ (d+2h2(k))%m \ (d+3h2(k))%m \ …… $</p>
<p>$h2$的选取方法为：</p>
<ul>
<li>若$m$为素数：$h2(k)=k%(m-2)+1$</li>
<li>若$m$为$2^i$：$h2(k)=1～m-1$之间的任一奇数。（这样总保证使$h2(k)$和$m$互质）</li>
</ul>
<p>3、<strong>公共溢出区法</strong></p>
<p>将关键字相同（即具有相同散列地址）的记录都存储在同一个溢出区中。</p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220303104613276.png" alt="image-20220303104613276" style="zoom:80%;">



<h4 id="hash表的查找"><a href="#hash表的查找" class="headerlink" title="hash表的查找"></a>hash表的查找</h4><p>查找过程和造表过程一致。</p>
<p>假设采用开放定址处理冲突，则查找过程为:</p>
<p>对于给定值$K$, 计算哈希地址 $j = H(K)$</p>
<ul>
<li><p>若$r[j] = NULL$ 则查找不成功</p>
</li>
<li><p>若$ r[i].key = K$ 则查找成功</p>
</li>
<li><p>否则 求下一地址$j$，直至$r[j] = NULL$ (查找不成功)或$r[j].key = K$ (查找成功)</p>
</li>
</ul>
<p><strong>用线性探测法解决冲突</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hashsize = &#123;<span class="number">997</span>, ...&#125; 	<span class="comment">// 哈希表容量递增表，一个合适的素数序列</span></span><br><span class="line"><span class="keyword">typedef</span> struct &#123;</span><br><span class="line">    ElemType *elem;	<span class="comment">//数据元素存储基址，动态分配数组</span></span><br><span class="line">    <span class="keyword">int</span> count;		<span class="comment">//当前数据元素个数</span></span><br><span class="line">    <span class="keyword">int</span> sizeindex;	<span class="comment">//hashsize[sizeindex]为当前容量</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUPLICATE -1</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">SearchHash</span><span class="params">(HashTable H, KeyType k, <span class="keyword">int</span> &amp;p, <span class="keyword">int</span> &amp;c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    j = Hash(k);</span><br><span class="line">    <span class="keyword">while</span>(shtable[j] != nullrecd &amp;&amp; shtable[j].key != k) j = (j + <span class="number">1</span>) % m;</span><br><span class="line">    <span class="keyword">if</span>(shtable[j] == nullrecd) <span class="keyword">return</span> nulladr;	<span class="comment">//未找到</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(shtable[j].key == k) <span class="keyword">return</span> j;		<span class="comment">//查找成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用链地址法解决冲突</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">j = Hash(k);</span><br><span class="line">p = shtable[j];</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; p-&gt;key != k) p = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="literal">NULL</span>;		<span class="comment">//未找到</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;key == k) <span class="keyword">return</span> p;	<span class="comment">//查找成功</span></span><br></pre></td></tr></table></figure>



<p><strong>决定哈希表查找的ASL的因素：</strong></p>
<ul>
<li><p>选用的哈希函数;</p>
</li>
<li><p>选用的处理冲突的方法;</p>
</li>
<li><p>哈希表饱和的程度，装载因子$α=n/m$ 值的大小。</p>
</li>
<li><p>一般情况下，可以认为选用的哈希函数是“均匀”的，则在讨论ASL时，可以不考虑它的因素。</p>
</li>
</ul>
<p><strong>hash表的查找分析</strong>：</p>
<p>装填（负载）因子：$α=表中填入的记录数\div hash表的长度$ </p>
<p>查找成功</p>
<ul>
<li>线性探测再散列 $S_{nl}\approx \frac{1}{2}(1+\frac{1}{1-\alpha})$ </li>
<li>链地址法 $S_{nc}\approx 1+\frac{\alpha}{2}$ </li>
<li>随机探测再散列、二次探测再散列 $S_{nr}\approx -\frac{1}{\alpha}\ln(1-\alpha)$ </li>
</ul>
<p>查找失败</p>
<ul>
<li>线性探测再散列 $S_{nl}\approx \frac{1}{2}(1+\frac{1}{(1-\alpha)^2})$ </li>
<li>链地址法 $S_{nc}\approx \alpha + e^{-\alpha}$  </li>
<li>随机探测再散列、二次探测再散列 $S_{nr}\approx \frac{1}{1-\alpha}$ </li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="概念及分类"><a href="#概念及分类" class="headerlink" title="概念及分类"></a>概念及分类</h3><p><strong>排序</strong>：将一组任意顺序的数据，重新排列成按关键字有序的序列。</p>
<p> 一般情况下，假设含$n$个记录的序列为：${R_1, R_2,…,R_n}$ </p>
<p>其相应的关键字序列为：${K_1,K_2,…,K_n}$    </p>
<p>关键字相互之间可以进行比较，即存在关系：$K_{p1}≤K_{p2}≤…≤K_{pn}$（其中$p1, p2, ……, pn$ 为$1,2,……,n$的一种排列）</p>
<p>将${R_1,R_2,…,R_n}$ 中的记录重新排列为 ${R_{p1}, R_{p2}, …R_{pn}}$的操作称为排序。</p>
<p>分类：</p>
<ul>
<li><strong>内部排序</strong>：待排序记录存放在计算机随机存储器中进行的排序过程<ul>
<li><strong>插入排序</strong><ul>
<li><strong>直接插入排序</strong></li>
<li><strong>希尔排序</strong></li>
</ul>
</li>
<li><strong>交换排序</strong><ul>
<li><strong>冒泡排序</strong></li>
<li><strong>快速排序</strong></li>
</ul>
</li>
<li><strong>选择排序</strong><ul>
<li><strong>简单选择排序</strong></li>
<li><strong>树形排序</strong></li>
<li><strong>堆排序</strong></li>
</ul>
</li>
<li><strong>归并排序</strong></li>
<li><strong>分配排序</strong></li>
</ul>
</li>
<li><strong>外部排序</strong>：待排序记录的数量很大，以致内存不能容纳全部记录</li>
</ul>
<p><strong>稳定性</strong>：若记录序列中的任意两个记录 $Rx、Ry$ 的关键字 $Kx = Ky$ ；如果在排序之前和排序之后，它们的相对位置保持不变，则这种排序方法是<strong>稳定</strong>的，否则是<strong>不稳定</strong>的</p>
<p><strong>存储结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXSIZE 10000	//一个用作示例的最大长度</span><br><span class="line">typedef int KeyType;	//	定义关键字类型为整数类型</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	KeyType key;</span><br><span class="line">	InfoType otherinfo;	//其它数据项</span><br><span class="line">&#125;RecordType;</span><br><span class="line">typedef struct &#123;	</span><br><span class="line">	RecordType r[MAXSIZE + 1];	//r[0]闲置或作监视哨</span><br><span class="line">	int length;					//顺序表长度</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>



<h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p><strong>排序策略</strong>：基于有序插入</p>
<p>在有序表的恰当处插入一个新元素，并保持该有序表的有序性。也即，当第$i$个元素插入时，第$1$到第$i-1$个元素已按关键字排序</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220303115514137.png" alt="image-20220303115514137"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220303115955840.png" alt="image-20220303115955840"></p>
<p><strong>算法实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">()</span> </span>&#123;<span class="comment">//对记录序列r[1]..r[n]作直接插入排序</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; ++i) &#123; <span class="comment">//从第二个元素开始比较</span></span><br><span class="line">        r[<span class="number">0</span>] = r[i];		<span class="comment">//r[0]为监视哨</span></span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r[<span class="number">0</span>].key &lt; r[j].key) &#123;</span><br><span class="line">            r[j + <span class="number">1</span>] = r[j]; --j;	<span class="comment">//记录后移，边移动边找插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        r[j + <span class="number">1</span>] = r[<span class="number">0</span>];	<span class="comment">//插入到正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong></p>
<p>时间复杂度：$T(n)=O(n^2)$ </p>
<p>空间复杂度：$S(n)=O(1)$ </p>
<p>稳定性：稳定</p>
<p>适用范围：$n$较小，局部有序</p>
<h4 id="希尔-shell-排序"><a href="#希尔-shell-排序" class="headerlink" title="希尔(shell)排序"></a>希尔(shell)排序</h4><p>希尔排序（Shell’s Sort）又叫“缩小增量排序”，是对直接插入排序所作的改进。</p>
<p><strong>排序策略</strong>：先将整个待排序的记录序列分割成为若干个子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220303121549613.png" alt="image-20220303121549613"></p>
<p><strong>算法设计</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shellsort</span><span class="params">()</span> </span>&#123;  <span class="comment">// 对记录序列r[1]..r[n]作shell排序,增量是 d </span></span><br><span class="line">	d = n / <span class="number">2</span>;		<span class="comment">// 取d = n / 2; d = d / 2; 分组排序</span></span><br><span class="line">    <span class="keyword">while</span>(d &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = d + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            r[<span class="number">0</span>] = r[i]; j = i - d;	<span class="comment">//r[0]是暂存单元</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; r[<span class="number">0</span>].key &lt; r[j].key) &#123;</span><br><span class="line">                r[j + d] = r[j]; </span><br><span class="line">                j = i - d;</span><br><span class="line">            &#125;	<span class="comment">////记录后移，查找插入位置</span></span><br><span class="line">            r[j + d] = r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        d = d / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong></p>
<p>时间复杂度：$T(n)=O(nlog2n)$ </p>
<p>空间复杂度：$S(n)=O(1)$ </p>
<p>稳定性：不稳定</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>排序方法</strong>：相邻的两个元素的关键字进行比较，小的元素向上冒，大的元素向下沉。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220304095532892.png" alt="image-20220304095532892"></p>
<p><strong>排序算法</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对r[1]..r[n] 进行冒泡排序</span></span><br><span class="line">    <span class="comment">// 策略：从上至下逐个进行两两比较</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n - i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[j].key &gt; r[j + <span class="number">1.</span>key]) &#123;</span><br><span class="line">                r[<span class="number">0</span>] = r[j + <span class="number">1</span>]; r[j + <span class="number">1</span>] = r[j]; r[j] = r[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法改进</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 对r[1]..r[n] 进行冒泡排序，策略：从上至下逐个进行两两比较</span></span><br><span class="line">    <span class="keyword">int</span> swap = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n &amp;&amp; swap; ++i) &#123; <span class="comment">// 进行n-1趟冒泡排序 或 某趟无交换止</span></span><br><span class="line">        swap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n - i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[j].key &gt; r[j + <span class="number">1.</span>key]) &#123;</span><br><span class="line">                r[<span class="number">0</span>] = r[j + <span class="number">1</span>]; r[j + <span class="number">1</span>] = r[j]; r[j] = r[<span class="number">0</span>];</span><br><span class="line">                swap = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong>：</p>
<p>时间复杂度分析：$T(n)=O(n^2)$</p>
<p>空间复杂度分析：$S(n)=O(1)$</p>
<p>稳定性：稳定的</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>排序策略</strong>：任选一个元素的关键字（如[1].key）作为标准，将序列分成两部分。其中左半部分的结点的关键字小于等于该元素的关键字，右半部分的结点的关键字大于等于该元素的关键字。然后, 对左右两部分分别进行类似的处理，直至排好序为止</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220303163804332.png" alt="image-20220303163804332"></p>
<p><strong>算法实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一趟快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对r[i]..r[j]中的记录进行一趟排序，将它们分成两部分</span></span><br><span class="line">    <span class="comment">// 使：[…这部分的值&lt;=x…] x […这部分的值&gt;=x…]</span></span><br><span class="line">    r[<span class="number">0</span>] = r[i]; x = r[i].key;	<span class="comment">//用子表的第一个记录作为界点记录</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;	 <span class="comment">// 从表的两端交替地向中间扫描</span></span><br><span class="line">        <span class="keyword">while</span>(r[j].key &gt; x &amp;&amp; i &lt; j) --j;</span><br><span class="line">        r[i] = r[j];	<span class="comment">// 将比界点记录小的记录交换到低端</span></span><br><span class="line">        <span class="keyword">while</span>(r[i].key &lt; x &amp;&amp; i &lt; j) ++i;</span><br><span class="line">        r[j] = r[i];	<span class="comment">// 将比界点记录大的记录交换到高端</span></span><br><span class="line">    &#125;</span><br><span class="line">    r[i] = r[<span class="number">0</span>];	</span><br><span class="line">    <span class="keyword">return</span> i;		<span class="comment">//返回界点所在位置</span></span><br><span class="line">&#125;<span class="comment">//Partition</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对记录序列r[low]..r[high]进行快速排序</span></span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;	<span class="comment">// 长度小于1</span></span><br><span class="line">    <span class="keyword">int</span> mid = Partition(low, high);</span><br><span class="line">    QuickSort(low, mid - <span class="number">1</span>);</span><br><span class="line">    QuickSort(mid + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong></p>
<p>时间复杂度：$T(n)=O(log_2n)$ </p>
<p>空间复杂度：$S(n)=O(log_2n)$ </p>
<p>稳定性：不稳定</p>
<p>适用范围：n较大且表无序时</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p><strong>排序策略</strong>：在待排序的数据中选择最小值。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220304100054253.png" alt="image-20220304100054253"></p>
<p><strong>算法实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对记录序列r[1]..r[n]进行简单选择排序</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; ++i) &#123;	<span class="comment">//进行n-1趟</span></span><br><span class="line">     	k = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[j] &lt; r[k]) k = j; <span class="comment">// 保持r[k]的关键字最小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != k) &#123;</span><br><span class="line">            r[<span class="number">0</span>] = r[i]; r[i] = r[k]; r[k] = r[<span class="number">0</span>]; <span class="comment">//在待排序的数据中选择最小值，并存入r[i]处</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong></p>
<p>时间分析：$T(n)=O(n^2)$</p>
<p>空间分析：$S(n)=O(1)$</p>
<p>稳定性：不稳定</p>
<p>适用范围：1）$n$较小时，2）在$n$个待排序的数据中选择前$k(k&lt;&lt;n)$个最小值时</p>
<h4 id="树形排序"><a href="#树形排序" class="headerlink" title="树形排序"></a>树形排序</h4><p><strong>树形选择排序(Tree Selection Sort)<strong>又称</strong>锦标赛排序(Tournament Sort)</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220304102306909.png" alt="image-20220304102306909"></p>
<h4 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h4><p><strong>堆的定义</strong>：$n$个元素的序列${k_1,k_2,…k_n}$，满足： $$\begin{cases} k_i &gt;= k_{2i} \ k_i &gt;=k_{2i+1} \end{cases} 或 \begin{cases} k_i &lt;= k_{2i} \ k_i &lt;=k_{2i+1} \end{cases}$$ </p>
<p>堆是一个完全二叉树。</p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220304104438730.png" alt="image-20220304104438730" style="zoom: 67%;">

<p><strong>堆排序</strong>：输出堆顶的最小值（最大值）后，将剩下的$n-1$个元素序列重新建成一个堆，得到次小值（次大值）。反复执行，得到一个有序序列。</p>
<p><strong>构造堆</strong>：按堆的定义将$r[1]…r[n]$调整为堆</p>
<p>$r[n]$与$r[1]$互换，将$r[1]…r[n-1]$调整为堆。再将$r[n-1]$与$r[1]$互换，将$r[1]…r[n-2]$调整为堆。……，直至排序完成。</p>
<p><strong>堆的调整</strong>：在选出某段序列最大（小）值后，要将剩下的序列调整</p>
<ul>
<li>左右孩子比较</li>
<li>父子比较</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220304120225824.png" alt="image-20220304120225824"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220304123205678.png" alt="image-20220304123205678"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220304123234392.png" alt="image-20220304123234392"></p>
<p><strong>算法实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> m)</span> </span>&#123;  <span class="comment">//堆的调整，也是建堆</span></span><br><span class="line">    <span class="comment">//把以 t 为根的完全二叉树r[i]..r[m]调整成一个堆 </span></span><br><span class="line"> 	<span class="comment">//初值：i的左右子树均是堆</span></span><br><span class="line">    <span class="keyword">int</span> j = i * <span class="number">2</span>;	<span class="comment">//j指向左孩子</span></span><br><span class="line">    r[<span class="number">0</span>] = r[i];	<span class="comment">//将r[i]暂存在r[0]中</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; m &amp;&amp; r[j].key &lt; r[j + <span class="number">1</span>].key) ++j; <span class="comment">//左孩子与右孩子进行比较，找较大孩子，确定筛选方向</span></span><br><span class="line">        <span class="keyword">if</span>(r[<span class="number">0</span>].key &lt; r[j].key) &#123;</span><br><span class="line">            r[i] = r[j]; i = j; j = <span class="number">2</span> * i;	<span class="comment">// 继续筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = m + <span class="number">1</span>;	<span class="comment">//筛选完毕</span></span><br><span class="line">        r[i] = r[<span class="number">0</span>];</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">()</span> </span>&#123;	<span class="comment">//将r[1]...r[n]进行堆排序</span></span><br><span class="line">    <span class="keyword">for</span>(j = n / <span class="number">2</span>; j &gt;= <span class="number">1</span>; --j) sift(j, n);	<span class="comment">//建堆，得最大值r[1]</span></span><br><span class="line">    <span class="keyword">for</span>(j = n; j &gt;= <span class="number">2</span>; --j) &#123;</span><br><span class="line">        r[<span class="number">0</span>] = r[<span class="number">1</span>]; r[<span class="number">1</span>] = r[j]; r[j] = r[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//堆顶（根）结点与最后结点的值对换</span></span><br><span class="line">        sift(<span class="number">1</span>, j - <span class="number">1</span>);	<span class="comment">//调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong></p>
<p>时间分析：$T(n)=O (nlog2n)$</p>
<p>空间分析：$S(n)=O(1)$</p>
<p>稳定性：不稳定</p>
<p>适用范围：1）$n$较大。2）选取前$k(K&lt;&lt;n)$个最小（大）元素时</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>归并排序（Merging Sort）</strong>就是将两个或两个以上的有序表合并成一个有序表的过程。将两个有序表合并成一个有序表的过程称为<strong>2-路归并</strong>，2-路归并最为简单和常用。</p>
<p><strong>排序示例：</strong> </p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220304141031376.png" alt="image-20220304141031376" style="zoom:80%;">

<p><strong>二路归并算法</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(RedType R[], RedType T[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将两个有序表R[low]..R[mid]和R[mid+1]..r[high]归并为一个新的有序表T[low]..r[high]</span></span><br><span class="line">    i = low; j = mid + <span class="number">1</span>; k = low;	<span class="comment">//初值i,j,k为指示器</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span>(R[i].key &lt;= R[j].key) T[k++] = R[i++];</span><br><span class="line">        <span class="keyword">else</span> T[k++] = R[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) T[k++] = R[i++];	<span class="comment">//将剩余的R[i]..R[mid]放入T中</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) T[k++] = R[i++];	<span class="comment">//将剩余的R[j]..R[high]放入T中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(RedType R[], RedType &amp;T[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//R[low]..R[high]归并排序后放入T[low]..T[high]中</span></span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;		<span class="comment">//将当前序列一分为二，分裂点mid</span></span><br><span class="line">        mergeSort(R, S, low, mid);		<span class="comment">//对子序列R[low..mid]递归归并排序</span></span><br><span class="line">        mergeSort(R, S, mid + <span class="number">1</span>, high);	<span class="comment">//对子序列R[mid+1..high]递归归并排序</span></span><br><span class="line">        Merge(R, T, low, mid, high);	<span class="comment">//将S[low..mid]和S[mid+1..high]归并到T[low..high]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong></p>
<p>时间复杂度：$T(n)=O(nlog_2n)$ </p>
<p>空间复杂度：$S(n) = O(n)$ </p>
<p>稳定性：稳定</p>
<p>适用范围：$n$较大时</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><strong>基数排序（Radix Sorting）</strong>是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。</p>
<p><strong>多关键字的排序</strong></p>
<p>假设$n$个记录的序列${R_1,R_2,…R_n}$，且每个记录$R_i$含有$d$个关键字$(K_i^0,K_i^1,…,K_i^{d-1})$</p>
<p>序列${R_1,R_2,…R_n}$对关键字$(K_i^0,K_i^1,…,K_i^{d-1})$有序：对于序列中任意两个记录$R_i$和$R_j(1&lt;=i&lt;j&lt;=n)$满足：$$(K_i^0,K_i^1,…,K_i^{d-1}) &lt; (K_j^0,K_j^1,…,K_j^{d-1})$$其中$K^0$称为最主位关键字，$K^{d-1}$称为最次位关键字。</p>
<p>法一：<strong>最高位优先法（Most Significant Digit first）MSD</strong></p>
<ul>
<li>对最主位关键字$K^0$排序，将序列分成若干个子序列，每个子序列中的记录有相同的$K^0$值</li>
<li>对每个子序列按$K^1$排序，每个序列再分成更小的序列，依次重复至对每个序列进行$K^{d-1}$排序后</li>
<li>将所有子序列依次联接称为一个有序序列</li>
</ul>
<p>法二：<strong>最低位优先法（Least Significant Digit first）LSD</strong></p>
<ul>
<li>和MSD相反</li>
</ul>
<p><strong>示例：10进制数排序</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220304150324750.png" alt="image-20220304150324750"></p>
<p><strong>队列的表示</strong></p>
<ul>
<li><p>顺序队列</p>
<p>问题：每一个队列的长度是多少？<br>缺点：空间开销大。</p>
</li>
<li><p>链式队列</p>
<p>需设 2rd 个指针，rd：基数。如10进制数，rd=10</p>
</li>
</ul>
<p><strong>存储结构</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_NUM	10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key[KEY_NUM];	<span class="comment">//d: 关键字的位数</span></span><br><span class="line">    infoType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>算法实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">distribute</span><span class="params">(struct node *head, <span class="keyword">int</span> i, )</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分配算法，考察每一个元素的第i个关键字，并放入相应的队列中</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; KEY_NUM; ++j) f[j] = <span class="literal">NULL</span>;	<span class="comment">//队列初始化，f保存每个子序列的头</span></span><br><span class="line">    p = head-&gt;next;	<span class="comment">//头指针不存储数据</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        j = p-&gt;key[i];	<span class="comment">//考察p所指结点的第i位</span></span><br><span class="line">        <span class="keyword">if</span>(f[j] == <span class="literal">NULL</span>) f[j] = p;</span><br><span class="line">        <span class="keyword">else</span> r[j]-&gt;next = p;</span><br><span class="line">        r[j] = p;		<span class="comment">//r记录每个子序列的尾</span></span><br><span class="line">        p = p-&gt;next;	<span class="comment">//p后移</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">collect</span><span class="params">(struct node &amp;head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//收集算法：从队列0到队列9进行收集</span></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(f[j] == <span class="literal">NULL</span>) ++j;	<span class="comment">//找第一个非空队列</span></span><br><span class="line">    head-&gt;next = f[j]; t = r[j]; <span class="comment">//head:收集后链表的头指针，t:尾指针</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; <span class="number">9</span>) &#123;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(f[j] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            t-&gt;next = f[j];</span><br><span class="line">            t = r[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(struct node *head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基数排序：从低位开始</span></span><br><span class="line">    <span class="function">create <span class="title">link_list</span><span class="params">(head)</span></span>;	<span class="comment">//建立链表，head:头指针</span></span><br><span class="line">    <span class="keyword">for</span>(i = KEY_NUM - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;	<span class="comment">//进行KEY_NUM趟分配和收集</span></span><br><span class="line">    	distribute(head, i);</span><br><span class="line">        collect(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong></p>
<p>时间复杂度：$T(n)=O(d(n+rd))=O(n)$ 关键码$d$位，对 rd 个队列收集</p>
<p>空间复杂度：$S(n)=O(n+2rd)$ </p>
<p>稳定性：稳定</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><table>
<thead>
<tr>
<th>排序方法</th>
<th>平均时间</th>
<th>最坏情况</th>
<th>辅助存储空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>直接插入排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>Y</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>Y</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>Y</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(nlog_2n)$</td>
<td>$O(n^2)$</td>
<td>$O(log_2n)$</td>
<td>N</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(nlog_2n)$</td>
<td>$O(nlog_2n)$</td>
<td>$O(1)$</td>
<td>N</td>
</tr>
<tr>
<td>归并排序</td>
<td>$O(nlog2n)$</td>
<td>$O(nlog_2n)$</td>
<td>$O(n)$</td>
<td>Y</td>
</tr>
<tr>
<td>基数排序</td>
<td>$O(n)$</td>
<td>$O(n)$</td>
<td>$O(rd)$</td>
<td>Y</td>
</tr>
</tbody></table>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306113737759.png" alt="image-20220306113737759"></p>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><h3 id="内存和外存"><a href="#内存和外存" class="headerlink" title="内存和外存"></a>内存和外存</h3><p>计算机存储器主要有两种：</p>
<ul>
<li>**主存储器 ( primary memory 或者 main memory ，简称“内存”，或者“主存”) **<ul>
<li><strong>随机访问存储器 ( Random Access Memory, 即 RAM )</strong></li>
<li><strong>高速缓存 ( cache )</strong></li>
<li>**视频存储器 ( video memory ) **</li>
</ul>
</li>
<li>**外存储器 ( peripheral storage 或者 secondary storage，简称“外存”，或“辅存”) **<ul>
<li><strong>硬盘 (几百$G$ - 几百$T$， $10^{12B} $)</strong></li>
<li><strong>磁带 (几个$P$， $10^{15}B$ )</strong></li>
<li><strong>磁盘</strong></li>
</ul>
</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220305134327171.png" alt="image-20220305134327171"></p>
<p><strong>内存的优缺点</strong></p>
<ul>
<li>优点：访问速度快</li>
<li>缺点：造价高，存储容量小，断电丢数据</li>
<li>CPU 直接与主存沟通，对存储在内存地址的数据进行访问时，所需要的时间可以看作是一个很小的常数，看作随机存取</li>
</ul>
<p><strong>外存的优缺点</strong></p>
<ul>
<li>优点：价格低、信息不易失 、便携性 </li>
<li>缺点：存取速度慢<ul>
<li>一般的内存访问存取时间的单位是 纳秒 （1 纳秒 = $10^{-9}$ 秒）</li>
<li>外存一次访问时间则以 毫秒（1 毫秒 = $10^{-3}$ 秒）或秒为数量级</li>
</ul>
</li>
<li>牵扯到外存的计算机程序应当尽量<strong>减少外存的访问次数</strong>， 从而减少程序执行的时间</li>
</ul>
<p><strong>单位</strong></p>
<ul>
<li>$KB$ (kilo byte)​ $10^3B$ (页块)</li>
<li>$MB$ (mega byte) $10^6B$ (高速缓存)</li>
<li>$GB$ (giga) $10^9B$ (内存、硬盘)</li>
<li>$TB$ (tera) $10^{12}B$ (磁盘阵列)</li>
<li>$PB$ (peta) $10^{15}B$ (磁带库)</li>
<li>$EB = 10^{18}B；ZB = 10^{21}B；YB = 10^{24}B$ </li>
<li>$Googol$ 是 10 的 100 次方</li>
</ul>
<h3 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h3><p>磁带大约1/2英寸宽，绕在一个卷盘上。使用时，将磁带盘放在磁带机上，驱动器控制磁带盘转动，带动磁带向前移动。通过读/写头就可以读出磁带上的信息或把信息写入磁带中。</p>
<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/IMG_20220305_142751_edit_978911093953752.jpg" style="zoom: 15%;">

<p>磁带不是连续转动的设备，而是一种启停设备（启停时间约5毫秒）。由于读写信息应在旋转稳定时进行，而磁带从静止转态启动后，需经历加速阶段；读/写结束后，需经历减速阶段。因此，在磁带上相邻两个字符组（记录）之间要留有一空白区，叫做**间隙IRG(Inter Record Gap)**。</p>
<p>为有效利用磁带，常常用组成块的长度的方法来减少 $IRG$ 的个数。在每次写信息时，不是按用户给出的字符组记入磁带，而是将若干个字符组合并成一块后一次写入磁带。字符组间没有了 $IRG$ ，变成块间的间隙 $IBG$ (Inter Block Gap) 。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220305150014325.png" alt="image-20220305150014325"></p>
<p>成块的好处和限制：</p>
<ul>
<li><p>减少 $IRG$，提高磁带利用率</p>
</li>
<li><p>减少 I/O 操作</p>
</li>
<li><p>物理块不能太大，通常 1K~8K 字节。太大容易出错，内存开辟的缓冲区也越大。</p>
</li>
</ul>
<p>磁带上读取一块信息所需时间由两部分组成：$T_{I/O}=t_a+n\times t_w$  </p>
<ul>
<li>$t_a$ 为延迟时间，读/写头到达传输信息所在物理块起始位置所需时间</li>
<li>$t_w$ 传输一个字符的时间</li>
</ul>
<p>顺序存储设备的主要缺点是检索和修改信息不方便。因此主要用于处理变化少，只进行顺序存取的大量数据。</p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘是一种 直接存取的存储设备（DASD）。可以直接存取任何字符组，容量大，存取速度比磁带快得多。</p>
<p>磁盘是一个扁平的圆盘，盘面有许多磁道记载信息。磁盘可以是单片，也可以是若干个盘片组成盘组。每一片有两个面，最顶上和最底下盘片的外侧面不存信息。</p>
<p>磁盘可分为<strong>固定头盘</strong>和<strong>活动头盘</strong>。</p>
<ul>
<li><p>固定头盘的每一道上都有独立的磁头，固定不动，专负责读/写某一道上的信息。</p>
</li>
<li><p>活动头盘的磁头可移动，盘组可变。一个面上只有一个磁头，可以从该面上的一道移到另一道。</p>
<ul>
<li>磁头装在动臂上，不同面的磁头是同时移到的，并处于同一圆柱面。</li>
<li>各面上半径相同的磁道组成一个圆柱面。</li>
<li>磁盘是上表面一个具体信息必须用一个三维地址：柱面号、盘面号、块号。</li>
<li>柱面号确定读/写头的径向运动，块号确定信息在盘片圆圈上的位置。</li>
</ul>
</li>
</ul>
<p>访问信息：</p>
<ul>
<li>先找柱面，磁头移动到所需柱面上（称为定位或寻查）</li>
<li>等待要访问的信息转到磁头下</li>
<li>读/写信息</li>
</ul>
<p>读写信息所需时间：$T_{I/O}=t_{seek}+t_{la}+n\times t_{wm}$ </p>
<ul>
<li>$t_{seek}$ **寻查时间(seek time)**：读/写头定位的时间</li>
<li>$t_{la}$ **等待时间(latency time)**：等待信息块的初始位置旋转到读写头下的时间</li>
<li>$t_{wm}$ <strong>传输时间(transmission time)</strong></li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220305141308482.png" alt="image-20220305141308482"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220305141333510.png" alt="image-20220305141333510"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220305141452329.png" alt="image-20220305141452329"></p>
<h3 id="外部排序的方法"><a href="#外部排序的方法" class="headerlink" title="外部排序的方法"></a>外部排序的方法</h3><p>外部排序基本由两个相对独立的阶段组成。</p>
<p>1）按可用内存大小，将外存上含 $n$ 个记录的文件分成若干长度为 $l$ 的子文件或<strong>段（segment）</strong>，依次读入内存并利用有效的内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写入外存。通常称这些<strong>有序子文件</strong>为<strong>归并段</strong>或<strong>顺串（run）</strong></p>
<p>2）对这些归并段逐趟归并，使归并段逐渐由小至大，直至得到整个有序文件为止。</p>
<p>第一阶段是内部排序的内容，主要是第二阶段即归并的过程。</p>
<p>示例：<strong>2-路平衡归并</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220305163752665.png" alt="image-20220305163752665"></p>
<p>在内存中将两个有序段归并成一个有序段很简单。但是，在外部排序中实现两两归并时，要进行外存的读／写，因为不可能将两个有序段及归并结果段同时存放在内存中的缘故。假设在上例中毎个物理块可以容纳200个记录，则每一趟归并需进行50次“读”和50次“写”,4趟归并加上内部排序时所需进行的读／写使得在外排中总共需进行500次的读 / 写。</p>
<p>一般情况下，$外部排序所需总的时间＝$$内部排序（产生初始归并段）所需的时间 (m\times t_{IS})+ \ 外存信息读写的时间 (d\times t_{IO})+ \ 内部归并所需的时间 (s\times ut_{mg})$</p>
<ul>
<li>$t_{IS}$ 是为得到一个初始归并段进行内部排序所需时间的均值</li>
<li>$t_{IO}$ 是进行一次外存读／写时间的均值</li>
<li>$ut_{mg}$ 是对 $u$ 个记录进行内部归并所需时间</li>
<li>$m$ 为经过内部排序之后得到的初始归并段的个数</li>
<li>$s$ 为归并的趟数</li>
<li>$d$ 为总的读／写次数</li>
</ul>
<p>由此，上例10000个记录利用2﹣路归并进行外排所需总的时间为：$10\times t_{IS}+500\times t_{IO}+4\times 10000t_{mg}$  </p>
<p>$t_{IO}$ 取决于所用的外存设备，比 $t_{mg}$ 大得多。**提高外排效率主要是减少外存信息读写的次数 $d$ 。 **</p>
<p>若对上例采取<strong>5-路平衡归并</strong>，仅需两趟归并，外排时总的读写次数便减至 $2\times 100+100=300$ ，比2-路平衡归并少了200次读写。</p>
<p>一般情况下：对 $m$ 个起始归并段进行 <strong>k-路平衡归并</strong> 时，归并趟数：$s=$ int $(log_km)$  即 $log_km$向下取整</p>
<h3 id="多路平衡归并"><a href="#多路平衡归并" class="headerlink" title="多路平衡归并"></a>多路平衡归并</h3><p>增加 $k$ 可以减少 $s$ ，从而减少外存读／写的次数。但单纯增加 $k$ 将导致增加内部归并的时间 $ut_{mg}$ 。</p>
<p>在2﹣路归并中，令 $u$ 个记录分布在两个归并段上。每得到归并后的一个记录，仅需一次比较即可，则得到含 $u$ 个记录的归并段需进行 $u-1$ <font color="#ff000">（不应该是 $u$ 次比较吗）</font>次比较。</p>
<p>再看 k﹣路归并。令 $u$ 个记录分布在 E 个归并段上，显然，归并后的第一个记录应是 $k$ 个归并段中关键字最小的记录，即应从毎个归并段的第一个记录的相互比较中选出最小者，这需要进行 $k-1$次比较。同理，每得到归并后的有序段中的一个记录，都要进行  $k-1$ 用次比较。显然，为得到含 $u$ 个记录的归并段需进行 $(u -1)(k-1)$ 次比较。由此，对 $n$ 个记录的文件进行外排时，在内部归并过程中进行的总的比较次数为 $s(k-1)(n-1)$ 。</p>
<p>假设所得初始归并段为 $m$ 个，则内部归并过程中进行比较的总的次数为<img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220305180603563.png" alt="image-20220305180603563" style="zoom: 50%;"></p>
<p>内部归并时间亦随 $k$ 的增长而增长。这将抵消由于增大 $k$ 而减少外存信息读写时间所得效益。然而，若在进行 k﹣路归并时用 **败者树( Tree of Loser )**，则可使在 $k$ 个记录中选出关键字最小的记录时仅需进行 $[log_2k]$ 次比较。</p>
<p>**败者树( Tree of Loser )**：类似于堆排序里面的完全二叉树，只不过败者树非叶子结点保存的是子孙比较中的败者。</p>
<p>**胜者树( Tree of Winner )**：和败者树相反</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220305181301909.png" alt="image-20220305181301909"></p>
<p>$k$ 值的选择并非越大越好，如何选择合适的 $k$ 是一个需要综合考虑的问题。</p>
<p><strong>算法实现</strong></p>
<p><code>K_Merge</code>简单描述利用败者树进行 K-路平衡排序归并 的过程，避开了外存信息存取的细节，可认为归并段已读入内存。</p>
<p><code>Adjust</code>描述在从败者树选得最小关键字的记录之后，如何从叶到根调整败者树选得下一个最小关键字。</p>
<p><code>CreateLoserTree</code>初建败者树的过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> LoserTree[k];	<span class="comment">//败者树是完全二叉树且不含叶子，可采用顺序存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ExNode, External[k + <span class="number">1</span>];	<span class="comment">//外结点，只存放待归并记录的关键字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">K_Merge</span><span class="params">(LoserTree &amp;ls, External &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//利用败者树 ls 将编号从 0 到 k-1 的 k 个输入归并段中的记录归并到输出归并段</span></span><br><span class="line">    <span class="comment">//b[0]至b[k-1]为败者树上的k个叶子结点，分别存放k个输入归并段中当前记录的关键字</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; K; ++i) input(b[i].key);	<span class="comment">//分别从k个输入归并段读入该段当前第一个记录的关键字到外接点</span></span><br><span class="line">    CreateLoserTree(ls);	<span class="comment">//建败者树ls，选得最小关键字为 b[ls[0]].key</span></span><br><span class="line">    <span class="keyword">while</span>(b[ls[<span class="number">0</span>]].key != MAXKEY) &#123;</span><br><span class="line">        q = ls[<span class="number">0</span>];	<span class="comment">//q指示当前最小关键字所在归并段</span></span><br><span class="line">        output(q);	<span class="comment">//将编号为q的归并段中当前（关键字为b[q].key）的记录写至输出归并段</span></span><br><span class="line">        input(b[q].key, q);	<span class="comment">//从编号为q的输入归并段读入下一个记录的关键字</span></span><br><span class="line">        Adjust(ls, q);		<span class="comment">//调整败者树，选择新的最小关键字</span></span><br><span class="line">    &#125;</span><br><span class="line">    output(ls[<span class="number">0</span>]);	<span class="comment">//将含最大关键字MAXKEY的记录写至输出归并段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Adjust</span><span class="params">(LoserTree &amp;ls, <span class="keyword">int</span> s)</span> </span>&#123;	</span><br><span class="line">    <span class="comment">//沿从叶子结点b[s]到根结点ls[0]的路径调整败者树</span></span><br><span class="line">    t = (s + k) / <span class="number">2</span>;	<span class="comment">//ls[t]是b[s]的双亲结点</span></span><br><span class="line">    <span class="keyword">while</span>(t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[s].key &gt; b[ls[t]].key) s&lt;--&gt;ls[t];      <span class="comment">//s指向新的胜者                           </span></span><br><span class="line">        t = t / <span class="number">2</span>;                                                                    </span><br><span class="line">    &#125;</span><br><span class="line">    ls[<span class="number">0</span>] = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateLoserTree</span><span class="params">(LoserTree &amp;ls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 已知b[0]到b[k-1]为完全二叉树ls的叶子结点存有k个关键字，沿叶子到根的k条路径将ls调整成败者树</span></span><br><span class="line">    b[k].key = MINKEY;	<span class="comment">//设MINKEY为关键字可能的最小值</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; ++i) ls[i] = k;	<span class="comment">//设置ls中“败者”的初值</span></span><br><span class="line">    <span class="keyword">for</span>(i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) Adjust(ls, i);	<span class="comment">//依次从b[k-1]...b[0]出发调整败者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h3><p>归并的趟数和 $k$ 成反比，也和 $m$ 成正比。因此，减少 $m$ 是减少 $s$ 的另一条途径。</p>
<p>$m$ 是外部文件经过内部排序之后得到的初始归并段的个数，显然，$m=ceil(n/l)$(向上取整)，其中 $n$ 为外部文件中的记录数，$l$ 为初始归并段中的记录数。但这依赖于进行内部排序时可用内存工作区的大小，则 $m$ 也随其而限定。若要减小 $m$，即增加 $l$，就必须探索新的排序方法。</p>
<p><strong>置换-选择排序（Replacement-Selection Sorting）</strong>是在树形选择排序的基础上得来的，它的特点是：在整个排序（得到所有初始归并段）的过程中，选择最小（或最大）关键字和输入、输出交叉或平行进行。</p>
<p><strong>例子</strong>：已知初始文件含有24个记录，它们的关键字分别为：51,49,39,46,38,29,14,61,15,30,1,48,52,3,63,27,4,13,89,24,46,58,33,76</p>
<p>假设内存工作区可容纳6个记录，则按前面讨论的选择排序可求得如下4个初始归并段：</p>
<ul>
<li>RUN1：29,38,39,46,49,51</li>
<li>RUN2：1,14,15,30,48,61</li>
<li>RUN3：3,4,13,27,52,63</li>
<li>RUN4：24,33,46,58,76,89</li>
</ul>
<p>若按置换-选择排序进行排序，则可求得如下3个初始归并段：（过程见下文）</p>
<ul>
<li>RUN1：29,38,39,46,49,51,61</li>
<li>RUN2：1,3,14,15,27,30,48,52,63,89</li>
<li>RUN3：4,13,24,33,46,58,76</li>
</ul>
<p>假设初始待排文件为输入文件$FI$,初始归并段文件为输出文件$FO$，内存工作区为$WA$，$FO$和$WA$的初始状态为空，并设内存工作区的容量可容纳 $w$ 个记录，则置换-选择排序的操作过程为：</p>
<ul>
<li>① 从FI输入w个记录到工作区WA。</li>
<li>② 从WA中选出其中关键字取最小值的记录，记为MINIMAX记录。</li>
<li>③ 将MINIMAX记录输入到FO中去。</li>
<li>④ 若FI不空，则从FI输入下一个记录到WA中。</li>
<li>⑤ 从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。</li>
<li>⑥ 重复③～⑤，直至WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。</li>
<li>⑦ 重复②～⑥，直至WA为空。由此得到所有初始归并段。</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/weread_image_1008947734277815.jpeg" alt="置换-选择过程"></p>
<p>在$WA$中选择MINIMAX记录的过程需利用<strong>败者树</strong>来实现。</p>
<p><strong>说明</strong>：</p>
<p>（1）内存工作区中的记录作为败者树的外部结点，而败者树中根结点的双亲结点指示工作区中关键字最小的记录。</p>
<p>（2）为了便于选出MINIMAX记录，为每个记录附设一个所在归并段的序号，在进行关键字的比较时，先比较段号，段号小者为胜者；段号相同的则关键字小的为胜者。</p>
<p>（3）败者树的建立可从设工作区中所有记录的段号均为 $0$ 开始，然后从$FI$逐个输入$w$个记录到工作区时，自上而下调整败者树。由于这些记录的段号为 $1$，则它们对于 $0$ 段的记录而言均为败者，从而逐个填充到败者树的各结点中去。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/weread_image_1009194685773090.jpeg"></p>
<p><strong>算法实现</strong>：</p>
<p><code>Replacd_selection</code>是置换﹣选择排序的简单描述，其中，求得一个初始归并段的过程如算法11.5所述。算法11.6和算法<br>11.7分别描述了置换﹣选择排序中的败者树的调整和初建的过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   RedType rec;                 <span class="comment">//记录</span></span><br><span class="line">   KeyType key;                 <span class="comment">//从记录中抽取的关键字</span></span><br><span class="line">   <span class="keyword">int</span> rnum;                    <span class="comment">//所属归并段的段号</span></span><br><span class="line">&#125;RcdNode,WorkArea[w];           <span class="comment">//内存工作区，容量为w</span></span><br><span class="line">WorkArea wa;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Construct_Loser</span><span class="params">(LoserTree &amp;ls, WorkArea &amp;wa)</span> </span>&#123; <span class="comment">//初建败者树</span></span><br><span class="line">    <span class="comment">//输入w个记录到内存工作区wa，建立败者树ls，选出关键字最小的记录并由s指示其在wa中的位置</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; w; ++i) &#123;</span><br><span class="line">        wa[i].rnum = wa[i].key = ls[i] = <span class="number">0</span>;	<span class="comment">//工作区初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = w - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        freed(&amp;wa[i].rec, <span class="keyword">sizeof</span>(RcdType), <span class="number">1</span>, fi);	<span class="comment">//输入一个记录</span></span><br><span class="line">        wa[i].key = wa[i].rec.key;					<span class="comment">//保存该记录的关键字</span></span><br><span class="line">        wa[i].rnum = <span class="number">1</span>;								<span class="comment">//其段号为 1 </span></span><br><span class="line">        Select_MiniMax(ls, wa, i);					<span class="comment">//调整败者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="function">yu</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Select_MiniMax</span><span class="params">(LoserTree &amp;ls, WorkArea wa, <span class="keyword">int</span> q)</span> </span>&#123;	<span class="comment">//选出MINIMAX</span></span><br><span class="line">    <span class="comment">//从wa[q]起到败者树的根比较选择MINIMAX记录，并由q指示它所在的归并段</span></span><br><span class="line">    t = (w + q) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = ls[t]; t &gt; <span class="number">0</span>; t = t / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(wa[p].rnum &lt; wa[q].rnum || (wa[p].rnum == wa[q].rnum &amp;&amp; wa[p].key &lt; wa[q].key)) &#123;</span><br><span class="line">            q &lt;--&gt; ls[t];	<span class="comment">//q指向新的胜利者</span></span><br><span class="line">        &#125;</span><br><span class="line">        ls[<span class="number">0</span>] = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Replacd_selection</span><span class="params">(LoserTree &amp;ls, WorkArea &amp;wa, FILE *fi, FILE *fo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在败者树ls和内存工作区wa上用置换-选择排序求初始归并段，fi为输入文件（只读文件）指针</span></span><br><span class="line">    <span class="comment">//fo为输出文件（只写文件指针）</span></span><br><span class="line">    Construct_Loser(ls, wa);	<span class="comment">//创建败者树</span></span><br><span class="line">    rc = rmax = <span class="number">1</span>;	<span class="comment">//rc指示当前生成的初始归并段的段号，rmax指示wa中关键字所属初始归并段的最大段号</span></span><br><span class="line">    <span class="keyword">while</span>(rc &lt;= rmax) &#123; <span class="comment">// rc = rmax + 1 表示输入文件的置换-选择排序已完成</span></span><br><span class="line">    	get_run(ls, wa); <span class="comment">//求得一个初始归并段</span></span><br><span class="line">        fwrite(&amp;RUNEND_SYMBOL, <span class="keyword">sizeof</span>(struct RcdNode), <span class="number">1</span>, fo);	<span class="comment">//将段结束标志写入输出文件</span></span><br><span class="line">        rc = wa[ls[<span class="number">0</span>]].rnum;	<span class="comment">//设置下一段的段号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_run</span><span class="params">(LoserTree &amp;ls, WorkArea &amp;wa)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//求得一个初始归并段，fi为输入文件指针，fo为输出文件指针</span></span><br><span class="line">    <span class="keyword">while</span>(wa[ls[<span class="number">0</span>]].rnum == rc) &#123; 	<span class="comment">//选得的MINIMAX记录属当前段时</span></span><br><span class="line">        q = ls[<span class="number">0</span>];			<span class="comment">//q指示MINIMAX记录在wa中的位置</span></span><br><span class="line">        minimax = wa[q].key;	</span><br><span class="line">        fwrite(&amp;wa[q].rec, <span class="keyword">sizeof</span>(RcdType), <span class="number">1</span>, fo); 	<span class="comment">//将刚选好的MINIMAX记录写入输出文件</span></span><br><span class="line">        <span class="keyword">if</span>(feof(fi)) &#123;	<span class="comment">//输入文件结束，虚设记录（属rmax+1段）</span></span><br><span class="line">            wa[q].rnum = rmax + <span class="number">1</span>;</span><br><span class="line">            wa[q].key = MAXKEY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;			<span class="comment">//输出文件非空时</span></span><br><span class="line">            fread(&amp;wa[q].rec, <span class="keyword">sizeof</span>(RcdType), <span class="number">1</span>, fi);	<span class="comment">//从输入文件读入下一记录</span></span><br><span class="line">            wa[q].key = wa[q].rec.key;	<span class="comment">//提取关键字</span></span><br><span class="line">            <span class="keyword">if</span>(wa[q].key &lt; minimax) &#123;	<span class="comment">//新读入的记录属下一段</span></span><br><span class="line">                rmax = rc + <span class="number">1</span>;</span><br><span class="line">                wa[q].rnum = rmax;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> wa[q].rnum = rc;	<span class="comment">//新读入的记录属当前段</span></span><br><span class="line">        &#125;</span><br><span class="line">        Select_MiniMax(ls, wa, q);	<span class="comment">//选出新的MINIMAX记录</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;<span class="comment">//get_run</span></span><br></pre></td></tr></table></figure>

<p>置换-选择排序所得初始归并段的长度不等。且可证明，当输入文件中记录的关键字为随机数时，所得初始归并段的平均长度为内存工作区大小 $w$ 的两倍。</p>
<p>假设一台扫雪机在环形路上等速进行扫雪，又下雪的速度也是均衡的（即每小时落到地面上的雪量相等），雪均匀地落在扫雪机的前、后路面上，边下雪边扫雪。显然，在某个时刻之后，整个系统达到平衡状态，路面上的积雪总量不变。且在任何时刻，整个路面上的积雪都形成一个均匀的斜面，紧靠扫雪机前端的积雪最厚，其深度为$h$，而在扫雪机刚扫过的路面上的积雪深度为零。若将环形路伸展开来，路面积雪状态如图所示。假设此刻路面积雪的总体积为$w$，环形路一圈的长度为$l$，由于扫雪机在任何时刻扫走的雪的深度为$h$，则扫雪机在环形路上走一圈扫掉的积雪体积为$lh$即$2w$。<br><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/weread_image_1014484107266032.jpeg" style="zoom: 33%;"></p>
<h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><p>假设由置换-选择得到9个初始归并段，其长度（即记录数）依次为9，30，12，18，3，17，2，6，24。现作3-路平衡归并，其归并树（表示归并过程的图）如图(b)所示，图中每个圆圈表示一个初始归并段，圆圈中数字表示归并段的长度。假设每个记录占一个物理块，则两趟归并所需对外存进行读/写次数为 $(9+30+12+18+3+17+2+6+24)×2×2=484$。若将初始归并段的长度看成是归并树中叶子结点的权，则此3叉树的带权路径长度的两倍恰为484。<strong>若对长度不等的$m$个初始归并段，构造一棵哈夫曼树作为归并树，便可使在进行外部归并时所需对外存进行读/写次数达最少</strong>。对上述9个初始归并段可构造一棵如图(a)所示的归并树，按此树进行归并，仅需对外存进行446次读/写，这棵归并树便称做<strong>最佳归并树</strong>。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306112724047.png" alt="image-20220306112724047"></p>
<p>如何判断附加虚段的数目？当3叉树中只有度为3或0的结点时，必有$n3=(n0-1)/2$。$n$ 是度为3的结点数，$n0$ 是度为0的结点数。由于$n3$必为整数，则$(n0-1)$ $MOD$ $2=0$。也就是说，对3-路归并而言，只有当初始归并段的个数为偶数时，才需加1个虚段。</p>
<p>一般情况下，对 k-路归并而言，容易推算得到</p>
<ul>
<li>若$(m-1)$ $MOD$ $(k-1)=0$，则不需加虚段</li>
<li>否则附加 $k-(m-1)$ $MOD$ $(k-1)-1$ 个虚段。换句话说，第一次归并为 $(m-1)$ $MOD$ $(k-1)+1$路归并。</li>
</ul>
<p>若按最佳归并树的归并方案进行磁盘归并排序，需在内存建立一张载有归并段的长度和它在磁盘上的物理位置的索引表。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h3><ul>
<li>主要应用<ul>
<li>信息检索 (information retrieval) </li>
<li>自然语言大规模的英文词典</li>
</ul>
</li>
<li>字符树——26叉Trie</li>
<li>二叉Trie树 <ul>
<li>用每个字母（或数值）的二进制编码来代表</li>
<li>编码只有0和1</li>
</ul>
</li>
</ul>
<p><strong>26叉Trie</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306141203947.png" alt="image-20220306141203947"><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306141644927.png" alt="image-20220306141644927"></p>
<p><strong>二叉Trie</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306142001259.png" alt="image-20220306142001259"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306142538994.png" alt="image-20220306142538994"></p>
<p><strong>后缀树（Suffix Trees）</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306142857276.png" alt="image-20220306142857276"></p>
<p><strong>后缀数组 (Suffix Array)</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306143836110.png" alt="image-20220306143836110"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306143850665.png" alt="image-20220306143850665"></p>
<h3 id="伸展树Splay"><a href="#伸展树Splay" class="headerlink" title="伸展树Splay"></a>伸展树Splay</h3><p>一种自组织数据结构</p>
<ul>
<li>数据随检索而调整位置</li>
<li>汉字输入法的词表，如：输入法输入<code>ss</code>出来第一个是<code>生生</code>(原先可能不是)，就是根据你使用次数调整的</li>
</ul>
<p>伸展树不是一个新数据结构，而只是改进 BST 性能的一组规则</p>
<ul>
<li>保证访问的总代价不高，达到最令人满意的性能</li>
<li>不能保证最终树高平衡</li>
</ul>
<p>访问一次结点 (例如结点 x) ，完成一次称为展开的过程</p>
<ul>
<li>x 被插入、检索时，把结点 x 移到 BST 的根结点</li>
<li>删除结点 x 时，把结点 x 的父结点移到根结点</li>
</ul>
<p>像在 AVL 树中一样，结点x的一次展开包括一组旋转(rotation) </p>
<ul>
<li>调整结点 x、父结点、祖父结点的位置</li>
<li>把 x 移到树结构中的更高层</li>
</ul>
<p>**单旋转 (single rotation) **</p>
<p>x 是根结点的直接子结点时</p>
<ul>
<li>把结点 x 与它的父结点交换位置</li>
<li>保持 BST 特性</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306151223735.png" alt="image-20220306151223735"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306153407987.png" alt="image-20220306153407987"></p>
<p>**双旋转 (double rotation) **</p>
<p>双旋转涉及到</p>
<ul>
<li>结点 x</li>
<li>结点 x 的父结点 (称为 y) </li>
<li>结点 x 的祖父结点 (称为 z) </li>
</ul>
<p>把结点 x 在树结构中向上移两层</p>
<p>一字形旋转 (zigzig rotation) 也称为同构调整 (homogeneous configuration) </p>
<p>之字形旋转 (zigzag rotation) 也称为异构调整 (heterogeneous configuration) </p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306154212520.png" alt="image-20220306154212520"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306153313634.png" alt="image-20220306153313634"></p>
<p><strong>两种旋转的不同作用</strong></p>
<p>之字形旋转</p>
<ul>
<li>把新访问的记录向根结点移动</li>
<li>使子树结构的高度减1</li>
<li>趋向于使树结构更加平衡</li>
</ul>
<p>一字形提升</p>
<ul>
<li>一般不会降低树结构的高度</li>
<li>只是把新访问的记录向根结点移动</li>
</ul>
<p><strong>伸展树的调整过程</strong></p>
<ul>
<li>一系列双旋转，直到结点 x 到达根结点或者根结点的子结点</li>
<li>如果结点x到达根结点的子结点进行一次单旋转使结点 x 成为根结点</li>
<li>这个过程趋向于使树结构重新平衡，使访问最频繁的结点靠近树结构的根层，从而减少访问代价</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306152402718.png" alt="image-20220306152402718"></p>
<p><strong>与AVL树的差别</strong></p>
<p>伸展树与结点被访问的频率相关根据插入、删除、检索动态地调整。</p>
<p>而 AVL 树的结构与访问频率无关只与插入、删除的顺序有关。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306154340706.png" alt="image-20220306154340706"></p>
<h3 id="红黑树RBT"><a href="#红黑树RBT" class="headerlink" title="红黑树RBT"></a>红黑树RBT</h3><p>红黑树<strong>（red-black tree）</strong>：平衡的 扩充 二叉搜索树</p>
<p>颜色特征：结点是 红色 或 黑色；</p>
<ul>
<li>根特征 ：根结点永远是 黑色 的；</li>
<li>外部特征：扩充外部叶结点都是空的 黑色结点；</li>
<li>内部特征：红色结点的两个子结点都是黑色的，不允许两个连续的红色结点；</li>
<li>深度特征：任何结点到其子孙外部结点的每条简单路径都包含相同数目的“黑色”结点</li>
</ul>
<p><strong>红黑树的阶</strong></p>
<p>结点$X$的阶（rank，也称“黑色高度”）</p>
<ul>
<li>从该结点到外部结点的黑色结点数量</li>
<li>不包括 $X$ 结点本身，包括叶结点</li>
</ul>
<p>外部结点的阶是零，根的阶称为该树的阶。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306155715286.png" alt="image-20220306155715286"></p>
<p><strong>红黑树的性质</strong></p>
<p>红黑树是满二叉树，空叶结点也看作结点</p>
<p>阶为 $k$ 的红黑树路径长度 最短是 $k$，最长是 $2k$ ，从根到叶的简单路径长度</p>
<p>阶为 $k$ 的红黑树树高最小是 $k+1$，最高是 $2k+1$</p>
<p>阶为$k$的红黑树的内部结点最少是一棵完全满二叉树，内部结点数最少是 $2^k-1$</p>
<p>$n$ 个内部结点的红黑树树高最大是 $2\log_2(n+1)+1$</p>
<p><strong>红黑树的插入</strong></p>
<p>先调用 BST 的插入算法</p>
<ul>
<li><p>把新记录着色为红色</p>
</li>
<li><p>若父结点是黑色，则算法结束</p>
</li>
<li><p>否则，双红调整</p>
</li>
</ul>
<p>调整方法一：重构</p>
<p>情况：新增结点$X$的叔父$C$节点是黑色</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306161526842.png" alt="image-20220306161526842"></p>
<p>调整方法二：换色</p>
<p>情况：新增结点 $X$ 的叔父结点$C$也是红色</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306161629875.png" alt="image-20220306161629875"></p>
<p>示例：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306162037828.png" alt="image-20220306162037828"></p>
<p><strong>红黑树的删除</strong></p>
<p>先调用 BST 的删除算法</p>
<ul>
<li>待删除的结点有一个以上的外部空指针，则直接删除</li>
<li>否则在右子树中找到其后继结点进行值交换（着色不变）删除</li>
</ul>
<p>$v$ 是被删除的内结点, $w$ 是被删外结点, $X$ 是 $w$ 的兄弟</p>
<ul>
<li>如果 $v$ 或者 $X$ 是红色, 则把 $X$ 标记为黑色即可</li>
<li>否则, $X$ 需要标记为双黑（即承担两层黑色）, 根据其兄弟结点 $C$ 进行重构调整 </li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306163200522.png" alt="image-20220306163200522"></p>
<p><strong>双黑调整</strong></p>
<p>假设 $X$ 是左子结点（若$X$为右孩子，则对称）</p>
<ul>
<li>情况 1： $C$ 是黑色，且子结点有红色<ul>
<li>重构，完成操作</li>
</ul>
</li>
<li>情况 2：$C$ 是黑色, 且有两个黑子结点<ul>
<li>换色</li>
<li>若父结点 $B$ 原为黑色，可能需要从 $B$ 继续向上调整</li>
</ul>
</li>
<li>情况 3： $C$ 是红色<ul>
<li>转换状态</li>
<li>$C$ 转为父结点，调整为情况 1 或 2 继续处理</li>
</ul>
</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306164319716.png" alt="image-20220306164319716"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306164413715.png" alt="image-20220306164413715"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306164540180.png" alt="image-20220306164540180"></p>
<p>示例：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306165510731.png" alt="image-20220306165510731"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/image-20220306170037324.png" alt="image-20220306170037324"></p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>机房预约系统</title>
    <url>/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>学习自黑马程序员&amp;传智教育，文档资料有修改</p>
<span id="more"></span>

<h1 id="机房预约系统"><a href="#机房预约系统" class="headerlink" title="机房预约系统"></a>机房预约系统</h1><h2 id="1、机房预约系统需求"><a href="#1、机房预约系统需求" class="headerlink" title="1、机房预约系统需求"></a>1、机房预约系统需求</h2><h3 id="1-1-系统简介"><a href="#1-1-系统简介" class="headerlink" title="1.1 系统简介"></a>1.1 系统简介</h3><ul>
<li>学校现有几个规格不同的机房，由于使用时经常出现”撞车”现象,现开发一套机房预约系统，解决这一问题。</li>
</ul>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682783885.png" alt="1548682783885"></p>
<h3 id="1-2-身份简介"><a href="#1-2-身份简介" class="headerlink" title="1.2 身份简介"></a>1.2 身份简介</h3><p>分别有三种身份使用该程序</p>
<ul>
<li><strong>学生代表</strong>：申请使用机房</li>
<li><strong>教师</strong>：审核学生的预约申请</li>
<li><strong>管理员</strong>：给学生、教师创建账号</li>
</ul>
<h3 id="1-3-机房简介"><a href="#1-3-机房简介" class="headerlink" title="1.3 机房简介"></a>1.3 机房简介</h3><p>机房总共有3间</p>
<ul>
<li>1号机房   — 最大容量20人</li>
<li>2号机房   — 最多容量50人</li>
<li>3号机房   — 最多容量100人</li>
</ul>
<h3 id="1-4-申请简介"><a href="#1-4-申请简介" class="headerlink" title="1.4 申请简介"></a>1.4 申请简介</h3><ul>
<li>申请的订单每周由管理员负责清空。</li>
<li>学生可以预约未来一周内的机房使用，预约的日期为周一至周五，预约时需要选择预约时段（上午、下午）</li>
<li>教师来审核预约，依据实际情况审核预约通过或者不通过</li>
</ul>
<h3 id="1-5-系统具体需求"><a href="#1-5-系统具体需求" class="headerlink" title="1.5 系统具体需求"></a>1.5 系统具体需求</h3><ul>
<li>首先进入登录界面，可选登录身份有：<ul>
<li>学生代表</li>
<li>老师</li>
<li>管理员</li>
<li>退出</li>
</ul>
</li>
<li>每个身份都需要进行验证后，进入子菜单<ul>
<li>学生需要输入 ：学号、姓名、登录密码</li>
<li>老师需要输入：职工号、姓名、登录密码</li>
<li>管理员需要输入：管理员姓名、登录密码</li>
</ul>
</li>
<li>学生具体功能<ul>
<li>申请预约    —   预约机房</li>
<li>查看自身的预约    —  查看自己的预约状态</li>
<li>查看所有预约   —   查看全部预约信息以及预约状态</li>
<li>取消预约    —   取消自身的预约，预约成功或审核中的预约均可取消</li>
<li>注销登录    —   退出登录</li>
</ul>
</li>
<li>教师具体功能<ul>
<li>查看所有预约   —   查看全部预约信息以及预约状态</li>
<li>审核预约    —   对学生的预约进行审核</li>
<li>注销登录    —   退出登录</li>
</ul>
</li>
<li>管理员具体功能<ul>
<li>添加账号    —   添加学生或教师的账号，需要检测学生编号或教师职工号是否重复</li>
<li>查看账号    —   可以选择查看学生或教师的全部信息</li>
<li>查看机房    —   查看所有机房的信息</li>
<li>清空预约    —   清空所有预约记录</li>
<li>注销登录    —   退出登录</li>
</ul>
</li>
</ul>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682206670.png" alt="1548682206670"></p>
<h2 id="2、创建项目"><a href="#2、创建项目" class="headerlink" title="2、创建项目"></a>2、创建项目</h2><p>创建项目步骤如下：</p>
<ul>
<li>创建新项目</li>
<li>添加文件</li>
</ul>
<h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><ul>
<li>打开vs2017后，点击创建新项目，创建新的C++项目</li>
</ul>
<p>如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682413343.png" alt="1548682413343"></p>
<ul>
<li>填写项目名称以及选取项目路径，点击确定生成项目</li>
</ul>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682522544.png" alt="1548682522544"></p>
<h3 id="2-2-添加文件"><a href="#2-2-添加文件" class="headerlink" title="2.2 添加文件"></a>2.2 添加文件</h3><ul>
<li>右键源文件，进行添加文件操作</li>
</ul>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682597721.png" alt="1548682597721"></p>
<ul>
<li>填写文件名称，点击添加</li>
</ul>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682679989.png" alt="1548682679989"></p>
<ul>
<li>生成文件成功，效果如下图</li>
</ul>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682733912.png" alt="1548682733912"></p>
<h2 id="3、创建主菜单"><a href="#3、创建主菜单" class="headerlink" title="3、创建主菜单"></a>3、创建主菜单</h2><p><strong>功能描述：</strong></p>
<ul>
<li>设计主菜单，与用户进行交互</li>
</ul>
<h3 id="3-1-菜单实现"><a href="#3-1-菜单实现" class="headerlink" title="3.1 菜单实现"></a>3.1 菜单实现</h3><ul>
<li>在主函数main中添加菜单提示，代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;======================  欢迎来到传智播客机房预约系统  =====================&quot;</span> </span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;请输入您的身份&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          1.学生代表           |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          2.老    师           |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          3.管 理 员           |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          0.退    出           |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输入您的选择: &quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行效果如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548557945611.png" alt="1548557945611"></p>
<h3 id="3-2-搭建接口"><a href="#3-2-搭建接口" class="headerlink" title="3.2 搭建接口"></a>3.2 搭建接口</h3><ul>
<li>接受用户的选择，搭建接口</li>
<li>在main中添加代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;======================  欢迎来到传智播客机房预约系统  =====================&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;请输入您的身份&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|          1.学生代表           |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|          2.老    师           |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|          3.管 理 员           |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|          0.退    出           |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入您的选择: &quot;</span>;</span><br><span class="line"></span><br><span class="line">		cin &gt;&gt; select; <span class="comment">//接受用户选择</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (select)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//学生身份</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//老师身份</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//管理员身份</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//退出系统</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;输入有误，请重新选择！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试，输入0、1、2、3会重新回到界面，输入其他提示输入有误，清屏后重新选择</p>
<p>效果如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548558694230.png" alt="1548558694230"></p>
<p>至此，界面搭建完毕</p>
<h2 id="4、-退出功能实现"><a href="#4、-退出功能实现" class="headerlink" title="4、 退出功能实现"></a>4、 退出功能实现</h2><h3 id="4-1-退出功能实现"><a href="#4-1-退出功能实现" class="headerlink" title="4.1 退出功能实现"></a>4.1 退出功能实现</h3><p>在main函数分支 0 选项中，添加退出程序的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;欢迎下一次使用&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548558992754.png" alt="1548558992754"></p>
<h3 id="4-2-测试退出功能"><a href="#4-2-测试退出功能" class="headerlink" title="4.2 测试退出功能"></a>4.2 测试退出功能</h3><p>运行程序，效果如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548559026436.png" alt="1548559026436"></p>
<p>至此，退出程序功能实现</p>
<h2 id="5、-创建身份类"><a href="#5、-创建身份类" class="headerlink" title="5、 创建身份类"></a>5、 创建身份类</h2><h3 id="5-1-身份的基类"><a href="#5-1-身份的基类" class="headerlink" title="5.1 身份的基类"></a>5.1 身份的基类</h3><ul>
<li>在整个系统中，有三种身份，分别为：学生代表、老师以及管理员</li>
<li>三种身份有其共性也有其特性，因此我们可以将三种身份抽象出一个身份基类<strong>identity</strong></li>
<li>在头文件下创建Identity.h文件</li>
</ul>
<p>Identity.h中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//身份抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Identity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//操作菜单</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	string m_Name; <span class="comment">//用户名</span></span><br><span class="line">	string m_Pwd;  <span class="comment">//密码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>效果如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548573329273.png" alt="1548573329273"></p>
<h3 id="5-2-学生类"><a href="#5-2-学生类" class="headerlink" title="5.2 学生类"></a>5.2 学生类</h3><h4 id="5-2-1-功能分析"><a href="#5-2-1-功能分析" class="headerlink" title="5.2.1 功能分析"></a>5.2.1 功能分析</h4><ul>
<li><p>学生类主要功能是可以通过类中成员函数，实现预约实验室操作</p>
</li>
<li><p>学生类中主要功能有：</p>
<ul>
<li>显示学生操作的菜单界面</li>
<li>申请预约</li>
<li>查看自身预约</li>
<li>查看所有预约</li>
<li>取消预约</li>
</ul>
</li>
</ul>
<h4 id="5-2-2-类的创建"><a href="#5-2-2-类的创建" class="headerlink" title="5.2.2 类的创建"></a>5.2.2 类的创建</h4><ul>
<li>在头文件以及源文件下创建 student.h 和 student.cpp文件</li>
</ul>
<p>student.h中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span><span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//默认构造</span></span><br><span class="line">	<span class="built_in">Student</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">	<span class="built_in">Student</span>(<span class="keyword">int</span> id, string name, string pwd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//菜单界面</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//申请预约</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">applyOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看我的预约</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showMyOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看所有预约</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showAllOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//取消预约</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cancelOrder</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//学生学号</span></span><br><span class="line">	<span class="keyword">int</span> m_Id;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>student.cpp中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Student::<span class="built_in">Student</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="keyword">int</span> id, string name, string pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::applyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看我的预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showMyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::cancelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="5-3-老师类"><a href="#5-3-老师类" class="headerlink" title="5.3 老师类"></a>5.3 老师类</h3><h4 id="5-3-1-功能分析"><a href="#5-3-1-功能分析" class="headerlink" title="5.3.1 功能分析"></a>5.3.1 功能分析</h4><ul>
<li><p>教师类主要功能是查看学生的预约，并进行审核</p>
</li>
<li><p>教师类中主要功能有：</p>
<ul>
<li><p>显示教师操作的菜单界面</p>
</li>
<li><p>查看所有预约</p>
</li>
<li><p>审核预约</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-3-2-类的创建"><a href="#5-3-2-类的创建" class="headerlink" title="5.3.2 类的创建"></a>5.3.2 类的创建</h4><ul>
<li>在头文件以及源文件下创建 teacher.h 和 teacher.cpp文件</li>
</ul>
<p>teacher.h中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span><span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认构造</span></span><br><span class="line">	<span class="built_in">Teacher</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">	<span class="built_in">Teacher</span>(<span class="keyword">int</span> empId, string name, string pwd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//菜单界面</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看所有预约</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showAllOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//审核预约</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">validOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_EmpId; <span class="comment">//教师编号</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>teacher.cpp中添加如下代码:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;teacher.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>(<span class="keyword">int</span> empId, string name, string pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::validOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="5-4-管理员类"><a href="#5-4-管理员类" class="headerlink" title="5.4 管理员类"></a>5.4 管理员类</h3><h4 id="5-4-1-功能分析"><a href="#5-4-1-功能分析" class="headerlink" title="5.4.1 功能分析"></a>5.4.1 功能分析</h4><ul>
<li><p>管理员类主要功能是对学生和老师账户进行管理，查看机房信息以及清空预约记录</p>
</li>
<li><p>管理员类中主要功能有：</p>
<ul>
<li><p>显示管理员操作的菜单界面</p>
</li>
<li><p>添加账号</p>
</li>
<li><p>查看账号</p>
</li>
<li><p>查看机房信息</p>
</li>
<li><p>清空预约记录</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-4-2-类的创建"><a href="#5-4-2-类的创建" class="headerlink" title="5.4.2 类的创建"></a>5.4.2 类的创建</h4><ul>
<li>在头文件以及源文件下创建 manager.h 和 manager.cpp文件</li>
</ul>
<p>manager.h中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> :</span><span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认构造</span></span><br><span class="line">	<span class="built_in">Manager</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有参构造  管理员姓名，密码</span></span><br><span class="line">	<span class="built_in">Manager</span>(string name, string pwd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选择菜单</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加账号  </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看账号</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看机房信息</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showComputer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空预约记录</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cleanFile</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>manager.cpp中添加如下代码:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;manager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Manager::<span class="built_in">Manager</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::<span class="built_in">Manager</span>(string name, string pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加账号  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::addPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看账号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showComputer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::cleanFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，所有身份类创建完毕，效果如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548574390768.png" alt="1548574390768"></p>
<h2 id="6、-登录模块"><a href="#6、-登录模块" class="headerlink" title="6、  登录模块"></a>6、  登录模块</h2><h3 id="6-1-全局文件添加"><a href="#6-1-全局文件添加" class="headerlink" title="6.1 全局文件添加"></a>6.1 全局文件添加</h3><p>功能描述：</p>
<ul>
<li>不同的身份可能会用到不同的文件操作，我们可以将所有的文件名定义到一个全局的文件中</li>
<li>在头文件中添加 <strong>globalFile.h</strong> 文件</li>
<li>并添加如下代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理员文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADMIN_FILE     <span class="meta-string">&quot;admin.txt&quot;</span></span></span><br><span class="line"><span class="comment">//学生文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STUDENT_FILE   <span class="meta-string">&quot;student.txt&quot;</span></span></span><br><span class="line"><span class="comment">//教师文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEACHER_FILE   <span class="meta-string">&quot;teacher.txt&quot;</span></span></span><br><span class="line"><span class="comment">//机房信息文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPUTER_FILE  <span class="meta-string">&quot;computerRoom.txt&quot;</span></span></span><br><span class="line"><span class="comment">//订单文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORDER_FILE     <span class="meta-string">&quot;order.txt&quot;</span></span></span><br></pre></td></tr></table></figure>



<p>并且在同级目录下，创建这几个文件</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548575650130.png" alt="1548575650130"></p>
<h3 id="6-2-登录函数封装"><a href="#6-2-登录函数封装" class="headerlink" title="6.2  登录函数封装"></a>6.2  登录函数封装</h3><p>功能描述：</p>
<ul>
<li>根据用户的选择，进入不同的身份登录</li>
</ul>
<p>在预约系统的.cpp文件中添加全局函数 <code>void LoginIn(string fileName, int type)</code></p>
<p>参数：</p>
<ul>
<li>fileName  — 操作的文件名</li>
<li>type      —  登录的身份  （1代表学生、2代表老师、3代表管理员）</li>
</ul>
<p>LoginIn中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;globalFile.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//登录功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoginIn</span><span class="params">(string fileName, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	Identity * person = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(fileName, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//文件不存在情况</span></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">		ifs.<span class="built_in">close</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">	string name;</span><br><span class="line">	string pwd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type == <span class="number">1</span>)	<span class="comment">//学生登录</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入你的学号&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) <span class="comment">//教师登录</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入你的职工号&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入用户名：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入密码： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; pwd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//学生登录验证</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//教师登录验证</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//管理员登录验证</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;验证登录失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在main函数的不同分支中，填入不同的登录接口</li>
</ul>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548575945985.png" alt="1548575945985"></p>
<h3 id="6-3-学生登录实现"><a href="#6-3-学生登录实现" class="headerlink" title="6.3 学生登录实现"></a>6.3 学生登录实现</h3><p>在student.txt文件中添加两条学生信息，用于测试</p>
<p>添加信息:   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 张三 <span class="number">123</span></span><br><span class="line"><span class="number">2</span> 李四 <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>第一列  代表  <strong>学号</strong></li>
<li>第二列  代表  <strong>学生姓名</strong></li>
<li>第三列  代表  <strong>密码</strong></li>
</ul>
<p>效果图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583693555.png" alt="1548583693555"></p>
<p>在Login函数的学生分支中加入如下代码，验证学生身份</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生登录验证</span></span><br><span class="line"><span class="keyword">int</span> fId;</span><br><span class="line">string fName;</span><br><span class="line">string fPwd;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (id == fId &amp;&amp; name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;学生验证登录成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		person = <span class="keyword">new</span> <span class="built_in">Student</span>(id, name, pwd);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加代码效果图</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583915819.png" alt="1548583915819"></p>
<p>测试：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583950828.png" alt="1548583950828"></p>
<h3 id="6-4-教师登录实现"><a href="#6-4-教师登录实现" class="headerlink" title="6.4 教师登录实现"></a>6.4 教师登录实现</h3><p>在teacher.txt文件中添加一条老师信息，用于测试</p>
<p>添加信息:   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 老王 <span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>第一列  代表  <strong>教师职工编号</strong></li>
<li>第二列  代表  <strong>教师姓名</strong></li>
<li>第三列  代表  <strong>密码</strong></li>
</ul>
<p>效果图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548584030522.png" alt="1548584030522"></p>
<p>在Login函数的教师分支中加入如下代码，验证教师身份</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//教师登录验证</span></span><br><span class="line"><span class="keyword">int</span> fId;</span><br><span class="line">string fName;</span><br><span class="line">string fPwd;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (id == fId &amp;&amp; name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;教师验证登录成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		person = <span class="keyword">new</span> <span class="built_in">Teacher</span>(id, name, pwd);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加代码效果图</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548584158339.png" alt="1548584158339"></p>
<p>测试：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548584177003.png" alt="1548584177003"></p>
<h3 id="6-5-管理员登录实现"><a href="#6-5-管理员登录实现" class="headerlink" title="6.5 管理员登录实现"></a>6.5 管理员登录实现</h3><p>在admin.txt文件中添加一条管理员信息，由于我们只有一条管理员，因此本案例中没有添加管理员的功能</p>
<p>添加信息:   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">admin <span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>其中：<code>admin</code>代表管理员用户名，<code>123</code>代表管理员密码</p>
<p>效果图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548577855190.png" alt="1548577855190"></p>
<p>在Login函数的管理员分支中加入如下代码，验证管理员身份</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//管理员登录验证</span></span><br><span class="line">		string fName;</span><br><span class="line">		string fPwd;</span><br><span class="line">		<span class="keyword">while</span> (ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;验证登录成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="comment">//登录成功后，按任意键进入管理员界面</span></span><br><span class="line">				<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">				<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">				<span class="comment">//创建管理员对象</span></span><br><span class="line">				person = <span class="keyword">new</span> <span class="built_in">Manager</span>(name,pwd);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>添加效果如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548588322712.png" alt="1548588322712"></p>
<p>测试效果如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583245072.png" alt="1548583245072"></p>
<p>至此，所有身份的登录功能全部实现！</p>
<h2 id="7、-管理员模块"><a href="#7、-管理员模块" class="headerlink" title="7、 管理员模块"></a>7、 管理员模块</h2><h3 id="7-1-管理员登录和注销"><a href="#7-1-管理员登录和注销" class="headerlink" title="7.1  管理员登录和注销"></a>7.1  管理员登录和注销</h3><h4 id="7-1-1-构造函数"><a href="#7-1-1-构造函数" class="headerlink" title="7.1.1 构造函数"></a>7.1.1 构造函数</h4><ul>
<li>在Manager类的构造函数中，初始化管理员信息，代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::<span class="built_in">Manager</span>(string name, string pwd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="7-1-2-管理员子菜单"><a href="#7-1-2-管理员子菜单" class="headerlink" title="7.1.2  管理员子菜单"></a>7.1.2  管理员子菜单</h4><ul>
<li>在机房预约系统.cpp中，当用户登录的是管理员，添加管理员菜单接口</li>
<li>将不同的分支提供出来<ul>
<li>添加账号</li>
<li>查看账号</li>
<li>查看机房</li>
<li>清空预约</li>
<li>注销登录</li>
</ul>
</li>
<li>实现注销功能</li>
</ul>
<p>添加全局函数 <code>void managerMenu(Identity * &amp;manager)</code>，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//管理员菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">managerMenu</span><span class="params">(Identity * &amp;manager)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//管理员菜单</span></span><br><span class="line">		manager-&gt;<span class="built_in">operMenu</span>();</span><br><span class="line"></span><br><span class="line">		Manager* man = (Manager*)manager;</span><br><span class="line">		<span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (select == <span class="number">1</span>)  <span class="comment">//添加账号</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;添加账号&quot;</span> &lt;&lt; endl;</span><br><span class="line">			man-&gt;<span class="built_in">addPerson</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>) <span class="comment">//查看账号</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;查看账号&quot;</span> &lt;&lt; endl;</span><br><span class="line">			man-&gt;<span class="built_in">showPerson</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">3</span>) <span class="comment">//查看机房</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;查看机房&quot;</span> &lt;&lt; endl;</span><br><span class="line">			man-&gt;<span class="built_in">showComputer</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">4</span>) <span class="comment">//清空预约</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;清空预约&quot;</span> &lt;&lt; endl;</span><br><span class="line">			man-&gt;<span class="built_in">cleanFile</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> manager;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-1-3-菜单功能实现"><a href="#7-1-3-菜单功能实现" class="headerlink" title="7.1.3 菜单功能实现"></a>7.1.3 菜单功能实现</h4><ul>
<li>在实现成员函数<code>void Manager::operMenu()</code> 代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;欢迎管理员：&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t ---------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          1.添加账号            |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          2.查看账号            |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          3.查看机房            |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          4.清空预约            |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录            |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t ---------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-1-4-接口对接"><a href="#7-1-4-接口对接" class="headerlink" title="7.1.4 接口对接"></a>7.1.4 接口对接</h4><ul>
<li>管理员成功登录后，调用管理员子菜单界面</li>
<li>在管理员登录验证分支中，添加代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入管理员子菜单</span></span><br><span class="line"><span class="built_in">managerMenu</span>(person);</span><br></pre></td></tr></table></figure>

<p>添加效果如：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589297779.png" alt="1548589297779"></p>
<p>测试对接，效果如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589344206.png" alt="1548589344206"></p>
<p>登录成功</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589328710.png" alt="1548589328710"></p>
<p>注销登录：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589416576.png" alt="1548589416576"></p>
<p>至此，管理员身份可以成功登录以及注销</p>
<h3 id="7-2-添加账号"><a href="#7-2-添加账号" class="headerlink" title="7.2 添加账号"></a>7.2 添加账号</h3><p>功能描述：</p>
<ul>
<li>给学生或教师添加新的账号</li>
</ul>
<p>功能要求：</p>
<ul>
<li>添加时学生学号不能重复、教师职工号不能重复</li>
</ul>
<h4 id="7-2-1-添加功能实现"><a href="#7-2-1-添加功能实现" class="headerlink" title="7.2.1 添加功能实现"></a>7.2.1 添加功能实现</h4><p>在Manager的<strong>addPerson</strong>成员函数中，实现添加新账号功能，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加账号  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::addPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入添加账号的类型&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、添加学生&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、添加老师&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string fileName;</span><br><span class="line">	string tip;</span><br><span class="line">	ofstream ofs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fileName = STUDENT_FILE;</span><br><span class="line">		tip = <span class="string">&quot;请输入学号： &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		fileName = TEACHER_FILE;</span><br><span class="line">		tip = <span class="string">&quot;请输入职工编号：&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">open</span>(fileName, ios::out | ios::app);</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	string name;</span><br><span class="line">	string pwd;</span><br><span class="line">	cout &lt;&lt;tip &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入姓名： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入密码： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; pwd;</span><br><span class="line"></span><br><span class="line">	ofs &lt;&lt; id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pwd &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;添加成功&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试添加学生：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641024216.png" alt="1548641024216"></p>
<p>成功在学生文件中添加了一条信息</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641141027.png" alt="1548641141027"></p>
<p>测试添加教师：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641195834.png" alt="1548641195834"></p>
<p>成功在教师文件中添加了一条信息</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641237513.png" alt="1548641237513"></p>
<h4 id="7-2-2-去重操作"><a href="#7-2-2-去重操作" class="headerlink" title="7.2.2 去重操作"></a>7.2.2 去重操作</h4><p>功能描述：添加新账号时，如果是重复的学生编号，或是重复的教师职工编号，提示有误</p>
<h5 id="7-2-2-1-读取信息"><a href="#7-2-2-1-读取信息" class="headerlink" title="7.2.2.1 读取信息"></a>7.2.2.1 读取信息</h5><ul>
<li>要去除重复的账号，首先要先将学生和教师的账号信息获取到程序中，方可检测</li>
<li>在manager.h中，添加两个容器，用于存放学生和教师的信息</li>
<li>添加一个新的成员函数  <code>void initVector()</code> 初始化容器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initVector</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生容器</span></span><br><span class="line">vector&lt;Student&gt; vStu;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师容器</span></span><br><span class="line">vector&lt;Teacher&gt; vTea;</span><br></pre></td></tr></table></figure>

<p>添加位置如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548644354561.png" alt="1548644354561"></p>
<p>在Manager的有参构造函数中，获取目前的学生和教师信息</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::initVector</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//读取学生文件中信息</span></span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(STUDENT_FILE, ios::in);</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件读取失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	vStu.<span class="built_in">clear</span>();</span><br><span class="line">     vTea.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">	Student s;</span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; s.m_Id &amp;&amp; ifs &gt;&gt; s.m_Name &amp;&amp;  ifs &gt;&gt; s.m_Pwd)</span><br><span class="line">	&#123;</span><br><span class="line">		vStu.<span class="built_in">push_back</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;当前学生数量为： &quot;</span> &lt;&lt; vStu.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	ifs.<span class="built_in">close</span>(); <span class="comment">//学生初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取老师文件信息</span></span><br><span class="line">	ifs.<span class="built_in">open</span>(TEACHER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">	Teacher t;</span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; t.m_EmpId &amp;&amp; ifs &gt;&gt; t.m_Name &amp;&amp;  ifs &gt;&gt; t.m_Pwd)</span><br><span class="line">	&#123;</span><br><span class="line">		vTea.<span class="built_in">push_back</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;当前教师数量为： &quot;</span> &lt;&lt; vTea.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在有参构造函数中，调用初始化容器函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::<span class="built_in">Manager</span>(string name, string pwd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//初始化容器</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">initVector</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>测试，运行代码可以看到测试代码获取当前学生和教师数量</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548642488049.png" alt="1548642488049"></p>
<h5 id="7-2-2-2-去重函数封装"><a href="#7-2-2-2-去重函数封装" class="headerlink" title="7.2.2.2 去重函数封装"></a>7.2.2.2 去重函数封装</h5><p>在manager.h文件中添加成员函数<code> bool checkRepeat(int id, int type);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检测重复 参数:(传入id，传入类型) 返回值：(true 代表有重复，false代表没有重复)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkRepeat</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure>



<p>在manager.cpp文件中实现成员函数  <code> bool checkRepeat(int id, int type);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Manager::checkRepeat</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;Student&gt;::iterator it = vStu.<span class="built_in">begin</span>(); it != vStu.<span class="built_in">end</span>(); it++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (id == it-&gt;m_Id)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;Teacher&gt;::iterator it = vTea.<span class="built_in">begin</span>(); it != vTea.<span class="built_in">end</span>(); it++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (id == it-&gt;m_EmpId)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="7-2-2-3-添加去重操作"><a href="#7-2-2-3-添加去重操作" class="headerlink" title="7.2.2.3 添加去重操作"></a>7.2.2.3 添加去重操作</h5><p>在添加学生编号或者教师职工号时，检测是否有重复，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string errorTip; <span class="comment">//重复错误提示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	fileName = STUDENT_FILE;</span><br><span class="line">	tip = <span class="string">&quot;请输入学号： &quot;</span>;</span><br><span class="line">	errorTip = <span class="string">&quot;学号重复，请重新输入&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	fileName = TEACHER_FILE;</span><br><span class="line">	tip = <span class="string">&quot;请输入职工编号：&quot;</span>;</span><br><span class="line">	errorTip = <span class="string">&quot;职工号重复，请重新输入&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">ofs.<span class="built_in">open</span>(fileName, ios::out | ios::app);</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">string name;</span><br><span class="line">string pwd;</span><br><span class="line">cout &lt;&lt;tip &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="keyword">this</span>-&gt;<span class="built_in">checkRepeat</span>(id, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret) <span class="comment">//有重复</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; errorTip &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码位置如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548643909979.png" alt="1548643909979"></p>
<p>检测效果：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548644151974.png" alt="1548644151974"></p>
<h5 id="7-2-2-4-bug解决"><a href="#7-2-2-4-bug解决" class="headerlink" title="7.2.2.4 bug解决"></a>7.2.2.4 bug解决</h5><p>bug描述：</p>
<ul>
<li>虽然可以检测重复的账号，但是刚添加的账号由于没有更新到容器中，因此不会做检测</li>
<li>导致刚加入的账号的学生号或者职工编号，再次添加时依然可以重复</li>
</ul>
<p>解决方案：</p>
<ul>
<li>在每次添加新账号时，重新初始化容器</li>
</ul>
<p>在添加完毕后，加入代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">initVector</span>();</span><br></pre></td></tr></table></figure>

<p>位置如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548644779578.png" alt="1548644779578"></p>
<p>再次测试，刚加入的账号不会重复添加了！</p>
<h3 id="7-3-显示账号"><a href="#7-3-显示账号" class="headerlink" title="7.3  显示账号"></a>7.3  显示账号</h3><p>功能描述：显示学生信息或教师信息</p>
<h4 id="7-3-1-显示功能实现"><a href="#7-3-1-显示功能实现" class="headerlink" title="7.3.1 显示功能实现"></a>7.3.1 显示功能实现</h4><p>在Manager的<strong>showPerson</strong>成员函数中，实现显示账号功能，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(Student &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;学号： &quot;</span> &lt;&lt; s.m_Id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; s.m_Name &lt;&lt; <span class="string">&quot; 密码：&quot;</span> &lt;&lt; s.m_Pwd &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTeacher</span><span class="params">(Teacher &amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;职工号： &quot;</span> &lt;&lt; t.m_EmpId &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t.m_Name &lt;&lt; <span class="string">&quot; 密码：&quot;</span> &lt;&lt; t.m_Pwd &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择查看内容：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、查看所有学生&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、查看所有老师&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; select;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;所有学生信息如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">		for_each(vStu.<span class="built_in">begin</span>(), vStu.<span class="built_in">end</span>(), printStudent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;所有老师信息如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">		for_each(vTea.<span class="built_in">begin</span>(), vTea.<span class="built_in">end</span>(), printTeacher);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-3-2-测试"><a href="#7-3-2-测试" class="headerlink" title="7.3.2 测试"></a>7.3.2 测试</h4><p>测试查看学生效果</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548646791248.png" alt="1548646791248"></p>
<p>测试查看教师效果</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548646833665.png" alt="1548646833665"></p>
<p>至此，显示账号功能实现完毕</p>
<h3 id="7-4-查看机房"><a href="#7-4-查看机房" class="headerlink" title="7.4 查看机房"></a>7.4 查看机房</h3><h4 id="7-4-1-添加机房信息"><a href="#7-4-1-添加机房信息" class="headerlink" title="7.4.1 添加机房信息"></a>7.4.1 添加机房信息</h4><p>案例需求中，机房一共有三个，其中1号机房容量20台机器，2号50台，3号100台</p>
<p>我们可以将信息录入到computerRoom.txt中</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548647538570.png" alt="1548647538570"></p>
<h4 id="7-4-2-机房类创建"><a href="#7-4-2-机房类创建" class="headerlink" title="7.4.2 机房类创建"></a>7.4.2 机房类创建</h4><p>在头文件下，创建新的文件 computerRoom.h</p>
<p>并添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//机房类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputerRoom</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_ComId; <span class="comment">//机房id号</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_MaxNum; <span class="comment">//机房最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="7-4-3-初始化机房信息"><a href="#7-4-3-初始化机房信息" class="headerlink" title="7.4.3 初始化机房信息"></a>7.4.3 初始化机房信息</h4><p>在Manager管理员类下，添加机房的容器,用于保存机房信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//机房容器</span></span><br><span class="line">vector&lt;ComputerRoom&gt; vCom;</span><br></pre></td></tr></table></figure>

<p>在Manager有参构造函数中，追加如下代码，初始化机房信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取机房信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">open</span>(COMPUTER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">ComputerRoom c;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; c.m_ComId &amp;&amp; ifs &gt;&gt; c.m_MaxNum)</span><br><span class="line">&#123;</span><br><span class="line">	vCom.<span class="built_in">push_back</span>(c);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前机房数量为： &quot;</span> &lt;&lt; vCom.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<p>位置如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548647976462.png" alt="1548647976462"></p>
<p>因为机房信息目前版本不会有所改动，如果后期有修改功能，最好封装到一个函数中，方便维护</p>
<h4 id="7-4-4-显示机房信息"><a href="#7-4-4-显示机房信息" class="headerlink" title="7.4.4 显示机房信息"></a>7.4.4 显示机房信息</h4><p>在Manager类的showComputer成员函数中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showComputer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;机房信息如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;ComputerRoom&gt;::iterator it = vCom.<span class="built_in">begin</span>(); it != vCom.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;机房编号： &quot;</span> &lt;&lt; it-&gt;m_ComId &lt;&lt; <span class="string">&quot; 机房最大容量： &quot;</span> &lt;&lt; it-&gt;m_MaxNum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试显示机房信息功能：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548648276929.png" alt="1548648276929"></p>
<h3 id="7-5-清空预约"><a href="#7-5-清空预约" class="headerlink" title="7.5 清空预约"></a>7.5 清空预约</h3><p>功能描述：</p>
<p>清空生成的<code>order.txt</code>预约文件</p>
<h4 id="7-5-1-清空功能实现"><a href="#7-5-1-清空功能实现" class="headerlink" title="7.5.1 清空功能实现"></a>7.5.1 清空功能实现</h4><p>在Manager的cleanFile成员函数中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::cleanFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::trunc)</span></span>;</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;清空成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试清空，可以随意写入一些信息在order.txt中，然后调用cleanFile清空文件接口，查看是否清空干净</p>
<h2 id="8、-学生模块"><a href="#8、-学生模块" class="headerlink" title="8、 学生模块"></a>8、 学生模块</h2><h3 id="8-1-学生登录和注销"><a href="#8-1-学生登录和注销" class="headerlink" title="8.1 学生登录和注销"></a>8.1 学生登录和注销</h3><h4 id="8-1-1-构造函数"><a href="#8-1-1-构造函数" class="headerlink" title="8.1.1 构造函数"></a>8.1.1 构造函数</h4><ul>
<li>在Student类的构造函数中，初始化学生信息，代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="keyword">int</span> id, string name, string pwd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//初始化属性</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-1-2-管理员子菜单"><a href="#8-1-2-管理员子菜单" class="headerlink" title="8.1.2  管理员子菜单"></a>8.1.2  管理员子菜单</h4><ul>
<li>在机房预约系统.cpp中，当用户登录的是学生，添加学生菜单接口</li>
<li>将不同的分支提供出来<ul>
<li>申请预约</li>
<li>查看我的预约</li>
<li>查看所有预约</li>
<li>取消预约</li>
<li>注销登录</li>
</ul>
</li>
<li>实现注销功能</li>
</ul>
<p>添加全局函数 <code>void studentMenu(Identity * &amp;manager)</code> 代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">studentMenu</span><span class="params">(Identity * &amp;student)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//学生菜单</span></span><br><span class="line">		student-&gt;<span class="built_in">operMenu</span>();</span><br><span class="line"></span><br><span class="line">		Student* stu = (Student*)student;</span><br><span class="line">		<span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (select == <span class="number">1</span>) <span class="comment">//申请预约</span></span><br><span class="line">		&#123;</span><br><span class="line">			stu-&gt;<span class="built_in">applyOrder</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>) <span class="comment">//查看自身预约</span></span><br><span class="line">		&#123;</span><br><span class="line">			stu-&gt;<span class="built_in">showMyOrder</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">3</span>) <span class="comment">//查看所有预约</span></span><br><span class="line">		&#123;</span><br><span class="line">			stu-&gt;<span class="built_in">showAllOrder</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">4</span>) <span class="comment">//取消预约</span></span><br><span class="line">		&#123;</span><br><span class="line">			stu-&gt;<span class="built_in">cancelOrder</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> student;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-1-3-菜单功能实现"><a href="#8-1-3-菜单功能实现" class="headerlink" title="8.1.3 菜单功能实现"></a>8.1.3 菜单功能实现</h4><ul>
<li>在实现成员函数<code>void Student::operMenu()</code> 代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;欢迎学生代表：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          1.申请预约              |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          2.查看我的预约          |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          3.查看所有预约          |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          4.取消预约              |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录              |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-1-4-接口对接"><a href="#8-1-4-接口对接" class="headerlink" title="8.1.4 接口对接"></a>8.1.4 接口对接</h4><ul>
<li>学生成功登录后，调用学生的子菜单界面</li>
<li>在学生登录分支中，添加代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入学生子菜单</span></span><br><span class="line"><span class="built_in">studentMenu</span>(person);</span><br></pre></td></tr></table></figure>

<p>添加效果如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659552298.png" alt="1548659552298"></p>
<p>测试对接，效果如图：</p>
<p>登录验证通过：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659590221.png" alt="1548659590221"></p>
<p>学生子菜单：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659670651.png" alt="1548659670651"></p>
<p>注销登录：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659682402.png" alt="1548659682402"></p>
<h3 id="8-2-申请预约"><a href="#8-2-申请预约" class="headerlink" title="8.2 申请预约"></a>8.2 申请预约</h3><h4 id="8-2-1-获取机房信息"><a href="#8-2-1-获取机房信息" class="headerlink" title="8.2.1 获取机房信息"></a>8.2.1 获取机房信息</h4><ul>
<li>在申请预约时，学生可以看到机房的信息，因此我们需要让学生获取到机房的信息</li>
</ul>
<p>在student.h中添加新的成员函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//机房容器</span></span><br><span class="line">vector&lt;ComputerRoom&gt; vCom;</span><br></pre></td></tr></table></figure>

<p>在学生的有参构造函数中追加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取机房信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(COMPUTER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">ComputerRoom c;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; c.m_ComId &amp;&amp; ifs &gt;&gt; c.m_MaxNum)</span><br><span class="line">&#123;</span><br><span class="line">	vCom.<span class="built_in">push_back</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<p>追加位置如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548661562158.png" alt="1548661562158"></p>
<p>至此，vCom容器中保存了所有机房的信息</p>
<h4 id="8-2-2-预约功能实现"><a href="#8-2-2-预约功能实现" class="headerlink" title="8.2.2 预约功能实现"></a>8.2.2 预约功能实现</h4><p>在student.cpp中实现成员函数 <code>void Student::applyOrder()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::applyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;机房开放时间为周一至周五！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入申请预约的时间：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、周一&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、周二&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3、周三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4、周四&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;5、周五&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span> date = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> interval = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> room = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; date;</span><br><span class="line">		<span class="keyword">if</span> (date &gt;= <span class="number">1</span> &amp;&amp; date &lt;= <span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入申请预约的时间段：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、上午&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、下午&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; interval;</span><br><span class="line">		<span class="keyword">if</span> (interval &gt;= <span class="number">1</span> &amp;&amp; interval &lt;= <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择机房：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">0</span>].m_MaxNum &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">1</span>].m_MaxNum &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">2</span>].m_MaxNum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; room;</span><br><span class="line">		<span class="keyword">if</span> (room &gt;= <span class="number">1</span> &amp;&amp; room &lt;= <span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;预约成功！审核中&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::app)</span></span>;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;date:&quot;</span> &lt;&lt; date &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;interval:&quot;</span> &lt;&lt; interval &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;stuId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;stuName:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;roomId:&quot;</span> &lt;&lt; room &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;status:&quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行程序，测试代码:</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548728936052.png" alt="1548728936052"></p>
<p>在order.txt文件中生成如下内容：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548662281801.png" alt="1548662281801"></p>
<h3 id="8-3-显示预约"><a href="#8-3-显示预约" class="headerlink" title="8.3 显示预约"></a>8.3 显示预约</h3><h4 id="8-3-1-创建预约类"><a href="#8-3-1-创建预约类" class="headerlink" title="8.3.1 创建预约类"></a>8.3.1 创建预约类</h4><p>功能描述：显示预约记录时，需要从文件中获取到所有记录，用来显示，创建预约的类来管理记录以及更新</p>
<p>在头文件以及源文件下分别创建<strong>orderFile.h</strong> 和 <strong>orderFile.cpp</strong>文件</p>
<p>orderFile.h中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;globalFile.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderFile</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">OrderFile</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新预约记录</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录的容器  key --- 记录的条数  value --- 具体记录的键值对信息</span></span><br><span class="line">	map&lt;<span class="keyword">int</span>, map&lt;string, string&gt;&gt; m_orderData;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//预约记录条数</span></span><br><span class="line">	<span class="keyword">int</span> m_Size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>构造函数</strong>中获取所有信息，并存放在容器中，添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">OrderFile::<span class="built_in">OrderFile</span>()</span><br><span class="line">&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(ORDER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">	string date;      <span class="comment">//日期</span></span><br><span class="line">	string interval;  <span class="comment">//时间段</span></span><br><span class="line">	string stuId;     <span class="comment">//学生编号</span></span><br><span class="line">	string stuName;   <span class="comment">//学生姓名</span></span><br><span class="line">	string roomId;    <span class="comment">//机房编号</span></span><br><span class="line">	string status;    <span class="comment">//预约状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>; <span class="comment">//预约记录个数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; date &amp;&amp; ifs &gt;&gt; interval &amp;&amp; ifs &gt;&gt; stuId &amp;&amp; ifs &gt;&gt; stuName &amp;&amp; ifs &gt;&gt; roomId &amp;&amp;  ifs &gt;&gt; status)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//测试代码</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; date &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; interval &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; stuId &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; stuName &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; roomId &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; status &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		string key;</span><br><span class="line">		string value;</span><br><span class="line">		map&lt;string, string&gt; m;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> pos = date.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			key = date.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">			value = date.<span class="built_in">substr</span>(pos + <span class="number">1</span>, date.<span class="built_in">size</span>() - pos <span class="number">-1</span>);</span><br><span class="line">			m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos = interval.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			key = interval.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">			value = interval.<span class="built_in">substr</span>(pos + <span class="number">1</span>, interval.<span class="built_in">size</span>() - pos <span class="number">-1</span> );</span><br><span class="line">			m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos = stuId.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			key = stuId.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">			value = stuId.<span class="built_in">substr</span>(pos + <span class="number">1</span>, stuId.<span class="built_in">size</span>() - pos <span class="number">-1</span> );</span><br><span class="line">			m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos = stuName.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			key = stuName.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">			value = stuName.<span class="built_in">substr</span>(pos + <span class="number">1</span>, stuName.<span class="built_in">size</span>() - pos <span class="number">-1</span>);</span><br><span class="line">			m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos = roomId.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			key = roomId.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">			value = roomId.<span class="built_in">substr</span>(pos + <span class="number">1</span>, roomId.<span class="built_in">size</span>() - pos <span class="number">-1</span> );</span><br><span class="line">			m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos = status.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			key = status.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">			value = status.<span class="built_in">substr</span>(pos + <span class="number">1</span>, status.<span class="built_in">size</span>() - pos <span class="number">-1</span>);</span><br><span class="line">			m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_orderData.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="keyword">this</span>-&gt;m_Size, m));</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//测试代码</span></span><br><span class="line">	<span class="comment">//for (map&lt;int, map&lt;string, string&gt;&gt;::iterator it = m_orderData.begin(); it != m_orderData.end();it++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//	for (map&lt;string, string&gt;::iterator mit = it-&gt;second.begin(); mit != it-&gt;second.end(); mit++)</span></span><br><span class="line">	<span class="comment">//	&#123;</span></span><br><span class="line">	<span class="comment">//		cout &lt;&lt; mit-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; mit-&gt;second &lt;&lt; &quot; &quot;;</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>更新预约记录的成员函数updateOrder代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OrderFile::updateOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::out | ios::trunc)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_Size;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ofs &lt;&lt; <span class="string">&quot;date:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;date&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		ofs &lt;&lt; <span class="string">&quot;interval:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;interval&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		ofs &lt;&lt; <span class="string">&quot;stuId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;stuId&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		ofs &lt;&lt; <span class="string">&quot;stuName:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;stuName&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		ofs &lt;&lt; <span class="string">&quot;roomId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;roomId&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		ofs &lt;&lt; <span class="string">&quot;status:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;status&quot;</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-3-2-显示自身预约"><a href="#8-3-2-显示自身预约" class="headerlink" title="8.3.2 显示自身预约"></a>8.3.2 显示自身预约</h4><p>首先我们先添加几条预约记录，可以用程序添加或者直接修改order.txt文件</p>
<p>order.txt文件内容如下： 比如我们有三名同学分别产生了3条预约记录</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548667534747.png" alt="1548667534747"></p>
<p>在Student类的<code>void Student::showMyOrder()</code>成员函数中，添加如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看我的预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showMyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OrderFile of;</span><br><span class="line">	<span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//string 转 int</span></span><br><span class="line">        <span class="comment">//string 用 .c_str() 转为 const char *</span></span><br><span class="line">        <span class="comment">//利用 atoi (const char *) 转为 int</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">atoi</span>(of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>].<span class="built_in">c_str</span>()) == <span class="keyword">this</span>-&gt;m_Id)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line">			string status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line">			<span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; status &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试效果如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548667252474.png" alt="1548667252474"></p>
<h4 id="8-3-3-显示所有预约"><a href="#8-3-3-显示所有预约" class="headerlink" title="8.3.3 显示所有预约"></a>8.3.3 显示所有预约</h4><p>在Student类的<code>void Student::showAllOrder()</code>成员函数中，添加如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OrderFile of;</span><br><span class="line">	<span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 学号：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuName&quot;</span>];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line">		string status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line">		<span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试效果如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548667591734.png" alt="1548667591734"></p>
<h3 id="8-4-取消预约"><a href="#8-4-取消预约" class="headerlink" title="8.4 取消预约"></a>8.4 取消预约</h3><p>在Student类的<code>void Student::cancelOrder()</code>成员函数中，添加如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::cancelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OrderFile of;</span><br><span class="line">	<span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;审核中或预约成功的记录可以取消，请输入取消的记录&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">atoi</span>(of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>].<span class="built_in">c_str</span>()) == <span class="keyword">this</span>-&gt;m_Id)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span> || of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				v.<span class="built_in">push_back</span>(i);</span><br><span class="line">				cout &lt;&lt;  index ++  &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line">				string status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约  -1 预约失败</span></span><br><span class="line">				<span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; status &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入取消的记录,0代表返回&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line">		<span class="keyword">if</span> (select &gt;= <span class="number">0</span> &amp;&amp; select &lt;= v.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (select == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//	cout &lt;&lt; &quot;记录所在位置： &quot; &lt;&lt; v[select - 1] &lt;&lt; endl;</span></span><br><span class="line">				of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">				of.<span class="built_in">updateOrder</span>();</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;已取消预约&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试取消预约：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669551036.png" alt="1548669551036"></p>
<p>再次查看个人预约记录：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669728023.png" alt="1548669728023"></p>
<p>查看所有预约</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669753496.png" alt="1548669753496"></p>
<p>查看order.txt预约文件</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669798037.png" alt="1548669798037"></p>
<p>至此，学生模块功能全部实现</p>
<h2 id="9、-教师模块"><a href="#9、-教师模块" class="headerlink" title="9、 教师模块"></a>9、 教师模块</h2><h3 id="9-1-教师登录和注销"><a href="#9-1-教师登录和注销" class="headerlink" title="9.1 教师登录和注销"></a>9.1 教师登录和注销</h3><h4 id="9-1-1-构造函数"><a href="#9-1-1-构造函数" class="headerlink" title="9.1.1 构造函数"></a>9.1.1 构造函数</h4><ul>
<li>在Teacher类的构造函数中，初始化教师信息，代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>(<span class="keyword">int</span> empId, string name, string pwd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//初始化属性</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_EmpId = empId;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-1-2-教师子菜单"><a href="#9-1-2-教师子菜单" class="headerlink" title="9.1.2  教师子菜单"></a>9.1.2  教师子菜单</h4><ul>
<li>在机房预约系统.cpp中，当用户登录的是教师，添加教师菜单接口</li>
<li>将不同的分支提供出来<ul>
<li>查看所有预约</li>
<li>审核预约</li>
<li>注销登录</li>
</ul>
</li>
<li>实现注销功能</li>
</ul>
<p>添加全局函数 <code>void TeacherMenu(Person * &amp;manager)</code> 代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//教师菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TeacherMenu</span><span class="params">(Identity * &amp;teacher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//教师菜单</span></span><br><span class="line">		teacher-&gt;<span class="built_in">operMenu</span>();</span><br><span class="line"></span><br><span class="line">		Teacher* tea = (Teacher*)teacher;</span><br><span class="line">		<span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//查看所有预约</span></span><br><span class="line">			tea-&gt;<span class="built_in">showAllOrder</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//审核预约</span></span><br><span class="line">			tea-&gt;<span class="built_in">validOrder</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> teacher;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-1-3-菜单功能实现"><a href="#9-1-3-菜单功能实现" class="headerlink" title="9.1.3 菜单功能实现"></a>9.1.3 菜单功能实现</h4><ul>
<li>在实现成员函数<code>void Teacher::operMenu()</code> 代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//教师菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;欢迎教师：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          1.查看所有预约          |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          2.审核预约              |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录              |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-1-4-接口对接"><a href="#9-1-4-接口对接" class="headerlink" title="9.1.4 接口对接"></a>9.1.4 接口对接</h4><ul>
<li>教师成功登录后，调用教师的子菜单界面</li>
<li>在教师登录分支中，添加代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入教师子菜单</span></span><br><span class="line"><span class="built_in">TeacherMenu</span>(person);</span><br></pre></td></tr></table></figure>

<p>添加效果如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670866708.png" alt="1548670866708"></p>
<p>测试对接，效果如图：</p>
<p>登录验证通过：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670949885.png" alt="1548670949885"></p>
<p>教师子菜单：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670958602.png" alt="1548670958602"></p>
<p>注销登录：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670966988.png" alt="1548670966988"></p>
<h3 id="9-2-查看所有预约"><a href="#9-2-查看所有预约" class="headerlink" title="9.2 查看所有预约"></a>9.2 查看所有预约</h3><h4 id="9-2-1-所有预约功能实现"><a href="#9-2-1-所有预约功能实现" class="headerlink" title="9.2.1 所有预约功能实现"></a>9.2.1 所有预约功能实现</h4><p>该功能与学生身份的查看所有预约功能相似，用于显示所有预约记录</p>
<p>在Teacher.cpp中实现成员函数 <code>void Teacher::showAllOrder()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OrderFile of;</span><br><span class="line">	<span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 学号：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuName&quot;</span>];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line">		string status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line">		<span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-2-2-测试功能"><a href="#9-2-2-测试功能" class="headerlink" title="9.2.2 测试功能"></a>9.2.2 测试功能</h4><p>运行测试教师身份的查看所有预约功能</p>
<p>测试效果如图：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548676922678.png" alt="1548676922678"></p>
<h3 id="9-3-审核预约"><a href="#9-3-审核预约" class="headerlink" title="9.3 审核预约"></a>9.3 审核预约</h3><h4 id="9-3-1-审核功能实现"><a href="#9-3-1-审核功能实现" class="headerlink" title="9.3.1 审核功能实现"></a>9.3.1 审核功能实现</h4><p>功能描述：教师审核学生的预约，依据实际情况审核预约</p>
<p>在Teacher.cpp中实现成员函数 <code>void Teacher::validOrder()</code></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::validOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OrderFile of;</span><br><span class="line">	<span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;待审核的预约记录如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			v.<span class="built_in">push_back</span>(i);</span><br><span class="line">			cout &lt;&lt; ++index &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line">			string status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0取消的预约   1 审核中   2 已预约  -1 预约失败</span></span><br><span class="line">			<span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入审核的预约记录,0代表返回&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line">		<span class="keyword">if</span> (select &gt;= <span class="number">0</span> &amp;&amp; select &lt;= v.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (select == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;请输入审核结果&quot;</span> &lt;&lt; endl;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;1、通过&quot;</span> &lt;&lt; endl;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;2、不通过&quot;</span> &lt;&lt; endl;</span><br><span class="line">				cin &gt;&gt; ret;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				of.<span class="built_in">updateOrder</span>();</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;审核完毕！&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-测试审核预约"><a href="#9-3-2-测试审核预约" class="headerlink" title="9.3.2 测试审核预约"></a>9.3.2 测试审核预约</h4><p>测试 - 审核通过</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677286679.png" alt="1548677286679"></p>
<p>审核通过情况</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677383681.png" alt="1548677383681"></p>
<p>测试-审核未通过</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677402705.png" alt="1548677402705"></p>
<p>审核未通过情况：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677632792.png" alt="1548677632792"></p>
<p>学生身份下查看记录：</p>
<p><img src="/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677798815.png" alt="1548677798815"></p>
<p>审核预约成功！</p>
<p>至此本案例制作完毕！  <code>^_^</code></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>进程和线程</title>
    <url>/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>学自电子科技大学，以下是一些补充内容和参考链接</p>
<p><a href="https://www.runoob.com/w3cnote/c-void-intro.html">C 语言中 void* 详解及应用 | 菜鸟教程 (runoob.com)</a> </p>
<p><a href="https://www.runoob.com/w3cnote/c-general-function.html">https://www.runoob.com/w3cnote/c-general-function.html</a></p>
<p><a href="https://blog.csdn.net/yangbodong22011/article/details/53224856"> void * 是什么？_杨博东的博客的博客-CSDN博客_void*是什么</a> </p>
<p><code>find /usr/include/ -name *.h | xargs grep &#39;MRT6_INIT&#39;</code></p>
<p><a href="https://blog.csdn.net/weibo1230123/article/details/81410241">linux中pthread_join()与pthread_detach()详解_魏波-的博客-CSDN博客_pthread_detach</a>  </p>
<p><a href="https://blog.csdn.net/modi000/article/details/108345917">pthread_join()和pthread_detach()二者的区别_modi000的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/Qiuoooooo/article/details/60573433">IPC之信号量详解_Qiuoooooo的博客-CSDN博客_ipc信号量</a></p>
<p><a href="https://blog.csdn.net/weixin_44522306/article/details/89643615">IPC之信号量_车小猿的博客-CSDN博客_ipc信号量</a></p>
<span id="more"></span>

<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>程序是包含可执行代码以及执行代码需要的数据等信息的文件，存放在磁盘等介质上。</p>
<p>当程序被操作系统装载到内存并分配给它一定资源后，此时可称为进程。</p>
<p>程序是静态概念，进程是动态概念。</p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408151230066.png" alt="image-20220408151230066"></p>
<h3 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h3><p>进程ID、用户ID、进程状态、调度信息、文件管理、虚拟内存管理、信号（进程间通信机制）、时间和定时器、……</p>
<h3 id="task-struct结构"><a href="#task-struct结构" class="headerlink" title="task_struct结构"></a>task_struct结构</h3><p>Linux进程控制块的具体实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;	<span class="comment">// 进程id</span></span><br><span class="line"><span class="keyword">uid_t</span> uid,euid;	<span class="comment">// 用户id 有效用户id</span></span><br><span class="line"><span class="keyword">gid_t</span> gid,egid;	<span class="comment">// 用户组id 有效用户组id</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> state;	<span class="comment">// 进程状态</span></span><br><span class="line"><span class="keyword">int</span> exit_state;			<span class="comment">// 退出状态</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;	<span class="comment">// </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> policy;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">real_parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>,<span class="title">sibling</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span> 	<span class="comment">// 文件描述表 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span>	<span class="comment">// 文件表 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>	<span class="comment">// 内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span></span><br><span class="line"><span class="keyword">cputime_t</span> utime, stime;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start_time</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">real_start_time</span>;</span></span><br></pre></td></tr></table></figure>



<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p><code>volatile long state;</code></p>
<ul>
<li><p>state成员的可能取值如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_ZOMBIE 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STOPPED 8</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>进程状态切换</strong></p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408152319518.png" alt="image-20220408152319518"></p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p><code>struct fs_struct *fs;     // 文件描述表 </code></p>
<p><code>struct files_struct *files;    // 文件表</code> </p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408152511000.png" alt="image-20220408152511000"></p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408153141627.png" alt="image-20220408153141627"></p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p><code>struct mm_struct *mm;    // 内存</code></p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408153548237.png" alt="image-20220408153548237"></p>
<h3 id="进程组织形式"><a href="#进程组织形式" class="headerlink" title="进程组织形式"></a>进程组织形式</h3><p><strong>进程控制块的物理组织结构</strong></p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408153641182.png" alt="image-20220408153641182"></p>
<p><strong>进程控制块的逻辑组织结构</strong></p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408153746262.png" alt="image-20220408153746262"></p>
<p>使用<code>pstree</code>查看当前进程的树形图</p>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408153845177.png" alt="image-20220408153845177" style="zoom: 80%;">



<h2 id="进程属性"><a href="#进程属性" class="headerlink" title="进程属性"></a>进程属性</h2><p>使用<code>ps -aux</code>查看进程及其部分属性</p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408154448602.png" alt="image-20220408154448602"></p>
<h3 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h3><p>头文件<code>/usr/include/unistd.h</code></p>
<p>函数：<code>pid_t getpid( void);</code></p>
<ul>
<li><code>pid_t</code>实际就是<code>int</code>类型</li>
<li>执行成功返回当前进程的ID，失败返回-1（错误原因存储在errorno中）</li>
</ul>
<h3 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h3><p><strong>与进程相关联的用户ID包含以下类型</strong>：</p>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408154918504.png" alt="image-20220408154918504" style="zoom: 50%;">

<p><strong>真实用户与有效用户的关系</strong>：</p>
<ul>
<li>通常情况下，有效用户与真实用户相同（有效用户ID等于真实用户ID ），有效用户组与真实用户组相同（有效用户组ID等于真实用户组ID）</li>
<li>可执行文件的文件属性可以<strong>设置特殊属性域</strong>，定义为“当执行此文件时,将进程的有效用户设置为文件的所有者”，与此类似，组ID也有类似的情况，定义为“当执行此文件时,将进程的有效用户组置为文件所有者所在组”。这两个标志位称为：<strong>设置用户ID位</strong>（setuid）和<strong>设置组ID位</strong>（setgid）</li>
<li><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408155147072.png" alt="image-20220408155147072"></li>
<li><strong>设置用户ID是图中11位，设置组ID位是图中10位</strong></li>
</ul>
<p>示例：<code>passwd</code>命令程序就设置了设置用户ID位</p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408155713660.png" alt="image-20220408155713660"></p>
<p>使用<code>chmod</code>对可执行文件修改设置用户ID位</p>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408160016081.png" alt="image-20220408160016081" style="zoom:80%;">

<hr>
<p><strong>获取真实用户和真实用户组</strong></p>
<p>进程真实用户为执行命令/可执行文件的用户，真实用户组为真实用户所在的组</p>
<p><strong>获取有效用户和有效用户组</strong></p>
<p>进程有效用户和有效用户组只有当可执行文件设置了<code>setuid</code>位或<code>setgid</code>位时才会发生变化</p>
<ul>
<li>真实用户ID：<code>uid_t getuid(void);</code></li>
<li>真实用户组ID：<code>uid_t getgid(void);</code></li>
<li>有效用户ID：<code>uid_t geteuid(void);</code></li>
<li>有效用户组ID：<code>uid_t getegid(void);</code></li>
</ul>
<p>头文件：<code>/usr/include/unistd.h</code></p>
<p>执行成功返回对应ID，失败返回-1（错误原因存储在errorno中）</p>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//suid.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;real uid: %d, real gid:%d\n&quot;</span>,getuid(),getgid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;effective uid: %d, effective gid: %d\n&quot;</span>,geteuid(),getegid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408165715572.png" alt="image-20220408165715572"></p>
<hr>
<p><strong>普通用户能够修改自己的密码的原因</strong>：</p>
<ul>
<li><p><code>/etc/passwd</code>文件用来存储所有用户信息，<code>/etc/shadow</code>用来存储用户密码</p>
</li>
<li><p>所有用户都可以修改自己的密码（修改了<code>/etc/shadow</code>文件），但普通用户对/etc/shadow没有读写权限</p>
</li>
<li><p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408170102390.png" alt="image-20220408170102390"></p>
</li>
<li><p>用户通过执行passwd命令（ <code>/usr/bin/passwd</code>文件）来修改密码；该文件设置了<code>setuid</code>位，在执行此命令时，该进程的有效用户不等于真实用户，而等于文件所有者（root）</p>
</li>
<li><p>Linux根据进程的有效用户进行权限检查，有效用户等于root则允许任何操作（包括对<code>/ect/shadow</code>文件的读写操作）</p>
</li>
<li><p>如果清除掉<code>/usr/bin/passwd</code>文件的<code>setuid</code>权限位，普通用户就不能修改自己的密码了</p>
</li>
</ul>
<h2 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h2><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408151230066.png" alt="image-20220408151230066"></p>
<h3 id="进程状态切换"><a href="#进程状态切换" class="headerlink" title="进程状态切换"></a>进程状态切换</h3><p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408152319518.png" alt="image-20220408152319518"></p>
<h3 id="进程的启动"><a href="#进程的启动" class="headerlink" title="进程的启动"></a>进程的启动</h3><p>C程序的启动函数是<code>main</code>，也是进程代码的入口点</p>
<ul>
<li><code>main ( int argc, char *argv[] );</code></li>
</ul>
<p>当内核启动C程序时，会在调用main函数前调用<strong>特殊的启动函数</strong>来获取<code>main</code>函数地址和传递给<code>main</code>函数的参数，并且将这些信息填写到进程控制块中</p>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>正常终止</p>
<ul>
<li>从<code>main</code>函数中返回</li>
<li>在任意代码中调用<code>exit</code>函数或<code>_exit</code>函数</li>
<li>最后一个线程从其启动例程中返回</li>
<li>最后一个线程调用<code>pthread_exit</code>函数</li>
</ul>
<p>异常终止</p>
<ul>
<li>在任意代码中调用<code>abort</code>函数</li>
<li>接收到终止信号</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408171803255.png" alt="image-20220408171803255"></p>
<h3 id="终止进程函数"><a href="#终止进程函数" class="headerlink" title="终止进程函数"></a>终止进程函数</h3><p>头文件<code>stdlib.h</code>，函数定义：<code>void exit( int status )</code></p>
<p>头文件<code>unistd.h</code>，函数定义：<code>void _exit (int status )</code></p>
<ul>
<li>调用这两个函数均会正常地终止一个进程</li>
<li>调用<code>_exit </code>函数将会立即返回内核</li>
<li>调用<code>exit</code>函数：<ul>
<li>执行预先注册的终止处理函数</li>
<li>执行文件I/O操作的善后工作，使得所有缓冲的输出数据被更新到相应的设备</li>
<li>返回内核</li>
</ul>
</li>
</ul>
<p><strong>exit与return的区别</strong>：</p>
<ul>
<li><code>return</code>是C语言关键字，<code>exit</code>是POSIX API函数</li>
<li>在<code>main</code>函数中，执行<code>return</code>和调用<code>exit</code>函数会产生相同的效果</li>
<li>在子函数中，执行<code>return</code>仅仅从子函数中返回，而调用<code>exit</code>函数将会退出当前进程</li>
</ul>
<h3 id="注册终止处理函数"><a href="#注册终止处理函数" class="headerlink" title="注册终止处理函数"></a>注册终止处理函数</h3><ul>
<li><p>当进程终止时，程序可能需要进行一些自身的清理工作，如日志登记、资源释放等</p>
</li>
<li><p>通过<code>atexit</code>函数或<code>on_exit</code>函数允许进程注册若干终止处理函数，当进程终止时，这些终止处理函数将会被自动调用</p>
</li>
</ul>
<p>头文件<code>stdlib.h</code></p>
<p>函数原型：</p>
<ul>
<li><code>int atexit(void (*func)(void));</code><ul>
<li>成功返回0，不成功非0</li>
</ul>
</li>
<li><code>int on_exit (void (*func)(int, void *), void *arg);</code><ul>
<li><code>func</code>第一个参数是来自最后一个exit()函数调用中的<code>status</code>或 <code>return</code></li>
<li><code>func</code>第二个参数是来自<code>on_exit()</code>函数中的arg</li>
<li>成功返回0，不成功非0</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li><code>ANSI C</code>规定一个进程最多能注册<strong>32</strong>个终止处理函数</li>
<li>当<strong>显示调用</strong>或者<strong>隐含调用</strong><code>exit</code>函数（从<code>main</code>中返回、最后一个线程退出等）终止进程将会回调这些注册的终止处理函数（最先注册的函数最后被回调）</li>
<li><strong>显示调用<code>_exit</code>函数</strong>终止进程时将不会回调这些注册的终止函数</li>
</ul>
<p><strong>示例：<code>atexit</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//atexit_text.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func1 is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func2 is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func3 is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	atexit(func1);</span><br><span class="line">	atexit(func2);</span><br><span class="line">	atexit(func3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;process exit\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408175512633.png" alt="image-20220408175512633" style="zoom:80%;">

<p><strong>示例：<code>on_exit</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//on_exit_text.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j ,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func1 exit status is %d\n&quot;</span>, status);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func1 arg is %d\n&quot;</span>, *((<span class="keyword">int</span>*)arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func2 exit status is %d\n&quot;</span>, status);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func2 arg is %d\n&quot;</span>, *((<span class="keyword">int</span>*)arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func3 exit status is %d\n&quot;</span>, status);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func3 arg is %d\n&quot;</span>, *((<span class="keyword">int</span>*)arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> *argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i = <span class="number">3</span>;</span><br><span class="line">	on_exit(func1, (<span class="keyword">void</span>*)&amp;i);</span><br><span class="line">	j = <span class="number">4</span>;</span><br><span class="line">	on_exit(func2, (<span class="keyword">void</span>*)&amp;j);</span><br><span class="line">	k = <span class="number">5</span>;</span><br><span class="line">	on_exit(func3, (<span class="keyword">void</span>*)&amp;k);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 改成1的话，下面输出的 status值就为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408191339232.png" alt="image-20220408191339232"></p>
<h2 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>1、内核空间  2、内存空间</p>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408210223114.png" alt="image-20220408210223114" style="zoom:80%;">



<h3 id="用户空间布局"><a href="#用户空间布局" class="headerlink" title="用户空间布局"></a>用户空间布局</h3><p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408210750881.png" alt="image-20220408210750881"></p>
<ul>
<li>正文：CPU执行的代码部分，正文段通常是共享、只读的</li>
<li>初始化的数据：包含了程序中需明确赋初值的变量，如全局变量<code>int maxcount=99;</code></li>
<li>未初始化的数据：程序执行之前，将此段中的数据初始化为0，如全局变量<code>long sum[1000];</code></li>
<li>堆：用于动态分配内存</li>
<li>栈：主要用于支撑函数调用存放参数、局部变量等</li>
<li>命令行参数</li>
<li>环境变量</li>
</ul>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><ul>
<li><strong>命令行参数</strong>：命令后面的字符都是参数<ul>
<li><code>ls [参数] &lt;路径或文件名&gt;</code> ，<code>ls -l /home</code></li>
<li><code>mkdir [参数] &lt;目录名&gt;</code>， <code>mkdir -p /home/xiaokun/src</code></li>
<li><code>cp [参数] &lt;源文件路径&gt; &lt;目标文件路径&gt;</code>， <code>cp -r /usr/local/src /root</code></li>
</ul>
</li>
</ul>
<p><strong>C程序中main函数参数</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//myecho.C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Argument %d is %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408212001229.png" alt="image-20220408212001229"></p>
<p><font color="#ff0000">注意：</font>命令名也传入<code>main</code>中，占 0 位</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p><strong>环境变量表</strong></p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408212220015.png" alt="image-20220408212220015"></p>
<ul>
<li>每个进程都会有自己的环境变量表 </li>
<li>通过全局的环境指针 （environ）可以直接访问环境变量表（字符串数组）<ul>
<li>头文件<code>unistd.h</code> </li>
<li><code>extern char **environ;</code></li>
</ul>
</li>
<li>环境变量字符串形式为 <code>name=value</code><ul>
<li><code>name</code>是环境变量名称</li>
<li><code>value</code>为环境变量赋值</li>
</ul>
</li>
</ul>
<p><strong>获取环境变量</strong></p>
<p>获取环境变量的方法</p>
<ul>
<li>直接通过<code>environ</code>变量访问环境表</li>
<li>使用<code>getenv</code>函数</li>
</ul>
<p><code>getenv</code>函数用于获取环境变量值</p>
<ul>
<li>头文件：<code>stdlib.h</code></li>
<li>函数原型：<code>char* getenv(const char *name);</code></li>
<li>指定环境变量名称，返回环境变量字符串指针，若未找到则返回空指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *path = getenv(<span class="string">&quot;PATH&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220408213845594.png" alt="image-20220408213845594"></p>
<p><strong>设置环境变量</strong></p>
<p>设置环境变量的三种方法</p>
<ul>
<li><code>putenv</code></li>
<li><code>setenv</code></li>
<li><code>unsetenv</code></li>
</ul>
<p><code>putenv</code>函数将环境变量字符串放入环境变量表中；若该字符串已经存在，则覆盖</p>
<ul>
<li>头文件：<code>stdlib.h</code></li>
<li>函数原型：<code>int putenv(char *str);</code></li>
</ul>
<p><code>setenv</code></p>
<ul>
<li>头文件：<code>stdlib.h</code></li>
<li>函数原型：<code>int setenv(const char* name, const char* value, int rewrite);</code></li>
<li><code>setenv</code>将指定环境变量的值设置为参数指定值（更改环境变量字符串）</li>
<li>若<code>name</code>已经存在<ul>
<li><code>rewrite</code>不等于0，则删除其原先的定义</li>
<li><code>rewrite</code>等于0，则不删除其原先的定义</li>
</ul>
</li>
</ul>
<p><code>unsetenv</code></p>
<ul>
<li>头文件：<code>stdlib.h</code></li>
<li>函数原型：<code>int unsetenv(const char* name);</code></li>
<li>删除指定的环境变量字符串</li>
</ul>
<h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><h3 id="Linux进程"><a href="#Linux进程" class="headerlink" title="Linux进程"></a>Linux进程</h3><p><strong>Linux中创建进程的方式：</strong></p>
<ul>
<li>在<code>shell</code>中执行命令或可执行文件<ul>
<li>由shell进程调用<code>fork</code>函数创建子进程</li>
</ul>
</li>
<li>在代码中（已经存在的进程中）调用<code>fork </code>函数创建子进程<ul>
<li>通过<code>fork</code>函数创建的进程为已经存在进程的子进程</li>
</ul>
</li>
</ul>
<hr>
<p>Linux系统中进程0（PID=0）是由内核创建，其他所有进程都是由父进程调用<code>fork</code>函数所创建的</p>
<p>Linux系统中进程0在创建子进程（PID=1，<code>init</code>进程）后，进程0就转为交换进程或空闲进程</p>
<p>进程1（init进程）是系统中其他所有进程的共同祖先</p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409105538106.png" alt="image-20220409105538106" style="zoom: 67%;"><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409105638271.png" alt="image-20220409105638271"></p>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409105638271.png" alt="image-20220409105538106" style="zoom: 67%;">



<hr>
<h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a><code>fork</code>函数</h3><p>头文件：<code>unistd.h</code><br>函数原型：<code>pid_t fork(void);</code></p>
<p>返回值：</p>
<ul>
<li><p><code>fork</code>函数被正确调用后，将会在子进程中和父进程中分别返回！！</p>
</li>
<li><p>在子进程中返回值为0（不合法的PID，提示当前运行在子进程中）</p>
</li>
<li><p>在父进程中返回值为子进程ID（让父进程掌握所创建子进程的ID号）</p>
</li>
<li><p>出错返回<code>-1</code></p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;the returned value is %d\n&quot;</span>, pid);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;in child process!!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;My PID is %d\n&quot;</span>, getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;the returned value is %d\n&quot;</span>, pid);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;in father process!!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;My PID is %d\n&quot;</span>, getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409110646792.png" alt="image-20220409110646792" style="zoom: 80%;">



<h3 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h3><p><strong>fork函数工作流程</strong></p>
<ul>
<li>子进程是父进程的副本<ul>
<li>子进程复制/拷贝父进程的PCB、数据空间（数据段、堆和栈）</li>
<li>父子进程共享正文段（只读）</li>
</ul>
</li>
<li>子进程和父进程继续执行<code>fork</code>函数调用之后的代码</li>
<li>为了提高效率，<code>fork</code>后不并立即复制父进程数据段、堆和栈，采用了<strong>写时复制机制（Copy-On-Write）</strong><ul>
<li>当父子进程任意之一要修改数据段、堆、栈时，进行复制操作，并且仅复制修改区域</li>
</ul>
</li>
</ul>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409111016348.png" alt="image-20220409111016348" style="zoom:67%;">



<p><strong>父子进程异同</strong></p>
<p>相同：</p>
<ul>
<li>真实用户ID，真实组ID</li>
<li>有效用户ID，有效组ID</li>
<li>环境变量</li>
<li>堆</li>
<li>栈</li>
<li>打开的文件</li>
</ul>
<p>不同：</p>
<ul>
<li><code>fork</code>的返回值</li>
<li>进程ID及父进程ID</li>
<li>子进程的 <code>tms_utime</code>, <code>tms_stime</code>,<code>tms_cutime</code>,<code>tms_ustime</code>值被设置为 0</li>
</ul>
<p><strong>父子进程共享文件</strong></p>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409111207007.png" alt="image-20220409111207007" style="zoom:67%;">

<p>父子进程对共享文件的常见处理方式：</p>
<ul>
<li>父进程等待子进程完成。当子进程终止后，文件当前位置已经得到了相应的更新</li>
<li>父子进程各自执行不同的程序段，各自关闭不需要的文件</li>
</ul>
<h3 id="fork用法"><a href="#fork用法" class="headerlink" title="fork用法"></a>fork用法</h3><ul>
<li>父进程希望复制自己（共享代码，复制数据空间），但父子进程<strong>执行相同代码中的不同分支</strong><ul>
<li>网络服务程序中，父进程等待客户端的服务请求，当请求达到时，父进程调用fork创建子进程处理该请求，而父进程继续等待下一个服务请求到达</li>
</ul>
</li>
<li>父子进程<strong>执行不同的可执行文件</strong>（父子进程具有完全不同的代码段和数据空间）<ul>
<li>子进程从<code>fork</code>返回后，立即调用<code>exec</code>类函数执行另外一个可执行文件</li>
</ul>
</li>
</ul>
<h3 id="vfork函数"><a href="#vfork函数" class="headerlink" title="vfork函数"></a>vfork函数</h3><ul>
<li><code>vfork</code>用于创建新进程，而该新进程的目的是执行另外一个可执行文件</li>
<li>由于新程序将有自己的地址空间，因此<code>vfork</code>函数并不将父进程的地址空间完全复制到子进程中</li>
<li>子进程在调用<code>exec</code>或<code>exit</code>之前，在父进程的地址空间中运行</li>
<li><code>vfork</code>函数保证子进程先执行，在它调用<code>exec</code>或者<code>exit</code>之后，父进程才会继续被调度执行（父进程处于<code>TASK_UNINTERRUPTIBLE</code>状态）</li>
</ul>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409111815455.png" alt="image-20220409111815455"></p>
<h2 id="子进程状态"><a href="#子进程状态" class="headerlink" title="子进程状态"></a>子进程状态</h2><p><strong>获知子进程状态信息改变</strong>：</p>
<p>当一个进程发生特定的状态变化（进程终止、暂停以及恢复）时，内核向其父进程发送<code>SIGCHLD</code>信号</p>
<p>父进程可以选择忽略该信号，也可以对信号进行处理（默认处理方式为忽略该信号）</p>
<p><strong><code>wait</code>或<code>waitpid</code>函数</strong>可以用于等待子进程状态信息改变，并获取其状态信息</p>
<p><strong>僵尸进程</strong></p>
<p>进程在退出之前会释放进程用户空间的所有资源，但PCB等内核空间资源不会被释放</p>
<ul>
<li>当父进程调用<code>wait</code>或<code>waitpid</code>函数后，内核将根据情况关闭该进程打开的所有文件，释放PCB（释放内核空间资源）</li>
<li>对于已经终止但父进程尚未对其调用<code>wait</code>或<code>waitpid</code>函数的进程（<code>TASK_ZOMBIE</code>状态），称为<strong>僵尸进程</strong></li>
</ul>
<p>如果父进程在子进程终止之前终止，则子进程的父进程将变为<code>init</code>进程，保证每个进程都有父进程，由<code>init</code>进程调用<code>wait</code>函数进行善后</p>
<p><strong>wait函数</strong></p>
<p>功能：获取任意子进程的状态改变信息（如果是终止状态则对子进程进行善后处理）</p>
<p>头文件：<code>sys/wait.h</code></p>
<p>函数原型：<code>pid_t wait(int *statloc);</code></p>
<ul>
<li><code>statloc</code>：用于获取子进程的状态改变</li>
<li><code>statloc</code>可以为空指针，此时父进程不需要具体了解子进程的状态变化，只是为了防止子进程成为僵尸进程，或者因为同步原因需等待子进程终止</li>
<li>若<code>statloc</code>不是空指针，则内核将子进程状态改变信息存放在它指向的存储空间中</li>
</ul>
<p>返回值：若成功返回状态信息改变子进程ID，出错返回-1</p>
<hr>
<p>子进程状态改变信息包含了多种类型的信息，可以通过系统提供的宏来快速解析子进程的状态</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>WIFEXITED(statloc)</code></td>
<td>当子进程正常终止时该宏为真，对于这种情况可进一步执行<code>WEXITSTATUS(statloc)</code>，获取子进程传递给<code>exit</code>、<code>_exit</code>函数参数的低8位</td>
</tr>
<tr>
<td><code>WIFSIGNALED(statloc)</code></td>
<td>当子进程异常终止时该宏为真，对于这种情况可进一步执行<code>WTERMSTG(statloc)</code>，获取使子进程终止的信号编号</td>
</tr>
<tr>
<td><code>WIFSTOPPED(statloc)</code></td>
<td>当子进程暂停时该宏为真，对于这种情况可进一步执行<code>WSTOPSIG(statloc)</code>，获取使子进程暂停的信号编号</td>
</tr>
<tr>
<td><code>WIFCONTINUED(statloc)</code></td>
<td>若子进程在暂停后已经继续则该宏为真</td>
</tr>
</tbody></table>
<hr>
<p>调用<code>wait</code>函数之后，父进程可能出现的情况：</p>
<ul>
<li>如果所有子进程都还在运行，则父进程被阻塞（<code>TASK_INTERRUPTIBLE</code>状态），直到有一个子进程终止或暂停，<code>wait</code>函数才返回</li>
<li>如果已经有子进程进入终止或暂停状态，则<code>wait</code>函数会立即返回</li>
<li>若进程没有任何子进程，则立即出错返回<code>-1</code></li>
</ul>
<p><strong>等待特定子进程状态改变</strong>：</p>
<p>如果一个进程有几个子进程，那么只要有一个子进程状态改变，wait函数就返回</p>
<p>如何才能使用wait函数等待某个特定子进程的状态改变？</p>
<ul>
<li>调用<code>wait</code>，然后将其返回的进程ID和所期望的子进程ID进行比较。如果ID不一致，则保存该ID，并循环调用<code>wait</code>函数，直到等到所期望的子进程ID为止</li>
<li>使用<code>waitpid</code></li>
</ul>
<p><strong>waitpid函数</strong></p>
<p>功能：等待某个特定子进程状态改变</p>
<p>头文件：<code>sys/wait.h</code></p>
<p>头文件：<code>pid_t waitpid(pid_t pid, int *statloc, int options);</code></p>
<p>返回值：成功返回终止子进程ID，失败返回-1</p>
<p>参数：</p>
<ul>
<li><code>pid</code></li>
<li><code>pid == -1</code>：等待任意子进程执行终止（同wait）</li>
<li><code>pid &gt; 0</code>：等待进程ID为pid的子进程执行终止</li>
<li><code>pid == 0</code>：等待其组ID等于调用进程组ID的任意子进程</li>
<li><code>pid &lt; -1</code>：等待其组ID等于pid绝对值的任意子进程</li>
<li><code>statloc</code>：存放子进程终止状态</li>
<li><code>options</code>：可以为0，也可以是以下常量或常量的或</li>
<li><code>WCONTINUED</code>：如果有暂停的进程由于<code>SIGCONT</code>信号的到来而继续运行，则函数将返回</li>
<li><code>WUNTRACED</code>：如果有处于终止状态的进程，则函数返回</li>
<li><code>WNOHANG</code>：如果没有任何已经终止的子进程则马上返回,，函数不等待，此时返回值为0</li>
</ul>
<p><strong>waitpid的特有功能</strong>：</p>
<ul>
<li><code>waitpid</code>可等待一个特定的进程的状态改变信息</li>
<li><code>waitpid</code>可以实现非阻塞（异步）的等待操作，有时希望取得子进程的状态改变信息，但不希望阻塞等待子进程状态改变</li>
<li><code>waitpid</code>支持作业控制（进程组控制）</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid_child, pid_return;</span><br><span class="line">    pid_child = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid_child &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occuredon forking.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid_child == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        pid_return = waitpid(pid_child, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span> (pid_return == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No child exited\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pid_return == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid_return == pid_child)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;successfullyget child %d\n&quot;</span>, pid_return);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;some error occured\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220412122856363.png" alt="image-20220412122856363"></p>
<h2 id="子进程运行可执行文件"><a href="#子进程运行可执行文件" class="headerlink" title="子进程运行可执行文件"></a>子进程运行可执行文件</h2><p>进程调用<strong>exec系列函数</strong>在进程中加载执行另外一个可执行文件</p>
<p>exec系列函数替换了当前进程（执行该函数的进程）的<strong>正文段、数据段、堆和栈</strong>（来源于加载的可执行文件）</p>
<p>执行exec系列函数后从加载可执行文件的main函数开始重新执行</p>
<p>exec系列函数并不创建新进程，所以在调用exec系列函数后其进程ID并未改变，已经打开的文件描述符不变</p>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409121804687.png" alt="image-20220409121804687" style="zoom:80%;">



<h3 id="exec系列函数"><a href="#exec系列函数" class="headerlink" title="exec系列函数"></a>exec系列函数</h3><ul>
<li><code>execl execle execlp execv execve execvp</code> 共6个函数</li>
<li><code>l</code>：表示list，每个命令行参数都说明为一个单独的参数</li>
<li><code>v</code>：表示vector，命令行参数放在数组中</li>
<li><code>e</code>：表示由函数调用者提供环境变量表</li>
<li><code>p</code>：表示通过环境变量PATH来指定路径，查找可执行文件</li>
</ul>
<h3 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a>execl函数</h3><p>头文件：<code>unistd.h</code></p>
<p>函数原型：<code>int execl(const char *pathname, const char *arg0, ...,NULL</code></p>
<p>参数：</p>
<ul>
<li><code>pathname</code>：要执行程序的绝对路径名</li>
<li>可变参数：要执行程序的命令行参数，以空指针<code>NULL</code>结束</li>
</ul>
<p>返回值：</p>
<ul>
<li>出错返回-1</li>
<li>成功该函数不返回！</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;entering main process--\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>); </span><br><span class="line">        <span class="comment">//若execl执行成功，execl后面的代码不会执行，而是运行新的可执行文件的代码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exiting main process --\n&quot;</span>); <span class="comment">//这句代码不会执行</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="execv函数"><a href="#execv函数" class="headerlink" title="execv函数"></a>execv函数</h3><p>头文件：<code>unistd.h</code></p>
<p>函数原型：<code>int execv(const char *pathname, char *const argv[]);</code></p>
<p>参数：</p>
<ul>
<li><code>pathname</code>：要执行程序的绝对路径名</li>
<li><code>argv</code>：数组指针维护的程序命令行参数列表，该数组的最后一个成员必须为空指针</li>
</ul>
<p>返回值</p>
<ul>
<li>出错返回-1</li>
<li>成功该函数不返回</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;entering main process --\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = execv(<span class="string">&quot;/bin/ls&quot;</span>, argv);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;execv error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exiting main process --\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="execle函数"><a href="#execle函数" class="headerlink" title="execle函数"></a>execle函数</h3><p>头文件：<code>unistd.h</code><br>函数原型：<code>int execle(const char *pathname, const char *arg0,... NULL, char *const envp[]);</code></p>
<p>参数：</p>
<ul>
<li><code>pathname</code>：要执行程序的绝对路径名</li>
<li>可变参数：要执行程序的命令行参数，以空指针结束</li>
<li><code>envp</code>指向环境字符串指针数组的指针，该数组的最后一个成员必须为空指针</li>
</ul>
<p>返回值：出错返回-1，成功该函数不返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *envp[] = &#123;<span class="string">&quot;PATH=/tmp&quot;</span>, <span class="string">&quot;USER=yang&quot;</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(execle(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>, envp) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;execle error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="execve函数"><a href="#execve函数" class="headerlink" title="execve函数"></a>execve函数</h3><p><code>int execve(const char *pathname,char *const argv[], char *const envp[]);</code></p>
<h3 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h3><p><code>int execlp(const char *filename,const char *arg0, ...,NULL);</code></p>
<ul>
<li><code>filename</code>参数可以是相对路径（路径信息从环境变量PATH中获取）</li>
<li>例如默认环境变量中包含的<code>PATH=/bin:/usr/bin:/usr/local/bin/</code></li>
</ul>
<h3 id="execvp函数"><a href="#execvp函数" class="headerlink" title="execvp函数"></a>execvp函数</h3><p><code>int execvp(const char *filename,char *const argv[]);</code></p>
<h3 id="exec函数的关系"><a href="#exec函数的关系" class="headerlink" title="exec函数的关系"></a>exec函数的关系</h3><p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409141437071.png" alt="image-20220409141437071"></p>
<h2 id="Linux线程"><a href="#Linux线程" class="headerlink" title="Linux线程"></a>Linux线程</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>进程</strong>的概念体现出两个特点：<strong>资源</strong>（代码和数据空间、打开的文件等）以及<strong>调度/执行</strong>。</p>
<p><strong>线程</strong>是进程内的独立执行代码的实体和<strong>调度</strong>单元</p>
<p>一个<strong>进程内的所有线程共享进程的很多资源</strong>（这种共享又带来了同步问题）</p>
<p><strong>线程间共享</strong></p>
<ul>
<li>进程指令 </li>
<li>全局变量 </li>
<li>打开的文件 </li>
<li>信号处理程序 </li>
<li>当前工作目录 </li>
<li>用户ID和组ID</li>
</ul>
<p><strong>线程私有</strong></p>
<ul>
<li>线程ID</li>
<li>寄存器集合（包括PC和栈指针）</li>
<li>栈（用于存放局部变量）</li>
<li>信号掩码</li>
<li>优先级</li>
</ul>
<h3 id="线程与进程对比"><a href="#线程与进程对比" class="headerlink" title="线程与进程对比"></a>线程与进程对比</h3><p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409142558448.png" alt="image-20220409142558448"></p>
<ul>
<li>线程只拥有少量在运行中必不可少的资源<ul>
<li>PC指针：标识当前线程执行的位置</li>
<li>寄存器：当前线程执行的上下文环境</li>
<li>栈：用于实现函数调用、局部变量（局部变量是私有的）</li>
</ul>
</li>
<li>进程占用资源多，线程占用资源少，使用灵活</li>
<li>线程不能脱离进程而存在，线程的层次关系，执行顺序并不明显，会增加程序的复杂度</li>
<li>没有通过代码显示创建线程的进程，可以看成是只有一个线程的进程</li>
</ul>
<p><strong>操作对比</strong></p>
<table>
<thead>
<tr>
<th>控制操作</th>
<th>进程操作API</th>
<th>线程操作API</th>
</tr>
</thead>
<tbody><tr>
<td>创建</td>
<td><code>fork</code>,<code>vfork</code></td>
<td><code>pthread_create</code></td>
</tr>
<tr>
<td>终止</td>
<td><code>exit</code></td>
<td><code>pthread_exit</code></td>
</tr>
<tr>
<td>等待</td>
<td><code>wait</code>、<code>waitpid</code></td>
<td><code>pthread_join</code></td>
</tr>
<tr>
<td>读取ID</td>
<td><code>getpid</code></td>
<td><code>pthread_self</code></td>
</tr>
</tbody></table>
<h3 id="线程ID"><a href="#线程ID" class="headerlink" title="线程ID"></a>线程ID</h3><p>同进程一样，每个线程也有一个线程ID</p>
<p>进程ID在整个系统中是唯一的，<strong>线程ID只在它所属的进程环境中唯一</strong></p>
<p>线程ID的类型是<code>pthread_t</code>，在Linux中的定义：<code>/usr/include/bits/pthreadtypes.h</code>（实际位置可能有变化）</p>
<ul>
<li><code>typedef unsigned long int pthread_t</code></li>
</ul>
<p><strong>获取线程ID</strong></p>
<p><code>pthread_self</code>函数可以让调用线程获取自己的线程ID</p>
<p>头文件：<code>pthread.h</code></p>
<p>函数原型：<code>pthread_t pthread_self();</code></p>
<p>返回值：调用线程的线程ID</p>
<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p><code>pthread_create</code>函数用于创建一个线程</p>
<p>头文件：<code>pthread.h</code></p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">void</span> *(*start_rtn)(<span class="keyword">void</span> *), </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用<code>pthread_create</code>函数的线程是所创建线程的父线程</p>
<p>参数：</p>
<ul>
<li><code>thread</code>：指向线程ID的指针，当函数成功返回时将存储所创建的子线程ID</li>
<li><code>attr</code>：用于指定线程属性（一般直接传入空指针NULL，采用默认线程属性）</li>
<li><code>start_rtn</code>：线程的<strong>启动例程函数</strong>（类似进程的main函数入口）指针，创建的线程首先执行该函数代码（可以调用其他函数）</li>
<li><code>arg</code>：向线程的启动例程函数传递信息的参数</li>
</ul>
<p>返回值：成功返回0，出错时返回各种错误码</p>
<h3 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h3><p>线程创建后等待系统调度，被调度后从线程启动例程函数</p>
<p>一次性创建多个线程，调度顺序与创建顺序无关</p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220412170357636.png" alt="image-20220412170357636"></p>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p>线程的三种终止方式</p>
<ul>
<li>线程从启动例程函数中返回，函数返回值作为线程的退出码</li>
<li>线程被同一进程中的其他线程取消</li>
<li>线程在任意函数中调用<code>pthread_exit</code>函数终止执行</li>
</ul>
<h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a><code>pthread_exit</code></h3><p>头文件：<code>pthread.h</code></p>
<p>函数原型：<code>void pthread_exit(void *rval_ptr);</code></p>
<p>参数：<code>rval_ptr</code> 该指针将参数传递给<code>pthread_join</code>函数（与<code>exit</code>函数参数用法类似）</p>
<h3 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a><code>pthread_cancel</code></h3><p>线程调用该函数可以取消同一进程中的其他线程（即让该线程终止）</p>
<p>头文件： <code>pthread.h</code></p>
<p>函数原型：<code>int pthread_cancel(pthread_t tid);</code></p>
<p>参数：<code>tid</code> 需要取消的线程ID</p>
<p>返回值：成功返回0，出错返回错误编号</p>
<p>注：</p>
<ul>
<li>在默认情况下，<code>pthread_cancel</code>函数与被取消线程（ID等于tid的线程）自身调用<code>pthread_exit</code>函数（参数为<code>PTHREAD_CANCELED</code>）效果等同</li>
<li>线程可以选择忽略取消方式或者控制取消方式</li>
<li><code>pthread_cancel</code>并不等待线程终止，它仅仅是提出请求</li>
</ul>
<h3 id="phread-join"><a href="#phread-join" class="headerlink" title="phread_join"></a><code>phread_join</code></h3><p>头文件：<code>pthread.h</code></p>
<p>函数原型：<code>int pthread_join(pthread_t thread,void **rval_ptr);</code></p>
<p>调用该函数的父线程将一直被阻塞，直到指定的子线程终止</p>
<p>返回值：成功返回0，否则返回错误编号</p>
<p>参数：</p>
<ul>
<li><code>thread</code>：需要等待的子线程ID</li>
<li><code>rval_ptr</code>：线程返回值<ul>
<li>若线程从启动例程返回，<code>rval_ptr</code>将包含返回码</li>
<li>若线程被取消，<code>rval_ptr</code>指向的内存单元值置为<code>PTHREAD_CANCELED</code></li>
<li>若线程通过调用<code>pthread_exit</code>函数终止，<code>rval_ptr</code>就是调用<code>pthread_exit</code>时传入的参数</li>
<li>若不关心线程返回值，可直接将该参数设置为空指针NULL</li>
</ul>
</li>
</ul>
<h3 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a><code>pthread_detach</code></h3><p>头文件：<code>pthread.h</code></p>
<p>函数原型：<code>int pthread_detach(pthread_t thread);</code></p>
<p>特点：</p>
<ul>
<li>使用pthread_detach函数后，使线程处于分离态；</li>
<li>使用pthread_detach函数后，线程在退出后，会自己清理资源</li>
<li>相较pthread_join,使用pthread_detach函数不会阻塞主线程，但是无法获取线程的返回值。</li>
<li><strong>pthread_detach使用时，依然需要配合sleep函数或者while(1);，否则无法保证子线程先于主线程执行完。</strong></li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc thread_test.c -o thread_test -lpthread </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">childthread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;childthread message\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create childthread\n&quot;</span>);</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, (<span class="keyword">void</span>*)childthread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;childthread exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409151806118.png" alt="image-20220409151806118"></p>
<p><a href="https://blog.csdn.net/llqkk/article/details/2854558"> undefined reference to ‘pthread_create’问题解决_李刘强博客的博客-CSDN博客_pthread_create undefined</a></p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="任务关系"><a href="#任务关系" class="headerlink" title="任务关系"></a>任务关系</h3><p>Linux系统中多任务（进程/线程）之间的关系</p>
<ul>
<li><strong>独立</strong>：仅竞争CPU资源</li>
<li><strong>互斥</strong>：竞争除CPU外的其他资源</li>
<li><strong>同步</strong>：协调彼此运行的步调，保证协同运行的各个任务具有正确的执行次序</li>
<li><strong>通信</strong>：数据共享，彼此间传递数据或信息，以协同完成某项工作</li>
</ul>
<h3 id="线程数据共享"><a href="#线程数据共享" class="headerlink" title="线程数据共享"></a>线程数据共享</h3><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409153932168.png" alt="image-20220409153932168" style="zoom:67%;">



<h3 id="任务互斥问题"><a href="#任务互斥问题" class="headerlink" title="任务互斥问题"></a>任务互斥问题</h3><p><strong>任务互斥—资源共享关系（间接相互制约关系）</strong></p>
<ul>
<li>任务本身之间不存在直接联系。一个任务正在使用某个系统资源，另外一个想用该资源的任务就必须等待，而不能同时使用</li>
</ul>
<p>全局变量存储在进程数据段中，被线程所共享。线程对全局变量的访问，要经历三个步骤</p>
<ol>
<li><p>将内存单元中的数据读入寄存器</p>
</li>
<li><p>对寄存器中的值进行运算</p>
</li>
<li><p>将寄存器中的值写回内存单元</p>
</li>
</ol>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409154622468.png" alt="image-20220409154622468" style="zoom:67%;">

<p>解决方法：互斥量</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p><strong>临界资源</strong>：在一段时间内只允许一个任务（线程或进程）访问的资源。诸任务间应采取互斥方式，实<br>现对资源的共享</p>
<ul>
<li>共享变量，打印机等属于临界资源</li>
<li>访问临界资源的那段代码被称为<strong>临界区</strong></li>
</ul>
<p><strong>互斥量</strong>确保同一时间里只有一个线程访问临界资源或进入临界区</p>
<p><strong>互斥量（mutex）</strong>本质上是一把锁</p>
<ul>
<li>在访问临界资源前，对互斥量进行加锁</li>
<li>在访问完成后对互斥量解锁</li>
<li>对互斥量加锁后，任何其他试图对互斥量加锁的线程将会被阻塞，直到互斥量被解锁为止</li>
</ul>
<p><strong>互斥量的操作</strong>：</p>
<ol>
<li>定义互斥量变量（ <code>pthread_mutex_t mutex;</code>）</li>
<li>调用<code>pthread_mutex_init</code>初始化互斥量变量</li>
<li>访问临界资源前，调用<code>pthread_mutex_lock</code>或者<code>pthread_mutex_trylock</code>对互斥量进行加锁操作</li>
<li>访问临界资源后，调用<code>pthread_mutex_unlock</code>对互斥量解锁</li>
<li>调用<code>pthread_mutex_destroy</code>销毁互斥量变量</li>
</ol>
<p><strong>初始化互斥量</strong></p>
<p>头文件：<code>pthread.h</code></p>
<p>静态初始化</p>
<ul>
<li><code>pthread_mutex_t mlock = PTHREAD_MUTEX_INITIALIZER;</code></li>
</ul>
<p>动态初始化</p>
<ul>
<li><code>int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *attr);</code></li>
<li>参数<ul>
<li><code>mutex</code>：指向互斥量的指针</li>
<li><code>attr</code>：设置互斥量的属性，通常可采用默认属性，传入空指针（<code>NULL</code>）。</li>
</ul>
</li>
<li>成功返回0，出错返回错误码</li>
</ul>
<p><strong>销毁互斥量</strong>：</p>
<p>互斥量在使用完毕后，必须要对互斥量进行销毁，以释放资源</p>
<p>头文件：<code>pthread.h</code></p>
<p>函数原型：<code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p>
<ul>
<li><code>mutex</code>：即互斥量</li>
<li>成功返回0，出错返回错误码</li>
</ul>
<p><strong>互斥量的加锁和解锁</strong>：</p>
<p>在对临界资源访问之前和访问之后，需要对互斥量进行加锁和解锁操作</p>
<p>头文件：<code>pthread.h</code></p>
<p>函数原型：</p>
<ul>
<li>加锁：<code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code> </li>
<li>解锁：<code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></li>
<li>成功返回0，出错返回错误码</li>
</ul>
<p>当调用<code>pthread_mutex_lock</code>时，若互斥量已被加锁，则调用线程将被<strong>阻塞</strong>直到可以完成加锁操作为止。</p>
<p><strong>互斥量非阻塞加锁</strong></p>
<p>头文件： <code>pthread.h</code></p>
<p>函数原型：<code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></p>
<ul>
<li>调用该函数时，若互斥量未加锁，则对该互斥量加锁，返回0；</li>
<li>若互斥量已加锁，则函数直接返回错误码EBUSY（不会阻塞调用线程）</li>
</ul>
<h3 id="任务同步问题"><a href="#任务同步问题" class="headerlink" title="任务同步问题"></a>任务同步问题</h3><p><strong>任务同步—相互合作关系（直接相互制约关系）</strong></p>
<ul>
<li>两个或多个任务为了合作完成同一个工作，在执行速度或某个确定的时序点上必须相互协调，即一个任务的执行必须依赖另一个任务的执行情况</li>
</ul>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409160816138.png" alt="image-20220409160816138" style="zoom:50%;">

<p>程序设计中存在这样的情况：多个线程都要访问临界资源又要相互合作（线程间<strong>同时存在互斥关系和同步关系</strong>）</p>
<p>线程A先执行某操作（例如对全局变量x的修改）后，线程B才能（根据变量x的值判断）执行另一操作<br>（可能是对全局变量x的修改），该如何实现？</p>
<ul>
<li>Linux提供了<strong>条件变量</strong>机制：<strong>条件变量与互斥量一起使用</strong>时，允许线程以互斥的方式阻塞等待特定条件的发生（同步）</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p><strong>条件变量的操作</strong>：</p>
<ul>
<li>定义条件变量（ <code>pthread_cond_t</code>类型）,定义互斥量变量</li>
<li>初始化条件变量，初始化互斥量</li>
<li>触发条件线程x<ul>
<li>互斥量加锁-&gt;XX操作-&gt;触发条件变量-&gt;互斥量解锁</li>
</ul>
</li>
<li>等待条件线程y<ul>
<li>互斥量加锁-&gt;等待条件变量-&gt;XX操作-&gt;互斥量解锁</li>
</ul>
</li>
<li>销毁条件变量，销毁互斥量变量</li>
</ul>
<p><strong>条件变量初始化</strong>：</p>
<p>静态初始化：<code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</code></p>
<p>动态初始化：</p>
<ul>
<li>头文件：<code>pthread.h</code></li>
<li>函数原型：<code>int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *attr);</code></li>
<li><code>cond</code>：条件变量</li>
<li><code>attr</code>：条件变量属性，若为<code>NULL</code>，则使用默认属性</li>
<li>成功返回0；出错返回错误码</li>
</ul>
<p><strong>条件变量销毁</strong>：</p>
<p>头文件：<code>pthread.h</code></p>
<p>函数原型：<code>int pthread_cond_destroy(pthread_cond_t * cond);</code></p>
<ul>
<li>cond：条件变量</li>
<li>成功返回0；出错返回错误码</li>
</ul>
<p><strong>等待条件变量</strong>：</p>
<p><code>pthread_cond_wait</code>函数将使调用线程进入阻塞状态，直到条件被触发</p>
<p>头文件：<code>pthread.h</code></p>
<p>函数原型：</p>
<ul>
<li><code>int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex);</code></li>
<li><code>cond</code>：条件变量</li>
<li><code>mutex</code>：互斥量</li>
<li>成功返回0；出错返回错误码</li>
</ul>
<p><strong>为什么条件变量需要和互斥量配合使用</strong></p>
<ul>
<li>条件变量的使用场景伴随共享资源的使用，例如全局变量</li>
<li>在调用<code>pthread_cond_wait</code>前，需要使互斥量处于加锁状态，这样可以通过原子操作的方式，将调用线程放到该条件变量等待线程队列（临界资源）中</li>
</ul>
<p><strong>等待条件变量的操作：</strong></p>
<ul>
<li>调用<code>pthread_mutex_lock</code></li>
<li>调用<code>pthread_cond_wait</code></li>
<li>调用<code>pthread_mutex_unlock</code></li>
</ul>
<p><strong>调用<code>pthread_cond_wait</code>函数后内核自动执行的操作：</strong></p>
<ul>
<li>在线程阻塞等待条件变量之前，调用<code>pthread_mutex_unlock</code></li>
<li>若条件变量被其他线程触发，在该线程被唤醒后，调用<code>pthread_mutex_lock</code></li>
</ul>
<p><strong>触发条件变量</strong>：</p>
<p><code>pthread_cond_signal</code>唤醒该条件变量等待线程队列中的<strong>某一个线程</strong></p>
<p><code>pthread_cond_broadcast</code>唤醒该条件变量等待线程队列中的<strong>所有线程</strong>，这些线程会进行竞争</p>
<p>头文件： <code>pthread.h</code></p>
<p>函数原型：</p>
<ul>
<li><code>int pthread_cond_signal(pthread_cond_t *cond);</code></li>
<li><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></li>
<li><code>cond</code>：条件变量</li>
<li>成功返回0；出错返回错误码</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> count_lock;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> count_ready;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">decrement_count</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">increment_count</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;count_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;count_ready, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, decrement_count, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, increment_count, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decrement quit\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//printf(&quot;&quot;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">decrement_count</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;count_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decrement:waitting\n&quot;</span>);</span><br><span class="line">    pthread_cond_wait(&amp;count_ready, &amp;count_lock);</span><br><span class="line">    <span class="comment">/*等待条件变量，期间互斥量仍然可用*/</span></span><br><span class="line">    </span><br><span class="line">    count -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decrement:count = %d\n&quot;</span>, count);</span><br><span class="line">    pthread_mutex_unlock(&amp;count_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decrement quit\n&quot;</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">increment_count</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;count_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;increment:running\n&quot;</span>);</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;count_ready);</span><br><span class="line">    <span class="comment">/*触发条件变量*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;increment:count = %d\n&quot;</span>, count);</span><br><span class="line">    pthread_mutex_unlock(&amp;count_lock);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409165937723.png" alt="image-20220409165937723"></p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p><strong>读写锁引入</strong></p>
<p>问题描述：</p>
<ul>
<li>在对临界资源的访问中，更多的是读操作，而写操作较少，只有互斥量机制可能会影响访问效率</li>
<li>期望对临界资源的访问控制粒度更精细，任一时刻允许<strong>多个线程对临界资源进行读操作</strong>，但只允许<strong>一个线程对临界资源进行写操作</strong></li>
</ul>
<p><strong>互斥关系：</strong></p>
<ul>
<li>读操作-写操作互斥</li>
<li>写操作-写操作互斥</li>
<li>读操作-读操作不互斥</li>
</ul>
<p>同步关系：</p>
<ul>
<li>缓冲区不满，才允许写操作</li>
<li>缓冲区不空，才允许读操作 </li>
</ul>
<p><strong>读写锁通信机制</strong></p>
<p>在保证互斥的基础上，Linux提供了<strong>对临界资源访问控制粒度更细</strong>的读写锁机制</p>
<p>读写锁机制可以实现如下访问控制规则：</p>
<ul>
<li>如果有线程对互斥资源进行读操作，则允许其它线程执行读操作，但不允许任何线程进行写操作</li>
<li>如果有线程对互斥资源进行写操作，则不允许任何线程进行读操作或写操作</li>
</ul>
<p><strong>读写锁的操作</strong></p>
<p>读写锁的操作与互斥量的操作非常类似</p>
<ol>
<li>定义读写锁变量 <code>pthread_rwlock_t rwlock;</code></li>
<li>初始化读写锁变量</li>
<li>访问临界资源（读操作或写操作）前对读写锁加锁</li>
<li>访问临界资源后对读写锁解锁</li>
<li>销毁读写锁变量</li>
</ol>
<p>读写锁的加锁操作在互斥量加锁的基础上扩展，具有<strong>加读锁</strong>和<strong>加写锁</strong>两种操作</p>
<ul>
<li>如果有线程已经成功对读写锁加读锁，其它线程可以继续对该读写锁加读锁，但不能再加写锁（加写锁的线程可能会被阻塞）</li>
<li>如果有线程已经成功对读写锁加写锁，则其它线程不能对该读写锁加读锁和加写锁</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>初始化读写锁</td>
<td><code>pthread_rwlock_init</code></td>
</tr>
<tr>
<td>阻塞申请读锁</td>
<td><code>pthread_rwlock_rdlock</code></td>
</tr>
<tr>
<td>非阻塞申请读锁</td>
<td><code>pthread_rwlock_tryrdlock</code></td>
</tr>
<tr>
<td>阻塞申请写锁</td>
<td><code>pthread_rwlock_wrlock</code></td>
</tr>
<tr>
<td>非阻塞申请写锁</td>
<td><code>pthread_rwlock_trywrlock</code></td>
</tr>
<tr>
<td>解锁（包括读锁和写锁）</td>
<td><code>pthread_rwlock_unlock</code></td>
</tr>
<tr>
<td>销毁读写锁</td>
<td><code>pthread_rwlock_destroy</code></td>
</tr>
</tbody></table>
<p><strong>读写锁初始化和销毁</strong></p>
<p>头文件： <code>pthread.h</code></p>
<p>初始化读写锁变量：</p>
<ul>
<li><code>int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock, __const pthread_rwlockattr_t *__restrict __attr);</code></li>
</ul>
<p>销毁读写锁变量：</p>
<ul>
<li><code>int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock);</code></li>
</ul>
<p>返回值：成功返回0，否则返回错误码</p>
<p><strong>加读锁</strong></p>
<p>头文件：<code>pthread.h</code></p>
<p>阻塞加读锁</p>
<ul>
<li><code>int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock); </code></li>
</ul>
<p>非阻塞加读锁</p>
<ul>
<li><code>int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock);</code></li>
</ul>
<p>限时加读锁</p>
<ul>
<li><code>int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock, __const struct timespec *__restrict __abstime);</code></li>
</ul>
<p><strong>加写锁</strong></p>
<p>头文件：<code>pthread.h</code></p>
<p>阻塞加写锁</p>
<ul>
<li><code>int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock);</code></li>
</ul>
<p>非阻塞加写锁</p>
<ul>
<li><code>int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock);</code></li>
</ul>
<p>限时等待加写锁</p>
<ul>
<li><code>int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __ rwlock, __const struct timespec *__restrict __abstime);</code></li>
</ul>
<p><strong>读写锁解锁</strong></p>
<p>头文件：<code>pthread.h</code></p>
<p>函数原型：<code>int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock);</code></p>
<p>如何确定是为读锁解锁还是为写锁解锁？</p>
<ul>
<li>就近原则。加锁（读锁/写锁）与解锁配对出现，为代码中距离最近的加锁操作解锁</li>
</ul>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="进程通信机制"><a href="#进程通信机制" class="headerlink" title="进程通信机制"></a>进程通信机制</h3><p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409175106240.png" alt="image-20220409175106240"></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是最古老、最简单的UNIX进程间通信机制</p>
<p>管道是一种特殊文件</p>
<p>管道的局限性</p>
<ul>
<li>半双工：一个进程写，一个进程读</li>
<li>只能在<strong>父子进程</strong>之间使用</li>
</ul>
<p><strong>创建管道</strong></p>
<p>头文件：<code>unistd.h</code></p>
<p>函数原型：<code>int pipe(int fildes[2]);</code></p>
<ul>
<li>程序通过文件描述符<code>fildes[0]</code>和<code>fildes[1]</code>来访问管道</li>
<li><code>filedes[0]</code>只能用于管道<strong>读操作</strong>，<code>filedes[1]</code>只能用于管道<strong>写操作</strong></li>
<li>写入<code>fildes[1]</code>的数据可以按照<strong>先进先出</strong>的顺序从<code>fildes[0]</code>中读出</li>
</ul>
<p>返回值：成功返回0，出错返回<code>-1</code></p>
<p><strong>命名管道（FIFO）</strong></p>
<ul>
<li>管道只能在父子进程之间使用</li>
<li>FIFO也被称为命名管道， FIFO是一种特殊的文件（创建FIFO类似于创建文件，FIFO的路径名存在于文件系统中）</li>
<li>创建FIFO之后可以通过文件I/O对其进行操作</li>
<li><strong>非父子进程可以通过文件名来使用FIFO</strong></li>
</ul>
<p><strong>创建FIFO</strong>：</p>
<p>头文件：</p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>sys/stat.h</code></li>
</ul>
<p>函数原型：<code>int mkfifo(const char *pathname, mode_t mode) ;</code></p>
<ul>
<li><code>pathname</code>：文件名（绝对路径）</li>
<li><code>mode</code>：文件类型、权限等</li>
</ul>
<p>返回值：成功返回<code>0</code>，出错返回<code>-1</code></p>
<h3 id="XSI-IPC机制"><a href="#XSI-IPC机制" class="headerlink" title="XSI IPC机制"></a>XSI IPC机制</h3><ul>
<li><strong>信号量集（semaphore set）</strong>，用于实现进程之间的同步与互斥</li>
<li><strong>共享内存（shared memory）</strong>，用于在进程之间高效地共享数据，适用于数据量大，速度要求高的场景</li>
<li><strong>消息队列（message queue）</strong>，进程之间传递数据的一种简单方法</li>
</ul>
<p><strong>IPC对象</strong>： <code>ipcs</code></p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409200437797.png" alt="image-20220409200437797"></p>
<p><strong>IPC对象的key值和ID</strong></p>
<p>Linux系统中的IPC对象都是全局的，为每个IPC对象分配唯一的ID</p>
<p>在IPC操作中通信各方需要通过ID来指示操作的IPC对象，需要有机制让通信各方获取获取IPC对象的ID</p>
<ul>
<li>创建IPC对象的进程通过创建IPC对象函数的返回值可获取ID值</li>
<li><font color="#ff0000">未创建IPC对象的进程如何获取IPC对象的ID值并使用该对象呢？</font></li>
</ul>
<p>IPC机制的ID值为<strong>动态分配</strong>，无法提前约定，不能跨进程传递</p>
<p>多个进程提前<strong>约定使用相同的key值</strong>做为参数来创建IPC对象或打开已经创建的IPC对象</p>
<p>如果通信各方（进程）在创建/打开IPC对象时使用相同的key值：</p>
<ul>
<li>首次使用该key值创建IPC对象的进程将<strong>真正创建</strong>该IPC对象，并获取其ID值</li>
<li>后续使用该key值创建IPC对象的进程都将<strong>在内核中找到该IPC对象</strong>并打开它，从而获取其ID值</li>
</ul>
<p>IPC对象与key值一一对应，因此<strong>key值不能重复</strong></p>
<p>通过**<code>ftok</code>函数**来产生独特的key值，避免重复</p>
<p>头文件： </p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>sys/ipc.h</code></li>
</ul>
<p>函数原型：<code>key_t ftok( char * pathname, int proj_id);</code></p>
<ul>
<li><code>pathname</code>是指定的文件名，可以是特殊文件也可以是目录文件）</li>
<li><code>proj_id</code>是子序号</li>
</ul>
<p>注：<strong>如果要确保<code>key_t</code>值不变，需要确保<code>ftok</code>所指定的文件名不被删除</strong> </p>
<table>
<thead>
<tr>
<th>信号量集</th>
<th>共享内存</th>
<th>消息队列</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>semget</code></td>
<td><code>shmget</code></td>
<td><code>msgget</code></td>
<td>创建或打开一个IPC对象，获得对IPC机制的访问权</td>
</tr>
<tr>
<td><code>semop</code></td>
<td><code>shmat</code> <code>shmdt</code></td>
<td><code>msgsnd</code> <code>msgrcv</code></td>
<td>IPC操作: 发送/接收消息；连接/释放共享内存；信号量操作</td>
</tr>
<tr>
<td><code>semctl</code></td>
<td><code>shmctl</code></td>
<td><code>msgctl</code></td>
<td>IPC控制：获得/修改IPC对象状态，“删除”IPC对象等</td>
</tr>
</tbody></table>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul>
<li>进程之间传递数据的一种简单方法</li>
<li>把每个消息看作一个记录，具有特定的格式</li>
<li>消息队列就是消息的链表</li>
<li>对消息队列有写权限的进程可以按照一定的规则添加新消息</li>
<li>对消息队列有读权限的进程则可以从消息队列中读走消息</li>
<li>消息队列能够克服管道或命名管道机制的一些缺点，例如实时性差等</li>
</ul>
<p><strong>消息队列结构</strong>：</p>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409203702015.png" alt="image-20220409203702015" style="zoom: 67%;">



<p><strong>消息队列操作</strong>：</p>
<p>头文件：</p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>sys/ipc.h</code></li>
<li><code>sys/msg.h</code></li>
</ul>
<p>打开或创建消息队列对象</p>
<ul>
<li><code>int msgget(key_t key, int msgflg);</code></li>
</ul>
<p>从消息队列接收消息</p>
<ul>
<li><code>int msgrcv(int msqid, struct msgbuf *msgp, int msgsz, long msgtyp, int msgflg); </code></li>
</ul>
<p>向消息队列发送消息</p>
<ul>
<li><code>int msgsnd(int msqid, struct msgbuf *msgp, int msgsz, intmsgflg); </code></li>
</ul>
<p>消息队列控制操作</p>
<ul>
<li><code>msgctl(int msqid, int cmd, struct msqid_ds *buf); </code></li>
</ul>
<p><strong>创建消息队列</strong></p>
<p><code>int msgget(key_t key, int oflag);</code></p>
<p>返回值：成功返回创建或打开的消息队列对象ID；出错返回<code>-1</code></p>
<ul>
<li><p><code>key</code>：创建或打开消息队列对象时指定的key值（提前约定或通过<code>ftok</code>函数创建）</p>
</li>
<li><p><code>Oflag</code>：设置访问权限，取值可以为以下一个或多个值的或</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*#define IPC_R 000400 读权限</span></span><br><span class="line"><span class="comment">#define IPC_W 000200 写和修改权限</span></span><br><span class="line"><span class="comment">#define IPC_M 010000 改变控制方式权限*/</span> 好像有错误，不对</span><br><span class="line">还可以附加以下参数值（按位或）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_CREAT 01000	<span class="comment">//如果消息队列对象不存在则创建，否则打开已经存在的消息队列对象</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_EXCL 02000	<span class="comment">//只有消息队列对象不存在的时候，才能创建新的消息队列对象，否则就产生错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_NOWAIT 04000 <span class="comment">//如果操作需要等待，则直接返回错误</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>发送信息到消息队列</strong></p>
<p><code>int msgsnd(int msgid, const void *ptr, size_t length, intflag);</code></p>
<p>返回值：成功返回0；出错返回<code>-1</code></p>
<ul>
<li><p><code>msgid</code>：消息队列ID</p>
</li>
<li><p><code>ptr</code>：指向<code>msgbuf</code>的结构体指针（其中消息类型<code>mtype</code>必须大于0，小于0的消息类型有特殊的指示作用）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> mtype; </span><br><span class="line">	<span class="keyword">char</span> mtext[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>length</code>：以字节为单位指定待发送消息的长度（<code>msgbuf</code>结构体中消息类型mtype之后的用户自定义数据的长度），该长度可以为0</p>
</li>
<li><p><code>flag</code>：可以是0，也可以是<code>IPC_NOWAIT</code>（该标志可以使函数工作在非阻塞模式）</p>
</li>
</ul>
<p>出现以下情况时：</p>
<p>1）指定的消息队列容量已满</p>
<p>2）在系统范围存在太多的消息</p>
<ul>
<li>若设置了<code>IPC_NOWAIT</code>，则<code>msgsnd</code>立即返回（返回<code>EAGAIN</code>错误）</li>
<li>若未指定该标志，则<code>msgsnd</code>导致调用进程阻塞，直到可以发送成功为止</li>
</ul>
<p><strong>从消息队列接收信息</strong></p>
<p><code>ssize_t msgrcv(int msqid, void *ptr, size_t length, long type, int flag);</code></p>
<p>返回值：成功返回实际读取数据的字节数；出错返回<code>-1</code></p>
<ul>
<li><code>msgid</code>：消息队列ID</li>
<li><code>ptr</code>：消息缓冲区指针，指向<code>msgbuf</code>的结构体指针</li>
<li><code>length</code>：消息缓冲区中数据部分的大小（<code>msgbuf</code>结构体中消息类型<code>mtype</code>之后的用户自定义数据的长度）</li>
<li><code>type</code>：指定期望从消息队列中接收什么样的消息<ul>
<li><code>type</code>为0，返回队列中第一个消息（消息队列是一个FIFO链表，所以返回的是队列中最早的消息）</li>
<li><code>type</code>大于0，返回消息队列中类型值为type的第一个消息</li>
<li><code>type</code>小于0，返回消息队列中类型值小于或等于type绝对值中类型值最小的第一个消息</li>
</ul>
</li>
<li><code>flag</code>：当消息队列中没有期望接收的消息时会如何操作<ul>
<li>若设置了<code>IPC_NOWAIT</code>标志，则函数立即返回<code>ENOMSG</code>错误</li>
<li>若未设置<code>IPC_NOWAIT</code>标志，否则<code>msgrcv</code>导致调用进程阻塞直到如下某个事件发生：<ul>
<li>有其他进程向消息队列中发送了所期望接收的消息</li>
<li>该消息队列被删除，此时返回<code>EIDRM</code>错误</li>
<li>进程被某个信号中断，此时返回<code>EINTR</code>错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>消息发送者： <code>msgsnd.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> msg_type;</span><br><span class="line">    <span class="keyword">char</span> text[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> msgid = <span class="number">-1</span>;</span><br><span class="line">    msgid = msgget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="number">0666</span> | IPC_CREAT); <span class="comment">// 0666 ?</span></span><br><span class="line">    <span class="keyword">if</span>(msgid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;megget failed with error:%d\n&quot;</span>, errno); </span><br><span class="line">        <span class="comment">// errno : int型 errno 是记录系统的最后一次错误代码 在头文件 errno.h中</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">// EXIT_FAILURE 1   stdlib.h中的宏定义</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter some text:&quot;</span>);</span><br><span class="line">        fgets(buffer, <span class="number">1024</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        data.msg_type = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(data.text, buffer);</span><br><span class="line">        <span class="keyword">if</span>(msgsnd(msgid, (<span class="keyword">void</span>*)&amp;data, <span class="number">1024</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;msgsnd failed\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buffer, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)  <span class="comment">// 字符串比较函数 在 string.h中</span></span><br><span class="line">        &#123;</span><br><span class="line">            running = <span class="number">0</span>;</span><br><span class="line">            sleep(<span class="number">1</span>); 	<span class="comment">// 在头文件 unistd.h 中定义</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS); <span class="comment">// EXIT_SUCCESS 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息接收者：<code>msgrcv.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msg_type;</span><br><span class="line">    <span class="keyword">char</span> text[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> msgid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msgtype = <span class="number">0</span>;</span><br><span class="line">    msgid = msgget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(msgid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;megget failed with error:%d\n&quot;</span>, errno);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(msgrcv(msgid, (<span class="keyword">void</span>*)&amp;data, <span class="number">1024</span>, msgtype, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;msgrcv failed with errno:%d\n&quot;</span>, errno);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You wrote:%s\n&quot;</span>, data.text);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(data.text, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            running = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(msgctl(msgid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;msgctl(IPC_RMID) failed\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220409232240314.png" alt="image-20220409232240314"></p>
<h3 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h3><p> <strong>任务资源共享情况</strong></p>
<p>临界资源：在一段时间内只允许一个任务访问的资源。诸任务间应采取互斥方式，实现对资源的共享</p>
<p>共享资源：允许多个任务同时访问同一种资源的多个实例</p>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220410122956953.png" alt="image-20220410122956953" style="zoom:50%;">

<p><strong>信号量</strong></p>
<p>信号量一般分为<strong>三种类型</strong>：</p>
<ul>
<li><strong>互斥信号量</strong>：任务之间互斥访问临界资源</li>
<li><strong>计数信号量</strong>：任务之间竞争访问共享资源</li>
<li><strong>二值信号量</strong>：任务之间的同步机制</li>
</ul>
<p>信号量是操作系统提供的管理资源共享的有效手段</p>
<p><strong>信号量作为操作系统核心代码执行，其地位高于任务（进程或线程），任务调度不能终止其运行</strong></p>
<p><strong>信号量的实现</strong></p>
<p>信号量<code>s</code>一般包含以下成员：</p>
<ul>
<li>整数值<code>s.count</code>（实现资源计数）</li>
<li>任务阻塞队列<code>s.queue</code></li>
</ul>
<p>信号量操作：初始化、P操作、V操作</p>
<ul>
<li><p>在进程初始化信号量将<code>s.count</code>指定为一个非负整数值，表示可用的共享资源实例总数</p>
</li>
<li><p>运行中<code>s.count</code>可为负值（其绝对值表示当前等待访问该共享资源的进程数）</p>
</li>
<li><p>P操作<code>wait(s)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--s.count;<span class="comment">//表示申请一个资源;</span></span><br><span class="line"><span class="keyword">if</span> (s.count &lt; <span class="number">0</span>)<span class="comment">//表示没有空闲资源;</span></span><br><span class="line">&#123;</span><br><span class="line">    调用进程进入阻塞队列s.<span class="built_in">queue</span>;</span><br><span class="line">    阻塞调用进程;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>V操作<code>signal(s)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">++s.count; <span class="comment">//表示释放一个资源</span></span><br><span class="line"><span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>) <span class="comment">//表示有进程处于阻塞状态</span></span><br><span class="line">&#123;</span><br><span class="line">    从等待队列s.<span class="built_in">queue</span>中取出一个进程p;</span><br><span class="line">    进程P进入就绪队列;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>互斥信号量状态图</strong></p>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220410124204976.png" alt="image-20220410124204976" style="zoom: 50%;">

<p><strong>计数信号量状态图</strong></p>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220410124244462.png" alt="image-20220410124244462" style="zoom:50%;">

<p><strong>二值信号量状态图</strong></p>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220410124311260.png" alt="image-20220410124311260" style="zoom:50%;">



<p><strong>信号量集结构</strong></p>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220410124618074.png" alt="image-20220410124618074" style="zoom:50%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>      </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">sem_base</span>;</span>   <span class="comment">/* 指向信号量数组的指针 */</span>       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">sem_pending</span>;</span>                     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> **<span class="title">sem_pending_last</span>;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">sem_undo</span> *<span class="title">undo</span>;</span>    </span><br><span class="line">    <span class="keyword">time_t</span> sem_otime; <span class="comment">/* 最后一次操作的时间 */</span></span><br><span class="line">	<span class="keyword">time_t</span> sem_ctime; <span class="comment">/* 最后一次改变此结构的时间 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sem_nsems; <span class="comment">/* 集合中信号量个数*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">pid_t</span> sempid; <span class="comment">/* 最后操作该信号量的进程ID */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> semncnt ; <span class="comment">/* 等待对该信号量执行P操作的进程数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> semzcnt; <span class="comment">/* 等待semval为0的进程数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> semval; <span class="comment">/* 信号量当前值 */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>XSI IPC信号量集操作</strong></p>
<p>头文件：</p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>sys/ipc.h</code></li>
<li><code>sys/sem.h</code></li>
</ul>
<p>创建或打开信号量集对象</p>
<ul>
<li><code>int semget(key_t key, int nsems, int semflg);</code></li>
</ul>
<p>信号量集操作（信号量的PV操作）</p>
<ul>
<li><code>int semop(int semid, struct sembuf *sops, unsigned nsops);</code></li>
</ul>
<p>信号量集控制（信号量初始化和删除操作）</p>
<ul>
<li><code>int semctl(int semid, int semnum, int cmd, union semun arg);</code></li>
</ul>
<h4 id="semget函数"><a href="#semget函数" class="headerlink" title="semget函数"></a>semget函数</h4><ul>
<li><p>头文件<code>sys/sem.h</code></p>
</li>
<li><p><code>int semget(key_t key, int nsems, int semflg);</code></p>
</li>
<li><p>返回值：成功返回创建或打开的信号量集对象（IPC对象）ID；失败返回<code>-1</code>；</p>
</li>
<li><p><code>key</code>：用于创建或打开信号量集对象时指定的<code>key</code>值（约定或通过<code>ftok</code>函数创建）或者0(<code>IPC_PRIVATE</code>)—— 创建一个只有创建进程可以访问的信号量。</p>
</li>
<li><p><code>nsems</code>：信号量集对象中包含的信号量数量（例如取值为1，则信号量集只包含1个信号量）</p>
</li>
<li><p><code>semflg</code>：设置访问权限，取值可以为以下某个值或多个值的或，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semflg 是 <span class="number">32</span>位的整数 ， IPC_CREAT和IPC_EXCL只用到了高<span class="number">24</span>位</span><br><span class="line">低<span class="number">8</span>位是权限位，一般是<span class="number">0666</span>，<span class="number">6</span>的二进制是<span class="number">110</span>，表示可读，可写，不可执行，三个<span class="number">6</span>分别对应当前用户，group组用户，其他用户    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/*#define IPC_R 000400 读权限</span></span><br><span class="line"><span class="comment">#define IPC_W 000200 写和修改权限</span></span><br><span class="line"><span class="comment">#define IPC_M 010000 改变控制方式权限*/</span> 好像有错误，不对</span><br><span class="line">还可以附加以下参数值（按位或）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_CREAT 01000	<span class="comment">//如果消息队列对象不存在则创建，否则打开已经存在的消息队列对象</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_EXCL 02000	<span class="comment">//只有消息队列对象不存在的时候，才能创建新的消息队列对象，否则就产生错误EEXIST</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_NOWAIT 04000 <span class="comment">//如果操作需要等待，则直接返回错误</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYKEY 0x1a0a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> semid;</span><br><span class="line">        semid = semget(MYKEY, <span class="number">1</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;semid = %d\n&quot;</span>, semid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220410135610074.png" alt="image-20220410135610074"></p>
</li>
</ul>
<h4 id="semop函数"><a href="#semop函数" class="headerlink" title="semop函数"></a>semop函数</h4><ul>
<li>头文件<ul>
<li><code>sys/types.h</code></li>
<li><code>sys/ipc.h</code></li>
<li><code>sys/sem.h</code></li>
</ul>
</li>
<li><code>int semop(int semid, struct sembuf sops[], size_t nsops);</code></li>
<li>成功返回0；失败返回-1</li>
<li><code>semid</code>：信号量集对象ID（<code>semget</code>的返回值）</li>
<li><code>sops</code>：指向<code>sembuf</code>结构数组的指针</li>
<li><code>nsops</code>：第二个参数中<code>sembuf</code>结构数组的元素个数</li>
</ul>
<p><strong>sembuf结构：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sem_num; <span class="comment">//信号量序号，指示本次是操作信号量集中的哪个信号量（序号从0开始）</span></span><br><span class="line"><span class="keyword">short</span> sem_op;	<span class="comment">//信号量操作码</span></span><br><span class="line"><span class="comment">/*该值为正，信号量V操作，增加信号量的值（为n，则加n）</span></span><br><span class="line"><span class="comment">该值为负，信号量P操作，减小信号量的值（为-n，则减n）</span></span><br><span class="line"><span class="comment">该值为0，对信号量的当前值是否为0的测试*/</span></span><br><span class="line"><span class="keyword">short</span> sem_flg; <span class="comment">// semop操作控制标志</span></span><br></pre></td></tr></table></figure>

<p><code>sem_flg</code>对<code>semop</code>操作进行控制，主要有2个控制标志：</p>
<ul>
<li><code>IPC_NOWAIT</code><ul>
<li>当指定的PV操作不能完成时，进程不会被阻塞，<code>semop</code>函数立即返回。返回值为-1，<code>errno</code>置为<code>EAGAIN</code>。</li>
<li>例如：信号量值在P操作后小于0，如果操作控制标志没有设置<code>IPC_NOWAIT</code>，则将调用进程阻塞，<code>semop</code>函数将不会返回直到资源可用为止；若设置了<code>IPC_NOWAIT</code>，则<code>semop</code>函数直接返回，调用进程将不会阻塞</li>
</ul>
</li>
<li><code>SEM_UNDO</code><ul>
<li>进程异常退出时，执行信号量解除（undo）操作</li>
<li>例如：进程执行了P操作后异常退出，如果操作控制标志设置了<code>SEM_UNDO</code>，则内核会对该进程执行V操作，保证安全性</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semaphore_p</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>; <span class="comment">// P操作</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;semaphore_p failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_v</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>; <span class="comment">// V操作</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;semaphore_v failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="semctl函数"><a href="#semctl函数" class="headerlink" title="semctl函数"></a>semctl函数</h4><p>头文件：</p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>sys/ipc.h</code></li>
<li><code>sys/sem.h</code></li>
</ul>
<p><code>int semctl(int semid, int semnum, int cmd, union semun arg);</code></p>
<ul>
<li><p>返回值：成功返回值大于或等于0；失败返回值-1</p>
</li>
<li><p><code>semid</code>：信号量集对象的ID（<code>semget</code>的返回值）</p>
</li>
<li><p><code>semnum</code>：信号量集中信号量的编号（如果控制是针对整个信号量集，则将该值设置为0）</p>
</li>
<li><p><code>cmd</code>：要执行的控制命令</p>
<ul>
<li><p>针对<strong>整个信号量集</strong>的控制命令主要包括：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IPC_RMID	<span class="comment">//删除</span></span><br><span class="line">IPC_SET		<span class="comment">//设置ipc_perm参数</span></span><br><span class="line">IPC_STAT	<span class="comment">//获取ipc_perm参数</span></span><br><span class="line">IPC_INFO 	<span class="comment">//获取系统信息</span></span><br></pre></td></tr></table></figure></li>
<li><p>针对信号量集中<strong>某个信号量</strong>的控制命令主要包括：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SETVAL	<span class="comment">//设置信号量的值（一般用于信号量初始化时设置初始值）</span></span><br><span class="line">GETVAL	<span class="comment">//获取信号量的值</span></span><br><span class="line">GETPID	<span class="comment">//获取信号量拥有者进程的PID值</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>arg</code>：与控制命令配合的参数（可选）</p>
<ul>
<li>```c<br>union semun {<pre><code>int val;   /* Value for SETVAL */
struct semid_ds *buf; /*Buffer for IPC_STAT,IPC_SET */
unsigned short *array;/* Array for GETALL, SETALL */
struct seminfo *__buf;  /* Buffer for IPC_INFO */
</code></pre>
};<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">`semctl`函数的控制命令通常为以下两种情况：</span><br><span class="line"></span><br><span class="line">- `SETVAL`：用来把信号量集中的某个信号量初始化为一个给定值， 这个值通过arg参数（union semun中的val成员）来指定</span><br><span class="line">- `IPC_RMID`：用于删除信号量集对象，此时arg参数无需赋值</span><br><span class="line">- `GETVAL`：返回值就是get得到的信号量的值</span><br><span class="line"></span><br><span class="line">#### 示例1</span><br><span class="line"></span><br><span class="line">这个示例有点问题，会死锁，参照示例2，然后可以改改示例1 ？？??</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/sem.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line"></span><br><span class="line">#define MYKEY 0x1a0a</span><br><span class="line"></span><br><span class="line">union semun &#123;    // semun 要自己添加</span><br><span class="line">    int val; </span><br><span class="line">    struct semid_ds *buf; </span><br><span class="line">    unsigned short *arry;</span><br><span class="line">    struct seminfo *__buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*信号量初始化（赋值函数）*/</span><br><span class="line">int init_sem(int sem_id, int init_value)</span><br><span class="line">&#123;</span><br><span class="line">	union semun sem_union;</span><br><span class="line">    sem_union.val = init_value;	// init_value为初始值</span><br><span class="line">    if(semctl(sem_id, 0, SETVAL, sem_union) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;Initialize semaphore\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*从系统中删除信号量的函数*/</span><br><span class="line">int del_sem(int sem_id)</span><br><span class="line">&#123;</span><br><span class="line">    union semun sem_union;</span><br><span class="line">    if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;Delete semaphore\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*P 操作函数*/</span><br><span class="line">int sem_p(int sem_id)</span><br><span class="line">&#123;</span><br><span class="line">    struct sembuf sem_b;</span><br><span class="line">    sem_b.sem_num = 0;	//信号量编号，单个信号量的编号为0</span><br><span class="line">    sem_b.sem_op = -1;	//信号量操作，-1 为 P操作</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;	//在进程没释放信号量而退出时，系统自动释放该进程中未释放的信号量</span><br><span class="line">    if(semop(sem_id, &amp;sem_b, 1) == -1) //进行P操作</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;V operation\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*V 操作函数*/</span><br><span class="line">int sem_v(int sem_id)</span><br><span class="line">&#123;</span><br><span class="line">    struct sembuf sem_b;</span><br><span class="line">    sem_b.sem_num = 0;	//信号量编号，单个信号量的编号为0</span><br><span class="line">    sem_b.sem_op = 1;	//信号量操作，1 为 v操作</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;	//在进程没释放信号量而退出时，系统自动释放该进程中未释放的信号量</span><br><span class="line">    if(semop(sem_id, &amp;sem_b, 1) == -1) //进行V操作</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;V operation\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t result;</span><br><span class="line">    int sem_id;</span><br><span class="line">    /*创建一个信号量*/</span><br><span class="line">    //sem_id = semget(ftok(&quot;.&quot;, &#x27;a&#x27;), 1, 0666 | IPC_CREAT);</span><br><span class="line">    sem_id = semget(MYKEY, 1, 0666 | IPC_CREAT);</span><br><span class="line">    init_sem(sem_id, 0);</span><br><span class="line">    /*调用fork()函数*/</span><br><span class="line">    result = fork();</span><br><span class="line">    if(result == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fork\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(result == 0) /*返回值为0代表子进程*/</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Child progress will wait for some seconds...\n&quot;);</span><br><span class="line">        sleep(3); //睡眠3秒，执行父进程</span><br><span class="line">        printf(&quot;The returned value is %d in the child progress(PID=%d)\n&quot;, result, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    else /*返回值大于0代表父进程*/</span><br><span class="line">    &#123;</span><br><span class="line">    	sem_p(sem_id);</span><br><span class="line">        printf(&quot;The returned value is %d in the father progress(PID=%d)\n&quot;, result, getpid());</span><br><span class="line">        sem_v(sem_id);</span><br><span class="line">        del_sem(sem_id);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220413222409448.png" alt="image-20220413222409448"></p>
<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;               <span class="comment">/* value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>  <span class="comment">/* buffer for IPC_STAT &amp; IPC_SET */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>; <span class="comment">/* array for GETALL &amp; SETALL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span> <span class="comment">/* buffer for IPC_INFO */</span></span><br><span class="line">    <span class="keyword">void</span> *__pad;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span></span>; <span class="comment">// P操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span></span>; <span class="comment">// V操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> semid, ret;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;/tmp&quot;</span>, <span class="number">0x04</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok key error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.创建信号量 （创建了三个信号量，实际只用0号信号量）</span></span><br><span class="line">    semid = semget(key, <span class="number">3</span>, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (semid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;create semget error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.对0号信号量设置初始值</span></span><br><span class="line">    arg.val = <span class="number">1</span>;</span><br><span class="line">    ret = semctl(semid, <span class="number">0</span>, SETVAL, arg);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;semctl error&quot;</span>);</span><br><span class="line">        semctl(semid, <span class="number">0</span>, IPC_RMID, arg);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.打印当前0号信号量的值</span></span><br><span class="line">    ret = semctl(semid, <span class="number">0</span>, GETVAL, arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after semctl setval  sem[0].val = %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="comment">// 4.开始P操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;P operate begin\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem_p(semid, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;P operate error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;P operate end\n&quot;</span>);</span><br><span class="line">    ret = semctl(semid, <span class="number">0</span>, GETVAL, arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after P sem[0].val= %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="comment">// 5.延时10s		（这个时间段内去执行另一个进程sem2，会在它的P操作那阻塞等待sem执行完V操作）</span></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">time_t</span> tNow = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;delay 60S，now time is:%s\n&quot;</span>, ctime(&amp;tNow));</span><br><span class="line">    <span class="comment">// 6.开始V操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;V operate begin\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem_v(semid, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;V operate error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;V operate end\n&quot;</span>);</span><br><span class="line">    ret = semctl(semid, <span class="number">0</span>, GETVAL, arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after V sem[0].val= %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="comment">// 7.移除信号量</span></span><br><span class="line">    sleep(<span class="number">15</span>);</span><br><span class="line">    semctl(semid, <span class="number">0</span>, IPC_RMID, arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对信号量数组semnum编号的信号量做P操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_p</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span>;</span></span><br><span class="line">    op.sem_num = <span class="number">0</span>;</span><br><span class="line">    op.sem_op = <span class="number">-1</span>;</span><br><span class="line">    op.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">return</span> (semop(semid, &amp;op, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对信号量数组semnum编号的信号量做V操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_v</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span>;</span></span><br><span class="line">    op.sem_num = <span class="number">0</span>;</span><br><span class="line">    op.sem_op = +<span class="number">1</span>;</span><br><span class="line">    op.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">return</span> (semop(semid, &amp;op, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220413222629672.png" alt="image-20220413222629672"></p>
<p>分别用两个终端运行<code>./IPC_sem</code>，等待约二十秒查看结果，注意删除信号量之前睡眠15秒是为了等待另一进程完成PV操作，<strong>即删除信号量时需保证所有使用该信号量的进程完成PV操作，否则会出错</strong></p>
<p><strong>PV操作类似线程的加锁和解锁</strong></p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul>
<li>共享内存是内核为进程间通信创建的<strong>特殊内存段</strong></li>
<li>不同进程可以将同一段共享内存连接到自己的地址空间</li>
<li>最快的进程间通信方式</li>
<li>本身不具有互斥访问机制</li>
</ul>
<img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220410144858118.png" alt="image-20220410144858118" style="zoom: 40%;">

<p><strong>共享内存的操作</strong></p>
<p>头文件：</p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>sys/ipc.h</code></li>
<li><code>sys/shm.h</code></li>
</ul>
<p>打开或创建共享内存对象</p>
<ul>
<li><code>int shmget(key_t key, int size, int flag);</code></li>
</ul>
<p>将共享内存连接到进程空间</p>
<ul>
<li><code>void *shmat(int shmid, void *addr, int flag);</code></li>
</ul>
<p>断开进程空间和共享内存的连接</p>
<ul>
<li><code>int shmdt(void *addr);</code></li>
</ul>
<p>共享内存控制操作</p>
<ul>
<li><code>int shmctl(int shmid, int cmd, struct 4 shmid_ds *buf);</code></li>
</ul>
<h4 id="shmget函数"><a href="#shmget函数" class="headerlink" title="shmget函数"></a>shmget函数</h4><p><code>int shmget(key_t key, size_t size, int shmflag)</code></p>
<ul>
<li><p>成功返回创建或打开的共享内存标识符；失败返回-1</p>
</li>
<li><p><code>key</code>：创建或打开共享内存对象时指定的key值（提前约定或通过ftok函数创建）</p>
</li>
<li><p><code>size</code>：指定创建的共享内存大小（首次创建共享内存对象时通过该参数指定共享内存段的大小）</p>
</li>
<li><p><code>shmflag</code>：设置共享内存的访问权限 ，取值可以为以下一个或多个值的或</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*#define IPC_R 000400 读权限</span></span><br><span class="line"><span class="comment">#define IPC_W 000200 写和修改权限</span></span><br><span class="line"><span class="comment">#define IPC_M 010000 改变控制方式权限*/</span> 好像有错误，不对</span><br><span class="line">还可以附加以下参数值（按位或）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_CREAT 01000	<span class="comment">//如果消息队列对象不存在则创建，否则打开已经存在的消息队列对象</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_EXCL 02000	<span class="comment">//只有消息队列对象不存在的时候，才能创建新的消息队列对象，否则就产生错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_NOWAIT 04000 <span class="comment">//如果操作需要等待，则直接返回错误</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="shmat函数"><a href="#shmat函数" class="headerlink" title="shmat函数"></a>shmat函数</h4><p><code>void *shmat(int shm_id, const void *addr, int shmflg);</code></p>
<ul>
<li>成功<strong>返回共享内存在进程空间中的连接地址</strong>；失败返回 -1</li>
<li><code>shm_id</code>：共享内存对象ID</li>
<li><code>addr</code>：指明共享内存连接到的进程空间地址；通常指定为空指针，让Linux系统决定共享内存连接到进程空间中的哪个地址</li>
<li><code>shmflg</code>：可以设置以下两个标志位之一或者不设置（值为0）<ul>
<li><code>SHM_RND</code>（ addr参数指定的地址应被规整到内存页面大小的整数倍）</li>
<li><code>SHM_RDONLY</code>（共享内存连接到进程空间时被限制为只读）</li>
</ul>
</li>
</ul>
<h4 id="shmdt函数"><a href="#shmdt函数" class="headerlink" title="shmdt函数"></a>shmdt函数</h4><p><code>int shmdt(const void *shmaddr);</code></p>
<ul>
<li>从调用进程的地址空间中，取消由<code>shmaddr</code>参数所指向的，共享内存映射区域</li>
<li>成功返回0；失败返回-1</li>
<li><code>shmaddr</code>：共享内存在进程空间中的连接地址，一般为<code>shmat</code>函数返回的地址。</li>
<li>内核将该共享内存的加载计数减1</li>
</ul>
<h4 id="shmctl函数"><a href="#shmctl函数" class="headerlink" title="shmctl函数"></a>shmctl函数</h4><p><code>int shmctl(int shm_id, int command, struct shmid_ds *buf);</code></p>
<ul>
<li>成功返回0；失败返回-1</li>
<li><code>shm_id</code>：共享内存对象ID</li>
<li><code>commad</code>：执行的控制命令<ul>
<li><code>IPC_RMID</code>，从系统中删除该共享内存对象</li>
<li><code>IPC_STAT</code>，获取共享内存对象的内核结构值</li>
<li><code>IPC_SET</code>，设置共享内存对象的内核结构值</li>
</ul>
</li>
<li><code>buf</code>：指向<code>shmid_ds</code>结构的指正，当控制命令为<code>IPC_STAT</code>或<code>IPC_SET</code>时，用于获取或设置共享内存对象的内核结构</li>
</ul>
<h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者/消费者问题"></a>生产者/消费者问题</h4><p>问题描述：进程之间通过共享缓冲池（包含一定数量的缓冲区）交换数据。其中，“生产者”进程不断写入，而“消费者”进程不断读出；任何时刻只能有一个任务可对共享缓冲池进行操作。</p>
<ul>
<li>进程之间的共享缓冲池可以通过共享内存机制实现</li>
</ul>
<p>消费者读取共享内存：<code>consume.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> Buffer[<span class="number">5</span>][<span class="number">100</span>]; <span class="comment">// 5 个缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> Index[<span class="number">5</span>];	<span class="comment">//缓冲区状态</span></span><br><span class="line">    <span class="comment">// 0 表示 对应的缓冲区未被生产者使用，可生产但不可消费</span></span><br><span class="line">    <span class="comment">// 1 表示 对应的缓冲区已被生产者使用，不可生产但可消费</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> *shm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span> *<span class="title">shared</span>;</span></span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    shmid = shmget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="keyword">sizeof</span>(struct BufferPool), <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    shm = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(*((<span class="keyword">int</span>*)shm) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    shared = (struct BufferPool*)shm;</span><br><span class="line">    <span class="keyword">while</span>(running)</span><br><span class="line">    &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(shared-&gt;Index[index] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;consume buffer: %s&quot;</span>, shared-&gt;Buffer[index]);</span><br><span class="line">            shared-&gt;Index[index] = <span class="number">0</span>;</span><br><span class="line">            sleep(rand() % <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(shared-&gt;Buffer[index], <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shmctl(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成者写入共享内存：<code>product.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> Buffer[<span class="number">5</span>][<span class="number">100</span>]; <span class="comment">// 5 个缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> Index[<span class="number">5</span>];	<span class="comment">//缓冲区状态</span></span><br><span class="line">    <span class="comment">// 0 表示 对应的缓冲区未被生产者使用，可生产但不可消费</span></span><br><span class="line">    <span class="comment">// 1 表示 对应的缓冲区已被生产者使用，不可生产但可消费</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> *shm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BufferPool</span> *<span class="title">shared</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line">    shmid = shmget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="keyword">sizeof</span>(struct BufferPool), <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    shm = shmat(shmid, (<span class="keyword">void</span>*)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(*((<span class="keyword">int</span>*)shm) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Memory attached at %X\n&quot;</span>, (<span class="keyword">int</span>*)shm);</span><br><span class="line">    shared = (struct BufferPool*)shm;</span><br><span class="line">    <span class="keyword">while</span>(running)</span><br><span class="line">    &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(shared-&gt;Index[index] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Enter some text:&quot;</span>);</span><br><span class="line">            fgets(buffer, <span class="number">100</span>, <span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">strncpy</span>(shared-&gt;Buffer[index], buffer, <span class="number">100</span>);</span><br><span class="line">            shared-&gt;Index[index] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buffer, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shmctl(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>警告不理会</p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220410170728545.png" alt="image-20220410170728545"></p>
<p>两个终端运行：</p>
<p><img src="/02%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20220410170545001.png" alt="image-20220410170545001"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程</title>
    <url>/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>学习自黑马程序员&amp;传智教育，文档资料有修改</p>
<span id="more"></span>

<h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++<strong>面向对象</strong>编程技术做详细讲解，探讨C++中的核心和精髓。</p>
<h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在程序编译后，生成了exe可执行程序，</span><br></pre></td></tr></table></figure>

<p><strong>未执行该程序前</strong>分为两个区域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>代码区：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存放 CPU 执行的机器指令</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码区是</span><br></pre></td></tr></table></figure>

<p><strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码区是</span><br></pre></td></tr></table></figure>

<p><strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>全局区：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局变量和静态变量存放在此.</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局区还包含了常量区, 字符串常量和其他常量也存放在此.</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==该区域的数据在程序结束后由操作系统释放==.</span><br></pre></td></tr></table></figure>


<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="keyword">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="keyword">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545017602518.png" alt="1545017602518"></p>
<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
</ul>
<h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>栈区：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由编译器自动分配释放, 存放函数的参数值,局部变量等</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</span><br></pre></td></tr></table></figure>


<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;		<span class="comment">//第一次可以打印正确的数字，是因为编译器做了保留</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;		<span class="comment">//第二次这个数据就不在保留了</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>堆区：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在C++中主要利用new在堆区开辟内存</span><br></pre></td></tr></table></figure>


<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//在堆区开辟数据</span></span><br><span class="line">	<span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);  <span class="comment">//初始值设为10</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内存</p>
<h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C++中利用<span class="keyword">new</span>操作符在堆区开辟数据</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 <span class="keyword">delete</span></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br></pre></td></tr></table></figure>

<p><code> new 数据类型</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用new创建的数据，会返回该数据对应的类型的指针</span><br></pre></td></tr></table></figure>


<p><strong>示例1： 基本语法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例2：开辟数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p><strong>作用：</strong> 给变量起别名</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">	<span class="keyword">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">	c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong> 函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong> 可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap02</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap03</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;	<span class="comment">//如果函数的返回值是引用，这个函数的调用可以作为左值</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">  </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong> 常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加<code>const修饰形参</code>，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">	<span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意事项</span></span><br><span class="line"><span class="comment">1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">2. 如果函数声明有默认值，函数实现的时候就不能有默认参数（声明和实现只能有一个设置默认参数）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//占位参数还可以有默认值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is func2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong> 函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a ,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a>4 类和对象</h2><p>C++面向对象的三大特性为：<code>封装、继承、多态</code></p>
<p>C++认为<code>万事万物都皆为对象</code>，对象上有其属性和行为</p>
<p><strong>例如：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调...</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</span><br></pre></td></tr></table></figure>


<h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在设计类的时候，属性和行为写在一起，表现事物</span><br></pre></td></tr></table></figure>


<p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p>
<p><strong>示例1：</strong> 设计一个圆类，求圆的周长</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	<span class="keyword">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//行为</span></span><br><span class="line">	<span class="comment">//获取到圆的周长</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//2 * pi  * r</span></span><br><span class="line">		<span class="comment">//获取圆的周长</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line">	<span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">	Circle c1;</span><br><span class="line">	c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong> 设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<p><strong>示例2代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		m_id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="keyword">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Student stu;</span><br><span class="line">	stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">	stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">	stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public        公共权限</li>
<li>protected     保护权限</li>
<li>private      私有权限</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问	子类也可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string m_Car;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">		m_Password = <span class="number">123456</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">	<span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line">	<span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	C1 c1;</span><br><span class="line">	c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">	C2 c2;</span><br><span class="line">	c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong> 将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong> 对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//姓名设置可读可写</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取年龄 </span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置年龄</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置为只写</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">		m_Lover = lover;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">	string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	<span class="comment">//姓名设置</span></span><br><span class="line">	p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄设置</span></span><br><span class="line">	p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置</span></span><br><span class="line">	p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>练习案例1：设计立方体类</strong></p>
<p>设计立方体类(Cube)</p>
<p>求出立方体的面积和体积</p>
<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>
<p><img src="/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545533548532.png" alt="1545533548532"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cube</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//设置长</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setL</span><span class="params">(<span class="keyword">int</span> L)</span> </span>&#123; m_L = L; &#125;</span><br><span class="line">	<span class="comment">//设置宽</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setW</span><span class="params">(<span class="keyword">int</span> W)</span> </span>&#123; m_W = W; &#125;</span><br><span class="line">	<span class="comment">//设置高</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setH</span><span class="params">(<span class="keyword">int</span> H)</span> </span>&#123; m_H = H; &#125;</span><br><span class="line">	<span class="comment">//获取长</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getL</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_L;&#125;</span><br><span class="line">	<span class="comment">//获取高</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getH</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_H; &#125;</span><br><span class="line">	<span class="comment">//获取宽</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getW</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_W; &#125;</span><br><span class="line">	<span class="comment">//计算面积</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">calculateS</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>*(m_L*m_H+m_L*m_W+m_H*m_W); &#125;</span><br><span class="line">	<span class="comment">//计算体积</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">calculateV</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_L*m_H*m_W; &#125;</span><br><span class="line">	<span class="comment">//比较两个长方体</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isSameCube</span><span class="params">(Cube cube)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(m_L==cube.<span class="built_in">getL</span>()&amp;&amp;m_W==cube.<span class="built_in">getW</span>()&amp;&amp;m_H==cube.<span class="built_in">getH</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span><span class="number">&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_L; <span class="comment">//长</span></span><br><span class="line">	<span class="keyword">int</span> m_W; <span class="comment">//宽</span></span><br><span class="line">	<span class="keyword">int</span> m_H; <span class="comment">//高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>练习案例2：点和圆的关系</strong></p>
<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>
<p><img src="/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545533829184.png" alt="1545533829184"></p>
<h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个对象或者变量没有初始状态，对其使用后果是未知</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</span><br></pre></td></tr></table></figure>


<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按参数分为： 有参构造和无参构造</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按类型分为： 普通构造和拷贝构造</span><br></pre></td></tr></table></figure>


<p>三种调用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">括号法</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">显示法</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">隐式转换法</span><br></pre></td></tr></table></figure>


<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.1  括号法，常用</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">	<span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">	<span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">	<span class="comment">//Person (p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">	<span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person newman3;</span></span><br><span class="line">	<span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; (<span class="keyword">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="keyword">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li>
<li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">	Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">	Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age ,<span class="keyword">int</span> height) &#123;</span><br><span class="line">	</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(height);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数  </span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p.m_height);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_height;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_age;</span><br><span class="line">	<span class="keyword">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">////传统方式初始化</span></span><br><span class="line">	<span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">	<span class="comment">//	m_A = a;</span></span><br><span class="line">	<span class="comment">//	m_B = b;</span></span><br><span class="line">	<span class="comment">//	m_C = c;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line">	<span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Phone</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		m_PhoneName = name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Phone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">	<span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line">	<span class="comment">//析构顺序与构造相反</span></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1：</strong> 静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员变量特点：</span></span><br><span class="line">	<span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">	<span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line">	<span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p1.m_A = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p2;</span><br><span class="line">	p2.m_A = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong> 静态成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数特点：</span></span><br><span class="line">	<span class="comment">//1 程序共享一个函数</span></span><br><span class="line">	<span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="keyword">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	<span class="comment">//空对象占用内存空间为：1字节</span></span><br><span class="line">	<span class="comment">//c++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置</span></span><br><span class="line">	<span class="comment">//每个空对象也应该有一个独一无二的内存地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">	<span class="keyword">int</span> mA;</span><br><span class="line">	<span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> mB; </span><br><span class="line">	<span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//返回对象本身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//链式编程思想</span></span><br><span class="line">	p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person * p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">	p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		m_A = <span class="number">0</span>;</span><br><span class="line">		m_B = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">	<span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//const Type* const pointer;</span></span><br><span class="line">		<span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">		<span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//mA = 10000;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="keyword">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">	person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象访问成员函数</span></span><br><span class="line">	person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用普通成员函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为  ==friend==</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Building b;</span><br><span class="line">	<span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">goodGay</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现 + 号运算符重载  </span></span><br><span class="line">	Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//	Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//	temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//	temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//	return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person&amp; p2, <span class="keyword">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p2.m_A + val;</span><br><span class="line">	temp.m_B = p2.m_B + val;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数方式</span></span><br><span class="line">	Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)，是简化的版本</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前置++</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		<span class="comment">//先++</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="comment">//再返回</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置++</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">		<span class="comment">//先返回</span></span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator=, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载赋值运算符 </span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line">		<span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回自身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄的指针</span></span><br><span class="line">	<span class="keyword">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int a = 10;</span></span><br><span class="line">	<span class="comment">//int b = 20;</span></span><br><span class="line">	<span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//c = b = a;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int a = 0;</span></span><br><span class="line">	<span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a != b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	<span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//匿名对象调用  </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p>
<p>有些类与类之间存在特殊的关系，例如下图中：</p>
<p><img src="/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1544861202252.png" alt="1544861202252"></p>
<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p><strong>普通实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Python</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPP</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Python</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPP</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>继承的好处：==可以减少重复的代码==</p>
<p>class A : public B;</p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img src="/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/clip_image002.png" alt="img"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> :</span><span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>:</span><span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2 s;</span><br><span class="line">	<span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>:</span><span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandSon3</span> :</span><span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">		<span class="comment">//m_A;</span></span><br><span class="line">		<span class="comment">//m_B;</span></span><br><span class="line">		<span class="comment">//m_C;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用工具查看：</p>
<p><img src="/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545881904150.png" alt="1545881904150"></p>
<p>打开工具窗口后，定位到当前CPP文件的盘符</p>
<p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p>
<p>效果如下图：</p>
<p><img src="/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545882158050.png" alt="1545882158050"></p>
<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">	Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
</blockquote>
<h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">	<span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">	Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
</blockquote>
<h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_C = <span class="number">300</span>;</span><br><span class="line">		m_D = <span class="number">400</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_C;</span><br><span class="line">	<span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个派生类继承同一个基类</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">又有某个类同时继承者两个派生类</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这种继承被称为菱形继承，或者钻石继承</span><br></pre></td></tr></table></figure>


<p><strong>典型的菱形继承案例：</strong></p>
<p><img src="/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/clip_image002.jpg" alt="IMG_256"></p>
<p><strong>菱形继承问题：</strong></p>
<ol>
<li>```<br>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</span><br><span class="line"></span><br><span class="line">**示例：**</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//继承前加virtual关键字后，变为虚继承</span><br><span class="line">//此时公共的父类Animal称为虚基类</span><br><span class="line">class Sheep : virtual public Animal &#123;&#125;;</span><br><span class="line">class Tuo   : virtual public Animal &#123;&#125;;</span><br><span class="line">class SheepTuo : public Sheep, public Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = 100;</span><br><span class="line">	st.Tuo::m_Age = 200;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Speak函数就是虚函数</span></span><br><span class="line">	<span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p>
<h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_Num1;</span><br><span class="line">	<span class="keyword">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//普通实现测试</span></span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">	c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractCalculator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_Num1;</span><br><span class="line">	<span class="keyword">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MulCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建加法计算器</span></span><br><span class="line">	AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建减法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建乘法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
</blockquote>
<h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为==抽象类==</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//纯虚函数</span></span><br><span class="line">	<span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">	<span class="comment">//抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base * base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">	base = <span class="keyword">new</span> Son;</span><br><span class="line">	base-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p>
<p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<p><img src="/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1545985945198.png" alt="1545985945198"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractDrinking</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//规定流程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> :</span> <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span> :</span> <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">	drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：</p>
<p><code> virtual ~类名() = 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line">	<span class="comment">//virtual ~Animal()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cat</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Name;</span><br><span class="line">			m_Name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line">	<span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line">	<span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line">	<span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. 拥有纯虚析构函数的类也属于抽象类</span><br></pre></td></tr></table></figure>


<h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>测试时组装三台不同的电脑进行工作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的计算函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoCard</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的显示函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的存储函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">	&#123;</span><br><span class="line">		m_cpu = cpu;</span><br><span class="line">		m_vc = vc;</span><br><span class="line">		m_mem = mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供工作的函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">		m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">		m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">		m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放CPU零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_cpu;</span><br><span class="line">			m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放显卡零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_vc;</span><br><span class="line">			m_vc = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放内存条零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_mem;</span><br><span class="line">			m_mem = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">	VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">	Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntelCPU</span> :</span><span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntelVideoCard</span> :</span><span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntelMemory</span> :</span><span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenovoCPU</span> :</span><span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenovoVideoCard</span> :</span><span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenovoMemory</span> :</span><span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一台电脑零件</span></span><br><span class="line">	CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">	Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//创建第一台电脑</span></span><br><span class="line">	Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">	computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第二台电脑组装</span></span><br><span class="line">	Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第三台电脑组装</span></span><br><span class="line">	Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件操作需要包含头文件 <code>&lt;fstream&gt;</code></p>
<p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三大类:</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ol>
<h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>写文件步骤如下：</p>
<ol>
<li><p>包含头文件</p>
<p>#include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象</p>
<p>ofstream ofs;</p>
</li>
<li><p>打开文件</p>
<p>ofs.open(“文件路径”,打开方式);</p>
</li>
<li><p>写数据</p>
<p>ofs &lt;&lt; “写入的数据”;</p>
</li>
<li><p>关闭文件</p>
<p>ofs.close();</p>
</li>
</ol>
<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>文件操作必须包含头文件 fstream</li>
<li>读文件可以利用 ofstream  ，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式</li>
<li>利用&lt;&lt;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p>
<p>读文件步骤如下：</p>
<ol>
<li><p>包含头文件</p>
<p>#include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象</p>
<p>ifstream ifs;</p>
</li>
<li><p>打开文件并判断文件是否打开成功</p>
<p>ifs.open(“文件路径”,打开方式);</p>
</li>
<li><p>读数据</p>
<p>四种方式读取</p>
</li>
<li><p>关闭文件</p>
<p>ifs.close();</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种方式</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种</span></span><br><span class="line">	<span class="comment">//string buf;</span></span><br><span class="line">	<span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)  <span class="comment">// end of file</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>读文件可以利用 ifstream  ，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件</li>
</ul>
<h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 ==ios::binary==</p>
<h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、创建输出流对象</span></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、打开文件</span></span><br><span class="line">	<span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">	Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、写文件</span></span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;p, <span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5、关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="keyword">char</span> *)&amp;p, <span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件输入流对象 可以通过read函数，以二进制方式读数据</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础入门</title>
    <url>/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>学习自黑马程序员&amp;传智教育，文档资料有修改</p>
<span id="more"></span>

<h1 id="C-基础入门"><a href="#C-基础入门" class="headerlink" title="C++基础入门"></a>C++基础入门</h1><h2 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1 C++初识"></a>1 C++初识</h2><h3 id="1-1-第一个C-程序"><a href="#1-1-第一个C-程序" class="headerlink" title="1.1  第一个C++程序"></a>1.1  第一个C++程序</h3><p>编写一个C++程序总共分为4个步骤</p>
<ul>
<li>创建项目</li>
<li>创建文件</li>
<li>编写代码</li>
<li>运行程序</li>
</ul>
<h4 id="1-1-1-创建项目"><a href="#1-1-1-创建项目" class="headerlink" title="1.1.1 创建项目"></a>1.1.1 创建项目</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</span><br></pre></td></tr></table></figure>


<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541383178746.png" alt="1541383178746"></p>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541384366413.png" alt="1541384366413"></p>
<h4 id="1-1-2-创建文件"><a href="#1-1-2-创建文件" class="headerlink" title="1.1.2 创建文件"></a>1.1.2 创建文件</h4><p>右键源文件，选择添加-&gt;新建项</p>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541383817248.png" alt="1541383817248"></p>
<p>给C++文件起个名称，然后点击添加即可。</p>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541384140042.png" alt="1541384140042"></p>
<h4 id="1-1-3-编写代码"><a href="#1-1-3-编写代码" class="headerlink" title="1.1.3 编写代码"></a>1.1.3 编写代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-4-运行程序"><a href="#1-1-4-运行程序" class="headerlink" title="1.1.4 运行程序"></a>1.1.4 运行程序</h4><p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541384818688.png" alt="1541384818688"></p>
<h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</p>
<p><strong>两种格式</strong></p>
<ol>
<li><strong>单行注释</strong>：<code>// 描述信息</code><ul>
<li>通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明==</li>
</ul>
</li>
<li><strong>多行注释</strong>： <code>/* 描述信息 */</code><ul>
<li>通常放在一段代码的上方，==对该段代码做整体说明==</li>
</ul>
</li>
</ol>
<blockquote>
<p>提示：编译器在编译代码时，会忽略注释的内容</p>
</blockquote>
<h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p>
<p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//变量的定义</span></span><br><span class="line">	<span class="comment">//语法：数据类型  变量名 = 初始值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p>
</blockquote>
<h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4  常量"></a>1.4  常量</h3><p><strong>作用</strong>：用于记录程序中不可更改的数据</p>
<p>C++定义常量两种方式</p>
<ol>
<li><p><strong>#define</strong> 宏常量： <code>#define 常量名 常量值</code></p>
<ul>
<li>==通常在文件上方定义==，表示一个常量</li>
</ul>
</li>
<li><p><strong>const</strong>修饰的变量 <code>const 数据类型 常量名 = 常量值</code></p>
<ul>
<li>==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改</li>
</ul>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、宏常量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> day 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一周里总共有 &quot;</span> &lt;&lt; day &lt;&lt; <span class="string">&quot; 天&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//day = 8;  //报错，宏常量不可以修改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、const修饰变量</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> month = <span class="number">12</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一年里总共有 &quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot; 个月份&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//month = 24; //报错，常量是不可以修改的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p><strong>作用：</strong>关键字是C++中预先保留的单词（标识符）</p>
<ul>
<li><strong>在定义变量或者常量时候，不要用关键字</strong></li>
</ul>
<p>C++关键字如下：</p>
<table>
<thead>
<tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr>
</thead>
<tbody><tr>
<td><strong>auto</strong></td>
<td><strong>double</strong></td>
<td><strong>inline</strong></td>
<td><strong>short</strong></td>
<td><strong>typeid</strong></td>
</tr>
<tr>
<td><strong>bool</strong></td>
<td><strong>dynamic_cast</strong></td>
<td><strong>int</strong></td>
<td><strong>signed</strong></td>
<td><strong>typename</strong></td>
</tr>
<tr>
<td><strong>break</strong></td>
<td><strong>else</strong></td>
<td><strong>long</strong></td>
<td><strong>sizeof</strong></td>
<td><strong>union</strong></td>
</tr>
<tr>
<td><strong>case</strong></td>
<td><strong>enum</strong></td>
<td><strong>mutable</strong></td>
<td><strong>static</strong></td>
<td><strong>unsigned</strong></td>
</tr>
<tr>
<td><strong>catch</strong></td>
<td><strong>explicit</strong></td>
<td><strong>namespace</strong></td>
<td><strong>static_cast</strong></td>
<td><strong>using</strong></td>
</tr>
<tr>
<td><strong>char</strong></td>
<td><strong>export</strong></td>
<td><strong>new</strong></td>
<td><strong>struct</strong></td>
<td><strong>virtual</strong></td>
</tr>
<tr>
<td><strong>class</strong></td>
<td><strong>extern</strong></td>
<td><strong>operator</strong></td>
<td><strong>switch</strong></td>
<td><strong>void</strong></td>
</tr>
<tr>
<td><strong>const</strong></td>
<td><strong>false</strong></td>
<td><strong>private</strong></td>
<td><strong>template</strong></td>
<td><strong>volatile</strong></td>
</tr>
<tr>
<td><strong>const_cast</strong></td>
<td><strong>float</strong></td>
<td><strong>protected</strong></td>
<td><strong>this</strong></td>
<td><strong>wchar_t</strong></td>
</tr>
<tr>
<td><strong>continue</strong></td>
<td><strong>for</strong></td>
<td><strong>public</strong></td>
<td><strong>throw</strong></td>
<td><strong>while</strong></td>
</tr>
<tr>
<td><strong>default</strong></td>
<td><strong>friend</strong></td>
<td><strong>register</strong></td>
<td><strong>true</strong></td>
<td><strong>try</strong></td>
</tr>
<tr>
<td><strong>delete</strong></td>
<td><strong>goto</strong></td>
<td><strong>reinterpret_cast</strong></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><code>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</code></p>
<h3 id="1-6-标识符命名规则"><a href="#1-6-标识符命名规则" class="headerlink" title="1.6 标识符命名规则"></a>1.6 标识符命名规则</h3><p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p>
<ul>
<li>标识符不能是关键字</li>
<li>标识符只能由字母、数字、下划线组成</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<blockquote>
<p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p>
</blockquote>
<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h2><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p>
<h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><p><strong>作用</strong>：整型变量表示的是==整数类型==的数据</p>
<p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>short(短整型)</td>
<td>2字节</td>
<td>(-2^15 ~ 2^15-1)</td>
</tr>
<tr>
<td>int(整型)</td>
<td>4字节</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long(长整形)</td>
<td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long long(长长整形)</td>
<td>8字节</td>
<td>(-2^63 ~ 2^63-1)</td>
</tr>
</tbody></table>
<h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p><strong>作用：</strong>利用sizeof关键字可以==统计数据类型所占内存大小==</p>
<p><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">short</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>整型结论</strong>：==short &lt; int &lt;= long &lt;= long long==</p>
</blockquote>
<h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p><strong>作用</strong>：用于==表示小数==</p>
<p>浮点型变量分为两种：</p>
<ol>
<li>单精度float</li>
<li>双精度double</li>
</ol>
<p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th><strong>有效数字范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15～16位有效数字</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line">	<span class="keyword">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; d1&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(f1) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(d1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//科学计数法</span></span><br><span class="line">	<span class="keyword">float</span> f2 = <span class="number">3e2</span>; <span class="comment">// 3 * 10 ^ 2 </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> f3 = <span class="number">3e-2</span>;  <span class="comment">// 3 * 0.1 ^ 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p><strong>作用：</strong>字符型变量用于显示单个字符</p>
<p><strong>语法：</strong><code>char ch = &#39;a&#39;;</code></p>
<blockquote>
<p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p>
</blockquote>
<blockquote>
<p>注意2：单引号内只能有一个字符，不可以是字符串</p>
</blockquote>
<ul>
<li>C和C++中字符型变量只占用==1个字节==。</li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span></span><br><span class="line">	<span class="comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="keyword">int</span>)ch &lt;&lt; endl;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">	ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p><strong>作用：</strong>用于表示一些==不能显示出来的ASCII字符==</p>
<p>现阶段我们常用的转义字符有：<code> \n  \\  \t</code></p>
<table>
<thead>
<tr>
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td><strong>010</strong></td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td>
<td><strong>009</strong></td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>*<em>\\*</em></td>
<td><strong>代表一个反斜线字符”&quot;</strong></td>
<td><strong>092</strong></td>
</tr>
<tr>
<td>&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>16进制转义字符，h范围0<del>9，a</del>f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\tHello&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p><strong>作用</strong>：用于表示一串字符</p>
<p><strong>两种风格</strong></p>
<ol>
<li><p><strong>C风格字符串</strong>： <code>char 变量名[] = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意：C风格的字符串要用双引号括起来</p>
</blockquote>
<ol>
<li><p><strong>C++风格字符串</strong>：  <code>string  变量名 = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意：C++风格字符串，需要加入头文件==#include&lt;string&gt;==</p>
</blockquote>
<h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><p><strong>作用：</strong>布尔数据类型代表真或假的值</p>
<p>bool类型只有两个值：</p>
<ul>
<li>true  — 真（本质是1）</li>
<li>false — 假（本质是0）</li>
</ul>
<p><strong>bool类型占==1个字节==大小</strong></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	flag = <span class="literal">false</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of bool = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">bool</span>) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-8-数据的输入"><a href="#2-8-数据的输入" class="headerlink" title="2.8 数据的输入"></a>2.8 数据的输入</h3><p><strong>作用：用于从键盘获取数据</strong></p>
<p><strong>关键字：</strong>cin</p>
<p><strong>语法：</strong> <code>cin &gt;&gt; 变量 </code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//整型输入</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//浮点型输入</span></span><br><span class="line">	<span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; d;</span><br><span class="line">	cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符型输入</span></span><br><span class="line">	<span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串型输入</span></span><br><span class="line">	string str;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//布尔类型输入</span></span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; flag;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2><p><strong>作用：</strong>用于执行代码的运算</p>
<p>本章我们主要讲解以下几类运算符：</p>
<table>
<thead>
<tr>
<th><strong>运算符类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>算术运算符</td>
<td>用于处理四则运算</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>用于将表达式的值赋给变量</td>
</tr>
<tr>
<td>比较运算符</td>
<td>用于表达式的比较，并返回一个真值或假值</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>用于根据表达式的值返回真值或假值</td>
</tr>
</tbody></table>
<h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><p><strong>作用</strong>：用于处理四则运算</p>
<p>算术运算符包括以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>正号</td>
<td>+3</td>
<td>3</td>
</tr>
<tr>
<td>-</td>
<td>负号</td>
<td>-3</td>
<td>-3</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>10 / 5</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>取模(取余)</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr>
<td>++</td>
<td>前置递增</td>
<td>a=2; b=++a;</td>
<td>a=3; b=3;</td>
</tr>
<tr>
<td>++</td>
<td>后置递增</td>
<td>a=2; b=a++;</td>
<td>a=3; b=2;</td>
</tr>
<tr>
<td>–</td>
<td>前置递减</td>
<td>a=2; b=–a;</td>
<td>a=1; b=1;</td>
</tr>
<tr>
<td>–</td>
<td>后置递减</td>
<td>a=2; b=a–;</td>
<td>a=1; b=2;</td>
</tr>
</tbody></table>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加减乘除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a1 + b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 - b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 * b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 / b1 &lt;&lt; endl;  <span class="comment">//两个整数相除结果依然是整数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b2 = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; a2 / b2 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b3 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数可以相除</span></span><br><span class="line">	<span class="keyword">double</span> d1 = <span class="number">0.5</span>;</span><br><span class="line">	<span class="keyword">double</span> d2 = <span class="number">0.25</span>;</span><br><span class="line">	cout &lt;&lt; d1 / d2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：在除法运算中，除数不能为0</p>
</blockquote>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取模</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a2 % b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数不可以取模</span></span><br><span class="line">	<span class="keyword">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line">	<span class="keyword">double</span> d2 = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：只有整型变量可以进行取模运算</p>
</blockquote>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递增</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a++; <span class="comment">//等价于a = a + 1</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//前置递增</span></span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">	++b;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//区别</span></span><br><span class="line">	<span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line">	<span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line">	<span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p>
</blockquote>
<h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><p><strong>作用：</strong>用于将表达式的值赋给变量</p>
<p>赋值运算符包括以下几个符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>赋值</td>
<td>a=2; b=3;</td>
<td>a=2; b=3;</td>
</tr>
<tr>
<td>+=</td>
<td>加等于</td>
<td>a=0; a+=2;</td>
<td>a=2;</td>
</tr>
<tr>
<td>-=</td>
<td>减等于</td>
<td>a=5; a-=3;</td>
<td>a=2;</td>
</tr>
<tr>
<td>*=</td>
<td>乘等于</td>
<td>a=2; a*=2;</td>
<td>a=4;</td>
</tr>
<tr>
<td>/=</td>
<td>除等于</td>
<td>a=4; a/=2;</td>
<td>a=2;</td>
</tr>
<tr>
<td>%=</td>
<td>模等于</td>
<td>a=3; a%2;</td>
<td>a=1;</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// =</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// +=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a += <span class="number">2</span>; <span class="comment">// a = a + 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a -= <span class="number">2</span>; <span class="comment">// a = a - 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a *= <span class="number">2</span>; <span class="comment">// a = a * 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// /=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a /= <span class="number">2</span>;  <span class="comment">// a = a / 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// %=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a %= <span class="number">2</span>;  <span class="comment">// a = a % 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p><strong>作用：</strong>用于表达式的比较，并返回一个真值或假值</p>
<p>比较运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>相等于</td>
<td>4 == 3</td>
<td>0</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>4 != 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>4 &lt;= 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>4 &gt;= 1</td>
<td>1</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a == b) &lt;&lt; endl; <span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a != b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &gt; b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &lt; b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。==</p>
</blockquote>
<h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><p><strong>作用：</strong>用于根据表达式的值返回真值或假值</p>
<p>逻辑运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真；  如果a为真，则!a为假。</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>a &amp;&amp; b</td>
<td>如果a和b都为真，则结果为真，否则为假。</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
<td>a|| b</td>
<td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td>
</tr>
</tbody></table>
<p><strong>示例1：</strong>逻辑非</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 非</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !a &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !!a &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结： 真变假，假变真</p>
</blockquote>
<p><strong>示例2：</strong>逻辑与</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 与</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：逻辑==与==运算符总结： ==同真为真，其余为假==</p>
</blockquote>
<p><strong>示例3：</strong>逻辑或</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 或</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>逻辑==或==运算符总结： ==同假为假，其余为真==</p>
</blockquote>
<h3 id="3-5-位运算符"><a href="#3-5-位运算符" class="headerlink" title="3.5 位运算符"></a>3.5 位运算符</h3><p>位运算符作用于位，并逐位执行操作。&amp;，|和 ^ 的真值表如下：</p>
<table>
<thead>
<tr>
<th>p</th>
<th>q</th>
<th>p&amp;q</th>
<th>p|q</th>
<th>p^q</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<blockquote>
<p>假设 A=60，B=13，现在以二进制格式表示：A=0011 1100，B=0000 1101</p>
<p>A&amp;B=0000 1100</p>
<p>A|B=0011 1101</p>
<p>A^B=0011 0001</p>
<p>~A=1100 0011</p>
</blockquote>
<p><strong>左移和右移运算符</strong></p>
<blockquote>
<p>&lt;&lt;    二进制左移运算符，将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</p>
<p>A&lt;&lt;2等到240，即为1111 0000</p>
<p>&gt;&gt;    二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</p>
<p>A&gt;&gt;2得到15，即为0000 1111</p>
</blockquote>
<h3 id="3-6-条件运算符"><a href="#3-6-条件运算符" class="headerlink" title="3.6 条件运算符"></a>3.6 条件运算符</h3><p>用来替代 <strong>if…else</strong> 语句。它的一般形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exp1 ? Exp2 : Exp3;</span><br></pre></td></tr></table></figure>

<p>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</p>
<p>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</p>
<h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4 程序流程结构"></a>4 程序流程结构</h2><p>C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==</p>
<ul>
<li>顺序结构：程序按顺序执行，不发生跳转</li>
<li>选择结构：依据条件是否满足，有选择的执行相应功能</li>
<li>循环结构：依据条件是否满足，循环多次执行某段代码</li>
</ul>
<h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><p><strong>作用：</strong>执行满足条件的语句</p>
<p>if语句的三种形式</p>
<ul>
<li>单行格式if语句</li>
<li>多行格式if语句</li>
<li>多条件的if语句</li>
</ul>
<ol>
<li><p>单行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;</code></p>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/clip_image002.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选择结构-单行if语句</span></span><br><span class="line">	<span class="comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入一个分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;您输入的分数为： &quot;</span> &lt;&lt; score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if语句</span></span><br><span class="line">	<span class="comment">//注意事项，在if判断语句后面，不要加分号</span></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意：if条件表达式后不要加分号</p>
</blockquote>
<ol start="2">
<li>多行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;</code></li>
</ol>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/clip_image002-1541662519170.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>多条件的if语句：<code>if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;</code></li>
</ol>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/clip_image002-1541662566808.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p>
<p>案例需求：</p>
<ul>
<li>提示用户输入一个高考考试分数，根据分数做如下判断</li>
<li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li>
<li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了北大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了清华&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了人大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>练习案例：</strong> 三只小猪称体重</p>
<p>有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？<img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/%E4%B8%89%E5%8F%AA%E5%B0%8F%E7%8C%AA.jpg" alt="三只小猪"></p>
<h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p><strong>作用：</strong> 通过三目运算符实现简单的判断</p>
<p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p>
<p><strong>解释：</strong></p>
<p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p>
<p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	c = a &gt; b ? a : b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line"></span><br><span class="line">	(a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p>
</blockquote>
<h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><p><strong>作用：</strong>执行多条件分支语句</p>
<p><strong>语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span>(表达式)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">1</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">2</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//请给电影评分 </span></span><br><span class="line">	<span class="comment">//10 ~ 9   经典   </span></span><br><span class="line">	<span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line">	<span class="comment">// 6 ~ 5   一般</span></span><br><span class="line">	<span class="comment">// 5分以下 烂片</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (score)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;经典&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;非常好&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;一般&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意1：switch语句中表达式类型只能是整型或者字符型</p>
</blockquote>
<blockquote>
<p>注意2：case里如果没有break，那么程序会一直向下执行</p>
</blockquote>
<blockquote>
<p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p>
</blockquote>
<h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><p><strong>作用：</strong>满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code> while(循环条件)&#123; 循环语句 &#125;</code></p>
<p><strong>解释：</strong>==只要循环条件的结果为真，就执行循环语句==</p>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/clip_image002-1541668640382.png" alt="img"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p>
</blockquote>
<p><strong>while循环练习案例：</strong>==猜数字==</p>
<p><strong>案例描述：</strong>系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。</p>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/%E7%8C%9C%E6%95%B0%E5%AD%97.jpg" alt="猜数字"></p>
<h4 id="4-2-2-do…while循环语句"><a href="#4-2-2-do…while循环语句" class="headerlink" title="4.2.2 do…while循环语句"></a>4.2.2 do…while循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong> <code>do&#123; 循环语句 &#125; while(循环条件);</code></p>
<p><strong>注意：</strong>与while的区别在于==do…while会先执行一次循环语句==，再判断循环条件</p>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/clip_image002-1541671163478.png" alt="img"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件</p>
</blockquote>
<p><strong>练习案例：水仙花数</strong></p>
<p><strong>案例描述：</strong>水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身</p>
<p>例如：1^3 + 5^3+ 3^3 = 153</p>
<p>请利用do…while语句，求出所有3位数中的水仙花数</p>
<h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code> for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>详解：</strong></p>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541673704101.png" alt="1541673704101"></p>
<blockquote>
<p>注意：for循环中的表达式，要用分号进行分隔</p>
</blockquote>
<blockquote>
<p>总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p>
</blockquote>
<p><strong>练习案例：敲桌子</strong></p>
<p>案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。</p>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/timg.gif" alt="timg"></p>
<h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p><strong>作用：</strong> 在循环体中再嵌套一层循环，解决一些实际问题</p>
<p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541676003486.png" alt="1541676003486"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//外层循环执行1次，内层循环执行1轮</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>练习案例：</strong>乘法口诀表</p>
<p>案例描述：利用嵌套循环，实现九九乘法表</p>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/0006018857256120_b.jpg" alt="0006018857256120_b"></p>
<h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p><strong>作用:</strong> 用于跳出==选择结构==或者==循环结构==</p>
<p>break使用的时机：</p>
<ul>
<li>出现在switch条件语句中，作用是终止case并跳出switch</li>
<li>出现在循环语句中，作用是跳出当前的循环语句</li>
<li>出现在嵌套循环中，跳出最近的内层循环语句</li>
</ul>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、在switch 语句中使用break</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择您挑战副本的难度：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、普通&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、中等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3、困难&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (num)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是普通难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是中等难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是困难难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//2、在循环语句中用break</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//跳出循环语句</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在嵌套循环语句中使用break，退出内层循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p><strong>作用：</strong>在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：continue并没有使整个循环终止，而break会跳出循环</p>
</blockquote>
<h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><p><strong>作用：</strong>可以无条件跳转语句</p>
<p><strong>语法：</strong> <code>goto 标记;</code></p>
<p><strong>解释：</strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> FLAG;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	FLAG:</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p>
</blockquote>
<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p>
<p><strong>特点1：</strong>数组中的每个==数据元素都是相同的数据类型==</p>
<p><strong>特点2：</strong>数组是由==连续的内存==位置组成的</p>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541748375356.png" alt="1541748375356"></p>
<h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组定义方式"><a href="#5-2-1-一维数组定义方式" class="headerlink" title="5.2.1 一维数组定义方式"></a>5.2.1 一维数组定义方式</h4><p>一维数组定义的三种方式：</p>
<ol>
<li><code>数据类型  数组名[ 数组长度 ];</code></li>
<li><code>数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;</code></li>
<li><code>数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;</code></li>
</ol>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式1</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数];</span></span><br><span class="line">	<span class="keyword">int</span> score[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标赋值</span></span><br><span class="line">	score[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">	score[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">	score[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标输出</span></span><br><span class="line">	cout &lt;&lt; score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种定义方式</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span></span><br><span class="line">	<span class="keyword">int</span> score2[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逐个输出</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score2[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="keyword">int</span> score3[] = &#123; <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score3[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p>
</blockquote>
<blockquote>
<p>总结2：数组中下标是从0开始索引</p>
</blockquote>
<h4 id="5-2-2-一维数组数组名"><a href="#5-2-2-一维数组数组名" class="headerlink" title="5.2.2 一维数组数组名"></a>5.2.2 一维数组数组名</h4><p>一维数组名称的<strong>用途</strong>：</p>
<ol>
<li>可以统计整个数组在内存中的长度</li>
<li>可以获取数组在内存中的首地址</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//数组名用途</span></span><br><span class="line">	<span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：数组名是常量，不可以赋值</p>
</blockquote>
<blockquote>
<p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小</p>
</blockquote>
<p><strong>练习案例1</strong>：五只小猪称体重</p>
<p><strong>案例描述：</strong></p>
<p>在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};</p>
<p>找出并打印最重的小猪体重。</p>
<p><strong>练习案例2：</strong>数组元素逆置</p>
<p><strong>案例描述：</strong>请声明一个5个元素的数组，并且将元素逆置.</p>
<p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p>
<h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4><p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li>
<li>重复以上的步骤，每次比较次数-1，直到不需要比较</li>
</ol>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541905327273.png" alt="1541905327273"></p>
<p><strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">9</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><p>二维数组就是在一维数组上，多加一个维度。</p>
<p><img src="/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1541905559138.png" alt="1541905559138"></p>
<h4 id="5-3-1-二维数组定义方式"><a href="#5-3-1-二维数组定义方式" class="headerlink" title="5.3.1 二维数组定义方式"></a>5.3.1 二维数组定义方式</h4><p>二维数组定义的四种方式：</p>
<ol>
<li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
<li><code> 数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
</ol>
<blockquote>
<p>建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==</p>
</blockquote>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式1  </span></span><br><span class="line">	<span class="comment">//数组类型 数组名 [行数][列数]</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式2 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span></span><br><span class="line">	<span class="keyword">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="keyword">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式4 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="keyword">int</span> arr4[][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p>
</blockquote>
<h4 id="5-3-2-二维数组数组名"><a href="#5-3-2-二维数组数组名" class="headerlink" title="5.3.2 二维数组数组名"></a>5.3.2 二维数组数组名</h4><ul>
<li>查看二维数组所占内存空间</li>
<li>获取二维数组首地址</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二维数组数组名</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组列数： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]) / <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结1：二维数组名就是这个数组的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p>
</blockquote>
<h4 id="5-3-3-二维数组应用案例"><a href="#5-3-3-二维数组应用案例" class="headerlink" title="5.3.3 二维数组应用案例"></a><strong>5.3.3 二维数组应用案例</strong></h4><p><strong>考试成绩统计：</strong></p>
<p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>100</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>李四</td>
<td>90</td>
<td>50</td>
<td>100</td>
</tr>
<tr>
<td>王五</td>
<td>60</td>
<td>70</td>
<td>80</td>
</tr>
</tbody></table>
<p><strong>参考答案：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> scores[<span class="number">3</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">90</span>,<span class="number">50</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	string names[<span class="number">3</span>] = &#123; <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += scores[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; names[i] &lt;&lt; <span class="string">&quot;同学总成绩为： &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码</p>
<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>
<h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般主要有5个步骤：</p>
<p>1、返回值类型</p>
<p>2、函数名</p>
<p>3、参数表列</p>
<p>4、函数体语句</p>
<p>5、return 表达式</p>
<p><strong>语法:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       函数体语句</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>表达式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li>
<li>函数名：给函数起个名称</li>
<li>参数列表：使用该函数时，传入的数据</li>
<li>函数体语句：花括号内的代码，函数内需要执行的语句</li>
<li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li>
</ul>
<p><strong>示例：</strong>定义一个加法函数，实现两个数相加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><p><strong>功能：</strong>使用定义好的函数</p>
<p><strong>语法：</strong><code> 函数名（参数）</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> <span class="comment">//定义中的num1,num2称为形式参数，简称形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//调用add函数</span></span><br><span class="line">	<span class="keyword">int</span> sum = <span class="built_in">add</span>(a, b);<span class="comment">//调用时的a，b称为实际参数，简称实参</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	sum = <span class="built_in">add</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p>
</blockquote>
<h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><ul>
<li>所谓值传递，就是函数调用时实参将数值传入给形参</li>
<li>值传递时，==如果形参发生，并不会影响实参==</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> temp = num1;</span><br><span class="line">	num1 = num2;</span><br><span class="line">	num2 = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//return ; 当函数声明时候，不需要返回值，可以不写return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian中的 a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian中的 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结： 值传递时，形参是修饰不了实参的</p>
</blockquote>
<h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a><strong>6.5 函数的常见样式</strong></h3><p>常见的函数样式有4种</p>
<ol>
<li>无参无返</li>
<li>有参无返</li>
<li>无参有返</li>
<li>有参有返</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数常见样式</span></span><br><span class="line"><span class="comment">//1、 无参无返</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//void a = 10; //无类型不可以创建变量,原因无法分配内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test01&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//test01(); 函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、 有参无返</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test02&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、无参有返</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test03 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、有参有返</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test04</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test04 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span> sum = a + b;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><p><strong>作用：</strong> 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<ul>
<li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明可以多次，定义只能一次</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 函数的分文件编写"></a>6.7 函数的分文件编写</h3><p><strong>作用：</strong>让代码结构更加清晰</p>
<p>函数分文件编写一般有4个步骤</p>
<ol>
<li>创建后缀名为.h的头文件</li>
<li>创建后缀名为.cpp的源文件</li>
<li>在头文件中写函数的声明</li>
<li>在源文件中写函数的定义</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p>
<ul>
<li>内存编号是从0开始记录的，一般用十六进制数字表示</li>
<li>可以利用指针变量保存地址</li>
</ul>
<h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><p>指针变量定义语法： <code>数据类型 * 变量名；</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、指针的定义</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量a</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class="line">	<span class="keyword">int</span> * p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量赋值</span></span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向变量a的地址</span></span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="comment">//打印数据a的地址</span></span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;  <span class="comment">//打印指针变量p</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、指针的使用</span></span><br><span class="line">	<span class="comment">//通过*操作指针变量指向的内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针变量和普通变量的区别</p>
<ul>
<li>普通变量存放的是数据,指针变量存放的是地址</li>
<li>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用</li>
</ul>
<blockquote>
<p>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p>
</blockquote>
<blockquote>
<p>总结2：利用指针可以记录地址</p>
</blockquote>
<blockquote>
<p>总结3：对指针变量解引用，可以操作指针指向的内存</p>
</blockquote>
<h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3><p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> * p;</span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//* 解引用</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span> *) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：所有指针类型在32位操作系统下是4个字节</p>
</blockquote>
<h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p>
<p><strong>用途：</strong>初始化指针变量</p>
<p><strong>注意：</strong>空指针指向的内存是不可以访问的</p>
<p><strong>示例1：空指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line">	<span class="keyword">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问空指针报错 </span></span><br><span class="line">	<span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>野指针</strong>：指针变量指向非法的内存空间</p>
<p><strong>示例2：野指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line">	<span class="keyword">int</span> * p = (<span class="keyword">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问野指针报错 </span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p>
</blockquote>
<h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const修饰指针有三种情况</p>
<ol>
<li>const修饰指针   — 常量指针</li>
<li>const修饰常量   — 指针常量</li>
<li>const即修饰指针，又修饰常量</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> * p1 = &amp;a; </span><br><span class="line">	p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">	<span class="comment">//*p1 = 100;  报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">	<span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">	<span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">	*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line">	<span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line">	<span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>
</blockquote>
<h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3><p><strong>作用：</strong>利用指针访问数组中元素</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> * p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//利用指针遍历数组</span></span><br><span class="line">		cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3><p><strong>作用：</strong>利用指针作函数参数，可以修改实参的值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b; </span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> * p1, <span class="keyword">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = *p1;</span><br><span class="line">	*p1 = *p2;</span><br><span class="line">	*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">swap1</span>(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>
</blockquote>
<h3 id="7-8-指针、数组、函数"><a href="#7-8-指针、数组、函数" class="headerlink" title="7.8 指针、数组、函数"></a>7.8 指针、数组、函数</h3><p><strong>案例描述：</strong>封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>
<p>例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printArray</span>(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>
</blockquote>
<h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型</p>
<h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><p><strong>语法：</strong><code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></p>
<p>通过结构体创建变量的方式有三种：</p>
<ul>
<li>struct 结构体名 变量名</li>
<li>struct 结构体名 变量名 = { 成员1值 ， 成员2值…}</li>
<li>定义结构体时顺便创建变量</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;stu3; <span class="comment">//结构体变量创建方式3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式1</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span> <span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">	stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	stu1.age = <span class="number">18</span>;</span><br><span class="line">	stu1.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式2</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu2</span> =</span> &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stu3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">	stu3.age = <span class="number">18</span>;</span><br><span class="line">	stu3.score = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结1：定义结构体时的关键字是struct，不可省略</p>
</blockquote>
<blockquote>
<p>总结2：创建结构体变量时，关键字struct可以省略</p>
</blockquote>
<blockquote>
<p>总结3：结构体变量利用操作符 ‘’.’’  访问成员</p>
</blockquote>
<h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p><strong>作用：</strong>将自定义的结构体放入到数组中方便维护</p>
<p><strong>语法：</strong><code> struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体数组</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">arr</span>[3]=</span></span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">70</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p><strong>作用：</strong>通过指针访问结构体中的成员</p>
<ul>
<li>利用操作符 <code>-&gt; </code>可以通过结构体指针访问结构体属性</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>, &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> * <span class="title">p</span> =</span> &amp;stu;</span><br><span class="line"></span><br><span class="line">	p-&gt;score = <span class="number">80</span>; <span class="comment">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p>
</blockquote>
<h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p>
<p><strong>例如：</strong>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line">	<span class="keyword">int</span> id; <span class="comment">//职工编号</span></span><br><span class="line">	string name;  <span class="comment">//教师姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;   <span class="comment">//教师年龄</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span> <span class="comment">//子结构体 学生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">teacher</span> <span class="title">t1</span>;</span></span><br><span class="line">	t1.id = <span class="number">10000</span>;</span><br><span class="line">	t1.name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">	t1.age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">	t1.stu.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	t1.stu.age = <span class="number">18</span>;</span><br><span class="line">	t1.stu.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;教师 职工编号： &quot;</span> &lt;&lt; t1.id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t1.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; t1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;辅导学员 姓名： &quot;</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="string">&quot; 考试分数： &quot;</span> &lt;&lt; t1.stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>
<h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p><strong>作用：</strong>将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<ul>
<li>值传递</li>
<li>地址传递</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(student stu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu.age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>&#125;;</span><br><span class="line">	<span class="comment">//值传递</span></span><br><span class="line">	<span class="built_in">printStudent</span>(stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址传递</span></span><br><span class="line">	<span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>
</blockquote>
<h3 id="8-7-结构体中-const使用场景"><a href="#8-7-结构体中-const使用场景" class="headerlink" title="8.7 结构体中 const使用场景"></a>8.7 结构体中 const使用场景</h3><p><strong>作用：</strong>用const来防止误操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(<span class="keyword">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printStudent</span>(&amp;stu);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><h4 id="8-8-1-案例1"><a href="#8-8-1-案例1" class="headerlink" title="8.8.1 案例1"></a>8.8.1 案例1</h4><p><strong>案例描述：</strong></p>
<p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p>
<p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p>
<p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p>
<p>最终打印出老师数据以及老师所带的学生数据。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	string name;</span><br><span class="line">	Student sArray[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocateSpace</span><span class="params">(Teacher tArray[] , <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string tName = <span class="string">&quot;教师&quot;</span>;</span><br><span class="line">	string sName = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tArray[i].name = tName + nameSeed[i];</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tArray[i].sArray[j].name = sName + nameSeed[j];</span><br><span class="line">			tArray[i].sArray[j].score = <span class="built_in">rand</span>() % <span class="number">61</span> + <span class="number">40</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTeachers</span><span class="params">(Teacher tArray[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; tArray[i].name &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;\t姓名：&quot;</span> &lt;&lt; tArray[i].sArray[j].name &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//随机数种子 头文件 #include &lt;ctime&gt;</span></span><br><span class="line"></span><br><span class="line">	Teacher tArray[<span class="number">3</span>]; <span class="comment">//老师数组</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(tArray) / <span class="built_in"><span class="keyword">sizeof</span></span>(Teacher);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">allocateSpace</span>(tArray, len); <span class="comment">//创建数据</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printTeachers</span>(tArray, len); <span class="comment">//打印数据</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-8-2-案例2"><a href="#8-8-2-案例2" class="headerlink" title="8.8.2 案例2"></a>8.8.2 案例2</h4><p><strong>案例描述：</strong></p>
<p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p>
<p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p>
<p>五名英雄信息如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//英雄结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hero</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	string sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(hero arr[] , <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j].age &gt; arr[j + <span class="number">1</span>].age)</span><br><span class="line">			&#123;</span><br><span class="line">				hero temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHeros</span><span class="params">(hero arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 性别： &quot;</span> &lt;&lt; arr[i].sex &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; arr[i].age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hero</span> <span class="title">arr</span>[5] =</span></span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(hero); <span class="comment">//获取数组元素个数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printHeros</span>(arr, len); <span class="comment">//打印</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-补充"><a href="#9-补充" class="headerlink" title="9 补充"></a>9 补充</h2><h3 id="9-1-条件编译"><a href="#9-1-条件编译" class="headerlink" title="9.1 条件编译"></a>9.1 条件编译</h3><p><strong>#if 0 … #endif</strong> 属于条件编译，0 即为参数。</p>
<p>此外，我们还可以使用 <strong>#if 0 … #endif</strong> 来实现注释，且可以实现嵌套，格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if 0</span><br><span class="line">   code</span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>

<p>你可以把 <strong>#if 0</strong> 改成 <strong>#if 1</strong> 来执行 <strong>code</strong> 的代码。</p>
<p>这种形式对程序调试也可以帮助，测试时使用 <strong>#if 1</strong> 来执行测试代码，发布后使用 <strong>#if 0</strong> 来屏蔽测试代码。</p>
<p><strong>#if</strong> 后可以是任意的条件语句。</p>
<p>下面的代码如果 condition 条件为 true 执行 code1 ，否则执行 code2。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if condition</span><br><span class="line">  code1</span><br><span class="line">#else</span><br><span class="line">  code2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>



<h3 id="9-2-数据类型"><a href="#9-2-数据类型" class="headerlink" title="9.2 数据类型"></a>9.2 数据类型</h3><p><strong>基本的内置类型</strong></p>
<p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">布尔型</td>
<td align="left">bool</td>
</tr>
<tr>
<td align="left">字符型</td>
<td align="left">char</td>
</tr>
<tr>
<td align="left">整型</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">浮点型</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">双浮点型</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">无类型</td>
<td align="left">void</td>
</tr>
<tr>
<td align="left">宽字符型</td>
<td align="left">wchar_t</td>
</tr>
</tbody></table>
<p>其实 wchar_t 是这样来的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef short int wchar_t;</span><br></pre></td></tr></table></figure>

<p>所以 wchar_t 实际上的空间是和 short int 一样。</p>
<p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p>
<ul>
<li>signed</li>
<li>unsigned</li>
<li>short</li>
<li>long</li>
</ul>
<p>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。</p>
<p><strong>注意：</strong>不同系统会有所差异，一字节为 8 位。</p>
<p><strong>注意：</strong>默认情况下，int、short、long都是带符号的，即 signed。</p>
<p><strong>注意：</strong>long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">位</th>
<th align="left">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="left">1 个字节</td>
<td align="left">-128 到 127 或者 0 到 255</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td align="left">1 个字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left">signed char</td>
<td align="left">1 个字节</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="left">4 个字节</td>
<td align="left">0 到 4294967295</td>
</tr>
<tr>
<td align="left">signed int</td>
<td align="left">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">short int</td>
<td align="left">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="left">unsigned short int</td>
<td align="left">2 个字节</td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left">signed short int</td>
<td align="left">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="left">long int</td>
<td align="left">8 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left">signed long int</td>
<td align="left">8 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left">unsigned long int</td>
<td align="left">8 个字节</td>
<td align="left">0 到 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">4 个字节</td>
<td align="left">精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">8 个字节</td>
<td align="left">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td>
</tr>
<tr>
<td align="left">long double</td>
<td align="left">16 个字节</td>
<td align="left">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td>
</tr>
<tr>
<td align="left">wchar_t</td>
<td align="left">2 或 4 个字节</td>
<td align="left">1 个宽字符</td>
</tr>
</tbody></table>
<h3 id="9-3-枚举类型"><a href="#9-3-枚举类型" class="headerlink" title="9.3 枚举类型"></a>9.3 枚举类型</h3><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>
<p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>
<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum 枚举名&#123; </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>如果枚举没有初始化, 即省掉”=整型常数”时, 则从第一个标识符开始。</p>
<p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum color &#123; red, green, blue &#125; c;</span><br><span class="line">c = blue;</span><br></pre></td></tr></table></figure>

<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，<strong>green</strong> 的值为 5。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum color &#123; red, green=5, blue &#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>blue</strong> 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p>
<h3 id="9-4-常量及其定义"><a href="#9-4-常量及其定义" class="headerlink" title="9.4 常量及其定义"></a>9.4 常量及其定义</h3><p><strong>整数常量</strong></p>
<blockquote>
<p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p>
<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p>
</blockquote>
<p>下面列举几个整数常量的实例：</p>
<blockquote>
<p>212         // 合法的 </p>
<p>215u        // 合法的 </p>
<p>0xFeeL      // 合法的 </p>
<p>078         // 非法的：8 不是八进制的数字 </p>
<p>032UU       // 非法的：不能重复后缀</p>
</blockquote>
<p>以下是各种类型的整数常量的实例：</p>
<blockquote>
<p>85         // 十进制 </p>
<p>0213       // 八进制  </p>
<p>0x4b       // 十六进制  </p>
<p>30         // 整数  </p>
<p>30u        // 无符号整数  </p>
<p>30l        // 长整数  </p>
<p>30ul       // 无符号长整数</p>
</blockquote>
<p><strong>浮点常量</strong></p>
<blockquote>
<p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p>
<p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p>
</blockquote>
<p>下面列举几个浮点常量的实例：</p>
<blockquote>
<p>3.14159       // 合法的  </p>
<p>314159E-5L    // 合法的  </p>
<p>510E          // 非法的：不完整的指数 </p>
<p>210f          // 非法的：没有小数或指数 </p>
<p>.e55          // 非法的：缺少整数或分数</p>
</blockquote>
<p><strong>布尔常量</strong></p>
<p>布尔常量共有两个，它们都是标准的 C++ 关键字：</p>
<ul>
<li><strong>true</strong> 值代表真。</li>
<li><strong>false</strong> 值代表假。</li>
</ul>
<p>我们不应把 true 的值看成 1，把 false 的值看成 0。</p>
<p><strong>字符常量</strong></p>
<blockquote>
<p>字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 <strong>wchar_t</strong> 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 <strong>char</strong> 类型的简单变量中。</p>
<p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）。</p>
</blockquote>
<p>在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：</p>
<table>
<thead>
<tr>
<th align="left">转义序列</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\a</td>
<td align="left">警报铃声</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格键</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行符</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">水平制表符</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">垂直制表符</td>
</tr>
<tr>
<td align="left">\ooo</td>
<td align="left">一到三位的八进制数</td>
</tr>
<tr>
<td align="left">\xhh . . .</td>
<td align="left">一个或多个数字的十六进制数</td>
</tr>
</tbody></table>
<p><strong>字符串常量</strong></p>
<p>字符串字面值或常量是括在双引号 <strong>“”</strong> 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</p>
<p>您可以使用 *<em>\*</em> 做分隔符，把一个很长的字符串常量进行分行。</p>
<p><strong>定义常量</strong></p>
<p>在 C++ 中，有两种简单的定义常量的方式：</p>
<ul>
<li><p>使用 <strong>#define</strong> 预处理器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> identifier value</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用 <strong>const</strong> 关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> type variable = value;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-5-运算符优先级"><a href="#9-5-运算符优先级" class="headerlink" title="9.5 运算符优先级"></a>9.5 运算符优先级</h3><p>运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。</p>
<p>例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</p>
<p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">运算符</th>
<th align="left">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">后缀</td>
<td align="left">() [] -&gt; . ++ - -</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">+ - ! ~ ++ - - (type)* &amp; sizeof</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">乘除</td>
<td align="left">* / %</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">加减</td>
<td align="left">+ -</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">移位</td>
<td align="left">&lt;&lt; &gt;&gt;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">关系</td>
<td align="left">&lt; &lt;= &gt; &gt;=</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left">== !=</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位与 AND</td>
<td align="left">&amp;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位异或 XOR</td>
<td align="left">^</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位或 OR</td>
<td align="left">|</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">逻辑与 AND</td>
<td align="left">&amp;&amp;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">逻辑或 OR</td>
<td align="left">||</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">条件</td>
<td align="left">?:</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">赋值</td>
<td align="left">= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |=</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">逗号</td>
<td align="left">,</td>
<td align="left">从左到右</td>
</tr>
</tbody></table>
<h3 id="9-6-Lambda和匿名函数"><a href="#9-6-Lambda和匿名函数" class="headerlink" title="9.6 Lambda和匿名函数"></a>9.6 Lambda和匿名函数</h3><p> C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p>
<p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p>
<p>Lambda 表达式本质上与函数声明非常类似。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture list] (params list) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>

<p>它主要由以下四个部分组成：</p>
<ul>
<li>capture list：捕获外部变量列表</li>
<li>params list：形参列表</li>
<li>mutable：标明是否可以修改捕获的变量</li>
<li>return type：返回类型</li>
<li>function body：函数体</li>
</ul>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="keyword">return</span> x &lt; y ; &#125;</span><br></pre></td></tr></table></figure>

<p>如果没有返回值可以表示为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](parameters)&#123;body&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]&#123; ++global_x; &#125; </span><br></pre></td></tr></table></figure>

<p>在一个更为复杂的例子中，返回类型可以被明确的指定如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">int</span> z = x + y; <span class="keyword">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure>

<p>本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。</p>
<p>如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。</p>
<p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[]      // 沒有定义任何变量。使用未定义变量会引发错误。</span><br><span class="line">[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。</span><br><span class="line">[&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。</span><br><span class="line">[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。</span><br><span class="line">[&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span><br><span class="line">[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span><br></pre></td></tr></table></figure>

<p>另外有一点需要注意。对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[this]() &#123; this-&gt;someFunc(); &#125;();</span><br></pre></td></tr></table></figure>



<h3 id="9-7-函数指针"><a href="#9-7-函数指针" class="headerlink" title="9.7 函数指针"></a>9.7 函数指针</h3><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>函数存放在内存的代码区域内，它们同样有地址.如果我们有一个 <strong>int test(int a)</strong> 的函数，那么，它的地址就是函数的名字，这一点如同数组一样，数组的名字就是数组的起始地址。</p>
<p>1、<strong>函数指针的定义方式</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">data_types</span> (*func_pointer)( data_types arg1, data_types arg2, ...,data_types argn);</span><br><span class="line"></span><br><span class="line"><span class="comment">//例：这里就定义了一个指向函数(这个函数参数仅仅为一个 int 类型，函数返回值是 int 类型)的指针 fp</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*fp)(<span class="keyword">int</span> a); </span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*fp)(<span class="keyword">int</span> a);</span><br><span class="line">    fp = test;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">fp</span>(<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>函数指针所指向的函数一定要保持函数的返回值类型，函数参数个数，类型一致。</p>
<p>2、<strong>typedef定义可以简化函数指针的定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*fp)</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    fp f = test;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">f</span>(<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、<strong>函数指针同样是可以作为参数传递给函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> (*fun)(<span class="keyword">int</span>),<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="built_in">fun</span>(<span class="number">10</span>)+b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*fp)</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    fp f = test;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">test2</span>(f, <span class="number">1</span>)&lt;&lt;endl; <span class="comment">// 调用 test2 的时候，把test函数的地址作为参数传递给了 test2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、<strong>构成指向函数的指针数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;test1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;test2&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t3</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;test3&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*fp)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    fp b[] = &#123;t1,t2,t3&#125;; <span class="comment">// b[] 为一个指向函数的指针数组</span></span><br><span class="line">    b[<span class="number">0</span>](); <span class="comment">// 利用指向函数的指针数组进行下标操作就可以进行函数的间接调用了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指向类成员函数的函数指针"><a href="#指向类成员函数的函数指针" class="headerlink" title="指向类成员函数的函数指针"></a>指向类成员函数的函数指针</h4><p><strong>定义：</strong>类成员函数指针（member function pointer），是 C++ 语言的一类指针数据类型，用于存储一个指定类具有给定的形参列表与返回值类型的成员函数的访问信息。</p>
<p><strong>注意：</strong></p>
<ul>
<li><font color="#ff0000"> 函数指针赋值要使用<code>&amp;</code></font></li>
<li><font color="#ff0000"> 使用<code>.*</code>（实例对象）或者<code>-&gt;*</code>（实例对象指针）调用类成员函数指针所指向的函数</font></li>
</ul>
<p>1、<strong>类成员函数指针指向类中的非静态成员函数</strong></p>
<p>对于 <strong>nonstatic member function （非静态成员函数）</strong>取地址，获得该函数在内存中的实际地址</p>
<p>对于 <strong>virtual function（虚函数）</strong>, 其地址在编译时期是未知的，所以对于 <strong>virtual member function（虚成员函数）</strong>取其地址，所能获得的只是一个索引值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指向类成员函数的函数指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">int</span> aa = <span class="number">0</span>):<span class="built_in">a</span>(aa)&#123;&#125;</span><br><span class="line"> 	~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> aa = <span class="number">1</span>)</span> </span>&#123; a = aa; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A: &quot;</span> &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A1: &quot;</span> &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>():<span class="built_in">A</span>(), <span class="built_in">b</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">B</span>(<span class="keyword">int</span> aa, <span class="keyword">int</span> bb):<span class="built_in">A</span>(aa), <span class="built_in">b</span>(bb)&#123;&#125;</span><br><span class="line"> 	~<span class="built_in">B</span>()&#123;&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		A::<span class="built_in">print</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A::<span class="built_in">printa</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (A::*ptr)(<span class="keyword">int</span>) = &amp;A::setA;</span><br><span class="line">    A* pa = &amp;a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对于非虚函数，返回其在内存的真实地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A::set(): %p\n&quot;</span>, &amp;A::setA);</span><br><span class="line">    <span class="comment">//对于虚函数， 返回其在虚函数表的偏移位置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B::print(): %p\n&quot;</span>, &amp;A::print);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B::print(): %p\n&quot;</span>, &amp;A::printa);</span><br><span class="line"> </span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    a.<span class="built_in">setA</span>(<span class="number">10</span>);</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    a.<span class="built_in">setA</span>(<span class="number">100</span>);</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对于指向类成员函数的函数指针，引用时必须传入一个类对象的this指针，所以必须由类实体调用</span></span><br><span class="line">    (pa-&gt;*ptr)(<span class="number">1000</span>);</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    (a.*ptr)(<span class="number">10000</span>);</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A::<span class="built_in">set</span>(): <span class="number">0x401464</span></span><br><span class="line">B::<span class="built_in">print</span>(): <span class="number">0x1</span></span><br><span class="line">B::<span class="built_in">print</span>(): <span class="number">0x9</span></span><br><span class="line">A: <span class="number">0</span></span><br><span class="line">A: <span class="number">10</span></span><br><span class="line">A: <span class="number">100</span></span><br><span class="line">A: <span class="number">1000</span></span><br><span class="line">A: <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>2、<strong>类成员函数指针指向类中的静态成员函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//p1是一个指向非static成员函数的函数指针</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (A::*p1)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="comment">//p2是一个指向static成员函数的函数指针</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*p2)(<span class="keyword">void</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="comment">/*对</span></span><br><span class="line"><span class="comment">         **指向非static成员函数的指针</span></span><br><span class="line"><span class="comment">         **和</span></span><br><span class="line"><span class="comment">         **指向static成员函数的指针</span></span><br><span class="line"><span class="comment">         **的变量的赋值方式是一样的，都是&amp;ClassName::memberVariable形式</span></span><br><span class="line"><span class="comment">         **区别在于：</span></span><br><span class="line"><span class="comment">         **对p1只能用非static成员函数赋值</span></span><br><span class="line"><span class="comment">         **对p2只能用static成员函数赋值</span></span><br><span class="line"><span class="comment">         **</span></span><br><span class="line"><span class="comment">         **再有，赋值时如果直接&amp;memberVariable，则在VS中报&quot;编译器错误 C2276&quot;</span></span><br><span class="line"><span class="comment">         **参见：http://msdn.microsoft.com/zh-cn/library/850cstw1.aspx</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        p1 =&amp;A::funa; <span class="comment">//函数指针赋值一定要使用 &amp;</span></span><br><span class="line">        p2 =&amp;A::funb;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//p1 =&amp;A::funb;//error</span></span><br><span class="line">        <span class="comment">//p2 =&amp;A::funa;//error</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//p1=&amp;funa;//error,编译器错误 C2276</span></span><br><span class="line">        <span class="comment">//p2=&amp;funb;//error,编译器错误 C2276</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">funa</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funb</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="comment">//p是指向A中非static成员函数的函数指针</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (A::*p)(<span class="keyword">void</span>);</span><br><span class="line">    </span><br><span class="line">    (a.*(a.p1))(); <span class="comment">//打印 A</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用.*(实例对象)或者-&gt;*（实例对象指针）调用类成员函数指针所指向的函数</span></span><br><span class="line">    p = a.p1;</span><br><span class="line">    (a.*p)();<span class="comment">//打印 A</span></span><br><span class="line">    </span><br><span class="line">    A *b = &amp;a;</span><br><span class="line">    (b-&gt;*p)(); <span class="comment">//打印 A</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*尽管a.p2本身是个非static变量,但是a.p2是指向static函数的函数指针，</span></span><br><span class="line"><span class="comment">     **所以下面这就话是错的!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    p = a.p2;//error</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*pp)(<span class="keyword">void</span>);</span><br><span class="line">    pp = &amp;A::funb;</span><br><span class="line">    <span class="built_in">pp</span>(); <span class="comment">//打印 B</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：</p>
<p>类成员函数指针与普通函数指针不是一码事。前者要用<code> .\</code> 与 <code>-&gt;*</code> 运算符来使用，而后者可以用 <code>*</code> 运算符（称为”解引用”dereference，或称”间址”indirection）。</p>
<p>普通函数指针实际上保存的是函数体的开始地址，因此也称”代码指针”，以区别于 C/C++ 最常用的数据指针。</p>
<p>而类成员函数指针就不仅仅是类成员函数的内存起始地址，还需要能解决因为 C++ 的多重继承、虚继承而带来的类实例地址的调整问题，所以类成员函数指针在调用的时候一定要传入类实例对象。</p>
<p><a href="https://blog.csdn.net/crayondeng/article/details/16868351"> C++ 函数指针 &amp; 类成员函数指针_小邓笔记-CSDN博客_函数指针 类成员函数</a></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="ASCII码表格"><a href="#ASCII码表格" class="headerlink" title="ASCII码表格"></a>ASCII码表格</h3><table>
<thead>
<tr>
<th><strong>ASCII</strong>值</th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>/</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>/</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>=</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>`</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody></table>
<p>ASCII 码大致由以下<strong>两部分组</strong>成：</p>
<ul>
<li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li>
<li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li>
</ul>
<h3 id="三字符组"><a href="#三字符组" class="headerlink" title="三字符组"></a>三字符组</h3><p>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。</p>
<p>三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。</p>
<p>三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。</p>
<p>下面列出了最常用的三字符序列：</p>
<table>
<thead>
<tr>
<th align="left">三字符组</th>
<th align="left">替换</th>
</tr>
</thead>
<tbody><tr>
<td align="left">??=</td>
<td align="left">#</td>
</tr>
<tr>
<td align="left">??/</td>
<td align="left">\</td>
</tr>
<tr>
<td align="left">??’</td>
<td align="left">^</td>
</tr>
<tr>
<td align="left">??(</td>
<td align="left">[</td>
</tr>
<tr>
<td align="left">??)</td>
<td align="left">]</td>
</tr>
<tr>
<td align="left">??!</td>
<td align="left">|</td>
</tr>
<tr>
<td align="left">??&lt;</td>
<td align="left">{</td>
</tr>
<tr>
<td align="left">??&gt;</td>
<td align="left">}</td>
</tr>
<tr>
<td align="left">??-</td>
<td align="left">~</td>
</tr>
</tbody></table>
<p>如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接：”…?””?…”或者转义序列：”…??…”。</p>
<p>从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项/Zc:trigraphs</p>
<p>g++仍默认支持三字符组，但会给出编译警告。</p>
<h3 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C++ 关键字"></a>C++ 关键字</h3><p>下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>
<table>
<thead>
<tr>
<th>asm</th>
<th>else</th>
<th>new</th>
<th>this</th>
</tr>
</thead>
<tbody><tr>
<td><strong>auto</strong></td>
<td><strong>enum</strong></td>
<td><strong>operator</strong></td>
<td><strong>throw</strong></td>
</tr>
<tr>
<td><strong>bool</strong></td>
<td><strong>explicit</strong></td>
<td><strong>private</strong></td>
<td><strong>true</strong></td>
</tr>
<tr>
<td><strong>break</strong></td>
<td><strong>export</strong></td>
<td><strong>protected</strong></td>
<td><strong>try</strong></td>
</tr>
<tr>
<td><strong>case</strong></td>
<td><strong>extern</strong></td>
<td><strong>public</strong></td>
<td><strong>typedef</strong></td>
</tr>
<tr>
<td><strong>catch</strong></td>
<td><strong>false</strong></td>
<td><strong>register</strong></td>
<td><strong>typeid</strong></td>
</tr>
<tr>
<td><strong>char</strong></td>
<td><strong>float</strong></td>
<td><strong>reinterpret_cast</strong></td>
<td><strong>typename</strong></td>
</tr>
<tr>
<td><strong>class</strong></td>
<td><strong>for</strong></td>
<td><strong>return</strong></td>
<td><strong>union</strong></td>
</tr>
<tr>
<td><strong>const</strong></td>
<td><strong>friend</strong></td>
<td><strong>short</strong></td>
<td><strong>unsigned</strong></td>
</tr>
<tr>
<td><strong>const_cast</strong></td>
<td><strong>goto</strong></td>
<td><strong>signed</strong></td>
<td><strong>using</strong></td>
</tr>
<tr>
<td><strong>continue</strong></td>
<td><strong>if</strong></td>
<td><strong>sizeof</strong></td>
<td><strong>virtual</strong></td>
</tr>
<tr>
<td><strong>default</strong></td>
<td><strong>inline</strong></td>
<td><strong>static</strong></td>
<td><strong>void</strong></td>
</tr>
<tr>
<td><strong>delete</strong></td>
<td><strong>int</strong></td>
<td><strong>static_cast</strong></td>
<td><strong>volatile</strong></td>
</tr>
<tr>
<td><strong>do</strong></td>
<td><strong>long</strong></td>
<td><strong>struct</strong></td>
<td><strong>wchar_t</strong></td>
</tr>
<tr>
<td><strong>double</strong></td>
<td><strong>mutable</strong></td>
<td><strong>switch</strong></td>
<td><strong>while</strong></td>
</tr>
<tr>
<td><strong>dynamic_cast</strong></td>
<td><strong>namespace</strong></td>
<td><strong>template</strong></td>
<td></td>
</tr>
</tbody></table>
<p>详细介绍<a href="https://www.runoob.com/w3cnote/cpp-keyword-intro.html">C++ 的关键字（保留字）完整介绍 | 菜鸟教程 (runoob.com)</a></p>
<h3 id="数学运算cmath"><a href="#数学运算cmath" class="headerlink" title="数学运算cmath"></a>数学运算cmath</h3><p>在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做<strong>内置</strong>函数。您可以在程序中引用这些函数。</p>
<p>C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数在 **&lt;cmath&gt;**。</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>double cos(double);</strong></td>
<td align="left">该函数返回弧度角（double 型）的余弦。</td>
</tr>
<tr>
<td align="left"><strong>double sin(double);</strong></td>
<td align="left">该函数返回弧度角（double 型）的正弦。</td>
</tr>
<tr>
<td align="left"><strong>double tan(double);</strong></td>
<td align="left">该函数返回弧度角（double 型）的正切。</td>
</tr>
<tr>
<td align="left"><strong>double log(double);</strong></td>
<td align="left">该函数返回参数的自然对数。</td>
</tr>
<tr>
<td align="left"><strong>double pow(double,  double);</strong></td>
<td align="left">假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</td>
</tr>
<tr>
<td align="left"><strong>double hypot(double, double);</strong></td>
<td align="left">该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</td>
</tr>
<tr>
<td align="left"><strong>double sqrt(double);</strong></td>
<td align="left">该函数返回参数的平方根。</td>
</tr>
<tr>
<td align="left"><strong>int abs(int);</strong></td>
<td align="left">该函数返回整数的绝对值。</td>
</tr>
<tr>
<td align="left"><strong>double fabs(double);</strong></td>
<td align="left">该函数返回任意一个浮点数的绝对值。</td>
</tr>
<tr>
<td align="left"><strong>double floor(double);</strong></td>
<td align="left">该函数返回一个小于或等于传入参数的最大整数。</td>
</tr>
</tbody></table>
<h3 id="C-随机数"><a href="#C-随机数" class="headerlink" title="C++随机数"></a>C++随机数</h3><p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 <strong>srand()</strong> 函数。</p>
<p>下面是一个关于生成随机数的简单实例。实例中使用了 <strong>time()</strong> 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i,j;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置种子</span></span><br><span class="line">   <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 生成 10 个随机数 */</span></span><br><span class="line">   <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 生成实际的随机数</span></span><br><span class="line">      j= <span class="built_in">rand</span>();</span><br><span class="line">      cout &lt;&lt;<span class="string">&quot;随机数： &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="C字符串操作"><a href="#C字符串操作" class="headerlink" title="C字符串操作"></a>C字符串操作</h3><p><strong>C风格字符串</strong>以下函数在头文件<code>&lt;cstring&gt;</code>中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(s1, s2); 	<span class="comment">//复制字符串 s2 到字符串 s1             </span></span><br><span class="line"><span class="built_in">strcat</span>(s1, s2); 	<span class="comment">//连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号，例如: string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str = str1 + str2;</span></span><br><span class="line"><span class="built_in">strlen</span>(s1); 		<span class="comment">//返回字符串 s1 的长度。                       </span></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s2); 	<span class="comment">//如果 s1 和 s2 是相同的，则返回 0；s1&lt;s2 则返回值小于0；s1&gt;s2 则返回值大于0。 </span></span><br><span class="line"><span class="built_in">strchr</span>(s1, ch); 	<span class="comment">//返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 </span></span><br><span class="line"><span class="built_in">strstr</span>(s1, s2); 	<span class="comment">//返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 </span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>文件和目录操作</title>
    <url>/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>学自电子科技大学</p>
<p>文档中的函数都可以用 <code>man funcName</code> 查看介绍</p>
<span id="more"></span>

<h2 id="Linux初识1"><a href="#Linux初识1" class="headerlink" title="Linux初识1"></a>Linux初识1</h2><h3 id="UNIX和Linux"><a href="#UNIX和Linux" class="headerlink" title="UNIX和Linux"></a>UNIX和Linux</h3><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220405150528083.png" alt="image-20220405150528083" style="zoom:67%;">

<p>C语言是UNIX的副产品！</p>
<hr>
<p>80年代UNIX版本的剧增以及各种UNIX版本之间的差别不断扩大导致了以美国政府为代表许多用户要求对其标准化，以增强各种应用程序在这些UNIX操作系统之间的可移植性</p>
<p>重要的UNIX标准包括：ANSI C、IEEE POSIX等</p>
<p>UNIX标准只是<strong>对应用程序接口进行统一</strong>（内部实现机制则留给操作系统开发者自行实现）</p>
<p>ANSI C</p>
<ul>
<li>ANSI C是美国国家标准协会（ANSI）于1983年发布的C语言标准</li>
<li>1989年，此标准被采纳为国际标准ISO/IEC 9899:1990</li>
<li>ISO C标准现旨在提供<strong>应用程序的可移植性</strong>，使其能适应于不同的操作系统，而不仅仅是UNIX操作系统</li>
</ul>
<p>POSIX</p>
<ul>
<li>1986年，IEEE制定了IEEE P1003标准，这套标准被称为POSIX（Potable Operating System Interface）</li>
<li>POSIX定义了一整套的应用程序接口，包括系统调用、库函数、公共命令</li>
<li>POSIX标准希望在<strong>源代码级别保证应用程序可移植性</strong></li>
</ul>
<hr>
<p>Stallman在 1983 年发起了<strong>GNU</strong>计划，GNU是“GNU‘s Not Unix”的递归缩写，其目标是创建一个完全自由的<strong>类Unix操作系统</strong>，GNU计划也开发了大批其他的自由软件，例如 Emacs 、Glibc、GCC、BASH等</p>
<p>1985年Stallman又创立了自由软件基金会（Free Software Foundation）来为GNU计划提供技术、法律以及财政支持</p>
<p>自由软件并不是指“免费”的，而是指具有“自由度”的软件。什么是自由度呢？也就是使用者运行、复制、发布、研究、修改和改进该软件的自由</p>
<p>GNU通用公共许可协议（GNU GPL）是一个广泛被使用的自由软件许可协议条款，最初Stallman为GNU计划而撰写，GPL授予程序接受人以下权利，或称“自由”：</p>
<ul>
<li>以任何目的运行此程序的自由；</li>
<li>再发行复制件的自由；</li>
<li>改进此程序，并公开发布改进的自由</li>
</ul>
<p>1984年”，安德鲁·斯图尔特·塔能鲍姆（ Andrew Stuart Tanenbaum ）自己编写了兼容于UNIX的<strong>Minix系统</strong>，用于教学</p>
<p>1991年，芬兰郝尔辛基大学研究生林纳斯·托瓦兹（Linus Torvalds）受Minix系统影响，开发了针对386机器的<strong>Linux内核</strong></p>
<p>1991年Linux的第一个版本公开发行时，GNU计划已经完成除了操作系统内核之外的大部分软件（其中包括了<strong>shell程序，C语言程序库以及C语言编译器</strong>）。 Linus Torvalds及其他早期Linux开发人员加入了这些工具，而完成了Linux操作系统</p>
<p><strong>Linux是在GNU通用公共许可证下发行，它却不是GNU计划的一部分</strong></p>
<hr>
<p>UNIX是可以应用从大型计算机到普通PC机等多种不同的平台上，是应用面最广、影响力最大的操作系统。</p>
<p>Linux是一种外观和性能与UNIX相同或更好的操作系统，但Linux不源于任何版本的UNIX的源代码，是一个类似于UNIX的产品</p>
<p>Linux遵循POSIX规范，成功的模仿了UNIX系统和功能，更具体地讲，Linux兼容于System V以及BSD UNIX：</p>
<ul>
<li>对于System V，应用程序源代码在Linux下重新编译之后就可以运行</li>
<li>对于BSD UNIX，应用程序可执行文件可以直接在Linux环境下运行</li>
</ul>
<h3 id="Linux体系结构"><a href="#Linux体系结构" class="headerlink" title="Linux体系结构"></a>Linux体系结构</h3><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220405152119180.png" alt="image-20220405152119180" style="zoom:67%;">

<p><strong>内核的功能</strong></p>
<ul>
<li><strong>内存管理</strong><ul>
<li>内存分配调用： 包括静态分配方式、动态分配方式；</li>
<li>内存保护：确保每个程序在自己的内存空间运行、互不干扰。方法是使用界限寄存器或存储保护键；</li>
<li>地址映射：实现程序的逻辑地址与存储器的物理地址之间的映射功能；</li>
<li>内存扩充：从逻辑上扩充物理内存，以允许比物理内存更大的程序在机器内运行，为此操作系统必须具有：请求调入功能与置换功能</li>
</ul>
</li>
<li><strong>进程管理</strong><ul>
<li>进程控制：包括进程创建、进程撤销、进程阻塞、进程唤醒</li>
<li>进程协调：由于进程运行的异步性，因此进程同步的任务是对诸进程的运行协调，包括两种方式：进程互斥方式与进程同步方式；</li>
<li>进程通信：主要完成同一台机器上不同进程间通信和不同机器上进程间的通信，以共同完成一相同的任务；</li>
<li>进程调度：操作系统按照一定的规则对等待运行的多道程序进行调度，以保证每个程序都能有机会得到运行，并最终完成</li>
</ul>
</li>
<li><strong>文件管理</strong><ul>
<li>文件存储空间的管理：为每一文件分配必要的外存空间。为提高外部存储空间的利用率，系统应设置相应的数据结构，用于记录文件存储空间的使用情况；</li>
<li>目录管理：为了方便对用户的文件进行管理，对文件系统建立一定结构的目录结构，同时要求快速的目录查询手段；</li>
<li>文件的读、写管理和存取控制：利用一定的系统调用对文件进行读写操作。同时，为防止系统中的文件被非法访问和窃取，文件系统中必须提供有效存取控制功能；</li>
</ul>
</li>
<li><strong>设备管理</strong><ul>
<li>缓冲管理：管理各种类型的缓冲区，如字符缓冲区和块缓冲区，以缓和CPU和I/O速度不匹配的矛盾，最终达到提高CPU和I／O设备的利用率，进而提高系统吞吐量的目的；</li>
<li>设备分配：根据用户的I/O请求，为之分配其所需要的设备；</li>
<li>设备处理：又称为设备驱动程序，任务是实现CPU和设备控制器之间的通信；</li>
<li>设备独立性和虚拟设备：一方面保证用户程序独立于物理设备，另一方面保证多个进程能并发地共享同一个设备；</li>
</ul>
</li>
</ul>
<hr>
<p><strong>UNIX/Linux操作系统结构</strong>：</p>
<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220405152619972.png" alt="image-20220405152619972"></p>
<h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><hr>
<p>操作系统用户接口：</p>
<ul>
<li><p><strong>命令接口</strong>：以命令形式呈现在用户面前，方便用户直接或间接控制自己的作业</p>
</li>
<li><p><strong>程序接口</strong>：为应用程序使用系统功能而设置，是应用程序取得操作系统服务的唯一途径。由一系列系统调用组成，每一个系统调用都是一个能完成特定功能的子程序。</p>
</li>
<li><p><strong>图形接口</strong>：采用了图形化的操作界面，将各种应用程序和文件，直观、逼真地表示出来。</p>
</li>
</ul>
<p><strong>系统调用是内核提供的程序接口，是应用程序和硬件设备之间的中间层</strong>：</p>
<blockquote>
<p>为应用程序提供了系统服务和硬件抽象能力，例如，当需要读文件时，应用程序可以不管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型；</p>
<p>系统调用保证了系统的稳定和安全</p>
<p>每个进程都运行在虚拟系统中</p>
</blockquote>
<p>Research UNIX系统的第7个版本提供了大给50个系统调用，4.4BSD提供了大约110个，SVR4有大约120个。<strong>Linux根据不同的版本有240到260个系统调用的接口</strong></p>
<ul>
<li><code>man 2 syscalls</code> 查看所有的系统调用接口</li>
</ul>
<p>系统调用的类型：</p>
<ul>
<li>文件操作类系统调用： 如打开、创建、读取、删除、修改文件；</li>
<li>进程控制类系统调用：如创建进程、设置或获取进程属性等；</li>
<li>通信类系统调用：创建进程间的通信连接，发送、接收消息，或其他的通信方式；</li>
<li>设备管理类系统调用：打开、关闭和操作设备；</li>
<li>信息维护类系统调用：在用户程序和OS之间传递信息。例如，系统向用户程序传送当前时间、日期、操作系统版本号等。</li>
</ul>
<p>系统调用与C库函数：</p>
<p>系统调用和C库函数之间并不是一一对应的关系，可能几个不同的函数会调用到同一个系统调用：</p>
<ul>
<li><p>malloc函数和free函数都是通过sbrk系统调用来扩大或缩小进程的堆栈空间；</p>
</li>
<li><p>execl、execlp、execle、execv、execvp和execve函数都是通过execve系统调用来执行一个可执行文件</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220405160247813.png" alt="image-20220405160247813" style="zoom:50%;"></li>
</ul>
<p>并非所有的库函数都会调用系统调用，例如，printf函数会调用write系统调用以输出一个字符串，但strcpy和atoi函数则不使用任何系统调用</p>
<p>UNIX/Linux软件层次架构：</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220405160358404.png" alt="image-20220405160358404" style="zoom:50%;">

<p>一般而言，应用程序使用API而不是直接使用系统调用来编程</p>
<p>进程UNIX/Linux的C库遵循POSIX规范，以库函数的形式实现了POSIX API（在API中使用系统调用完成相应功能）。</p>
<p>参考：<code>/usr/include/asm/unistd.h</code> （没有的话，用 <code>find / -name &quot;unistd.h&quot;</code>找一下，出来一大堆，感觉应该是<code>/usr/include/unistd.h</code>）<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220405160535000.png" alt="image-20220405160535000"></p>
<h3 id="文件目录命令"><a href="#文件目录命令" class="headerlink" title="文件目录命令"></a>文件目录命令</h3><p>浏览目录命令：<code>ls</code> 、<code>pwd</code></p>
<p>目录操作命令：<code>cd</code>、 <code>mkdir</code>、 <code>rmdir</code></p>
<p>浏览文件命令：<code>cat</code>、<code>more</code>、<code>less</code>、<code>head</code>、<code>tail</code></p>
<p>文件操作命令：<code>cp</code>、<code>rm</code>、 <code>mv</code>、<code>find</code>、 <code>grep</code>、<code>tar</code></p>
<hr>
<p>命令名称：<code>ls</code></p>
<ul>
<li>命令英文原意：<code>list</code></li>
<li>功能描述：显示目录文件</li>
<li>语法：ls 选项[-ald] [文件或目录]<ul>
<li><code>-a</code> 显示所有文件，包括隐藏文件</li>
<li><code>-l</code> 详细信息显示</li>
<li><code>-d</code> 查看目录属性</li>
</ul>
</li>
</ul>
<p>命令名称：<code>pwd</code></p>
<ul>
<li>命令英文原意：<code>print working directory</code></li>
<li>语法：pwd</li>
<li>功能描述：显示当前所在的工作目录</li>
</ul>
<p>命令名称：<code>cd</code></p>
<ul>
<li>命令英文原意：<code>change directory</code></li>
<li>语法：<code>cd [目录]</code></li>
<li>功能描述：切换目录</li>
<li>范例：<ul>
<li><code>$ cd / 切换到根目录</code></li>
<li><code>$ cd .. 回到上一级目录</code> </li>
</ul>
</li>
</ul>
<p>命令名称：<code>mkdir</code></p>
<ul>
<li>命令英文原意：<code>make directory</code></li>
<li>语法：<code>mkdir [目录名]</code></li>
<li>功能描述：创建新目录</li>
<li>范例： <code>$ mkdir newdir</code></li>
</ul>
<p>命令名称：<code>rmdir</code></p>
<ul>
<li>命令英文原意：<code>remove directory</code></li>
<li>语法：<code>rmdir [目录名]</code></li>
<li>功能描述：删除空目录</li>
<li>范例： <code>$ rmdir newdir</code></li>
</ul>
<p>命令名称：<code>cat</code></p>
<ul>
<li>命令英文原意：<code>concatenate and display files</code></li>
<li>功能描述：连接文件并打印到标准输出设备上</li>
<li>选项：<ul>
<li><code>-E</code> 在每一行的末尾显示<code>$</code></li>
<li><code>-n</code> 为显示行添加行号</li>
</ul>
</li>
<li>参数：指定要连接的文件列表。</li>
<li>范例：<ul>
<li><code>cat m1</code> （在屏幕上显示文件ml的内容）</li>
<li><code>cat m1 m2</code> （同时显示文件ml和m2的内容）</li>
</ul>
</li>
</ul>
<p>命令名称：<code>more</code></p>
<ul>
<li>语法：<code>more [文件名]</code><ul>
<li><code>(空格)或f</code> 显示下一页</li>
<li><code>(Enter)</code> 显示下一行</li>
<li><code>q或Q</code>   退出</li>
</ul>
</li>
<li>功能描述：分页显示文件内容</li>
<li>范例：<code>$ more /etc/services</code></li>
</ul>
<p><code>less</code>命令的用法与more命令类似，也可以用来浏览超过一页的文件。所不同的是less命令除了可以按空格键向下显示文件外，还可以利用上下键来卷动文件。</p>
<p><code>head</code>命令：用于显示文件前几行的内容</p>
<ul>
<li>格式：<code>head [参数] &lt;文件名&gt;</code><ul>
<li><code>-n</code>：显示前n行，不指定此参数显示前10行</li>
<li><code>[root@linux root]# head /etc/passwd</code></li>
</ul>
</li>
</ul>
<p><code>tail</code>命令：用于显示文件后几行的内容</p>
<ul>
<li>格式：<code>tail [参数] &lt;文件名&gt;</code><ul>
<li><code>-n</code>：显示后n行，不指定此参数显示后10行</li>
<li><code>+n</code>：从第n行显示到文件尾</li>
<li><code>-F</code>：用于跟踪显示不断增长的文件结尾内容（通常用于显示日志文件）。</li>
<li><code>[root@linux root]# tail /etc/passwd</code></li>
</ul>
</li>
</ul>
<p><code>cp</code>（copy）命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。</p>
<ul>
<li>格式：<code>cp [参数] &lt;源文件路径&gt; &lt;目标文件路径&gt;</code><ul>
<li><code>-p</code> ：连同文件的属性一起复制，而非使用默认方式，常用于备份</li>
<li><code>-i</code> ：若目标文件已经存在时，在覆盖时会先询问操作的进行</li>
<li><code>-r</code> ：递归持续复制，用于目录的复制行为</li>
<li><code>-u</code> ：目标文件与源文件有差异时才会复制</li>
</ul>
</li>
<li>范例：<ul>
<li>将test1.txt复制成test2.txt：<code>[test@linux test]$ cp test1.txt test2.txt</code> </li>
<li>将test3.txt复制到/tmp目录中：<code>[test@linux test]$ cp test3.txt /tmp</code> </li>
<li>目录test1拷贝：<code>[test@linux test]$ cp –r test1 test2</code></li>
</ul>
</li>
</ul>
<p><code>rm</code>（remove）命令：删除文件或目录</p>
<ul>
<li>格式：<code>rm [参数] &lt;目标文件路径&gt;</code><ul>
<li><code>-f</code> ：就是force的意思，忽略不存在的文件，不会出现警告消息</li>
<li><code>-i</code> ：互动模式，在删除前会询问用户是否操作</li>
<li><code>-r</code> ：递归删除，最常用于目录删除，它是一个非常危险的参数</li>
</ul>
</li>
<li>范例：<ul>
<li>删除myfiles文件：<code>[test@linux test]$ rm myfiles</code></li>
<li>删除当前目录下的所有文件：<code>[test@linux test]$ rm *</code></li>
<li>递归删除某个目录所有内容：``[test@linux test]$ rm -r myfolder`</li>
<li>强迫删除所有后缀名为txt文件：<code>[test@linux test]$ rm –f *.txt</code></li>
<li>删除当前目录下的所有文件：<code>[test@linux test]$ rm –i *</code>（删除文件时会询问,可按Y或N键表示允许或拒绝删除文件）</li>
</ul>
</li>
</ul>
<p><code>find</code>命令：用来寻找文件或目录</p>
<ul>
<li>格式：<code>find 路径 [参数]</code><ul>
<li><code>-name filename</code>：找出文件名为filename的文件</li>
<li><code>-size [+-]SIZE</code> ：找出比<code>SIZE</code>还要大（+）或小（-）的文件</li>
<li><code>-tpye TYPE</code>：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f）、设备文件（b、c）、目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；</li>
<li><code>-perm mode</code>：查找文件权限刚好等于mode的文件，mode用数字表示，如0755</li>
</ul>
</li>
</ul>
<p><code>grep</code>命令（Globally search a Regular Expression and Print）</p>
<ul>
<li>功能：在文件中搜索匹配的字符并进行输出</li>
<li>格式：<code>grep[参数] &lt;要找的字串&gt; &lt;要寻找字串的源文件&gt;</code><ul>
<li><code>-a</code>：将<code>binary</code>文件以<code>text</code>文件的方式查找数据</li>
<li><code>-c</code>：计算找到“查找字符串”的次数</li>
<li><code>-i</code>：忽略大小写的区别，即把大小写视为相同</li>
<li><code>-v</code>：反向选择，即显示出不包含‘查找字符串’内容的那一行</li>
</ul>
</li>
</ul>
<p><code>tar</code>（tape archive）命令能够将用户所指定的文件或目录打包成一个文件，也可以通过指定参数开启压缩/解压缩功能</p>
<ul>
<li>格式：<code>tar [参数] &lt;文件&gt;</code><ul>
<li><code>-c</code>：新建打包文件</li>
<li><code>-t</code>：查看打包文件的内容含有哪些文件名</li>
<li><code>-x</code>：解打包或解压缩的功能，可以搭配<code>-C</code>（大写）指定解压的目录，注意<code>-c,-t,-x</code>不能同时出现在同一条命令中</li>
<li><code>-j</code>：通过<code>bzip2</code>的支持进行压缩/解压缩</li>
<li><code>-z</code>：通过<code>gzip</code>的支持进行压缩/解压缩</li>
<li><code>-v</code>：在压缩/解压缩过程中，将正在处理的文件名显示出来</li>
<li><code>-f filename</code>：filename为要处理的文件</li>
<li><code>-C dir</code>：指定压缩/解压缩的目录<code>dir</code>，<code>dir</code>必须已存在</li>
</ul>
</li>
<li>范例：<ul>
<li><p>将当前目录的所有文件打包成test.tar：<code>[root@linux test]# tar -cvf test.tar *</code></p>
</li>
<li><p>将当前目录的所有文件打包成test.tar,再用gzip命令压缩：<code>[root@linux test]# tar -czvf test.tar.gz *</code> </p>
</li>
<li><p>查看test.tar文件中包括了哪些文件：<code>[root@linux ljr]# tar -tf test.tar</code></p>
</li>
<li><p>将test.tar解打包：<code>[root@linux test]# tar -xvf test.tar</code></p>
</li>
<li><p>将foo.tar.gz解压缩并解打包：<code>[root@linux test]# tar -xzvf foo.tar.gz</code> </p>
</li>
<li><p><code>-C</code>的示例，打包Cprogram内的文件，不把<code>Cprogram</code>文件夹名也打包</p>
<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406120310070.png" alt="image-20220406120310070"></p>
</li>
</ul>
</li>
</ul>
<h3 id="进程控制类命令"><a href="#进程控制类命令" class="headerlink" title="进程控制类命令"></a>进程控制类命令</h3><p>查看系统中的进程命令：<code>ps</code> 、<code>top</code></p>
<p>控制系统中的进程命令：<code>kill</code> 、<code>killall</code>、 <code>nice</code>、 <code>renice</code></p>
<p>进程后台运行命令 <code>&amp;</code></p>
<p>进程的挂起和恢复</p>
<hr>
<p><strong>程序和进程的区别</strong></p>
<p>程序是一个包含可执行代码的文件，它放在磁盘等介质上。</p>
<p>当程序被操作系统装载到内存并分配给它一定资源后，此时可称为<strong>进程</strong>。</p>
<p>程序是<strong>静态概念</strong>，进程是<strong>动态概念</strong>。</p>
<hr>
<p><strong>进程状态</strong></p>
<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220405170349612.png" alt="image-20220405170349612"></p>
<p><code>ps</code>命令是用来显示系统瞬间的进程信息，它可以显示出在用户输入ps命令时系统的进程及进程的相关信息。</p>
<ul>
<li>格式：<code>ps [参数]</code><ul>
<li><code>-l</code> 长格式输出</li>
<li><code>-u</code> 按用户名和启动时间的顺序来显示进程</li>
<li><code>-j</code> 用任务格式来显示进程</li>
<li><code>-f</code> 用树形格式来显示进程</li>
<li><code>-a</code> 显示所有用户的所有进程（包括其它用户）</li>
<li><code>-x</code> 显示无控制终端的进程</li>
<li><code>-r</code> 显示运行中的进程</li>
</ul>
</li>
</ul>
<p><code>top</code>命令</p>
<ul>
<li><p>功能：动态监视系统任务的工具，输出结果是连续的</p>
</li>
<li><p>格式：<code>top [参数]</code></p>
<ul>
<li><code>-b</code> 以批量模式运行，但不能接受命令行输入</li>
<li><code>-c</code> 显示命令行，而不仅仅是命令名</li>
<li><code>-d N</code> 显示两次刷新时间的间隔，比如<code>-d 5</code>，表示两次刷新间隔为5秒</li>
<li><code>-i</code> 禁止显示空闲进程或僵尸进程</li>
<li><code>-n NUM</code> 显示更新次数，然后退出。比如<code>-n 5</code>，表示top更新5次数据就退出</li>
<li><code>-p PID</code> 仅监视指定进程的ID；<code>PID</code>是一个数值</li>
<li><code>-q</code> 不经任何延时就刷新</li>
<li><code>-s</code> 安全模式运行，禁用一些效互指令</li>
<li><code>-S</code> 累积模式，输出每个进程的总的CPU时间</li>
</ul>
</li>
<li><p>范例：</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220405171331260.png" alt="image-20220405171331260" style="zoom:67%;"></li>
</ul>
<p><code>kill</code>命令，该命令用于向某个进程（通过PID标识）传送一个信号，它通常与<code>ps</code>和<code>jobs</code>命令一起使用</p>
<ul>
<li>格式：<code>kill –signal PID</code>，常用的<code>signal</code>参数如下：<ul>
<li><code>1:SIGHUP</code>，启动被终止的进程</li>
<li><code>2:SIGINT</code>，相当于输入<code>ctrl+c</code>，中断一个程序的进行</li>
<li><code>9:SIGKILL</code>，强制中断一个进程的进行</li>
<li><code>15:SIGTERM</code>，以正常的结束进程方式来终止进程</li>
<li><code>17:SIGSTOP</code>，相当于输入<code>ctrl+z</code>，暂停一个进程的进行</li>
</ul>
</li>
<li>范例：<ul>
<li>以正常的结束进程方式来终止第一个后台工作进程  <code>kill -SIGTERM %1</code></li>
<li>重新启动进程ID为PID的进程  <code>kill -SIGHUP PID</code></li>
</ul>
</li>
</ul>
<p><code>killall</code>命令使用进程的名称来杀死进程，使用此指令可以杀死一组同名进程</p>
<p>使用kill命令可以杀死指定进程PID的进程，如果要根据进程名称找到需要杀死的进程，还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一</p>
<ul>
<li>用法：<code>killall [参数] &lt;正在运行的进程名&gt;</code><ul>
<li><code>-e</code>：对长名称进行精确匹配</li>
<li><code>-I</code>：忽略大小写的不同</li>
<li><code>-p</code>：杀死进程所属的进程组</li>
<li><code>-i</code>：交互式杀死进程，杀死进程前需要进行确认</li>
<li><code>-l</code>：打印所有已知信号列表</li>
<li><code>-q</code>：如果没有进程被杀死，则不输出任何信息</li>
<li><code>-r</code>：使用正规表达式匹配要杀死的进程名称</li>
<li><code>-s</code>：用指定的进程号代替默认信号“SIGTERM”</li>
<li><code>-u</code>：杀死指定用户的进程</li>
</ul>
</li>
<li>使用范例：<code>[root@localhost test]# killall game</code></li>
</ul>
<p><code>nice</code>命令：允许在默认优先级的基础上进行增大或减小的方式来运行命令</p>
<ul>
<li>格式：<code>nice [参数] &lt;command [arguments...]&gt;</code><ul>
<li>command 是系统中任意可执行文件的名称</li>
<li><code>-n</code>, <code>--adjustment</code> 指定程序运行优先级的调整值</li>
<li>优先级的调整值范围为<code>-20 ～ 19</code> ，其中数值越小优先级越高，数值越大优先级越低</li>
<li>若 nice命令未指定优先级的调整值，则以缺省值10来调整程序运行优先级，既在命令通常运行优先级基础之上增加10</li>
</ul>
</li>
<li>使用范例：<code>[root@host root]# nice -n -5 myprogram&amp;</code>在后台以通常运行优先级<code>-5</code>的优先级运行<code>myprogram </code></li>
</ul>
<p><code>renice</code>命令：改变一个正在运行的进程的<code>nice</code>值</p>
<ul>
<li>格式：<code>renice [参数] &lt;pid&gt;</code><ul>
<li><code>-n</code> 指定程序运行优先级的调整值</li>
</ul>
</li>
<li>使用范例：<code>[root@host root]# renice -5 777</code> 将正在运行的PID为777的进程nice值改为-5</li>
</ul>
<p>后台运行程序的<code>＆</code>命令</p>
<ul>
<li><code>[root@host root]# cp –r /usr/* test &amp; </code>将/usr 目录下的所有子目录及文件复制到/root/test目录下的工作放到后台运行</li>
</ul>
<p>进程的中止（挂起）和终止</p>
<ul>
<li>挂起（Ctrl+Z）</li>
<li>终止（Ctrl+C）</li>
</ul>
<p>进程的恢复</p>
<ul>
<li>恢复到前台继续运行 <code>fg</code> ： <code>fg [n]</code></li>
<li>恢复到后台继续运行 <code>bg</code> ：<code>bg [n]</code></li>
<li>查看被挂起的进程 <code>jobs</code></li>
</ul>
<h3 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h3><p>用户管理类命令：<code>useradd</code> 、<code>usermod</code>、 <code>passwd</code> 、<code>userdel</code>、 <code>su</code> 、<code>id</code>、 <code>whoami</code> 、<code>w</code>、 <code>finger</code> </p>
<p>用户组管理类命令：<code>groupadd</code>、 <code>groupmod</code> 、<code>groupdel</code></p>
<p>文件权限管理类命令：<code>chmod</code>、 <code>chown</code> 、<code>chgrp</code></p>
<p>Linux用户分为三类：</p>
<ul>
<li>超级用户：拥有最高权限</li>
<li>系统用户：与系统服务相关，但不能用于登录</li>
<li>普通用户：由超级用户创建并赋予权限，只能操作其拥有权限的文件和目录，只能管理自己启动的进程</li>
</ul>
<p><strong>用户信息：</strong></p>
<ul>
<li>用户名：唯一，由字母、数字和符号组成。</li>
<li>口令</li>
<li>用户<code>ID(uid)</code>：每个用户拥有的唯一的识别号码。超级用户为0，系统用户1-499，普通用户从500开始</li>
<li>用户组<code>id(gid)</code></li>
<li>用户主目录</li>
<li>全称：用户帐户的附加信息，可以为空</li>
<li>登录Shell：默认使用Bash</li>
</ul>
<p><strong>与用户相关的文件：</strong></p>
<ul>
<li>用户帐号信息文件<code>/etc/passwd</code><ul>
<li>文件中每一行为一个用户的信息</li>
<li>文件中各字段从左到右依次为：<strong>用户名、口令、用户ID、用户组、全称、用户主目录和登录Shell</strong>。</li>
<li>口令字段用<code>x</code>来填充，加密后的口令保存在<code>/etc/shadow</code>文件中。</li>
</ul>
</li>
<li>用户口令信息文件<code>/etc/shadow</code><ul>
<li><code>shadow</code> 文件只有超级用户才能查看并修改其内容，且加密(AES-256)存储。</li>
</ul>
</li>
</ul>
<p><strong>用户组</strong>：</p>
<ul>
<li>Linux将相同特性的用户划归为同一用户组，可以大大简化用户的管理，方便用户之间文件的共享，任何用户都至少属于一个用户组。</li>
<li>一个用户只能属于一个用户组，但可以同时属于多个附加组。用户不仅拥有其用户组的权限，还同时拥有其附加组的权限。</li>
<li>用户组包括系统用户组与私人用户组</li>
</ul>
<p><strong>与用户组相关的文件：</strong></p>
<ul>
<li>用户组账号信息文件<code>/etc/group</code><ul>
<li>每一行为一个用户组信息</li>
<li>文件中各字段从左到右依次为：<code>用户组名、口令、用户组ID和附加用户列表</code>。</li>
</ul>
</li>
<li>用户组口令信息文件<code>/etc/gshadow</code><ul>
<li>同<code>/etc/shadow</code></li>
</ul>
</li>
</ul>
<hr>
<p><code>useradd</code>命令：新建用户帐号（超级用户可用）</p>
<ul>
<li>格式：<code>useradd [参数] &lt;用户名&gt;</code><ul>
<li><code>-d</code> 指定用户登入时的主目录</li>
<li><code>-e</code> 账号终止日期</li>
<li><code>-g</code> 指定账户所属的用户组</li>
<li><code>-G</code> 指定账户所属的附加组</li>
<li><code>-s</code> 指定账户登录后所使用的shell</li>
<li><code>-u</code> 指定用户ID号</li>
</ul>
</li>
<li>举例：新建一个用户zhangsan，用户组为net04：<code>useradd –g net04 zhangsan</code></li>
</ul>
<p><code>passwd</code>命令：设置或修改用户的口令以及口令的属性</p>
<ul>
<li>格式：<code>passwd [参数] &lt;用户&gt;</code><ul>
<li><code>-d</code> 删除用户的口令</li>
<li><code>-l</code> 暂时锁定指定的用户帐号</li>
<li><code>-u</code> 解除指定用户帐号的锁定</li>
<li><code>-s</code> 显示指定用户帐号的状态</li>
</ul>
</li>
<li>范例：<ul>
<li>设置与修改属性 <code>passwd zhangsan</code></li>
<li>删除口令 <code>passwd –d zhangsan</code></li>
<li>锁定用户帐号 <code>passwd –l zhangsan</code></li>
<li>解锁用户帐号 <code>passwd –u zhangsan</code></li>
<li>显示用户帐号状态 <code>passwd –s zhangsan</code></li>
</ul>
</li>
</ul>
<p><code>usermod</code>命令：修改用户的属性（超级用户可用）</p>
<ul>
<li>格式：<code>usermod [参数] &lt;用户名&gt;</code><ul>
<li><code>-d</code> 指定用户登入时的主目录</li>
<li><code>-e</code> 账号终止日期</li>
<li><code>-g</code> 指定账户所属的用户组</li>
<li><code>-G</code> 指定账户所属的附加组</li>
<li><code>-s</code> 指定账户登录后所使用的shell</li>
<li><code>-u</code> 指定用户ID号</li>
<li><code>-l</code> 新用户名（用于修改用户名）</li>
</ul>
</li>
<li>举例：将zhangsan改为zhangs ：<code>usermod –l zhangs zhangsan</code></li>
</ul>
<p><code>userdel</code>命令：删除指定的用户帐号（超级用户可用）</p>
<ul>
<li>格式：userdel [参数] &lt;用户名&gt;<ul>
<li><code>-r</code>：不仅删除此用户帐号，而且删除用户主目录及本地邮件存储的目录或文件</li>
<li><code>-f</code>：删除用户登入目录以及目录中所有文件</li>
</ul>
</li>
<li>如果删除用户属于私人组群，而该组群没有其他用户，组群也一并删除。</li>
<li>正在使用系统的用户不能删除。</li>
</ul>
<p><code>su</code>命令：切换用户身份</p>
<ul>
<li>格式：<code>su &lt;用户名&gt;</code><ul>
<li>超级用户可以切换为任何普通用户，而不需要输入口令；普通用户转换为其他用户时需要输入被转换用户的口令</li>
</ul>
</li>
<li>使用<code>exit</code>可以返回到本来的用户身份</li>
</ul>
<p><code>id</code>命令：查看用户的UID、GID和用户所属用户组的信息，如果不指定用户，则显示当前用户的相关信息。</p>
<ul>
<li>格式：<code>id &lt;用户名&gt;</code></li>
</ul>
<p><code>whoami</code>命令：查看当前用户名</p>
<p><code>w</code>命令：查看当前登录系统用户和详细信息</p>
<p><code>groupadd</code>命令：新建组群（超级用户可用）</p>
<ul>
<li>格式：<code>groupadd [参数] &lt;用户组名&gt;</code><ul>
<li><code>-g</code>：指定用户组ID</li>
<li><code>-o</code>：允许组ID号不唯一</li>
</ul>
</li>
</ul>
<p><code>groupmod</code>命令：修改指定用户组的属性（超级用户可用）</p>
<ul>
<li>格式：groupmod [参数] &lt;用户组名&gt;<ul>
<li><code>-g</code>：指定新的用户组ID</li>
<li><code>-n</code>：指定新的用户组名字</li>
<li><code>-o</code>： 允许组ID号不唯一</li>
</ul>
</li>
</ul>
<p><code>groupdel</code>命令：删除指定的用户组（超级用户可用）</p>
<ul>
<li>格式：<code>groupdel &lt;用户组名&gt;</code></li>
<li>注意：在删除指定用户组之前必须保证该用户组不是任何用户的主要组群，否则要先删除以此用户组为主要组群的用户才可以删除该用户组</li>
</ul>
<hr>
<p><strong>文件权限</strong></p>
<ul>
<li>读取权限：浏览文件/目录中内容的权限</li>
<li>写入权限：<ul>
<li>对文件而言是修改文件内容的权限</li>
<li>对目录而言是删除、添加和重命名目录内文件的权限</li>
</ul>
</li>
<li>执行权限：<ul>
<li>对可执行文件而言是允许执行的权限</li>
<li>对目录而言是进入目录的权限。</li>
</ul>
</li>
</ul>
<p><strong>文件用户分类</strong>：</p>
<ul>
<li>文件所有者：建立文件和目录的用户</li>
<li>文件所有者所在组用户：文件所有者所属用户组中的其他用户</li>
<li>其他用户：既不是文件所有者，又不是文件所有组所在组的其他所有用户</li>
<li>超级用户：负责整个系统的管理和维护，拥有系统中所有文件的全部访问权限。</li>
</ul>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220405225155321.png" alt="image-20220405225155321" style="zoom: 80%;">

<hr>
<p><code>chmod</code>命令：修改文件的访问权限</p>
<ul>
<li>格式：<code>chmod &lt;模式&gt; &lt;文件&gt;</code><ul>
<li>模式：<ul>
<li>对象：<code>u</code> 文件所有者 、<code>g</code> 同组用户、<code>o</code>其他用户</li>
<li>操作符：<code>+</code>增加、<code>-</code>删除、<code>=</code>赋予</li>
<li>权限：<code>r</code> 读、<code>w</code> 写、<code>x</code> 执行、<code>s</code>设置用户ID</li>
</ul>
</li>
</ul>
</li>
<li>举例：<ul>
<li>取消同组用户对file文件的写入权限 <code>chmod g-w file</code></li>
<li>将pict目录的访问权限设置为775 <code>chmod 775 pict</code></li>
<li>设置file文件的设置用户ID位 <code>chmod u+s file</code></li>
</ul>
</li>
</ul>
<p><code>chown</code>命令：将指定文件的拥有者改为指定的用户或用户组</p>
<ul>
<li>格式：<code>chown [选项] &lt;所有者/组&gt; &lt;文件&gt;...</code><ul>
<li><code>-c</code> ：显示更改的部分的信息</li>
<li><code>-f</code> ：忽略错误信息</li>
<li><code>-h</code> ：修复符号链接</li>
<li><code>-R</code> ：处理指定目录以及其子目录下的所有文件</li>
<li><code>-v</code> ：显示详细的处理信息</li>
<li><code>-deference</code> ：作用于符号链接的指向，而不是链接文件本身</li>
<li>用户是用户名或者用户ID，用户组可以是组名或者组ID</li>
<li>文件是以空格分开的要改变权限的文件列表，支持通配符</li>
</ul>
</li>
<li>举例：将<code>ex1</code>的所有者由root改为hellen：<code>chown hellen ex1</code></li>
</ul>
<p><code>chgrp</code>命令：改变文件的所属用户组</p>
<ul>
<li>格式：<code>chgrp [选项] &lt;组&gt; &lt;文件&gt;</code><ul>
<li><code>-c</code> ：显示更改的部分的信息</li>
<li><code>-f</code> ：忽略错误信息</li>
<li><code>-h</code> ：修复符号链接</li>
<li><code>-R</code> ：处理指定目录以及其子目录下的所有文件</li>
<li><code>-v</code> ：显示详细的处理信息</li>
<li><code>-deference</code> ：作用于符号链接的指向，而不是链接文件本身</li>
<li>用户组可以是组名或者组ID</li>
</ul>
</li>
<li>举例：将ex1文件所属的用户组由root改为staff：<code>chgrp staff ex1</code></li>
</ul>
<h3 id="编译调试方法"><a href="#编译调试方法" class="headerlink" title="编译调试方法"></a>编译调试方法</h3><h4 id="gcc概述"><a href="#gcc概述" class="headerlink" title="gcc概述"></a><strong>gcc概述</strong></h4><p>gcc是GNU计划的一个项目。是一个自由编译器，如今的gcc已经是一个包含众多语言的编译器了（ C，C++，Ada，Object C，Java及Go等）。所以，GCC也由原来的GNU C Compiler变为<br>GNU Compiler Collection</p>
<p>GCC主要包括:</p>
<ul>
<li><code>cpp</code>(预处理器)</li>
<li><code>gcc</code>(c编译器)、<code>g++</code>(c++编译器)等编译器</li>
<li><code>binutils</code>等二进制工具.<ul>
<li><code>as</code>(汇编器)</li>
<li><code>ld</code>(链接器)</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>源文件-》预处理-》编译-》汇编-》链接-》可执行</strong></p>
<ul>
<li><code>cpp -o hello.i hello.c</code></li>
<li><code>ccl -o hello.s hello.i</code></li>
<li><code>as -o hello.o hello.s</code></li>
<li><code>ld -o hello hello.o</code></li>
</ul>
<hr>
<p><strong>gcc基础使用方法：</strong></p>
<ul>
<li>gcc命令格式：<code>gcc [选项] &lt;文件名&gt;</code><ul>
<li><code>-o filename</code> ：指定输出文件为filename.该选项不在乎gcc产生什么输出，无论是可执行文件，目标文件，汇编文件还是预处理后的C代码</li>
<li>如果没有使用<code>-o</code>选项,默认的输出结果是:可执行文件为<code>a.out</code>，编译后产生的目标文件是<code>sourcename.o</code>，汇编文件是 <code>sourcename.s</code>，而预处理后的C源代码送往标准输出 </li>
</ul>
</li>
<li>对于源代码<code>main.c</code>，可以通过如下命令编译成最终可执行文件（默认包含了预处理、编译、汇编及链接四个阶段）：<code>gcc main.c –o main</code></li>
</ul>
<p><strong>gcc常用编译选项</strong>：</p>
<ul>
<li><p><code>-D</code>: 宏定义选项，等同于代码中的<code>#define MACRO</code> ，但<code>-D</code>定义的宏作用于所有的源文件。</p>
<ul>
<li><code>#define PI 3.14159</code>(如果程序用到PI则用3.14159代替)</li>
<li><code>gcc -DPI=3.14159 main.c</code>（但如果没有定义宏的话，就可以直接在编译的时候赋值再运行）</li>
</ul>
</li>
<li><p><code>-I</code> 头文件的搜索路径:如果用户的头文件不在gcc的搜索路径中，可以用此选项指定额外搜索路径。</p>
<ul>
<li><code>gcc helloworld.c –I /usr/include –o helloworld</code>（将<code>/usr/inlcude</code>加入到文件头文件的搜索路径中）</li>
</ul>
</li>
<li><p>警告选项</p>
<ul>
<li>警告是针对程序结构的诊断信息,程序不一定有错误,而是存在风险,或者可能存在错误。</li>
<li>所有以<code>-W</code>开头的选项基本上均可使用<code>-Wno-option</code>来关闭该警告信息</li>
<li>如<code>-Wunused</code>在某个局部变量除了声明就没再使用,或者声明了静态函数但是没有定义,或者某条语句的运算结果显然没有使用时, 编译器就发出警告。使用``-Wno-unused`可禁止该警告信息。</li>
<li><code>-w</code> ：禁止所有警告信息. </li>
<li><code>-Wall</code>：打开所有警告选项，输出警告信息</li>
<li>通常建议打开<code>-Wall</code>，这样至少可以看出你的代码里有哪些地方可能存在问题</li>
</ul>
</li>
</ul>
<p><strong>静态库编译和使用</strong>：</p>
<ul>
<li>把 <code>.c</code>编译成 <code>.o</code>：  <code>gcc –c increase.c –o increase.o</code></li>
<li>把 <code>.o</code>归档成 静态库<code>.a</code> ：<code>ar –r libincrease.a increase.o</code></li>
<li>静态库和其它源文件链接成可执行文件：<code>gcc main.c –L –static –o main</code></li>
</ul>
<p><strong>动态库编译</strong>：</p>
<ul>
<li>生成动态链接库：<code>gcc -shared -fPIC -o libinc.so increase.c</code><ul>
<li>动态链接库的名字必须以<code>lib</code>开头 <code>.so</code>结束，这是linux系统上的强制约束，否则无法使用该共享库</li>
<li><code>-shared</code> 生成共享文件</li>
<li><code>-fPIC</code> 生成位置独立的代码，此类代码可以在不同进程间共享。</li>
</ul>
</li>
</ul>
<p><strong>动态库的使用</strong>：</p>
<ul>
<li><code>-l library</code> 名字为library的动态链接库。事实上此动态链接库在文件系统中的名字为liblibrary .so。连接器会自动加上lib*.so。</li>
<li><code>-L dir</code> 共享库搜索目录。gcc除了会在自定义的目录中搜索共享库外，用户也自定义目录让gcc搜索。<code>gcc main.c -o main -linc -L./</code></li>
</ul>
<h4 id="gdb概述"><a href="#gdb概述" class="headerlink" title="gdb概述"></a><strong>gdb概述</strong></h4><p>gdb是GNU计划开发的程序调试工具</p>
<p>gdb可以完成以下四个方面的功能：</p>
<ul>
<li>启动程序，可以按照自定义的要求随心所欲的运行程序</li>
<li>可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式）</li>
<li>当程序被停住时，可以检查此时程序中所发生的情况</li>
<li>动态的改变程序的执行环境</li>
</ul>
<p><strong>gdb的启动</strong>：</p>
<ul>
<li>直接在shell中运行<code>gdb</code>命令，进入gdb界面后用<code>file program</code>装载程序。</li>
<li>在shell中启动gdb并加载可执行文件<code>gdb &lt;program&gt;</code></li>
<li>用gdb同时调试一个运行程序和core文件（core是程序非法执行后core dump后产生的文件）<code>gdb program core</code></li>
<li>调试正在运行的进程<code>gdb program &lt;processid&gt;</code><ul>
<li>进入gdb后用 <code>attach &lt;processid&gt;</code> 调试正在运行的进程。</li>
</ul>
</li>
</ul>
<p><strong>gdb常用命令</strong>：</p>
<p><code>break</code>命令：</p>
<ul>
<li>功能：断点设置命令<code>break</code>(缩写 <code>b</code>)，当gdb执行到该断点时会让程序暂停运行。此时程序员可以查看运行中程序的情况。</li>
<li>格式：<code>break [LOCATION] [thread THREADNUM] [if CONDITION]</code><ul>
<li><code>[LOCATION]</code>：<ul>
<li><code>linenum</code>（行号），如<code>b 123</code></li>
<li><code>function</code>(函数名) ，如<code>b main</code></li>
<li><code>filename:linenum</code>，如<code>b increase:123</code></li>
<li><code>filename:function</code>，如<code>b increase:main</code></li>
<li>class:function（c++）</li>
</ul>
</li>
<li><code>[thread THREADNUM]</code> 调试多线程程序时，切换到哪个线程或者在那个线程中设置断点。<code>break frik.c:13 thread 28</code> </li>
<li><code>[if CONDITION]</code>： 当条件满足时，断点才生效。一般称为条件断点。CONDITION跟C语言一样。<ul>
<li><code>b 123 if index==2</code>当index为2时，程序在123行停下</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>watchpoint</code>命令：</p>
<ul>
<li><code>watchpoint</code>称为观察点，当观察对象的值有变化时，程序立即停止执行。</li>
<li><code>watch &lt;expr&gt;</code> ：为表达式（变量）expr设置一个观察点。一旦表达式值有变化时，马上停住程序。</li>
<li><code>rwatch &lt;expr&gt;</code> ：当表达式（变量）expr被读时，停住程序。</li>
<li><code>awatch &lt;expr&gt;</code> ：当表达式（变量）的值被读或被写时，停住程序。</li>
<li><code>info watchpoints</code> ：列出当前所设置了的所有观察点</li>
</ul>
<p>清除禁止断点或观察点：</p>
<ul>
<li><code>clear [linenum] [function name]</code> 清除所有断点，不会清除watchpoints</li>
<li><code>delete &lt;num&gt;</code> 清除编号为num的断点或者watchpoint</li>
<li><code>disable &lt;num&gt;</code> 禁止某个断点</li>
<li><code>enable &lt;num&gt;</code> 开启某个断点</li>
</ul>
<p>gdb调试命令：</p>
<ul>
<li><code>step</code> 单步调试命令，一次执行一行程序。</li>
<li><code>next</code> 单步调试命令，但跳过函数调用。</li>
<li><code>finish</code> 单步调试时直接从一个函数中返回</li>
<li><code>disassemble</code> 显示汇编代码。</li>
<li><code>backtrace</code>或者<code>bt</code> 查看目前程序的堆栈情况。</li>
<li><code>where</code>查看当前位置。</li>
<li><code>up/down</code> 向上或者向下移动一个堆栈。</li>
<li><code>frame&lt;num&gt;</code>或者<code>f</code> 移动到第num个堆栈。</li>
<li>当移动到某个堆栈时，便可以用gdb命令查看在那个堆栈中的局部变量。</li>
</ul>
<h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><h3 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h3><p>文件系统是以合理有效的层次结构组织的文件和目录的集合</p>
<p>“<strong>一切皆是文件</strong>”是 Unix/Linux 的基本哲学之一</p>
<p>普通文件、目录、字符设备、块设备、 套接字等在 Unix/Linux 中都是文件</p>
<p>类型不同的文件都是通过<strong>相同的API</strong>对其进行操作</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406135159849.png" alt="image-20220406135159849" style="zoom:80%;">



<p>Unix/Linux 中允许不同的文件系统共存，如 ext2, ext3, ext4, xfs, btrfs 等</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406135301992.png" alt="image-20220406135301992" style="zoom:67%;">

<p>通过统一的文件 I/O 系统调用API即可对系统中的任意文件进行操作而无需考虑其所在的具体文件系统格式</p>
<p>文件操作可以跨文件系统执行</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406135352137.png" alt="image-20220406135352137" style="zoom:67%;">

<p><strong>与windows文件系统的区别</strong>：</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406135433630.png" alt="image-20220406135433630" style="zoom:67%;">



<h3 id="文件系统架构"><a href="#文件系统架构" class="headerlink" title="文件系统架构"></a>文件系统架构</h3><p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406135923462.png" alt="image-20220406135923462"></p>
<h3 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h3><p><strong>虚拟文件系统VFS</strong></p>
<ul>
<li>虚拟文件系统是Linux 内核中的一个软件层，对内实现文件系统的抽象，允许不同的文件系统共存，对外向应用程序提供统一的文件系统接口</li>
<li>为了能够支持不同文件系统，VFS 定义了所有文件系统都支持的基本的、抽象的接口和<strong>数据结构</strong></li>
<li>实际文件系统实现VFS 定义的抽象接口和数据结构，将自身的诸如文件、目录等概念在形式上与VFS的定义保持一致，在统一的接口和数据结构下隐藏了具体的实现细节</li>
</ul>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406140531667.png" alt="image-20220406140531667" style="zoom:67%;">

<p><strong>VFS中的数据结构：</strong></p>
<ul>
<li><strong>超级块（super block）</strong>：用于存储文件系统的控制信息的数据结构。描述文件系统的状态、文件系统类型、大小、区块数、索引节点数等，存放于磁盘的特定扇区中。</li>
<li><strong>索引节点（inode）</strong>：用于存储文件的元数据（文件的基本信息）的一个数据结构，包含诸如文件的大小、拥有者、创建时间、磁盘位置等信息。</li>
<li><strong>目录项（dentry）</strong>：目录被用来容纳文件，目录可以包含子目录，层层嵌套以形成文件路径。</li>
<li><strong>文件对象（file）</strong>：一组在逻辑上具有完整意义的信息项的系列</li>
</ul>
<p><strong>VFS-超级块（super block</strong>）：</p>
<ul>
<li>超级块用来描述整个文件系统的信息。每个具体的文件系统都有各自的超级块</li>
<li>VFS超级块是各种具体文件系统在安装时建立的，并在卸载时被自动删除，其数据结构是<code>super_block</code></li>
<li>所有超级块对象以双向环形链表的形式链接在一起</li>
</ul>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406140929967.png" alt="image-20220406140929967" style="zoom:80%;">

<p><strong>VFS-索引节点（inode）</strong>：</p>
<ul>
<li>文件系统处理文件所需要的所有信息都放在称为索引节点的数据结构inode中</li>
<li>具体文件系统的索引节点是存放在磁盘上的，是一种<strong>静态结构</strong>，要使用它，必须调入内存，填写VFS的索引节点，因此，也称VFS索引节点是<strong>动态节点</strong></li>
<li>文件名可以随时更改，但是索引节点对文件是唯一的，并且随文件的存在而存在</li>
<li>每个inode节点的大小，一般是128字节或256字节</li>
</ul>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406141107311.png" alt="image-20220406141107311" style="zoom:80%;">

<p><strong>VFS-目录项对象（dentry）</strong>：</p>
<ul>
<li>每个文件除了有一个索引节点inode数据结构外，还有一个目录项dentry数据结构。</li>
<li>dentry结构代表的是逻辑意义上的文件，描述的是文件逻辑上的属性，目录项对象在磁盘上并没有对应的映像</li>
<li>inode结构代表的是物理意义上的文件，记录的是物理上的属性，对于一个具体的文件系统，其inode结构在磁盘上就有对应的映像</li>
<li>一个索引节点对象可能对应多个目录项对象</li>
</ul>
<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406143746728.png" alt="image-20220406143746728"></p>
<p><strong>VFS-文件对象（file）</strong>：</p>
<ul>
<li>进程是通过文件描述符来访问文件的</li>
<li>Linux中专门用了一个<code>file</code>文件对象来保存打开文件的文件位置，这个对象称为打开的文件描述（open file description）</li>
<li>文件描述符是用来描述打开的文件的。每个进程用一个<code>files_struct</code>结构来记录文件描述符的使用情况，这个files_struct结构称为用户打开文件表，它是进程的私有数据</li>
<li>file结构中主要保存了文件位置，此外，还把指向该文件索引节点的指针也放在其中。file结构形成一个双链表，称为系统打开文件表。</li>
</ul>
<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406143935113.png" alt="image-20220406143935113"></p>
<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406143948216.png" alt="image-20220406143948216"></p>
<p><strong>VFS数据结构之间的关系</strong></p>
<ul>
<li>超级块是对一个文件系统的描述</li>
<li>索引节点是对一个文件物理属性的描述</li>
<li>目录项是对一个文件逻辑属性的描述</li>
<li>一个进程所处的位置是由<code>fs_struct</code>来描述的，而一个进程（或用户）打开的文件是由<code>files_struct</code>来描述的，而整个系统所打开的文件是由<code>file</code>结构来描述</li>
</ul>
<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406150131249.png" alt="image-20220406150131249"></p>
<h3 id="文件系统的注册和注销"><a href="#文件系统的注册和注销" class="headerlink" title="文件系统的注册和注销"></a>文件系统的注册和注销</h3><ul>
<li>当内核被编译时，就已经确定了可以支持哪些文件系统，这些文件系统在系统引导时，在 VFS 中进行注册。</li>
<li>VFS的初始化函数用来向VFS注册，即填写文件注册表<code>file_system_type</code>数据结构</li>
<li>注册调用<code>register_filesystem()</code>函数</li>
<li>注销即删除一个<code>file_system_type</code> 结构，需调用 <code>unregister_filesystem()</code>函数</li>
</ul>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406150315979.png" alt="image-20220406150315979" style="zoom:67%;">

<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406150416375.png" alt="image-20220406150416375" style="zoom:67%;">



<h3 id="文件系统的安装"><a href="#文件系统的安装" class="headerlink" title="文件系统的安装"></a>文件系统的安装</h3><ul>
<li>安装一个文件系统实际上是安装一个物理设备</li>
<li>自己（一般是超级用户）安装文件系统时，需要指定三种信息：文件系统的名称、包含文件系统的物理块设备、文件系统在已有文件系统中的安装点。</li>
<li><code>$ mount -t iso9660 /dev/hdc /mnt/cdrom</code> 其中，<code>iso9660</code>是光驱文件系统的名称，<code>/dev/hdc</code>是包含文件系统的物理块设备，<code>/mnt/cdrom</code>就是将要安装到的目录，即安装点。</li>
<li>在用户程序中要安装一个文件系统则可以调用<code>mount()</code>系统调用。安装过程主要工作是创建安装点对象，将其挂接到根文件系统的指定安装点下，然后初始化超级块对象，从而获得文件系统基本信息和相关的操作。</li>
</ul>
<h3 id="文件系统的卸载"><a href="#文件系统的卸载" class="headerlink" title="文件系统的卸载"></a>文件系统的卸载</h3><ul>
<li>如果文件系统中的文件当前正在使用，该文件系统是不能被卸载的</li>
<li>查看对应的 VFS 超级块，如果该文件系统的 VFS 超级块标志为“脏”，则必须将超级块信息写回磁盘</li>
<li>之后，对应的 VFS 超级块被释放，vfsmount 数据结构将从vfsmntlist 链表中断开并被释放</li>
<li>具体的实现代码为<code>fs/super.c</code>中的<code>sys_umount()</code>函数</li>
</ul>
<h2 id="文件IO操作"><a href="#文件IO操作" class="headerlink" title="文件IO操作"></a>文件IO操作</h2><p>系统调用：操作系统提供给用户程序调用的一组“特殊”接口，用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406152559930.png" alt="image-20220406152559930" style="zoom: 50%;">

<p>Q：为什么用户程序不能直接访问系统内核提供的服务？</p>
<p>A：为了更好地保护内核空间，将程序的运行空间分为内核空间和用户空间（也就是常称的内核态和用户态），它们分别运行在不同的级别上，在逻辑上是相互隔离的。因此，用户进程在通常情况下不允许访问内核数据，也无法使用内核函数，它们只能在用户空间操作用户数据，调用用户空间的函数。</p>
<p>进行系统调用时，程序运行空间从用户空间进入内核空间，处理完后再返回到用户空间</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406152730069.png" alt="image-20220406152730069" style="zoom:67%;">

<p>系统调用并不是直接与程序员进行交互的，它仅仅是一个通过<strong>软中断机制</strong>向内核提交请求，以获取内核服务的接口。</p>
<p>在实际使用中程序员调用的通常是用户编程接口——API</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406152820289.png" alt="image-20220406152820289" style="zoom:50%;">

<p>Linux中的系统调用包含在Linux的libc库中，通过标准的C函数调用方法可以调用</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406152854242.png" alt="image-20220406152854242" style="zoom: 67%;">

<p><strong>系统命令</strong>相对API更高了一层，它实际上是一个可执行程序，它的内部调用了用户编程接口（API）来实现相应的功能</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406152959593.png" alt="image-20220406152959593" style="zoom:67%;">



<p><strong>文件描述符</strong>：</p>
<p>Q：内核如何区分和引用特定的文件？</p>
<p>A：通过<strong>文件描述符</strong>。文件描述符是一个非负的整数，它是一个索引值，并指向在内核中每个进程打开文件的记录表。当打开一个现存文件或创建一个新文件时，内核就向进程返回一个文件描述符；当需要读写文件时，也需要把文件描述符作为参数传递给相应的函数。</p>
<p>一个进程启动时，通常会打开3个文件：</p>
<ul>
<li>标准输入 描述符为0</li>
<li>标准输出 描述符为1</li>
<li>标准出错处理 描述符为2</li>
</ul>
<p><strong>文件IO函数</strong></p>
<ul>
<li><code>open()</code> 用于打开或创建文件，可以指定文件的属性及用户的权限等各种参数</li>
<li><code>creat()</code> 打开一个文件，如果文件不存在，则创建它</li>
<li><code>close()</code> 用于关闭一个被打开的文件。当一个进程终止时，所有被它打开的文件都由内核自动关闭，很多程序都使用这一功能而不显示地关闭一个文件</li>
<li><code>read()</code> 用于将从指定的文件描述符中读出的数据放到缓存区中，并返回实际读入的字节数。若返回0，则表示没有数据可读，即已达到文件尾。读操作从文件的当前指针位置开始</li>
<li><code>write()</code>  用于向打开的文件写数据，写操作从文件的当前指针位置开始。对磁盘文件进行写操作，若磁盘已满或超出该文件的长度，则write()函数返回失败</li>
</ul>
<hr>
<h3 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h3><p>头文件</p>
<ul>
<li><code>#include &lt;sys/types.h&gt;</code></li>
<li><code>#include &lt;sys/stat.h&gt;</code></li>
<li><code>#include &lt;fcntl.h&gt;</code></li>
</ul>
<p>函数原型</p>
<ul>
<li><code>int open(const char* pathname, int flags);</code></li>
<li><code>int open(const char* pathname, int flags, mode_t mode);</code></li>
</ul>
<p>函数说明</p>
<ul>
<li>参数<code>pathname</code> 指向欲打开的文件路径字符串。</li>
<li>下列是参数<code>flags</code> 常用的标识:<ul>
<li><code>O_RDONLY</code> 以<strong>只读</strong>方式打开文件</li>
<li><code>O_WRONLY</code> 以<strong>只写</strong>方式打开文件</li>
<li><code>O_RDWR</code> 以<strong>可读写</strong>方式打开文件。上述三种标识是互斥的，也就是不可同时使用，但可与下列的标识利用OR(|)运算符组合。</li>
<li><code>O_CREAT</code> 若欲打开的文件<strong>不存在则自动建立</strong>该文件。</li>
<li><code>O_TRUNC</code> 若文件存在并且以可写的方式打开时，此标识会<strong>令文件长度清为0</strong>，而原来存于该文件的资料也会消失。</li>
<li><code>O_APPEND</code> 当读写文件时会从文件尾开始移动，也就是所写入的数据会以<strong>附加</strong>的方式加入到文件后面。</li>
<li><code>O_NONBLOCK</code> 以不可阻断的方式打开文件，也就是无论有无数据读取或等待，都会立即返回进程之中。</li>
<li><code>O_EXCL</code>: 如果同时指定 O_CREAT，而该文件又是存在的，报错；也可以测试一个文件是否存在，不存在则创建。</li>
</ul>
</li>
<li>返回值：文件打开成功返回文件的描述符，失败返回-1</li>
</ul>
<h3 id="creat函数"><a href="#creat函数" class="headerlink" title="creat函数"></a>creat函数</h3><p>头文件</p>
<ul>
<li><code>#include&lt;sys/types.h&gt;</code></li>
<li><code>#include&lt;sys/stat.h&gt;</code></li>
<li><code>#include&lt;fcntl.h&gt;</code></li>
</ul>
<p>函数原型</p>
<ul>
<li><code>int creat(const char * pathname, mode_t mode)</code></li>
</ul>
<p>参数说明</p>
<ul>
<li>参数<code>pathname</code>指向欲建立的文件路径字符串。</li>
<li><code>creat()</code>相当于使用下列的调用方式调用<code>open(const char * pathname ,(O_CREAT|O_WRONLY|O_TRUNC))</code></li>
</ul>
<p>返回值</p>
<ul>
<li><code>creat()</code>会返回新的文件描述词，若有错误发生则会返回-1，并把错误代码设给errno</li>
</ul>
<p>附加说明</p>
<ul>
<li><code>creat</code>函数的一个不足之处是它以<strong>只写</strong>方式打开所创建的文件</li>
</ul>
<h3 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h3><p>头文件</p>
<ul>
<li><code>#include&lt;unistd.h&gt;</code></li>
</ul>
<p>函数原型</p>
<ul>
<li><code>int close(int fd);</code></li>
</ul>
<p>函数说明</p>
<ul>
<li>当使用完文件后若已不再需要则可使用close()关闭该文件，close()会让数据写回磁盘，并释放该文件所占用的资源。</li>
<li>参数<code>fd</code>为先前由open()或creat()所返回的文件描述符;</li>
<li>返回值：若文件顺利关闭则返回0，发生错误时返回-1。</li>
<li>附加说明：虽然在进程结束时，系统会自动关闭已打开的文件，但仍建议自行关闭文件，并检查返回值。</li>
</ul>
<h3 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h3><p>头文件</p>
<ul>
<li><code>#include&lt;unistd.h&gt;</code></li>
</ul>
<p>定义函数</p>
<ul>
<li><code>ssize_t read(int fd, void * buf, size_t count);</code></li>
</ul>
<p>函数说明</p>
<ul>
<li><code>read()</code>会把参数<code>fd</code> 所指的文件传送<code>count</code>个字节到<code>buf</code>指针所指的内存中。</li>
<li>若参数<code>count</code>为0，则<code>read()</code>不会有作用并返回0。</li>
<li>返回值为实际读取到的字节数，如果返回0，表示已到达文件尾或是无可读取的数据，此外文件读写位置会随读取到的字节移动;</li>
<li>返回值：成功返回读取的字节数，出错返回-1</li>
</ul>
<p><code>read</code>函数实际读到的字节数少于要求读的字节数时：</p>
<ul>
<li>读普通文件，在读到要求字节数之前就到达文件尾</li>
<li>当从终端设备读，通常一次最多读一行；</li>
<li>当从网络读时，网络中的缓冲机构可能造成返回值小于所要求读的字节数；</li>
<li>某些面向记录的设备，如磁带，一次最多返回一个记录；</li>
</ul>
<p>读操作完成后，文件的当前位置将从读之前的位置加上实际读的字节数</p>
<p>当有错误发生时则返回-1，错误代码存入errno中，而文件读写位置则无法预期</p>
<h3 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h3><p>头文件</p>
<ul>
<li><code>#include&lt;unistd.h&gt;</code></li>
</ul>
<p>函数原型</p>
<ul>
<li><code>ssize_t write (int fd, const void * buf, size_t count);</code> </li>
</ul>
<p>函数说明</p>
<ul>
<li><code>write()</code>会把参数<code>buf</code>所指的内存写入<code>count</code>个字节到参数<code>fd</code>所指的文件内。当然，文件读写位置也会随之移动;</li>
<li>返回值：如果顺利<code>write()</code>会返回实际写入的字节数。当有错误发生时则返回<code>-1</code>，错误代码存入<code>errno</code>中。</li>
<li><code>write</code>出错的原因可能是磁盘满、没有访问权限、或写超过文件长度限制等等</li>
<li>附加说明：将数据写入已打开的文件内。对于普通文件，写操作从文件当前位置开始写（除非打开文件时指定了<code>O_APPEND</code>选项）。写操作完成后，文件的当前位置将从写之前的位置加上实际写的字节数。</li>
</ul>
<p><font color="#ff0000">注意：</font>数据无法一次性读完时：</p>
<ul>
<li>第二次读<code>buf</code>中数据时，读位置指针并不会自动移动</li>
<li>按如下格式实现读位置移动：<code>write(fp, p1+len, (strlen(p1)-len)</code>，直至指针恢复</li>
</ul>
<p>Write一次可以写的最大数据范围是<code>8192</code></p>
<ul>
<li>写入数据大小最好小于buff中的值</li>
<li>Count参数值大于<code>SSIZE_MAX</code>，则<code>write</code>调用的结果未定义</li>
<li>Count参数值为0时，write调用会立即返回0这个值</li>
<li>Write调用返回时，内核已经将缓冲区所提供的数据复制到内核的缓冲区，但是无法保证数据已经写出到预定的目的地</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_PATH <span class="meta-string">&quot;./test.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>((fd = open(FILE_PATH, O_RDWR | O_CREAT | O_EXCL, <span class="number">0666</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>); <span class="comment">//test.txt文件存在的话会报错</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open success\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入内容到test.txt文件中\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>]; </span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">if</span> ((num = read(STDIN_FILENO, buf, <span class="number">200</span>)) == <span class="number">-1</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;read error&quot;</span>); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>); </span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// 将键盘输入又输出到屏幕上</span></span><br><span class="line">		write(STDOUT_FILENO, buf, num);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将键盘输入 分两次 输出到test.txt文件</span></span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((front = write(fd, buf, <span class="number">10</span>)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write %d Bytes\n&quot;</span>, front);</span><br><span class="line">        <span class="keyword">if</span>((front = write(fd, buf+<span class="number">10</span>, num<span class="number">-10</span>)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write %d bytes\n&quot;</span>, front);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//问题：怎么会读不到test.txt文件中的内容呢？</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">if</span>((fd = open(<span class="string">&quot;./test.txt&quot;</span>, O_RDONLY) == <span class="number">-1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open success\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd = %d\n&quot;</span>, fd);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = read(fd, buf, <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read %d bytes\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">        num = read(fd, buf, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read %d bytes\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ioctl函数"><a href="#ioctl函数" class="headerlink" title="ioctl函数"></a>ioctl函数</h3><p>设备驱动程序中对设备的I/O通道进行管理</p>
<p>头文件</p>
<ul>
<li><code>#include&lt;sys/ioctl.h&gt;</code></li>
</ul>
<p>定义函数</p>
<ul>
<li><code>int ioctl(int fd, int cmd, ...);</code></li>
</ul>
<p>函数说明</p>
<ul>
<li><code>ioctl()</code>能对一些特殊的文件(主要是设备)进行一些底层参数的操作。许多字符设备都使用ioctl请求来完成对设备的控制;</li>
<li>返回值：成动返回0。当有错误发生时则返回-1，错误代码存入errno中</li>
<li>附加说明：ioctl是设备驱动程序中对设备的I/O通道进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等</li>
</ul>
<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406165728902.png" alt="image-20220406165728902"></p>
<p>在驱动程序中实现的ioctl函数体内，实际上是有一个<code>switch&#123;case&#125;</code>结构，每一个case对应一个<strong>命令码</strong>，做出一些相应的操作</p>
<p>ioctl中命令码是唯一联系用户程序命令和驱动程序支持的途径</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220406165833211.png" alt="image-20220406165833211" style="zoom:67%;">

<p>“幻数”是一个字母，数据长度也是8，用一个特定的字母来标明设备类型</p>
<h2 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h2><p>为什么要设计标准I/O库？</p>
<ul>
<li>直接使用API进行文件访问时，需要考虑许多细节问题，例如：read、write时，缓冲区的大小该如何确定，才能使效率最优</li>
<li>read和write等底层系统调用函数进行输入输出时，在用户态和内核态之间来回切换，每次读出或写入的数据量较少，导致频繁的I/O操作，增加了系统开销</li>
</ul>
<p>标准I/O库是ANSI C规范的一部分，函数原型在文件<code>stdio.h</code>中定义，对底层I/O系统调用进行了封装，为程序员提供了带有格式转换功能的输入输出操作，并在用户空间增加了缓冲区管理</p>
<p><strong>标准I/O库</strong>：</p>
<ul>
<li>分离了应用程序空间和实际的物理设备</li>
<li>减少了直接读盘次数，提高性能<ul>
<li>读取前查看是否已存在页缓存中，如果已经存放在了页缓存中，数据立即返回给应用程序</li>
<li>写数据前先写到页缓存中，如果用户采用的是同步写机制（synchronous writes），那么数据会立即被写回到磁盘上，应用程序会一直等到数据被写完为止；如果用户采用的是延迟写机制（ deferred writes ），那么应用程序就完全不需要等到数据全部被写回到磁盘，数据只要被写到页缓存中去就可以了</li>
</ul>
</li>
</ul>
<h3 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h3><p>fopen函数功能：打开一个指定文件</p>
<p>函数原型</p>
<ul>
<li><code>FILE *fopen(const char *restrict pathname, const char *restrict type);</code></li>
</ul>
<p>参数</p>
<ul>
<li><code>pathname</code>：要打开的文件名 </li>
<li><code>type</code>：指定文件的读、写方式</li>
</ul>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r或rb</td>
<td align="center">为读而打开</td>
</tr>
<tr>
<td align="center">w或wb</td>
<td align="center">使文件长度为0，或为写而创建</td>
</tr>
<tr>
<td align="center">a或ab</td>
<td align="center">追加文件内容，或为写而创建</td>
</tr>
<tr>
<td align="center">r+或r+b或rb+</td>
<td align="center">为读写而打开</td>
</tr>
<tr>
<td align="center">w+或w+b或wb+</td>
<td align="center">使文件长度为0，或为读写而打开或创建</td>
</tr>
<tr>
<td align="center">a+或a+b或ab+</td>
<td align="center">在文件尾读写而打开或创建</td>
</tr>
</tbody></table>
<h3 id="setbuf函数"><a href="#setbuf函数" class="headerlink" title="setbuf函数"></a>setbuf函数</h3><p>  定义流 stream 应如何缓冲</p>
<p>函数原型</p>
<ul>
<li><code>void setbuf(FILE *steam, char *buf);</code></li>
</ul>
<p>参数</p>
<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。</li>
<li><strong>buffer</strong> – 这是分配给用户的缓冲，它的长度至少为 <code>BUFSIZ</code> 字节，<code>BUFSIZ</code> 是一个宏常量，表示数组的长度。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">   setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;This is runoob&quot;</span>);</span><br><span class="line"></span><br><span class="line">   fflush(<span class="built_in">stdout</span>);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.runoob.com/cprogramming/c-function-setbuf.html">C 库函数 – setbuf() | 菜鸟教程 (runoob.com)</a></p>
<h3 id="setvbuf函数"><a href="#setvbuf函数" class="headerlink" title="setvbuf函数"></a>setvbuf函数</h3><p>函数原型</p>
<ul>
<li><code>void setvbuf(FILE *steam, char *buf, int mode, size_t size);</code></li>
</ul>
<p>参数</p>
<ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。</li>
<li><strong>buffer</strong> – 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。</li>
<li><strong>mode</strong> – 这指定了文件缓冲的模式：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_IOFBF</td>
<td align="left"><strong>全缓冲</strong>：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。</td>
</tr>
<tr>
<td align="left">_IOLBF</td>
<td align="left"><strong>行缓冲</strong>：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。</td>
</tr>
<tr>
<td align="left">_IONBF</td>
<td align="left"><strong>无缓冲</strong>：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。</td>
</tr>
</tbody></table>
<ul>
<li><strong>size</strong> –这是缓冲的大小，以字节为单位。</li>
</ul>
<p>返回值：如果成功，则该函数返回 0，否则返回非零值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">memset</span>( buff, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>( buff ));</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;启用全缓冲\n&quot;</span>);</span><br><span class="line">   setvbuf(<span class="built_in">stdout</span>, buff, _IOFBF, <span class="number">1024</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;这里是 runoob.com\n&quot;</span>);</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;该输出将保存到 buff\n&quot;</span>);</span><br><span class="line">   fflush( <span class="built_in">stdout</span> );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;这将在编程时出现\n&quot;</span>);</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;最后休眠五秒钟\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   sleep(<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.runoob.com/cprogramming/c-function-setvbuf.html">C 库函数 – setvbuf() | 菜鸟教程 (runoob.com)</a></p>
<h3 id="fdopen函数"><a href="#fdopen函数" class="headerlink" title="fdopen函数"></a>fdopen函数</h3><p>函数功能</p>
<ul>
<li>取一个现存的文件描述符，并使一个标准I/O流与该描述符相结合</li>
</ul>
<p>头文件</p>
<ul>
<li><code>#include&lt;stdio.h&gt;</code></li>
</ul>
<p>函数原型</p>
<ul>
<li><code>FILE *fdopen(int fd, const char *type);</code></li>
</ul>
<p>fdopen常用于由创建管道及网络通信通道函数返回的描述符。</p>
<ul>
<li>这些特殊类型的文件，不能用fopen打开</li>
<li>因此必须先调用设备专用函数以获得一个文件描述符，然后再用fdopen使一个标准I/O流与该描述符相关联</li>
</ul>
<p>对于fdopen函数，<code>type</code>参数的意义稍有区别</p>
<ul>
<li>因为该描述符已被打开，所以fdopen为写而打开并不截短该文件</li>
<li>不能用于创建该文件（因为如若一个描述符引用一个文件，则该文件一定已经存在）</li>
</ul>
<table>
<thead>
<tr>
<th>Type值</th>
<th>操作文件类型</th>
<th>是否新建文件</th>
<th>是否清空原文件</th>
<th>可读</th>
<th>可写</th>
<th>读写开始位置</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>文本文件</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
<td>文件开头</td>
</tr>
<tr>
<td>r+</td>
<td>文本文件</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td>文件开头</td>
</tr>
<tr>
<td>w</td>
<td>文本文件</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>文件开头</td>
</tr>
<tr>
<td>w+</td>
<td>文本文件</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>文件开头</td>
</tr>
<tr>
<td>a</td>
<td>文本文件</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>文件结尾</td>
</tr>
<tr>
<td>a+</td>
<td>文本文件</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>文件结尾</td>
</tr>
<tr>
<td>rb</td>
<td>二进制文件</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
<td>文件开头</td>
</tr>
<tr>
<td>r+b或rb+</td>
<td>二进制文件</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td>文件开头</td>
</tr>
<tr>
<td>wb</td>
<td>二进制文件</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>文件开头</td>
</tr>
<tr>
<td>w+b或wb+</td>
<td>二进制文件</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>文件开头</td>
</tr>
<tr>
<td>ab</td>
<td>二进制文件</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>文件结尾</td>
</tr>
<tr>
<td>a+b或ab+</td>
<td>二进制文件</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>文件结尾</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>)) == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fopen file error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;hello word\n&quot;</span>); <span class="comment">//写入文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR)) == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file fail\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fp = fdopen(fd, <span class="string">&quot;a+&quot;</span>)) == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fdopen open\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;linux c program\n&quot;</span>); <span class="comment">//写入文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><h3 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h3><p>lseek函数用于改变文件的当前偏移量。</p>
<p>头文件</p>
<ul>
<li><code>#include&lt;unistd.h&gt;</code></li>
</ul>
<p>定义函数</p>
<ul>
<li><code>off_t lseek(int filedes, off_t offset, int origin);</code></li>
</ul>
<p>函数说明</p>
<ul>
<li><code>filedes</code> 文件描述符</li>
<li><code>offset</code> 必须与origin一同解析</li>
<li><code>origin</code>为 SEEK_SET, 则offset从文件的开头算起。</li>
<li><code>origin</code>为 SEEK_CUR, 则offset从当前位置算起，既新偏移量为当前偏移量加上offset</li>
<li><code>origin</code>为 SEEK_END, 则offset从文件末尾算起。</li>
</ul>
<p>返回值</p>
<ul>
<li>如果失败，返回值为-1</li>
<li>成功返回移动后的文件偏移量。可用<code>lseek</code>确定文件当前偏移量: <code>currpos = lseek(fd, 0, SEEK_CUR)</code></li>
</ul>
<p>lseek常用于找到文件的开头、找到文件的末端，判定文件描述符的当前位置</p>
<p>lseek仅将当前的文件偏移量记录在内核中，它并不引起任何I/O操作，然后该偏移量用于下一次读、写操作。</p>
<p>文件偏移量可以大于文件的当前长度，但并不改变相应的i节点信息。在这种情况下的下一次写将延长该文件，并在文件中构成一个<strong>空洞</strong>，但文件大小并不是文件的最大偏移量。对空洞位置的读操作将返回0。</p>
<p><strong>lseek实现空洞</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	fd=open(<span class="string">&quot;hole.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	write(fd,<span class="string">&quot;hello&quot;</span>,<span class="number">5</span>);</span><br><span class="line">	ret = lseek(fd, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>, SEEK_CUR);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;lseek error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	write(fd,<span class="string">&quot;world&quot;</span>,<span class="number">5</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yang@Ubuntu18~$ gcc lseek_test.c -o lseek_test</span><br><span class="line">yang@Ubuntu18~$ ./lseek_test</span><br><span class="line">yang@Ubuntu18~$ ls -lh hole.txt</span><br><span class="line">-rw-r--r-- 1 yang yang 1.1G Apr  6 20:49 hole.txt</span><br><span class="line">yang@Ubuntu18~$ od -c hole.txt</span><br><span class="line">0000000   h   e   l   l   o  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0</span><br><span class="line">0000020  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0</span><br><span class="line">*</span><br><span class="line">10000000000  \0  \0  \0  \0  \0   w   o   r   l   d</span><br><span class="line">10000000012</span><br><span class="line">yang@Ubuntu18~$ cat hole.txt</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>



<h3 id="pread函数"><a href="#pread函数" class="headerlink" title="pread函数"></a>pread函数</h3><p>在给定的偏移量读取一个文件描述</p>
<p>头文件</p>
<ul>
<li><code>#include &lt;unistd.h&gt;</code></li>
</ul>
<p>函数原型</p>
<ul>
<li><code>ssize_t pread (int fd, void *buf, size_t count, off_t pos)</code></li>
</ul>
<p>返回值</p>
<ul>
<li>返回读到的字节数；出错：返回-1；到文件结尾：返回0</li>
</ul>
<p>解决问题</p>
<ul>
<li>由于lseek和read调用之间，内核可能会临时挂起进程，所以对同步问题造成了问题，调用<strong>pread相当于顺序调用了lseek 和read</strong>，这两个操作相当于一个<strong>捆绑的原子操作</strong></li>
</ul>
<p>其他</p>
<ul>
<li>调用pread时，无法中断其定位和读操作，另外不更新文件指针</li>
</ul>
<h3 id="pwrite函数"><a href="#pwrite函数" class="headerlink" title="pwrite函数"></a>pwrite函数</h3><p>在给定的偏移量写入一个文件描述符</p>
<p>头文件</p>
<ul>
<li><code>#include&lt;unistd.h&gt;</code></li>
</ul>
<p>函数原型</p>
<ul>
<li><code>ssize_t pwrite (int fd, const void *buf, size_t count, off_t pos )</code></li>
</ul>
<p>返回值</p>
<ul>
<li>返回已写的字节数；出错：返回-1</li>
</ul>
<p>解决问题</p>
<ul>
<li>由于lseek和write 调用之间，内核可能会临时挂起进程，所以对同步问题造成了问题，调用<strong>pwrite相当于顺序调用了lseek 和 write</strong>，这两个操作相当于一个捆绑的原子操作</li>
</ul>
<p>其他</p>
<ul>
<li>调用pwrite时，无法中断其定位和读操作，另外不更新文件指针</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><code>pread/pwrite</code>与<code>read/write</code>的区别</p>
<ul>
<li>调用更容易使用，特别是在进行需要技巧的操作时</li>
<li>完成工作后不会改变文件指针</li>
<li>避免使用lseek时可能造成的竞争条件<ul>
<li>如果有多个线程共享文件描述符，当地一个线程调用lseek之后，在它进行读取或写入操作之前，同一个程序中的另一个线程可能会改变文件的位置</li>
</ul>
</li>
</ul>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>UNIX/Linux支持不同进程间共享文件。内核使用的三种表（<strong>文件描述符表、文件表、索引结点表</strong>）之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响</p>
<ul>
<li><p>每个进程在进程表中有一个文件描述符表，每个描述符表项指向一个文件表</p>
</li>
<li><p>内核为每一个被打开的文件维护一张文件表，文件表项包含</p>
<ul>
<li>文件的状态标志（读、写、同步、非阻塞）</li>
<li>文件当前位置</li>
<li>指向该文件索引节点表的指针</li>
</ul>
</li>
<li><p>每个文件（或设备）都有一个索引节点，它包含了文件类型属性及文件数据</p>
</li>
</ul>
<p>如果两个进程分别打开同一个的文件（物理文件），则它们有不同的文件表，因此每个进程有自己的文件当前位置，因此其读写操作互不影响。</p>
<p>也存在不同进程共享同一个文件表（父子进程），或同一进程共享同一个文件表（dup操作）。此时，两个进程对该文件的读写操作将基于同一个文件当前位置。</p>
<h3 id="进程共享文件"><a href="#进程共享文件" class="headerlink" title="进程共享文件"></a>进程共享文件</h3><p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220407103144896.png" alt="image-20220407103144896" style="zoom: 67%;"><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220407103203149.png" alt="image-20220407103144896" style="zoom: 67%;"></p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220407103229973.png" alt="image-20220407103144896" style="zoom: 67%;">



<h3 id="dup和dup2"><a href="#dup和dup2" class="headerlink" title="dup和dup2"></a>dup和dup2</h3><p>头文件：<code>unistd.h</code></p>
<p>函数原型</p>
<ul>
<li><code>int dup( int oldfd );</code></li>
<li><code>int dup2( int oldfd, int targetfd );</code></li>
</ul>
<p>函数说明：复制一个文件的描述符，dup2函数跟dup函数相似，但dup2函数允许调用者规定一个有效描述符和目标描述符的</p>
<p>返回值：dup2函数成功返回时，目标描述符（dup2函数的第二个参数）将变成源描述符（dup2函数的第一个参数）的复制品</p>
<h3 id="线程共享文件"><a href="#线程共享文件" class="headerlink" title="线程共享文件"></a>线程共享文件</h3><p>线程的定义：有时称<strong>轻量级进程</strong>，是进程中的一个执行线路或线索，是一个相对独立的、可独立调度和指派的执行单元</p>
<p>线程的创建：应用程序可以通过一个统一的<code>clone()</code>系统调用接口，用不同的参数指定创建轻量进程还是普通进程</p>
<p><code>clone()</code>调用<code>do_fork()</code>创建线程， <code>do_fork()</code>参数为：<code>(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND)</code></p>
<ul>
<li><code>CLONE_VM</code>：<code>do_fork()</code>需要调用<code>copy_mm()</code>来设置<code>task_struct</code>中的<code>mm</code>和active_mm项，这两个<code>mm_struct</code>数据与进程所关联的<strong>内存空间</strong>相对应。如果<code>do_fork()</code>时指定了<code>CLONE_VM</code>开关，<code>copy_mm()</code>将把新的<code>task_struct</code>中的<code>mm</code>和<code>active_mm</code>设置成与<code>current</code>的相同，同时提高该<code>mm_struct</code>的使用者数目<code>(mm_struct::mm_users)</code>。也就是说，<strong>轻量级进程与父进程共享内存地址空间</strong></li>
<li><code>CLONE_FS</code>：<code>task_struct</code>中利用<code>fs(struct fs_struct *)</code>记录了<strong>进程所在文件系统的根目录和当前目录信息</strong>，<code>do_fork()</code>时调用<code>copy_fs()</code>复制了这个结构;而对于轻量级进程则仅增加<code>fs-&gt;count</code>计数，与父进程共享相同的<code>fs_struct</code>。也就是说，<strong>轻量级进程没有独立的文件系统相关的信息，进程中任何一个线程改变当前目录、根目录等信息都将直接影响到其他线程</strong></li>
<li><code>CLONE_FILES</code>：一个进程可能打开了一些文件，在进程结构<code>task_struct</code>中利用<code>files(struct files_struct *)</code>来保存进程<strong>打开的文件结构<code>(struct file)</code>信息</strong>，<code>do_fork()</code>中调用了<code>copy_files()</code>来处理这个进程属性；轻量级进程与父进程是共享该结构的，<code>copy_files()</code>时仅增加<code>files-&gt;count</code>计数。这一共享使得<strong>任何线程都能访问进程所维护的打开文件，对它们的操作会直接反映到进程中的其他线程</strong></li>
<li><code>CLONE_SIGHAND</code>：每一个Linux进程都可以自行定义对信号的处理方式，在<code>task_struct</code>中的<code>sig(struct signal_struct)</code>中使用一个<code>struct k_sigaction</code>结构的数组来保存这个配置信息，<code>do_fork()</code>中的<code>copy_sighand()</code>负责复制该信息；<strong>轻量级进程不进行复制</strong>，而仅仅增加<code>signal_struct::count</code>计数，与父进程共享该结构。也就是说，<strong>子进程与父进程的信号处理方式完全相同，而且可以相互更改</strong></li>
</ul>
<p><strong>总结</strong>：线程间所有文件结构都为共享资源，不但“文件表项”（file对象）是共享的，就连“文件描述符表”（files_struct结构）也是共享的。线程的创建仅仅增加的是<code>files</code>和<code>fs</code>的引用计数，“文件打开计数”（file对象的引用计数）并没有增加，所以任何一个线程对打开的文件执行<code>close</code>操作，文件都将关闭（文件打开计数为1的情况）。但是如果线程不进行打开文件的关闭，则文件直到进程结束时才会关闭，这就是使用多线程实现tcp服务器时，服务线程必须要显示调用close的原因，否则永远不会发送FIN终止链接（因为主线程一直处于监听不会结束）。</p>
<p><strong>进程间文件描述符的传递</strong>：</p>
<ul>
<li>传递描述符的函数的参数是fd，fd是打开文件指针在数组中的下标</li>
<li>将一个文件描述符传递给另一个进程后，文件的“访问计数”会增加</li>
<li>进程间传递文件描述符可以看做跨进程的dup调用，也就是同一个file对象在不同进程间的映射</li>
<li>对于网络接口返回的描述符 ，只能采取传递文件描述符的方法。</li>
<li>UNIX系统中两个方法：BSD <code>sendmsg</code>，<code>recvmsg</code>方法；SYSV <code>ioctl</code>方法</li>
<li>进程间传递文件描述符时，发送进程和接收进程共享同一文件表项</li>
<li>进程间文件描述符的传递，只是通过内核将接收文件的一个新file指针指向和发送进程的同一个file对象，并使这个file对象的引用计数增加</li>
</ul>
<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><h3 id="ls-l"><a href="#ls-l" class="headerlink" title="ls -l"></a>ls -l</h3><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220407113940167.png" alt="image-20220407113940167" style="zoom:67%;">

<p><strong>文件类型</strong>：</p>
<table>
<thead>
<tr>
<th>标识</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>普通文件</td>
</tr>
<tr>
<td>d</td>
<td>目录文件</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件</td>
</tr>
<tr>
<td>b</td>
<td>块设备文件</td>
</tr>
<tr>
<td>p</td>
<td>管道或FIFO</td>
</tr>
<tr>
<td>l</td>
<td>符号链接</td>
</tr>
<tr>
<td>s</td>
<td>套接字</td>
</tr>
</tbody></table>
<p><strong>文件访问权限：</strong></p>
<ul>
<li><code>r</code> 读权限</li>
<li><code>w</code> 写权限</li>
<li><code>x</code> 执行权限</li>
</ul>
<p><strong>ls –l 程序设计</strong>：</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220407114308228.png" alt="image-20220407114308228" style="zoom:67%;">



<h3 id="获取当前目录"><a href="#获取当前目录" class="headerlink" title="获取当前目录"></a>获取当前目录</h3><p><strong>getcwd</strong>函数</p>
<p>头文件： <code>unistd.h</code></p>
<p>函数声明：<code>char *getcwd(char *buf, size_t size);</code></p>
<p>函数说明：将当前的工作目录绝对路径字符串复制到参数<code>buf</code>所指的缓冲区，参数<code>size</code>为<code>buf</code>缓冲区大小。</p>
<p>返回值：成功调用返回指向<code>buf</code>的指针，失败返回<code>NULL</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 255</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> path[MAX_SIZE];</span><br><span class="line">        getcwd(path, <span class="keyword">sizeof</span>(path));</span><br><span class="line">        <span class="built_in">puts</span>(path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yang@Ubuntu18:~/Documents/Cprogram/$ gcc getcwd_test.c -o getcwd_test</span><br><span class="line">yang@Ubuntu18:~/Documents/Cprogram/$ ./getcwd_test</span><br><span class="line">/home/yang/Documents/Cprogram</span><br></pre></td></tr></table></figure>



<p><strong>get_current_dir_name</strong></p>
<p>文件首加宏定义：<code>#define _GNU_SOURCE</code></p>
<p>头文件： <code>unistd.h</code></p>
<p>函数声明：<code>char * get_current_dir_name(void);</code></p>
<p>函数说明：调用后会返回一个字符串指针，指向当前工作目录绝对路径字符串</p>
<p>返回值：成功则返回<code>字符串指针</code>，失败则返回<code>NULL</code>，错误代码存放于errno中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *path;</span><br><span class="line">        path = get_current_dir_name();</span><br><span class="line">        <span class="built_in">puts</span>(path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yang@Ubuntu18:~/Documents/Cprogram$ gcc get_current_dir_name_test.c -o get_current_dir_name_test</span><br><span class="line">yang@Ubuntu18:~/Documents/Cprogram$ ./get_current_dir_name_test</span><br><span class="line">/home/yang/Documents/Cprogram</span><br></pre></td></tr></table></figure>



<h3 id="DIR结构体"><a href="#DIR结构体" class="headerlink" title="DIR结构体"></a>DIR结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">dirstream</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *__fd;</span><br><span class="line">    <span class="keyword">char</span> *__data;</span><br><span class="line">    <span class="keyword">int</span> __entry_data;</span><br><span class="line">    <span class="keyword">char</span> *__ptr;</span><br><span class="line">    <span class="keyword">int</span> __entry_ptr;</span><br><span class="line">    <span class="keyword">size_t</span> __allocation;</span><br><span class="line">    <span class="keyword">size_t</span> __size;</span><br><span class="line">    __libc_lock_define (, __lock)</span><br><span class="line">&#125;; <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">dirstream</span> <span class="title">DIR</span>；</span></span><br></pre></td></tr></table></figure>



<h3 id="打开目录"><a href="#打开目录" class="headerlink" title="打开目录"></a>打开目录</h3><p><strong>opendir函数</strong></p>
<p>头文件：</p>
<ul>
<li> <code>sys/types.h</code></li>
<li><code>dirent.h</code></li>
</ul>
<p>函数声明：<code>DIR *opendir(const char *path);</code></p>
<p>函数说明：打开参数<code>path</code>指定的目录</p>
<p>返回值：成功则返回<strong>DIR形态的目录流</strong>，失败则返回<code>NULL</code>，错误代码存放于errno中</p>
<p>错误代码：</p>
<ul>
<li><code>EACCESS</code> 代表权限不足，也就是对这个目录没有执行权限。</li>
<li><code>EMFILE</code> 表示目前同时打开这个文件的进程数目已经到达了系统上限。</li>
<li><code>ENFILE</code> 代表已经达到系统可以同时打开的文件数上限。</li>
<li><code>ENOTDIR</code> 代表参数<code>path</code>指向的不是一个真正的目录。</li>
<li><code>EOENT</code> 表示参数<code>path</code>指向的目录不存在，或者参数<code>path</code>是一个空的字符串。</li>
<li><code>ENOMEM</code> 表示核心内存不足</li>
</ul>
<h3 id="关闭目录"><a href="#关闭目录" class="headerlink" title="关闭目录"></a>关闭目录</h3><p><strong>closedir函数</strong></p>
<p>头文件：</p>
<ul>
<li> <code>sys/types.h</code></li>
<li><code>dirent.h</code></li>
</ul>
<p>函数声明：<code>int closedir(DIR *dir);</code></p>
<p>函数说明：关闭参数<code>dir</code>指定的目录</p>
<p>返回值：关闭成功就返回0，失败的话就返回-1，错误原因存于errno中</p>
<p>错误代码：<code>EBADF</code>代表参数<code>dir</code>是一个无效的目录流</p>
<h3 id="dirent结构体"><a href="#dirent结构体" class="headerlink" title="dirent结构体"></a>dirent结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">ino_t</span> d_ino; <span class="comment">// i节点号</span></span><br><span class="line">    <span class="keyword">off_t</span> d_off; <span class="comment">// 在目录文件中的偏移，相对目录开头而言</span></span><br><span class="line">    usigned <span class="keyword">short</span> d_reclen; <span class="comment">// 文件名长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type;   <span class="comment">// 文件类型</span></span><br><span class="line">    <span class="keyword">char</span> d_name[<span class="number">256</span>];       <span class="comment">// 文件名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="读取目录文件"><a href="#读取目录文件" class="headerlink" title="读取目录文件"></a>读取目录文件</h3><p><strong>readdir函数</strong></p>
<p>头文件： </p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>dirent.h</code></li>
</ul>
<p>函数声明：<code>struct dirent *readdir(DIR *dirp);</code></p>
<p>函数说明：读取目标流<code>dir</code>标识的目录</p>
<p>返回值：每执行一次<code>readdir</code>，这个函数返回指向当前读取目录项结构的指针，有错误发生或读取到目录文件尾的时候就返回<code>NULL</code></p>
<p>错误代码：<code>EBADF</code>代表参数<code>dir</code>是一个无效的目录流</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 255</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> path <span class="meta-string">&quot;/home/yang/Documents/Cprogram&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        DIR *dir = opendir(path);</span><br><span class="line">        <span class="keyword">char</span> dir1[MAX_SIZE];</span><br><span class="line">        getcwd(dir1, <span class="keyword">sizeof</span>(dir1));</span><br><span class="line">        <span class="built_in">puts</span>(dir1);</span><br><span class="line">        <span class="keyword">char</span> *dir2 = get_current_dir_name();</span><br><span class="line">        <span class="built_in">puts</span>(dir2);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>((dent = readdir(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220407155354291.png" alt="image-20220407155354291"></p>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p><strong>mkdir函数</strong></p>
<p>头文件：<code>sys/stat.h</code></p>
<p>函数声明：<code>int mkdir(const char *pathname, mode_t mode);</code></p>
<p>函数说明：以<code>mode</code>方式创建一个以参数<code>pathname</code>命名的目录，<code>mode</code>定义新创建目录的权限</p>
<p>返回值：若目录创建成功，则返回0；否则返回-1，并将错误记录到全局变量errno中</p>
<p>注意事项：</p>
<ul>
<li>创建<code>777</code>权限的目录，需要先执行<code>umask(0)</code>，然后再调用<code>mkdir</code>函数</li>
<li>目录已存在会返回-1</li>
<li>不能创建多个目录</li>
</ul>
<h3 id="文件权限mode"><a href="#文件权限mode" class="headerlink" title="文件权限mode"></a>文件权限mode</h3><table>
<thead>
<tr>
<th>字段</th>
<th>权限</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>S_IRWXU</code></td>
<td>00700</td>
<td>文件所有者拥有读写执行的权限</td>
</tr>
<tr>
<td><code>S_IRUSR(S_IREAD)</code></td>
<td>00400</td>
<td>文件所有者拥有可读权限</td>
</tr>
<tr>
<td><code>S_IWUSR(S_IWRITE)</code></td>
<td>00200</td>
<td>文件所有者拥有可写权限</td>
</tr>
<tr>
<td><code>S_IXUSR(S_IEXEC)</code></td>
<td>00100</td>
<td>文件所有者拥有执行权限</td>
</tr>
<tr>
<td><code>S_IRWXG</code></td>
<td>00070</td>
<td>文件用户组拥有读写执行的权限</td>
</tr>
<tr>
<td><code>S_IRGRP</code></td>
<td>00040</td>
<td>文件用户组拥有可读权限</td>
</tr>
<tr>
<td><code>S_IWGRP</code></td>
<td>00020</td>
<td>文件用户组拥有可写权限</td>
</tr>
<tr>
<td><code>S_IXGRP</code></td>
<td>00010</td>
<td>文件用户组拥有执行权限</td>
</tr>
<tr>
<td><code>S_IRWXO</code></td>
<td>00007</td>
<td>其他用户拥有读写执行权限</td>
</tr>
<tr>
<td><code>S_IROTH</code></td>
<td>00004</td>
<td>其他用户拥有可读权限</td>
</tr>
<tr>
<td><code>S_IWOTH</code></td>
<td>00002</td>
<td>其他用户拥有可写权限</td>
</tr>
<tr>
<td><code>S_IXOTH</code></td>
<td>00001</td>
<td>其他用户拥有执行权限</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH <span class="meta-string">&quot;home/yang/Documents/Cprogram/Linux系统编程学习/mulu&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    umask(<span class="number">0</span>); <span class="comment">//不调用umask，最高权限775</span></span><br><span class="line">    <span class="keyword">if</span>(mkdir(<span class="string">&quot;目录&quot;</span>, S_IRWXU | S_IRWXG | S_IRWXO) == <span class="number">-1</span>) <span class="comment">//权限777</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mkdir error\n&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">//在当前下创建</span></span><br><span class="line">    	</span><br><span class="line">    <span class="keyword">if</span>(mkdir(<span class="string">&quot;../mulu&quot;</span>, S_IRWXU | S_IRGRP | S_IROTH) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mkdir error\n&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">//在上级目录下创建</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(mkdir(<span class="string">&quot;../Linux系统编程学习/mulu&quot;</span>, S_IRWXU | S_IRGRP) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mkdir error\n&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">//这是ok的，在当前目录上一级目录下的 Linux系统编程学习 文件夹下创建 mulu</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(mkdir(PATH, S_IRWXU ) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mkdir error\n&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">//使用绝对路径创建</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><p><strong>rmdir函数</strong></p>
<p>头文件：<code>unistd.h</code></p>
<p>函数声明：<code>int rmdir(const char *pathname);</code></p>
<p>函数说明：删除一个目录，该目录必须是空的</p>
<p>返回值：若目录删除成功，则返回0；否则返回-1，并将错误记录到全局变量errno中</p>
<p>注意事项：<code>pathname</code>不能超过255，目录名不能以<code>.</code>开头（<code>.</code>开头的是隐藏文件）。目录没有被其他进程占用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rmdir(<span class="string">&quot;./mulu&quot;</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;rmdir error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="改变当前工作目录"><a href="#改变当前工作目录" class="headerlink" title="改变当前工作目录"></a>改变当前工作目录</h3><p><strong>chdir函数</strong></p>
<p>头文件：<code>unistd.h</code></p>
<p>函数声明：<code>int chdir(const char *path);</code></p>
<p>函数说明：<code>chdir</code>函数用于<strong>改变当前工作目录</strong>。调用参数是指向目录的指针，调用进程需要有搜索整个目录的权限</p>
<p>返回值：成功，则返回0；否则返回-1，并将错误记录到全局变量errno中</p>
<p>错误信息：</p>
<ul>
<li><code>EFAULT</code>: path指向了非法地址</li>
<li><code>ENAMETOOLNG</code>:  路径过长</li>
<li><code>ENOENT</code>: 文件不存在</li>
<li><code>ENOMEM</code>: 内核内存不足</li>
<li><code>ENOTDIR</code>: 给出路径不是目录</li>
<li><code>EACCES</code>: 无访问路径中某个目录的权限</li>
<li><code>ELOOP</code>：解析路径中太多的符号链接</li>
<li><code>EIO</code>: 发生I/O错误</li>
</ul>
<p>函数说明：</p>
<ul>
<li>每个进程都具有一个当前工作目录。在解析相对目录引用时，该目录是搜索路径的开始之处</li>
<li>如果调用进程更改了目录，则它只对该进程有效，而不能影响调用它的那个进程</li>
<li>在退出程序时，shell还会返回开始时的那个工作目录</li>
<li>内核解析参数中的路径名，并确保这个路径名有效。内核定位该目录的索引节点，并检查它的文件类型和权限位，确保目标文件是目录以及进程的所有者可以访问该目录</li>
<li>内核用新目标目录的路径名和索引节点替换u区中当前目录路径名和索引节点号</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH <span class="meta-string">&quot;/home/yang&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(chdir(<span class="string">&quot;..&quot;</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">//相对路径</span></span><br><span class="line">    <span class="keyword">char</span> *nowdir = get_current_dir_name();</span><br><span class="line">    <span class="built_in">puts</span>(nowdir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(chdir(PATH) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">//绝对路径</span></span><br><span class="line">    nowdir = get_current_dir_name();</span><br><span class="line">    <span class="built_in">puts</span>(nowdir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220407174200065.png" alt="image-20220407174200065"></p>
<h3 id="设置目录读取位置"><a href="#设置目录读取位置" class="headerlink" title="设置目录读取位置"></a>设置目录读取位置</h3><p><strong>rewinddir函数</strong></p>
<p>头文件：</p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>dirent.h</code></li>
</ul>
<p>函数声明：<code>void rewinddir(DIR *dir);</code></p>
<p>函数说明：设置参数<code>dir</code>指向的目录流目前的读取位置为原来<strong>开头</strong>的读取位置</p>
<p>返回值：无返回值，函数执行失败后会将错误记录到全局变量errno中</p>
<p>错误信息：<code>EBADF</code>：表示<code>dir</code>指向的目录流无效</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dir = opendir(<span class="string">&quot;./&quot;</span>); <span class="comment">//读取当前目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//先读3个文件</span></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    <span class="comment">//设置会开头</span></span><br><span class="line">    rewinddir(dir);</span><br><span class="line">    <span class="comment">//在读3个文件</span></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220407174829214.png" alt="image-20220407174829214"></p>
<p><strong>seekdir函数</strong></p>
<p>头文件： <code>dirent.h</code></p>
<p>函数声明：<code>void seekdir(DIR * dir, off_t offset)</code></p>
<p>函数说明：设置参数dir指向的目录流目前的读取位置为<code>offset</code>，在调用<code>readdir()</code>时便从此新位置开始读取。参数<code>offset</code>代表<strong>距离目录文件开头的偏移量</strong>。</p>
<p>返回值：无返回值，函数执行失败后会将错误记录到全局变量errno中</p>
<p>错误信息：<code>EBADF</code>：表示dir指向的目录流无效</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dir = opendir(<span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先读3个文件</span></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;该文件的offset = %ld\n\n&quot;</span>, dent-&gt;d_off);</span><br><span class="line"></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;该文件offset = %ld\n\n&quot;</span>, dent-&gt;d_off);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">off_t</span> offset = dent-&gt;d_off;  <span class="comment">//文件的偏移量是相对目录开头而言的，不要叠加</span></span><br><span class="line"></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;该文件offset = %ld\n\n&quot;</span>, dent-&gt;d_off);</span><br><span class="line"></span><br><span class="line">    seekdir(dir, offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;移动到离目录开头偏移%ld\n\n&quot;</span>, offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在读3个文件</span></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    dent = readdir(dir);</span><br><span class="line">    <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220407180857330.png" alt="image-20220407180857330"></p>
<h3 id="获取目录读取位置"><a href="#获取目录读取位置" class="headerlink" title="获取目录读取位置"></a>获取目录读取位置</h3><p><strong>telldir函数</strong></p>
<p>头文件： <code>dirent.h</code></p>
<p>函数声明：<code>off_t telldir(DIR * dir);</code></p>
<p>函数说明：取得目录流<code>dir</code>的读取位置。</p>
<p>返回值：返回参数<code>dir</code>目录流目前的读取位置. 此返回值代表<strong>距离目录文件开头的偏移量</strong>，有错误发生时返回-1.</p>
<p>错误信息：<code>EBADF</code>：表示dir指向的目录流无效</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dir = opendir(<span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dent = readdir(dir);</span><br><span class="line">        <span class="built_in">puts</span>(dent-&gt;d_name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dirent-&gt;d_off = %ld\n&quot;</span>, dent-&gt;d_off);</span><br><span class="line">        <span class="keyword">off_t</span> offset = telldir(dir);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;telldir = %ld\n\n&quot;</span>, offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220407181940228.png" alt="image-20220407181940228"></p>
<h3 id="读取特定目录数据"><a href="#读取特定目录数据" class="headerlink" title="读取特定目录数据"></a>读取特定目录数据</h3><p><strong>scandir函数</strong></p>
<p>头文件： <code>dirent.h</code></p>
<p>函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scandir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dir, </span></span></span><br><span class="line"><span class="params"><span class="function">            struct dirent ***namelist, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> (*filter) (<span class="keyword">const</span> struct dirent*), </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span>(*compar)(<span class="keyword">const</span> struct dirent **, <span class="keyword">const</span> struct dirent**)</span></span></span><br><span class="line"><span class="params"><span class="function">           )</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数说明：<code>scandir()</code>会扫描参数<code>dir</code>指定的目录文件，经由参数<code>filter</code>指定的函数来挑选目录结构至参数<code>namelist</code>数组中，最后再调用参数<code>compar</code>指定的函数来排序<code>namelist</code>数组中的目录数据。每次从目录文件中读取一个目录结构后便将此结构传给参数<code>filter</code>所指的函数，<code>filter</code>函数若不想要将此目录结构复制到<code>namelist</code>数组就返回0，若<code>filter</code>为空指针则代表选择所有的目录结构。<code>scandir()</code>会调用<code>qsort()</code>来排序数据，参数<code>compar</code>则为<code>qsort()</code>的参数，若是要排列目录名称字母则可使用<code>alphasort()</code>。</p>
<p>返回值：成功则返回复制到<code>namelist</code>数组中的数据结构数目，有错误发生则返回-1.</p>
<p>错误信息：<code>ENOMEM</code> 核心内存不足</p>
<p>补充：</p>
<ul>
<li><code>int alphasort(const void **a, const void **b);</code></li>
<li><code>int versionsort(const void **a, const void **b);</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">namelist</span>;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    n = scandir(<span class="string">&quot;.&quot;</span>, &amp;namelist, <span class="number">0</span>, alphasort);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;not found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, namelist[n]-&gt;d_name);</span><br><span class="line">            <span class="built_in">free</span>(namelist[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(namelist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="文件属性管理"><a href="#文件属性管理" class="headerlink" title="文件属性管理"></a>文件属性管理</h2><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>Linux系统中常见的文件类型：</p>
<ul>
<li>普通文件 <code>-</code> ：包含了某种形式的数据</li>
<li>目录文件 <code>d</code> ：包含了其他文件的名字以及指向与这些文件有关信息的指针</li>
<li>字符特殊文件 <code>c</code> ：提供对设备不带缓冲的访问</li>
<li>FIFO文件 <code>p</code> ：用于进程间的通信，命名管道</li>
<li>套接字文件 <code>s</code> ：用于网络通信</li>
<li>符号链接 <code>l</code> ：使文件指向另一个文件</li>
</ul>
<h3 id="读取文件属性"><a href="#读取文件属性" class="headerlink" title="读取文件属性"></a>读取文件属性</h3><p>头文件：<code>sys/stat.h</code></p>
<ul>
<li><code>int stat(const char *path, struct stat *buf);</code></li>
<li><code>int lstat(const char *path, struct stat *buf);</code></li>
<li><code>int fstat(int fd, struct stat *buf);</code></li>
<li><code>int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag);</code></li>
</ul>
<p>函数说明：</p>
<ul>
<li><code>stat</code>和<code>lstat</code>参数相同，功能类似。读取<code>path</code>参数所指定文件的文件属性并将其填充到<code>buf</code>参数所指向的结构体中；对于符号链接文件，<code>lstat</code>返回符号链接的文件属性，<code>stat</code>返回符号链接引用文件的文件属性。</li>
<li><code>fstat</code>与前两个函数功能类似，指定文件的方式改为通过文件描述符</li>
<li><code>statat</code>函数为一个相对于当前打开目录(由fd参数指向)的路径名返回文件统计信息。 <code>flag</code>参数控制着是否跟随着一个符号链接，返回符号链接本身的信息或者符号链接所指向的实际文件信息。<ul>
<li>如果fd参数的值是<code>AT_FDCWD</code>，并且<code>pathname</code>参数是一个相对路径名，<code>fstatat</code>会计算相对于当前目录的<code>pathname</code>参数，如果<code>pathname</code>是一个绝对路径，<code>fd</code>参数就会被忽略。这两种情况下，根据<code>flag</code>的取值<code>fstatat</code>的作用就跟<code>stat</code>或<code>lstat</code>一样</li>
</ul>
</li>
<li>参数<code>buf</code>，是一个指向<code>stat</code>结构的指针，这几个函数都是为了填充<code>buf</code>指向的结构<code>stat</code></li>
<li>成功返回0，失败返回-1</li>
</ul>
<h3 id="stat结构"><a href="#stat结构" class="headerlink" title="stat结构"></a>stat结构</h3><p><code>stat</code>是linux系统用来描述文件属性的重要数据结构信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span> </span><br><span class="line">    <span class="keyword">mode_t</span> st_mode; 	<span class="comment">// 文件类型与访问权限</span></span><br><span class="line">    <span class="keyword">ino_t</span> st_ino; 		<span class="comment">// i节点号</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_dev; 		<span class="comment">// 文件的主、次设备号信息</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_rdev; 		<span class="comment">// 设备文件的设备号</span></span><br><span class="line">    <span class="keyword">nlink_t</span> st_nlink; 	<span class="comment">// 文件的硬链接数</span></span><br><span class="line">    <span class="keyword">uid_t</span> st_uid; 		<span class="comment">// 文件所有者用户ID</span></span><br><span class="line">    <span class="keyword">gid_t</span> st_gid; 		<span class="comment">// 文件所有者组ID</span></span><br><span class="line">    <span class="keyword">off_t</span> st_size; 		<span class="comment">// 文件大小（以字节为单位）</span></span><br><span class="line">    <span class="keyword">time_t</span> st_atime; 	<span class="comment">// 最后一次访问该文件的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> st_mtime; 	<span class="comment">// 最后一次修改该文件的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> st_ctime; 	<span class="comment">// 最后一次改变该文件状态的时间</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize; 	<span class="comment">// 包含该文件的磁盘块的大小</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span> st_blocks; 	<span class="comment">// 该文件所占的磁盘块数</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="st-mode"><a href="#st-mode" class="headerlink" title="st_mode"></a><code>st_mode</code></h3><table>
<thead>
<tr>
<th>宏</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>S_ISREG()</code></td>
<td>普通文件<code>-</code></td>
</tr>
<tr>
<td><code>S_ISDIR()</code></td>
<td>目录文件<code>d</code></td>
</tr>
<tr>
<td><code>S_ISCHR()</code></td>
<td>字符特殊文件<code>c</code></td>
</tr>
<tr>
<td><code>S_ISBLK()</code></td>
<td>块特殊文件<code>b</code></td>
</tr>
<tr>
<td><code>S_ISFIFO()</code></td>
<td>管道或FIFO<code>p</code></td>
</tr>
<tr>
<td><code>S_ISLNK()</code></td>
<td>符号链接<code>l</code></td>
</tr>
<tr>
<td><code>S_ISSOCK()</code></td>
<td>套接字<code>s</code></td>
</tr>
</tbody></table>
<p><code>mode_t st_mode</code> 无符号整数，其低16位定义如下：</p>
<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220408113535578.png" alt="image-20220408113535578"></p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220408113556252.png" alt="image-20220408113556252" style="zoom:67%;">

<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220408113707390.png" alt="image-20220408113707390" style="zoom:67%;">



<p><strong>设置用户ID位和设置组ID位</strong>：</p>
<p>定义：</p>
<ul>
<li>包含在可执行文件的权限标记中，有一个“设置用户ID位”若该位被设置，表示：执行该文件时，进程的有效用户ID变为文件的所有者对于设置组ID位类似</li>
<li>通过命令行设置用户ID位：<ul>
<li><code>chmod u+s filename</code>； <code>chmod u-s filename</code>；</li>
<li><code>chmod g+s filename</code>； <code>chmod g-s filename</code>；</li>
</ul>
</li>
<li>若文件所有者是超级用户，且设置了设置用户ID位，则执行此文件的进程拥有超级用户权限</li>
<li>Passwd(1) 允许任一用户改变其口令，该程序是一个设置用户ID程序</li>
<li>分别用常量<code>S_ISUID</code>和<code>S_ISGID</code>测试</li>
</ul>
<h3 id="粘着位"><a href="#粘着位" class="headerlink" title="粘着位"></a>粘着位</h3><p>在UNIX早期版本中，有一位被称为粘住位，如果一可执行程序文件的这一位被设置了，那么在该程序第一次执行并结束时，该程序正文被保存在交换区中，这使得下次执行该程序时能较快地将其装入内存。</p>
<p>现今较新的UNIX系统大多数都具有<strong>虚存系统以及快速文件系统</strong>，所以<strong>不再需要使用这种技术</strong></p>
<p>如果对一个目录设置了粘住位，则只有对该目录具有<strong>写许可权</strong>的用户并且满足下列条件之一，才能删除或更名该目录下文件：</p>
<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户</li>
</ul>
<p>目录/<code>tmp</code>和<code>/var/spool/uucppublic</code>(<strong>怎么没有？</strong>)是设置粘住位的候选者。这两个目录是任何用户都可在其中创建文件的目录，对任一用户(用户、组和其他)的许可权通常都是读、写和执行。但是<strong>用户不应能删除或更名属于其他人的文件</strong>，为此在这两个目录的文件方式中都设置了粘住位。</p>
<h3 id="st-size"><a href="#st-size" class="headerlink" title="st_size"></a><code>st_size</code></h3><p><code>stat</code>结构的成员<code>st_size</code>包含了<strong>以字节为单位的该文件的长度</strong>。此字段只对普通文件、目录文件和符号连接有意义</p>
<ul>
<li>对于普通文件，其文件长度可以是0，在读这种文件时，将得到文件结束指示</li>
<li>对于目录，文件长度通常是一个数，例如16或512的整倍数</li>
<li>对于符号连接，文件长度是在文件名中的实际字节数。例如：<ul>
<li><code>lrwxrwxrwx 1 root 7 Sep 25 07:14 lib -&gt; usr/lib</code></li>
<li>其中，文件长度7就是路径名<code>usr/lib</code>的长度</li>
</ul>
</li>
</ul>
<h3 id="文件截断"><a href="#文件截断" class="headerlink" title="文件截断"></a>文件截断</h3><p>函数原型：</p>
<ul>
<li><code>int truncate(const char* pathname, off_t length);</code></li>
<li><code>int ftruncate(int fd, off_t length);</code></li>
</ul>
<p>函数说明：</p>
<ul>
<li>用于改变文件的长度</li>
<li><code>pathname</code>：欲改变长度的文件的文件名</li>
<li><code>fd</code>：欲改变长度的文件的文件描述符；</li>
<li><code>length</code>：要设置的文件的新长度</li>
</ul>
<p>返回值：成功返回0，出错返回-1</p>
<p>注意事项：</p>
<ul>
<li>当文件以前的长度<code>&gt;length</code>时，则超过length以外的数据将不复存在</li>
<li>当文件以前的长度<code>&lt;length</code>时，在文件以前长度到length之间，将形成空洞，读该区域，将返回0</li>
</ul>
<p>常见问题：</p>
<p><code>truncate</code>和<code>ftruncate</code>函数并未实质性的向磁盘写入数据，只是分配了一定的空间供当前文件使用。当<code>fd&lt;length</code>时，此时如果使用十六进制编辑工具打开该文件，会发现文件末尾多了很多00，这就是执行这个函数后的效果。如果发生系统复位或者装置掉电以后，该函数所产生的作用将被文件系统忽略，也就是说它所分配的空间将不能被识别，文件的大小将会是最后一次写入操作的<br>区域大小，而非<code>ftruncate</code>分配的空间大小，也就是说，文件大小有可能会被改变</p>
<p>解决方案：</p>
<p>可以在执行完<code>ftruncate</code>之后，在新空间的末尾写入一个或以上字节的数据（不为0x00），这样新空间则不为空，文件系统会把这部分空间当成这个文件的私有空间处理，而不会出现文件大小改变的错误。</p>
<h3 id="passwd结构体"><a href="#passwd结构体" class="headerlink" title="passwd结构体"></a>passwd结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> * pw_name; <span class="comment">/* 用户名*/</span></span><br><span class="line">    <span class="keyword">char</span> * pw_passwd; <span class="comment">/* 密码.*/</span></span><br><span class="line">    <span class="keyword">__uid_t</span> pw_uid; <span class="comment">/* 用户ID.*/</span></span><br><span class="line">    <span class="keyword">__gid_t</span> pw_gid; <span class="comment">/*组ID.*/</span></span><br><span class="line">    <span class="keyword">char</span> * pw_gecos; <span class="comment">/*真实名*/</span></span><br><span class="line">    <span class="keyword">char</span> * pw_dir; <span class="comment">/* 主目录.*/</span></span><br><span class="line">    <span class="keyword">char</span> * pw_shell; <span class="comment">/*使用的shell*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="获取用户属性"><a href="#获取用户属性" class="headerlink" title="获取用户属性"></a>获取用户属性</h3><p>常用函数：<code>getpwuid</code></p>
<p>头文件： </p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>pwd.h</code></li>
</ul>
<p>函数原型：<code>struct passwd *getpwuid(uid_t uid);</code></p>
<p>函数说明：输入用户ID，返回用户属性信息（passwd结构）</p>
<h3 id="group结构体"><a href="#group结构体" class="headerlink" title="group结构体"></a>group结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *gr_name; <span class="comment">/*组名称*/</span></span><br><span class="line">	<span class="keyword">char</span> *gr_passwd; <span class="comment">/* 组密码*/</span></span><br><span class="line">	<span class="keyword">gid_t</span> gr_gid; <span class="comment">/*组ID*/</span></span><br><span class="line">	<span class="keyword">char</span> **gr_mem; <span class="comment">/*组成员账号*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取组属性"><a href="#获取组属性" class="headerlink" title="获取组属性"></a>获取组属性</h3><p>常用函数：<code>getgrgid</code></p>
<p>头文件： </p>
<ul>
<li><code>sys/types.h</code></li>
<li><code>grp.h</code></li>
</ul>
<p>函数原型：<code>struct group *getgrgid(gid_t gid);</code></p>
<p>函数说明：输入用户组ID，返回用户组属性信息（group结构）</p>
<h3 id="设备特殊文件"><a href="#设备特殊文件" class="headerlink" title="设备特殊文件"></a>设备特殊文件</h3><p>每一个文件系统所在的存储设备都由其主、次设备号表示。设备号所用的数据类型是基本系统数据类型<code>dev_t</code></p>
<p>主设备号标识设备驱动程序，次设备号标识特定的子设备</p>
<p>通常可以使用两个宏<code>major</code>和<code>minor</code>来访问主、次设备号</p>
<ul>
<li>早期系统用16位整型存放设备号：8位用于主设备号，8位用于次设备号</li>
<li>FreeBSD 8.0和Mac OS X 10.6.8使用32位整型，其中8位表示主设备号，24位表示次设备号。</li>
<li>32位系统中，Solaris 10用32位整型表示dev_t，其中14位用于主设备号，18位用于次设备</li>
<li>64位系统中，Solaris 10用64位整型表示dev_t，主设备号和次设备号各为32位</li>
<li>在Linux 3.2.0上，dev_t是64位整型，12位用于主设备号，20位用于次设备号</li>
</ul>
<p>系统中与每个文件名关联的<code>st-dev</code>值是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的索引结点</p>
<p>只有<strong>字符特殊文件和块特殊文件才有<code>st-rdev</code>值</strong>，此值包含实际设备的设备号</p>
<h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><p>Linux系统通过进程的<strong>有效用户ID和有效用户组ID</strong>来决定进程对系统资源的访问权限</p>
<p>与一个进程相关联的用户ID和用户组ID有如下几种：</p>
<img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220408120554130.png" alt="image-20220408120554130" style="zoom:67%;">



<p>通常情况下，有效用户ID等于实际用户ID，有效组ID等于实际组ID；</p>
<p>可执行文件的权限中有一个特殊标志，定义为“当执行此文件时，将进程的有效用户ID设置为文件的所有者”，与此类似，组ID也有类似的情况。</p>
<p>这两个标志位称为：“设置用户ID” 和 “ 设 置 组 ID”， 这 两 位 都 包 含 在 <code>stat </code>信 息 中 的 <code>st_mode</code> 中 ， 可 用<code>S_ISUID</code>，<code>S_ISGID</code>测试。</p>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul>
<li>对于一个文件的<strong>读权限</strong>决定了我们是否能够打开该文件进行读操作</li>
<li>对一个文件的<strong>写权限</strong>决定了我们是否能够打开该文件进行写操作</li>
<li>为了在<code>open</code>函数中对一个文件指定<code>O_TRUNC</code>标志，必须对该文件具有写权限</li>
<li>执行某个可执行文件，都必须对该文件具有<strong>执行权限</strong></li>
</ul>
<h3 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h3><ul>
<li>目录文件的<strong>执行权限</strong>也表示可以进入该目录</li>
<li>通过文件名打开一个任意类型的文件时，对该文件路径名中包含的每一个目录都应具有执行权限</li>
<li>为了在一个目录中创建一个新文件，必须对该目录具有<strong>写权限</strong>和<strong>执行权限</strong></li>
<li>为了删除一个文件，必须对包含该文件的目录具有<strong>写权限</strong>和<strong>执行权限</strong>，对该文件本身则不需要有读、写权限</li>
</ul>
<h3 id="检查文件权限"><a href="#检查文件权限" class="headerlink" title="检查文件权限"></a>检查文件权限</h3><p>进程访问文件时，内核就进行文件权限检查。这种检查涉及到文件的所有者、文件的所有者所在组、进程有效用户、进程的有效组及进程的附加组。两个所有者是文件的性质，而有效用户与有效组是进程的性质</p>
<p>当进程对某个文件进行操作时，内核按顺序执行下列4步来检查文件权限</p>
<ul>
<li>若进程的有效用户为root（ID等于0），则允许任何操作；</li>
<li>若进程的有效用户等于文件的所有者（ID相同）（即该进程拥有文件），按照文件所有者具有的权限判定操作是否合法</li>
<li>若进程的有效组或进程的附加组之一等于文件所有者所在组,按照文件所有者所在组具有的权限判定操作是否合法</li>
<li>按照其他用户具有权限判定操作是否合法</li>
</ul>
<p>一般情况下：</p>
<ul>
<li>若进程有效用户拥有此文件，则按用户权限批准或拒绝该进程对文件的操作</li>
<li>若进程有效用户并不拥有该文件，但进程有效用户属于某个适当的组，则按组权限批准或拒绝该进程对文件的操作</li>
<li>若进程有效用户并不拥有该文件，也不属于某个适当的组，则按照其他其他用户权限批准或拒绝该进程对文件的操作</li>
</ul>
<p><strong>新文件和新目录的所有权：</strong></p>
<p>新文件的所有者设置为进程的有效用户</p>
<p>新文件所有者所在的组，POSIX允许选择下列之一：</p>
<ul>
<li>新文件所有者所在的组可以是进程的有效组</li>
<li>新文件所有者所在的组可以是它所在目录的组</li>
</ul>
<p>新文件所有者所在的组取决于它所在目录的设置组ID位是否设置，若设置，则为目录组，否则则为进程有效组</p>
<p>BSD总是用目录组作为新文件所有者所在组</p>
<p><strong><code>access</code>函数</strong></p>
<p>函数功能：按照前述文件权限检查的4个步骤测试存取文件是否具有相应权限</p>
<p>函数原型：<code>int access(const char *pathname, int mode);</code></p>
<p>成功返回0，失败返回-1</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>R_OK</code></td>
<td>测试读许可</td>
</tr>
<tr>
<td><code>W_OK</code></td>
<td>测试写许可</td>
</tr>
<tr>
<td><code>X_OK</code></td>
<td>测试执行许可</td>
</tr>
<tr>
<td><code>F_OK</code></td>
<td>文件是否存在</td>
</tr>
</tbody></table>
<h3 id="改变文件权限"><a href="#改变文件权限" class="headerlink" title="改变文件权限"></a>改变文件权限</h3><p>函数原型</p>
<ul>
<li><code>int chmod(const char * pathname, mode_t mode);</code></li>
<li><code>int fchmod( int fd, mode_t mode);</code></li>
</ul>
<p>函数用途：改变指定文件的权限位。</p>
<p>函数说明：</p>
<ul>
<li><code>chmod</code>要求给出的是文件或目录所在的位置，而<code>fchmod</code>主要针对的是文件，要求调用是相应的文件描述符。</li>
<li>修改时，进程的有效用户ID必须等于文件的所有者ID，或是root运行的此进程</li>
</ul>
<p><strong><code>mode</code>：</strong> </p>
<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220408122030806.png" alt="image-20220408122030806"></p>
<p><strong><code>chmod</code>出错信息</strong>：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>EACCES</code></td>
<td>给出的文件所处路径没有访问权限</td>
</tr>
<tr>
<td><code>EFAULT</code></td>
<td>路径指向的文件地址错误</td>
</tr>
<tr>
<td><code>EIO</code></td>
<td>发生I/O错误</td>
</tr>
<tr>
<td><code>ELOOP</code></td>
<td>给出的文件所在路径中符号连接过多</td>
</tr>
<tr>
<td><code>ENAMETOOLONG</code></td>
<td>路径过长</td>
</tr>
<tr>
<td><code>ENOENT</code></td>
<td>文件不存在</td>
</tr>
<tr>
<td><code>ENOMEM</code></td>
<td>内核内存空间不足</td>
</tr>
<tr>
<td><code>ENOTDIR</code></td>
<td>给出的文件所处路径中包含不是目录的部分</td>
</tr>
<tr>
<td><code>EPERM</code></td>
<td>有效用户ID与文件拥有者不同，进程无权访问修改文件权限</td>
</tr>
<tr>
<td><code>EROFS</code></td>
<td>文件位于只读文件系统</td>
</tr>
</tbody></table>
<p><strong><code>fchmod</code>函数出错信息</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>EBADF</code></td>
<td>非法的文件描述符</td>
</tr>
<tr>
<td><code>EIO</code></td>
<td>发生I/O错误</td>
</tr>
<tr>
<td><code>EPERM</code></td>
<td>有效用户ID与文件拥有者不同，进程无权访问修改文件权限</td>
</tr>
<tr>
<td><code>EROFS</code></td>
<td>文件位于只读系统</td>
</tr>
</tbody></table>
<h3 id="更改文件所有者"><a href="#更改文件所有者" class="headerlink" title="更改文件所有者"></a>更改文件所有者</h3><p>函数原型</p>
<ul>
<li><code>int chown( const char *pathname, uid_t owner, gid_t group);</code></li>
<li><code>int fchown( int filedes, uid_t owner, gid_t group);</code></li>
<li><code>int lchown( const char *pathname, uid_t owner, gid_t group);</code></li>
</ul>
<p>函数用途：更改文件的用户ID和组ID。成功返回0，若出错则返回-1</p>
<p>函数说明：</p>
<ul>
<li>如果两个参数<code>owner</code>或<code>group</code>中的任意一个是<code>-1</code>，则不改变文件所有者或文件所属用户组</li>
<li><code>lchown</code>是改变符号链接本身的所有者，而不是该符号链接所指向的文件</li>
<li>基于BSD的系统中，只有超级用户才能更改一个文件的所有者</li>
<li>非超级用户进程调用,则在成功返回时，该文件的设置用户ID位和设置组ID位会被清除</li>
</ul>
<h3 id="Link函数"><a href="#Link函数" class="headerlink" title="Link函数"></a>Link函数</h3><p>函数原型：<code>int link ( const char *pathname, const char *newpath);</code></p>
<p>函数用途：任何一个文件可以有多个目录项指向其索引节点，创建一个指向现有文件的新目录项</p>
<p>函数说明</p>
<ul>
<li>此函数创建一个新目录项<code>newpath</code>，它指向<code>pathname</code>指向的文件。如果<code>newpath</code>已经存在，则返回出错</li>
<li>创建新目录项以及增加连接计数是一个原子操作。</li>
<li>大多数的系统规定，只有超级用户可以创建指向一个目录的新连接，目的是避免在文件系统中形成循环。</li>
</ul>
<h3 id="unlink函数"><a href="#unlink函数" class="headerlink" title="unlink函数"></a>unlink函数</h3><p>函数原型：<code>int unlink ( const char *pathname);</code></p>
<p>头文件：<code>unistd.h</code></p>
<p>函数用途：<code>unlink</code>删除目录项，并将由<code>pathname</code>所引用文件的链接计数减1，清空这个文件使用的可用的系统资源</p>
<p><code>unlink</code>是系统调用</p>
<h3 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h3><p>函数原型：<code>int remove( const char *pathname);</code></p>
<p>头文件：<code>stdio.h</code></p>
<p>函数用途：<code>remove</code>删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下的所有文件及子目录均删除</p>
<p><code>remove</code>是库函数</p>
<p><code>remove</code>的参数为普通文件时等价于<code>unlink</code></p>
<h3 id="rename函数"><a href="#rename函数" class="headerlink" title="rename函数"></a>rename函数</h3><p>函数原型：<code>int rename ( const char * oldname, const char * newname);</code></p>
<p>函数用途：更名文件或目录</p>
<p>函数说明</p>
<ul>
<li>如果<code>oldname</code>是一个文件而不是目录，那么为该文件更名</li>
<li>如果<code>oldname</code>是一个目录，那么为该目录更名</li>
<li>如果<code>oldname</code>和<code>newname</code>引用同一文件，则函数不做任何更改而成功返回</li>
<li>应对包含两个文件的目录具有写和执行许可权</li>
</ul>
<h3 id="文件的时间"><a href="#文件的时间" class="headerlink" title="文件的时间"></a>文件的时间</h3><p>每个文件有三个时间字段</p>
<p><img src="/01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/image-20220408123707548.png" alt="image-20220408123707548"></p>
<p>对文件进行一次读操作，它的访问时间就会改变</p>
<p>修改时间是文件内容最后一次被修改的时间</p>
<p>状态时间是该文件索引节点最后一次被修改的时间，影响索引节点的操作：</p>
<ul>
<li>更改文件访问权限</li>
<li>更改文件用户ID</li>
<li>更改文件链接数</li>
</ul>
<h3 id="utime函数"><a href="#utime函数" class="headerlink" title="utime函数"></a>utime函数</h3><p>函数原型：<code>int utime( const char *pathname, const struct utimbuf *times);</code></p>
<p>函数用途：设置存取和修改文件的时间</p>
<p>函数说明：此函数的操作以及执行它所要求的优先权取决于<code>times</code>参数是否是<code>NULL</code></p>
<ul>
<li>如果<code>times</code>是一个<code>NULL</code>，则存取时间和修改时间两者都设置为当前时间，但必须满足下面二者之一：<ul>
<li>进程的有效用户ID必须等于该文件的所有者</li>
<li>进程对该文件有写许可权</li>
</ul>
</li>
<li>如果<code>times</code>是非空指针，则存取时间和修改时间被设置为<code>times</code>所指向的时间，此时进程的有效用户ID必须等于该文件的所有者ID，或者进程必须是超级用户的进程</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++提高编程</title>
    <url>/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>学习自黑马程序员&amp;传智教育，文档资料有修改</p>
<span id="more"></span>

<h1 id="C-提高编程"><a href="#C-提高编程" class="headerlink" title="C++提高编程"></a>C++提高编程</h1><ul>
<li>本阶段主要针对C++==泛型编程==和==STL==技术做详细讲解，探讨C++更深层的使用</li>
</ul>
<h2 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h2><h3 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p>
<p>例如生活中的模板</p>
<p>一寸照片模板：</p>
<p><img src="/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547105026929.png" alt="1547105026929"></p>
<p>PPT模板：</p>
<p><img src="/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547103297864.png" alt="1547103297864"></p>
<p><img src="/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547103359158.png" alt="1547103359158"></p>
<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h3 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h3><ul>
<li>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板</li>
</ul>
<ul>
<li>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong> </li>
</ul>
<h4 id="1-2-1-函数模板语法"><a href="#1-2-1-函数模板语法" class="headerlink" title="1.2.1 函数模板语法"></a>1.2.1 函数模板语法</h4><p>函数模板作用：</p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//交换整型函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapInt</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换浮点型函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapDouble</span><span class="params">(<span class="keyword">double</span>&amp; a, <span class="keyword">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//swapInt(a, b);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用模板实现交换</span></span><br><span class="line">	<span class="comment">//1、自动类型推导</span></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、显示指定类型</span></span><br><span class="line">	mySwap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>函数模板利用关键字 template</li>
<li>使用函数模板有两种方式：自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
<h4 id="1-2-2-函数模板注意事项"><a href="#1-2-2-函数模板注意事项" class="headerlink" title="1.2.2 函数模板注意事项"></a>1.2.2 函数模板注意事项</h4><p>注意事项：</p>
<ul>
<li>自动类型推导，必须推导出一致的数据类型T,才可以使用</li>
</ul>
<ul>
<li>模板必须要确定出T的数据类型，才可以使用</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line">	<span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line">	func&lt;<span class="keyword">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<h4 id="1-2-3-函数模板案例"><a href="#1-2-3-函数模板案例" class="headerlink" title="1.2.3 函数模板案例"></a>1.2.3 函数模板案例</h4><p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li>
<li>排序规则从大到小，排序算法为<strong>选择排序</strong></li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="comment">// 也可以替换成typename</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">			&#123;</span><br><span class="line">				max = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max != i) <span class="comment">//如果最大数的下标不是i，交换两者</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//测试char数组</span></span><br><span class="line">	<span class="keyword">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in"><span class="keyword">sizeof</span></span>(charArr) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(charArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//测试int数组</span></span><br><span class="line">	<span class="keyword">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in"><span class="keyword">sizeof</span></span>(intArr) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(intArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：模板可以提高代码复用，需要熟练掌握</p>
<h4 id="1-2-4-普通函数与函数模板的区别"><a href="#1-2-4-普通函数与函数模板的区别" class="headerlink" title="1.2.4 普通函数与函数模板的区别"></a>1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别：</strong></p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAdd01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">	myAdd02&lt;<span class="keyword">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
<h4 id="1-2-5-普通函数与函数模板的调用规则"><a href="#1-2-5-普通函数与函数模板的调用规则" class="headerlink" title="1.2.5 普通函数与函数模板的调用规则"></a>1.2.5 普通函数与函数模板的调用规则</h4><p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配,优先调用函数模板</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line">	<span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">	myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">	<span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="keyword">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
<h4 id="1-2-6-模板的局限性"><a href="#1-2-6-模板的局限性" class="headerlink" title="1.2.6 模板的局限性"></a>1.2.6 模板的局限性</h4><p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的</li>
</ul>
<p><strong>例如：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	a = b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p>
<p>再例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	<span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="built_in">myCompare</span>(a, b);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line">	<span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h3 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h3><h4 id="1-3-1-类模板语法"><a href="#1-3-1-类模板语法" class="headerlink" title="1.3.1 类模板语法"></a>1.3.1 类模板语法</h4><p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li>
</ul>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">	Person&lt;string, <span class="keyword">int</span>&gt;<span class="built_in">P1</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">	P1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
<h4 id="1-3-2-类模板与函数模板区别"><a href="#1-3-2-类模板与函数模板区别" class="headerlink" title="1.3.2 类模板与函数模板区别"></a>1.3.2 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">	Person &lt;string ,<span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h4 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyClass&lt;Person1&gt; m;</span><br><span class="line">	</span><br><span class="line">	m.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<h4 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h4><p>学习目标：</p>
<ul>
<li>类模板实例化出的对象，向函数传参的方式</li>
</ul>
<p>一共有三种传入方式：</p>
<ol>
<li>指定传入的类型   — 直接显示对象的数据类型</li>
<li>参数模板化           — 将对象中的参数变为模板进行传递</li>
<li>整个类模板化       — 将这个对象类型 模板化进行传递</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="keyword">int</span>&gt; &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="keyword">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="keyword">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="keyword">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种：指定传入的类型</li>
</ul>
<h4 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span><span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h4 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中的成员函数类外实现</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数类内声明</span></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h4 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h4><p>学习目标：</p>
<ul>
<li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li>
</ul>
<p>问题：</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li>解决方式1：直接包含.cpp源文件</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ul>
<p><strong>示例：</strong></p>
<p>person.hpp中代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类模板分文件编写.cpp中代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;person.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.cpp&quot;</span> <span class="comment">//解决方式1，包含cpp源文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h4 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h4><p>学习目标：</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现</li>
</ul>
<p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局函数配合友元  类外实现</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="keyword">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="keyword">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<h4 id="1-3-9-类模板案例"><a href="#1-3-9-类模板案例" class="headerlink" title="1.3.9 类模板案例"></a>1.3.9 类模板案例</h4><p>案例描述:  实现一个通用的数组类，要求如下：</p>
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ul>
<p><strong>示例：</strong></p>
<p>myArray.hpp中代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="keyword">int</span> capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="keyword">const</span> MyArray &amp; arr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line">			<span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">	MyArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载[] 操作符  arr[0]</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> index)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//不考虑越界，用户自己去处理</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Push_back</span><span class="params">(<span class="keyword">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取数组容量</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取数组大小</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span>	<span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">MyArray</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line">	<span class="keyword">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line">	<span class="keyword">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>类模板案例—数组类封装.cpp中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		array1.<span class="built_in">Push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">	array2.<span class="built_in">Pop_back</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array2);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125; </span><br><span class="line">		<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; personArr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建数组</span></span><br><span class="line">	<span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入数据</span></span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p1);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p2);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p3);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p4);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printPersonArray</span>(pArray);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>能够利用所学知识点实现通用的数组</p>
<h2 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h2><h3 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h3><ul>
<li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p>
</li>
<li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p>
</li>
<li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p>
</li>
<li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p>
</li>
</ul>
<h3 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h3><ul>
<li>STL(Standard Template Library,<strong>标准模板库</strong>)</li>
<li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h3 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p>
<ol>
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ol>
<h3 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4  STL中容器、算法、迭代器"></a>2.4  STL中容器、算法、迭代器</h3><p><strong>容器：</strong>置物之所也</p>
<p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p>
<p>常用的数据结构：数组, 链表, 树, 栈, 队列, 集合, 映射表 等</p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p>
<p>​    <strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​    <strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p>
<p><strong>算法：</strong>问题之解法也</p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>
<p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>
<p><strong>迭代器：</strong>容器和算法之间粘合剂</p>
<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>
<p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody></table>
<p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p>
<h3 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p>
<p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p>
<h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><p>容器：     <code>vector</code></p>
<p>算法：     <code>for_each</code></p>
<p>迭代器： <code>vector&lt;int&gt;::iterator</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="comment">//向容器中放数据</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line">	<span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line">	<span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line">	<span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种遍历方式：</span></span><br><span class="line">	<span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line">		cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">		pBegin++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第二种遍历方式：</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种遍历方式：</span></span><br><span class="line">	<span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">		mName = name;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mName;</span><br><span class="line">	<span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		Person * p = (*it);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-5-3-Vector容器嵌套容器"><a href="#2-5-3-Vector容器嵌套容器" class="headerlink" title="2.5.3 Vector容器嵌套容器"></a>2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">		v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">		v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">			cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3-STL-容器"><a href="#3-STL-容器" class="headerlink" title="3 STL- 容器"></a>3 STL- 容器</h2><h3 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h3><h4 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h4><p><strong>本质：</strong></p>
<ul>
<li>string是C++风格的字符串，而string本质上是一个类</li>
</ul>
<p><strong>string和char * 区别：</strong></p>
<ul>
<li>char * 是一个指针</li>
<li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li>
</ul>
<p><strong>特点：</strong></p>
<p>string 类内部封装了很多成员方法</p>
<p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p>
<p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>
<h4 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h4><p>构造函数原型：</p>
<ul>
<li><code>string();</code>                                       //创建一个空的字符串 例如: string str;</li>
<li><code>string(const char* s);</code>            //使用字符串s初始化</li>
<li><code>string(const string&amp; str);</code>    //使用一个string对象初始化另一个string对象</li>
<li><code>string(int n, char c);</code>           //使用n个字符c初始化 </li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：string的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h4><p>功能描述：</p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p>赋值的函数原型：</p>
<ul>
<li><code>string&amp; operator=(const char* s);</code>             //char*类型字符串 赋值给当前的字符串</li>
<li><code>string&amp; operator=(const string &amp;s);</code>         //把字符串s赋给当前的字符串</li>
<li><code>string&amp; operator=(char c);</code>                          //字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串</li>
<li><code>string&amp; assign(const char *s, int n);</code>     //把字符串s的前n个字符赋给当前的字符串</li>
<li><code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串</li>
<li><code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1;</span><br><span class="line">	str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str2;</span><br><span class="line">	str2 = str1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str3;</span><br><span class="line">	str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str4;</span><br><span class="line">	str4.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str5;</span><br><span class="line">	str5.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	string str6;</span><br><span class="line">	str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str7;</span><br><span class="line">	str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>​    string的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p>
<h4 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; operator+=(const char* str);</code>                   //重载+=操作符</li>
<li><code>string&amp; operator+=(const char c);</code>                         //重载+=操作符</li>
<li><code>string&amp; operator+=(const string&amp; str);</code>                //重载+=操作符</li>
<li><code>string&amp; append(const char *s); </code>                               //把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s, int n);</code>                 //把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code>                           //同operator+=(const string&amp; str)</li>
<li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">	str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">	str1 += str2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">	str3.<span class="built_in">append</span>(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">	str3.<span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="comment">//str3.append(str2);</span></span><br><span class="line">	str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p>
<h4 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int find(const string&amp; str, int pos = 0) const;</code>              //查找str第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos = 0) const; </code>                     //查找s第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos, int n) const; </code>               //从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c, int pos = 0) const; </code>                       //查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      //查找str最后一次位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos = npos) const;</code>              //查找s最后一次出现位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos, int n) const;</code>              //从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c, int pos = 0) const;  </code>                      //查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>       //替换从pos开始n个字符为字符串str</li>
<li><code>string&amp; replace(int pos, int n,const char* s); </code>                 //替换从pos开始的n个字符为字符串s</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	pos = str1.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//替换</span></span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">	str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>find查找是从左往后，rfind从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h4 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p>
<ul>
<li>字符串之间的比较</li>
</ul>
<p><strong>比较方式：</strong></p>
<ul>
<li>字符串比较是按字符的ASCII码进行对比</li>
</ul>
<p>= 返回   0</p>
<p>&gt; 返回   1 </p>
<p>&lt; 返回  -1</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int compare(const string &amp;s) const; </code>  //与字符串s比较</li>
<li><code>int compare(const char *s) const;</code>      //与字符串s比较</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	string s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<h4 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p>
<ul>
<li><code>char&amp; operator[](int n); </code>     //通过[]方式取字符</li>
<li><code>char&amp; at(int n);   </code>                    //通过at方法获取字符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符修改</span></span><br><span class="line">	str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p>
<h4 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对string字符串进行插入和删除字符操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; insert(int pos, const char* s);  </code>                //插入字符串</li>
<li><code>string&amp; insert(int pos, const string&amp; str); </code>        //插入字符串</li>
<li><code>string&amp; insert(int pos, int n, char c);</code>                //在指定位置插入n个字符c</li>
<li><code>string&amp; erase(int pos, int n = npos);</code>                    //删除从Pos开始的n个字符 </li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p>
<h4 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h4><p><strong>功能描述：</strong></p>
<ul>
<li>从字符串中获取想要的子串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个字符组成的字符串</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">	string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">	string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>
<h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><p><strong>功能：</strong></p>
<ul>
<li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li>
</ul>
<p><strong>vector与普通数组区别：</strong></p>
<ul>
<li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li>
</ul>
<p><strong>动态扩展：</strong></p>
<ul>
<li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li>
</ul>
<p><img src="/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002.jpg" alt="说明: 2015-11-10_151152"></p>
<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h4 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>创建vector容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&lt;T&gt; v; </code>                            //采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(), v.end());   </code>       //将v[begin(), end())区间中的元素拷贝给本身。</li>
<li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li>
<li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给vector容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</li>
</ul>
<ul>
<li><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">	v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v4;</span><br><span class="line">	v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p>
<h4 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4  vector容量和大小"></a>3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器的容量和大小操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>empty(); </code>                            //判断容器是否为空</p>
</li>
<li><p><code>capacity();</code>                      //容器的容量</p>
</li>
<li><p><code>size();</code>                              //返回容器中元素的个数</p>
</li>
<li><p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
<p>​                          //如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
<p>​                              //如果容器变短，则末尾超出容器长度的元素被删除</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="keyword">if</span> (v1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">	v1.<span class="built_in">resize</span>(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">	v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>判断是否为空  — empty</li>
<li>返回元素个数  — size</li>
<li>返回容器容量  — capacity</li>
<li>重新指定大小  —  resize</li>
</ul>
<h4 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器进行插入、删除操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>push_back(ele);</code>                                         //尾部插入元素ele</li>
<li><code>pop_back();</code>                                                //删除最后一个元素</li>
<li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li>
<li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li>
<li><code>clear();</code>                                                        //删除容器中所有元素</li>
<li><code>emplace(const_iterator position, Args&amp;&amp;... args);</code> 插入元素</li>
<li><code>emplace_back(Args&amp;&amp;... args);</code> 在尾部插入元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	v1.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">	v1.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>尾插  — push_back</li>
<li>尾删  — pop_back</li>
<li>插入  — insert    (位置迭代器)</li>
<li>删除  — erase  （位置迭代器）</li>
<li>清空  —  clear  </li>
</ul>
<h4 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     //返回索引idx所指的数据</li>
<li><code>operator[]; </code>       //返回索引idx所指的数据</li>
<li><code>front(); </code>            //返回容器中第一个数据元素</li>
<li><code>back();</code>              //返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现两个容器内元素进行互换</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>swap(vec);</code>  // 将vec与本身的元素互换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//互换容器</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//收缩内存</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p>
<h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p>
<ul>
<li>减少vector在动态扩展容量时的扩展次数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//预留空间</span></span><br><span class="line">	v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">			p = &amp;v[<span class="number">0</span>];</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>
<h3 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h4><p><strong>功能：</strong></p>
<ul>
<li>双端数组，可以对头端进行插入删除操作</li>
</ul>
<p><strong>deque与vector区别：</strong></p>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度回比vector快</li>
<li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li>
</ul>
<p><img src="/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547547642923.jpg" alt="说明: 2015-11-19_204101"></p>
<p>deque内部工作原理:</p>
<p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
<p><img src="/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547547896341.jpg" alt="clip_image002-1547547896341"></p>
<ul>
<li>deque容器的迭代器也是支持随机访问的</li>
</ul>
<h4 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>deque容器构造</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&lt;T&gt;</code> deqT;                      //默认构造形式</li>
<li><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</li>
<li><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">	<span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;<span class="built_in">d3</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;d4 = d3;</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>
<h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给deque容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&amp; operator=(const deque &amp;deq); </code>         //重载等号操作符</li>
</ul>
<ul>
<li><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>                                             //将n个elem拷贝赋值给本身。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">	d2 = d1;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;d3;</span><br><span class="line">	d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;d4;</span><br><span class="line">	d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：deque赋值操作也与vector相同，需熟练掌握</p>
<h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对deque容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>deque.empty();</code>                       //判断容器是否为空</p>
</li>
<li><p><code>deque.size();</code>                         //返回容器中元素的个数</p>
</li>
<li><p><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p>
<p>​                                         //如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p>
<p>​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断容器是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (d1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//统计大小</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>deque没有容量的概念</li>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>向deque容器中插入和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<p>两端插入操作：</p>
<ul>
<li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li>
<li><code>push_front(elem);</code>        //在容器头部插入一个数据</li>
<li><code>pop_back();</code>                   //删除容器最后一个数据</li>
<li><code>pop_front();</code>                 //删除容器第一个数据</li>
</ul>
<p>指定位置操作：</p>
<ul>
<li><p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
</li>
<li><p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p>
</li>
<li><p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p>
</li>
<li><p><code>clear();</code>                           //清空容器的所有数据</p>
</li>
<li><p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p>
</li>
<li><p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	d.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	d.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	d.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>插入和删除提供的位置是迭代器！</li>
<li>尾插   —  push_back</li>
<li>尾删   —  pop_back</li>
<li>头插   —  push_front</li>
<li>头删   —  pop_front</li>
</ul>
<h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对deque 中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     //返回索引idx所指的数据</li>
<li><code>operator[]; </code>      //返回索引idx所指的数据</li>
<li><code>front(); </code>            //返回容器中第一个数据元素</li>
<li><code>back();</code>              //返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7  deque 排序"></a>3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p>
<ul>
<li>利用算法实现对deque容器进行排序</li>
</ul>
<p><strong>算法：</strong></p>
<ul>
<li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">	<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p>
<h3 id="3-4-案例-评委打分"><a href="#3-4-案例-评委打分" class="headerlink" title="3.4 案例-评委打分"></a>3.4 案例-评委打分</h3><h4 id="3-4-1-案例描述"><a href="#3-4-1-案例描述" class="headerlink" title="3.4.1 案例描述"></a>3.4.1 案例描述</h4><p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p>
<h4 id="3-4-2-实现步骤"><a href="#3-4-2-实现步骤" class="headerlink" title="3.4.2 实现步骤"></a>3.4.2 实现步骤</h4><ol>
<li>创建五名选手，放到vector中</li>
<li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li>
<li>sort算法对deque容器中分数排序，去除最高和最低分</li>
<li>deque容器遍历一遍，累加总分</li>
<li>获取平均分</li>
</ol>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> score)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Score = score;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name; <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> m_Score;  <span class="comment">//平均分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createPerson</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">		name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function">Person <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将创建的person对象 放入到容器中</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将评委的分数 放入到deque容器中</span></span><br><span class="line">		deque&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> score = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>;  <span class="comment">// 60 ~ 100</span></span><br><span class="line">			d.<span class="built_in">push_back</span>(score);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;</span></span><br><span class="line">		<span class="comment">//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//	cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//排序</span></span><br><span class="line">		<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">		<span class="comment">//去除最高和最低分</span></span><br><span class="line">		d.<span class="built_in">pop_back</span>();</span><br><span class="line">		d.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取平均分</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::iterator dit = d.<span class="built_in">begin</span>(); dit != d.<span class="built_in">end</span>(); dit++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += *dit; <span class="comment">//累加每个评委的分数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> avg = sum / d.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将平均分 赋值给选手身上</span></span><br><span class="line">		it-&gt;m_Score = avg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 平均分： &quot;</span> &lt;&lt; it-&gt;m_Score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//随机数种子</span></span><br><span class="line">	<span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、创建5名选手</span></span><br><span class="line">	vector&lt;Person&gt;v;  <span class="comment">//存放选手容器</span></span><br><span class="line">	<span class="built_in">createPerson</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">	<span class="comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、给5名选手打分</span></span><br><span class="line">	<span class="built_in">setScore</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、显示最后得分</span></span><br><span class="line">	<span class="built_in">showScore</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p>
<h3 id="3-5-stack容器"><a href="#3-5-stack容器" class="headerlink" title="3.5 stack容器"></a>3.5 stack容器</h3><h4 id="3-5-1-stack-基本概念"><a href="#3-5-1-stack-基本概念" class="headerlink" title="3.5.1 stack 基本概念"></a>3.5.1 stack 基本概念</h4><p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p>
<p><img src="/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547604555425-16525141443681.jpg"></p>
<p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p>
<p>栈中进入数据称为  — <strong>入栈</strong>  <code>push</code></p>
<p>栈中弹出数据称为  — <strong>出栈</strong>  <code>pop</code></p>
<p>生活中的栈：</p>
<p><img src="/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002.png" alt="img"></p>
<p><img src="/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547605111510.jpg" alt="img"></p>
<h4 id="3-5-2-stack-常用接口"><a href="#3-5-2-stack-常用接口" class="headerlink" title="3.5.2 stack 常用接口"></a>3.5.2 stack 常用接口</h4><p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式</li>
<li><code>stack(const stack &amp;stk);</code>            //拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>      //向栈顶添加元素</li>
<li><code>pop();</code>                //从栈顶移除第一个元素</li>
<li><code>top(); </code>                //返回栈顶元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>            //判断堆栈是否为空</li>
<li><code>size(); </code>              //返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出栈顶元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出栈顶元素</span></span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>入栈   — push</li>
<li>出栈   — pop</li>
<li>返回栈顶   — top</li>
<li>判断栈是否为空   — empty</li>
<li>返回栈大小   — size</li>
</ul>
<h3 id="3-6-queue-容器"><a href="#3-6-queue-容器" class="headerlink" title="3.6 queue 容器"></a>3.6 queue 容器</h3><h4 id="3-6-1-queue-基本概念"><a href="#3-6-1-queue-基本概念" class="headerlink" title="3.6.1 queue 基本概念"></a>3.6.1 queue 基本概念</h4><p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p>
<p><img src="/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547606475892.jpg" alt="说明: 2015-11-15_214429"></p>
<p>队列容器允许从一端新增元素，从另一端移除元素</p>
<p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p>
<p>队列中进数据称为 — <strong>入队</strong>    <code>push</code></p>
<p>队列中出数据称为 — <strong>出队</strong>    <code>pop</code></p>
<p>生活中的队列：</p>
<p><img src="/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547606785041.png" alt="1547606785041"></p>
<h4 id="3-6-2-queue-常用接口"><a href="#3-6-2-queue-常用接口" class="headerlink" title="3.6.2 queue 常用接口"></a>3.6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li>
<li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>                             //往队尾添加元素</li>
<li><code>pop();</code>                                      //从队头移除第一个元素</li>
<li><code>back();</code>                                    //返回最后一个元素</li>
<li><code>front(); </code>                                  //返回第一个元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>            //判断堆栈是否为空</li>
<li><code>size(); </code>              //返回堆栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建队列</span></span><br><span class="line">	queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">	q.<span class="built_in">push</span>(p1);</span><br><span class="line">	q.<span class="built_in">push</span>(p2);</span><br><span class="line">	q.<span class="built_in">push</span>(p3);</span><br><span class="line">	q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//队列不提供迭代器，更不支持随机访问	</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出队头元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name  </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出队头元素</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>入队   — push</li>
<li>出队   — pop</li>
<li>返回队头元素   — front</li>
<li>返回队尾元素   — back</li>
<li>判断队是否为空   — empty</li>
<li>返回队列大小   — size</li>
</ul>
<h3 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h3><h4 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h4><p><strong>功能：</strong>将数据进行链式存储</p>
<p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成：链表由一系列<strong>结点</strong>组成</p>
<p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p>
<p>STL中的链表是一个==双向循环链表==</p>
<p><img src="/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547608564071.jpg" alt="说明: 2015-11-15_225145"></p>
<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p>
<p>list的优点：</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p>list的缺点：</p>
<ul>
<li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li>
</ul>
<p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
<p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p>
<h4 id="3-7-2-list构造函数"><a href="#3-7-2-list构造函数" class="headerlink" title="3.7.2  list构造函数"></a>3.7.2  list构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>创建list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>list&lt;T&gt; lst;</code>                               //list采用采用模板类实现,对象的默认构造形式：</li>
<li><code>list(beg,end);</code>                           //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>list(n,elem);</code>                             //构造函数将n个elem拷贝给本身。</li>
<li><code>list(const list &amp;lst);</code>            //拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;<span class="built_in">L2</span>(L1.<span class="built_in">begin</span>(),L1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;<span class="built_in">L3</span>(L2);</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;<span class="built_in">L4</span>(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p>
<h4 id="3-7-3-list-赋值和交换"><a href="#3-7-3-list-赋值和交换" class="headerlink" title="3.7.3 list 赋值和交换"></a>3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给list容器进行赋值，以及交换list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>assign(beg, end);</code>            //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>              //将n个elem拷贝赋值给本身。</li>
<li><code>list&amp; operator=(const list &amp;lst);</code>         //重载等号操作符</li>
<li><code>swap(lst);</code>                         //将lst与本身的元素互换。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">	L2 = L1;</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L3;</span><br><span class="line">	L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L4;</span><br><span class="line">	L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">	L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	L1.<span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：list赋值和交换操作能够灵活运用即可</p>
<h4 id="3-7-4-list-大小操作"><a href="#3-7-4-list-大小操作" class="headerlink" title="3.7.4 list 大小操作"></a>3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>size(); </code>                             //返回容器中元素的个数</p>
</li>
<li><p><code>empty(); </code>                           //判断容器是否为空</p>
</li>
<li><p><code>resize(num);</code>                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
<p>​                        //如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>resize(num, elem); </code>       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
<pre><code>                                           //如果容器变短，则末尾超出容器长度的元素被删除。
</code></pre>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (L1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h4 id="3-7-5-list-插入和删除"><a href="#3-7-5-list-插入和删除" class="headerlink" title="3.7.5 list 插入和删除"></a>3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器进行数据的插入和删除</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>push_back(elem);//在容器尾部加入一个元素</li>
<li>pop_back();//删除容器中最后一个元素</li>
<li>push_front(elem);//在容器开头插入一个元素</li>
<li>pop_front();//从容器开头移除第一个元素</li>
<li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();//移除容器的所有数据</li>
<li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li>
<li>remove(elem);//删除容器中所有与elem值匹配的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	L.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	L.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">erase</span>(++it);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移除</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">	L.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>尾插   — push_back</li>
<li>尾删   — pop_back</li>
<li>头插   — push_front</li>
<li>头删   — pop_front</li>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>移除   — remove</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-7-6-list-数据存取"><a href="#3-7-6-list-数据存取" class="headerlink" title="3.7.6 list 数据存取"></a>3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器中数据进行存取</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>front();</code>        //返回第一个元素。</li>
<li><code>back();</code>         //返回最后一个元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素   — front</li>
<li>返回最后一个元素   — back</li>
</ul>
<h4 id="3-7-7-list-反转和排序"><a href="#3-7-7-list-反转和排序" class="headerlink" title="3.7.7 list 反转和排序"></a>3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器中的元素反转，以及将容器中的数据进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reverse();</code>   //反转链表</li>
<li><code>sort();</code>        //链表排序</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> val1 , <span class="keyword">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反转容器的元素</span></span><br><span class="line">	L.<span class="built_in">reverse</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	L.<span class="built_in">sort</span>(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>反转   — reverse</li>
<li>排序   — sort （成员函数）</li>
</ul>
<h4 id="3-7-8-排序案例"><a href="#3-7-8-排序案例" class="headerlink" title="3.7.8 排序案例"></a>3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p>
<p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age , <span class="keyword">int</span> height) &#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">		m_Age = age;</span><br><span class="line">		m_Height = height;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p1.m_Age == p2.m_Age) &#123;</span><br><span class="line">		<span class="keyword">return</span> p1.m_Height  &gt; p2.m_Height;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>  p1.m_Age &lt; p2.m_Age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	list&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	L.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p5);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p6);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	L.<span class="built_in">sort</span>(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li>
</ul>
<ul>
<li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li>
</ul>
<h3 id="3-8-set-multiset-容器"><a href="#3-8-set-multiset-容器" class="headerlink" title="3.8 set/ multiset 容器"></a>3.8 set/ multiset 容器</h3><h4 id="3-8-1-set基本概念"><a href="#3-8-1-set基本概念" class="headerlink" title="3.8.1 set基本概念"></a>3.8.1 set基本概念</h4><p><strong>简介：</strong></p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li>
</ul>
<p><strong>set和multiset区别</strong>：</p>
<ul>
<li>set不允许容器中有重复的元素</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<h4 id="3-8-2-set构造和赋值"><a href="#3-8-2-set构造和赋值" class="headerlink" title="3.8.2 set构造和赋值"></a>3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值</p>
<p>构造：</p>
<ul>
<li><code>set&lt;T&gt; st;</code>                        //默认构造函数：</li>
<li><code>set(const set &amp;st);</code>       //拷贝构造函数</li>
</ul>
<p>赋值：</p>
<ul>
<li><code>set&amp; operator=(const set &amp;st);</code>    //重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//没有push和pop</span></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt;s3;</span><br><span class="line">	s3 = s2;</span><br><span class="line">	<span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序</li>
</ul>
<h4 id="3-8-3-set大小和交换"><a href="#3-8-3-set大小和交换" class="headerlink" title="3.8.3 set大小和交换"></a>3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计set容器大小以及交换set容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>size();</code>          //返回容器中元素的数目</li>
<li><code>empty();</code>        //判断容器是否为空</li>
<li><code>swap(st);</code>      //交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">	</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	s1.<span class="built_in">swap</span>(s2);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h4 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>set容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>           //在容器中插入元素。</li>
<li><code>clear();</code>                    //清除所有元素</li>
<li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(elem);</code>            //删除容器中值为elem的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	<span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">	s1.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-8-5-set查找和统计"><a href="#3-8-5-set查找和统计" class="headerlink" title="3.8.5 set查找和统计"></a>3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对set容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>                //统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt;::iterator pos = s1.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != s1.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="keyword">int</span> num = s1.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于set，结果为0或者1）</li>
</ul>
<h4 id="3-8-6-set和multiset区别"><a href="#3-8-6-set和multiset区别" class="headerlink" title="3.8.6 set和multiset区别"></a>3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p>
<ul>
<li>掌握set和multiset的区别</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	pair&lt;set&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt;  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//multiset</span></span><br><span class="line">	multiset&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (multiset&lt;<span class="keyword">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>如果不允许插入重复数据可以利用set</li>
<li>如果需要插入重复数据利用multiset</li>
</ul>
<h4 id="3-8-7-pair对组创建"><a href="#3-8-7-pair对组创建" class="headerlink" title="3.8.7 pair对组创建"></a>3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p><strong>两种创建方式：</strong></p>
<ul>
<li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li>
<li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">pair&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(string(<span class="string">&quot;Tom&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	pair&lt;string, <span class="keyword">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>两种方式都可以创建对组，记住一种即可</p>
<h4 id="3-8-8-set容器排序"><a href="#3-8-8-set容器排序" class="headerlink" title="3.8.8 set容器排序"></a>3.8.8 set容器排序</h4><p>学习目标：</p>
<ul>
<li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li>
</ul>
<p>主要技术点：</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例一</strong>   set存放内置数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指定排序规则</span></span><br><span class="line">	set&lt;<span class="keyword">int</span>,MyCompare&gt; s2;</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="keyword">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：利用仿函数可以指定set容器的排序规则</p>
<p><strong>示例二</strong> set存放自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparePerson</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p1, <span class="keyword">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line">		<span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">insert</span>(p1);</span><br><span class="line">	s.<span class="built_in">insert</span>(p2);</span><br><span class="line">	s.<span class="built_in">insert</span>(p3);</span><br><span class="line">	s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h3 id="3-9-map-multimap容器"><a href="#3-9-map-multimap容器" class="headerlink" title="3.9 map/ multimap容器"></a>3.9 map/ multimap容器</h3><h4 id="3-9-1-map基本概念"><a href="#3-9-1-map基本概念" class="headerlink" title="3.9.1 map基本概念"></a>3.9.1 map基本概念</h4><p><strong>简介：</strong></p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p>map和multimap<strong>区别</strong>：</p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h4 id="3-9-2-map构造和赋值"><a href="#3-9-2-map构造和赋值" class="headerlink" title="3.9.2  map构造和赋值"></a>3.9.2  map构造和赋值</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行构造和赋值操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<p><strong>构造：</strong></p>
<ul>
<li><code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数: </li>
<li><code>map(const map &amp;mp);</code>             //拷贝构造函数</li>
</ul>
<p><strong>赋值：</strong></p>
<ul>
<li><code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;<span class="built_in">m2</span>(m); <span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m3;</span><br><span class="line">	m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">	<span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p>
<h4 id="3-9-3-map大小和交换"><a href="#3-9-3-map大小和交换" class="headerlink" title="3.9.3 map大小和交换"></a>3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计map容器大小以及交换map容器</li>
</ul>
<p>函数原型：</p>
<ul>
<li><code>size();</code>          //返回容器中元素的数目</li>
<li><code>empty();</code>        //判断容器是否为空</li>
<li><code>swap(st);</code>      //交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2;</span><br><span class="line">	m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">	m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">	m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	m.<span class="built_in">swap</span>(m2);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h4 id="3-9-4-map插入和删除"><a href="#3-9-4-map插入和删除" class="headerlink" title="3.9.4 map插入和删除"></a>3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>map容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>           //在容器中插入元素。</li>
<li><code>clear();</code>                    //清除所有元素</li>
<li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(key);</code>            //删除容器中值为key的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">	<span class="comment">//第一种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	<span class="comment">//第二种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	<span class="comment">//第三种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="comment">//第四种插入方式</span></span><br><span class="line">	m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">	m.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>map插入方式很多，记住其一即可</li>
</ul>
<ul>
<li>插入   — <code>insert </code></li>
<li>删除   — <code>erase</code></li>
<li>清空   — <code>clear</code></li>
</ul>
<h4 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>                //统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m; </span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != m.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="keyword">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>查找   —  <code>find</code>（返回的是迭代器）</li>
<li>统计   —  <code>count </code>（对于map，结果为0或者1）</li>
</ul>
<h4 id="3-9-6-map容器排序"><a href="#3-9-6-map容器排序" class="headerlink" title="3.9.6 map容器排序"></a>3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p>
<ul>
<li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li>
</ul>
<p><strong>主要技术点:</strong></p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//默认从小到大排序</span></span><br><span class="line">	<span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则,同set容器</li>
</ul>
<p><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html">C++中的STL中map用法详解 - Boblim - 博客园 (cnblogs.com)</a></p>
<h3 id="3-10-案例-员工分组"><a href="#3-10-案例-员工分组" class="headerlink" title="3.10 案例-员工分组"></a>3.10 案例-员工分组</h3><h4 id="3-10-1-案例描述"><a href="#3-10-1-案例描述" class="headerlink" title="3.10.1 案例描述"></a>3.10.1 案例描述</h4><ul>
<li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li>
<li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li>
<li>随机给10名员工分配部门和工资</li>
<li>通过multimap进行信息的插入  key(部门编号) value(员工)</li>
<li>分部门显示员工信息</li>
</ul>
<h4 id="3-10-2-实现步骤"><a href="#3-10-2-实现步骤" class="headerlink" title="3.10.2 实现步骤"></a>3.10.2 实现步骤</h4><ol>
<li>创建10名员工，放到vector中</li>
<li>遍历vector容器，取出每个员工，进行随机分组</li>
<li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li>
<li>分部门显示员工信息</li>
</ol>
<p><strong>案例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">- 随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">- 分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CEHUA  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEISHU 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YANFA  2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createWorker</span><span class="params">(vector&lt;Worker&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Worker worker;</span><br><span class="line">		worker.m_Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">		worker.m_Name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">		worker.m_Salary = <span class="built_in">rand</span>() % <span class="number">10000</span> + <span class="number">10000</span>; <span class="comment">// 10000 ~ 19999</span></span><br><span class="line">		<span class="comment">//将员工放入到容器中</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(worker);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工分组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGroup</span><span class="params">(vector&lt;Worker&gt;&amp;v,multimap&lt;<span class="keyword">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Worker&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//产生随机部门编号</span></span><br><span class="line">		<span class="keyword">int</span> deptId = <span class="built_in">rand</span>() % <span class="number">3</span>; <span class="comment">// 0 1 2 </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//将员工插入到分组中</span></span><br><span class="line">		<span class="comment">//key部门编号，value具体员工</span></span><br><span class="line">		m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(deptId, *it));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showWorkerByGourp</span><span class="params">(multimap&lt;<span class="keyword">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 0  A  B  C   1  D  E   2  F G ...</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;策划部门：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	multimap&lt;<span class="keyword">int</span>,Worker&gt;::iterator pos = m.<span class="built_in">find</span>(CEHUA);</span><br><span class="line">	<span class="keyword">int</span> count = m.<span class="built_in">count</span>(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++ , index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;美术部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(MEISHU);</span><br><span class="line">	count = m.<span class="built_in">count</span>(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;研发部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(YANFA);</span><br><span class="line">	count = m.<span class="built_in">count</span>(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、创建员工</span></span><br><span class="line">	vector&lt;Worker&gt;vWorker;</span><br><span class="line">	<span class="built_in">createWorker</span>(vWorker);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、员工分组</span></span><br><span class="line">	multimap&lt;<span class="keyword">int</span>, Worker&gt;mWorker;</span><br><span class="line">	<span class="built_in">setGroup</span>(vWorker, mWorker);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、分组显示员工</span></span><br><span class="line">	<span class="built_in">showWorkerByGourp</span>(mWorker);</span><br><span class="line"></span><br><span class="line">	<span class="comment">////测试</span></span><br><span class="line">	<span class="comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>当数据以键值对形式存在，可以考虑用map 或 multimap</li>
</ul>
<h3 id="3-11-array数组"><a href="#3-11-array数组" class="headerlink" title="3.11 array数组"></a>3.11 array数组</h3><h4 id="3-11-1-array容器定义"><a href="#3-11-1-array容器定义" class="headerlink" title="3.11.1 array容器定义"></a>3.11.1 array容器定义</h4><p>头文件<code>&lt;array&gt;</code></p>
<p><code>array</code>模板类声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_t</span> <span class="title">N</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">array</span>;</span>	<span class="comment">// T为元素类型，N为元素个数</span></span><br></pre></td></tr></table></figure>

<p>容器属性：</p>
<ul>
<li>序列容器中的元素按严格的线性顺序排序。各个元素按其顺序访问它们的位置。</li>
<li>元素存储在连续的存储器位置，允许对元素进行恒定时间随机访问。可以偏移元素的指针以访问其他元素。</li>
<li>容器使用隐式构造函数和析构函数静态分配所需的空间。它的大小是编译时常量。没有内存或时间开销。</li>
</ul>
<h4 id="3-11-2-array容器使用"><a href="#3-11-2-array容器使用" class="headerlink" title="3.11.2 array容器使用"></a>3.11.2 array容器使用</h4><p>Iterators迭代器的作用是遍历array数组类中的元素。可以通过**begin/end()<strong>、</strong>rbegin/rend()<strong>、</strong>cbegin/cend()<strong>、</strong>crbegin/crend()**等函数进行访问。</p>
<table>
<thead>
<tr>
<th>begin</th>
<th>Return iterator to beginning</th>
</tr>
</thead>
<tbody><tr>
<td>end</td>
<td>Return iterator to end</td>
</tr>
<tr>
<td>rbegin</td>
<td>Return reverse iterator to reverse beginning</td>
</tr>
<tr>
<td>rend</td>
<td>Return reverse iterator to reverse end</td>
</tr>
<tr>
<td>cbegin</td>
<td>Return const_iterator to beginning</td>
</tr>
<tr>
<td>cend</td>
<td>Return const_iterator to end</td>
</tr>
<tr>
<td>crbegin</td>
<td>Return const_reverse_iterator to reverse beginning</td>
</tr>
<tr>
<td>crend</td>
<td>Return const_reverse_iterator to reverse end</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;array values: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = arr.<span class="built_in">begin</span>(); it != arr.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//array values: 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>



<p>array数组容器的大小是固定的。可以通过**sizeof()<strong>、</strong>size()<strong>、</strong>max_size()<strong>、</strong>empty()**等函数进行检测。</p>
<table>
<thead>
<tr>
<th>size</th>
<th>Return size</th>
</tr>
</thead>
<tbody><tr>
<td>max_size</td>
<td>Return maximum size</td>
</tr>
<tr>
<td>empty</td>
<td>Test whether list is empty</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(array) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of array = &quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;max_size of array = &quot;</span> &lt;&lt; arr.<span class="built_in">max_size</span>() &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;array is empty!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;array is not empty!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sizeof(array) = 20</span><br><span class="line">size of array = 5</span><br><span class="line">max_size of array = 5</span><br><span class="line">array is not empty!</span><br></pre></td></tr></table></figure>



<p>可以通过下标**[ ]<strong>、</strong>at()<strong>、</strong>front()<strong>、</strong>back()<strong>、</strong>data()**等函数访问array容器内的元素。</p>
<table>
<thead>
<tr>
<th>operator[ ]</th>
<th>Access element</th>
</tr>
</thead>
<tbody><tr>
<td>at</td>
<td>Access element</td>
</tr>
<tr>
<td>front</td>
<td>Access first element</td>
</tr>
<tr>
<td>back</td>
<td>Access last element</td>
</tr>
<tr>
<td>data</td>
<td>Get pointer to first data</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;array[0] = &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;array.at(4) = &quot;</span> &lt;&lt; arr.<span class="built_in">at</span>(<span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;array.front() = &quot;</span> &lt;&lt; arr.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;array.back() = &quot;</span> &lt;&lt; arr.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;array: &quot;</span> &lt;&lt; arr.<span class="built_in">data</span>() &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; &amp;arr &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array[0] = 1</span><br><span class="line">array.at(4) = 5</span><br><span class="line">array.front() = 1</span><br><span class="line">array.back() = 5</span><br><span class="line">&amp;array: 0x7ffd22df6e50 = 0x7ffd22df6e50	</span><br></pre></td></tr></table></figure>



<p>可以使用**fill()<strong>、</strong>swap()**等函数对array容器整体进行操作。</p>
<table>
<thead>
<tr>
<th>fill</th>
<th>Fill array with value</th>
</tr>
</thead>
<tbody><tr>
<td>swap</td>
<td>Swap content</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="keyword">int</span>, 5&gt; arr;</span><br><span class="line">arr.<span class="built_in">fill</span>(<span class="number">5</span>);  <span class="comment">// fill</span></span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="keyword">int</span>, 3&gt; first = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::array&lt;<span class="keyword">int</span>, 3&gt; second = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">first.<span class="built_in">swap</span>(second);  <span class="comment">// swap</span></span><br></pre></td></tr></table></figure>



<p>还可以使用&gt; &lt; ==等符号对两个array数组容器进行比较。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,5&gt; a = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,5&gt; b = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,5&gt; c = &#123;<span class="number">50</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a == b&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a != b&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (a == c) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a == c&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a != c&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (a &lt; c) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a &lt; c&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a &gt;= c&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a == b</span><br><span class="line">a != c</span><br><span class="line">a &lt; c</span><br></pre></td></tr></table></figure>



<p>c++重载了<strong>get()<strong>函数来访问数组容器中的元素，为了和元组相似，还重载了</strong>tuple_size</strong>和<strong>tuple_element</strong>类型。</p>
<table>
<thead>
<tr>
<th>get( array)</th>
<th>Get element (tuple interface)</th>
</tr>
</thead>
<tbody><tr>
<td>tuple_element&lt;array&gt;</td>
<td>Tuple element type for array</td>
</tr>
<tr>
<td>tuple_size&lt;array&gt;</td>
<td>Tuple size traits for array</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,3&gt; myarray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="function">std::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">mytuple</span> <span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    std::tuple_element&lt;<span class="number">0</span>, <span class="keyword">decltype</span>(myarray)&gt;::type myelement;  <span class="comment">// int myelement</span></span><br><span class="line"> </span><br><span class="line">    myelement = std::get&lt;<span class="number">2</span>&gt;(myarray);</span><br><span class="line">    std::get&lt;<span class="number">2</span>&gt;(myarray) = std::get&lt;<span class="number">0</span>&gt;(myarray);</span><br><span class="line">    std::get&lt;<span class="number">0</span>&gt;(myarray) = myelement;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;first element in myarray: &quot;</span> &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(myarray) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;first element in mytuple: &quot;</span> &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">first element in myarray: 30</span><br><span class="line">first element in mytuple: 10</span><br></pre></td></tr></table></figure>





<h2 id="4-STL-函数对象（仿函数）"><a href="#4-STL-函数对象（仿函数）" class="headerlink" title="4 STL- 函数对象（仿函数）"></a>4 STL- 函数对象（仿函数）</h2><h3 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h3><h4 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h4><p><strong>概念：</strong></p>
<ul>
<li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li>
<li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li>
</ul>
<p><strong>本质：</strong></p>
<p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p>
<h4 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2  函数对象使用"></a>4.1.2  函数对象使用</h4><p><strong>特点：</strong></p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd myAdd;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyPrint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">		count++; <span class="comment">//统计使用次数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>仿函数写法非常灵活，可以作为参数进行传递。</li>
</ul>
<h3 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2  谓词"></a>4.2  谓词</h3><h4 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h4><p><strong>概念：</strong></p>
<ul>
<li>返回bool类型的仿函数称为<strong>谓词</strong></li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ul>
<h4 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h4><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreaterFive</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：参数只有一个的谓词，称为一元谓词</p>
<h4 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h4><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：参数只有两个的谓词，称为二元谓词</p>
<h3 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p>
<ul>
<li>STL内建了一些函数对象</li>
</ul>
<p><strong>分类:</strong></p>
<ul>
<li><p>算术仿函数</p>
</li>
<li><p>关系仿函数</p>
</li>
<li><p>逻辑仿函数</p>
</li>
</ul>
<p><strong>用法：</strong></p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li>
</ul>
<h4 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现四则运算</li>
<li>其中negate是一元运算，其他都是二元运算</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                //加法仿函数</li>
<li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              //减法仿函数</li>
<li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    //乘法仿函数</li>
<li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         //除法仿函数</li>
<li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         //取模仿函数</li>
<li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           //取反仿函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p>
<h4 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现关系对比</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    //等于</li>
<li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            //不等于</li>
<li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      //大于</li>
<li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          //大于等于</li>
<li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           //小于</li>
<li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               //小于等于</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自己实现仿函数</span></span><br><span class="line">	<span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line">	<span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p>
<h4 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现逻辑运算</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              //逻辑与</li>
<li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                //逻辑或</li>
<li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              //逻辑非</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">bool</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">	vector&lt;<span class="keyword">bool</span>&gt; v2;</span><br><span class="line">	v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v2.<span class="built_in">begin</span>(), logical_not&lt;<span class="keyword">bool</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：逻辑仿函数实际应用较少，了解即可</p>
<h2 id="5-STL-常用算法"><a href="#5-STL-常用算法" class="headerlink" title="5 STL- 常用算法"></a>5 STL- 常用算法</h2><p><strong>概述</strong>:</p>
<ul>
<li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li>
</ul>
<ul>
<li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li>
<li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li>
<li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li>
</ul>
<h3 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的遍历算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>for_each</code>     //遍历容器</li>
<li><code>transform</code>   //搬运容器到另一个容器中</li>
</ul>
<h4 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现遍历容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>for_each(iterator beg, iterator end, _func);  </code></p>
<p>// 遍历算法 遍历容器元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _func 函数或者函数对象</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">print02</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历算法</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p>
<h4 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h4><p><strong>功能描述：</strong></p>
<ul>
<li>搬运容器到另一个容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li>
</ul>
<p>//beg1 源容器开始迭代器</p>
<p>//end1 源容器结束迭代器</p>
<p>//beg2 目标容器开始迭代器</p>
<p>//_func 函数或者函数对象</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransForm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
<h3 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h3><p>学习目标：</p>
<ul>
<li>掌握常用的查找算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>find</code>                     //查找元素</li>
<li><code>find_if</code>               //按条件查找元素</li>
<li><code>adjacent_find</code>    //查找相邻重复元素</li>
<li><code>binary_search</code>    //二分查找法</li>
<li><code>count</code>                   //统计元素个数</li>
<li><code>count_if</code>             //按条件统计元素个数</li>
</ul>
<h4 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find(iterator beg, iterator end, value);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载==</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp; p) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p>
<h4 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h4><p><strong>功能描述：</strong></p>
<ul>
<li>按条件查找元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater20</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>
<h4 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找相邻重复元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>adjacent_find(iterator beg, iterator end);  </code></p>
<p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找相邻重复元素</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p>
<h4 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素是否存在</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p>
<p>// 查找指定的元素，查到 返回true  否则false</p>
<p>// 注意: 在<strong>无序序列中不可用</strong></p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//二分查找</span></span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p>
<h4 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count(iterator beg, iterator end, value);  </code></p>
<p>// 统计元素出现次数</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 统计的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p>
<h4 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h4><p><strong>功能描述：</strong></p>
<ul>
<li>按条件统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p>
<p>// 按条件统计元素出现次数</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _Pred 谓词</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeLess35</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p>
<h3 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的排序算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>sort</code>             //对容器内元素进行排序</li>
<li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li>
<li><code>merge </code>           // 容器元素合并，并存储到另一容器中</li>
<li><code>reverse</code>       // 反转指定范围的元素</li>
</ul>
<h4 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对容器内元素进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>//  beg    开始迭代器</p>
<p>//  end    结束迭代器</p>
<p>// _Pred  谓词</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//sort默认从小到大排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从大到小排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p>
<h4 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p>
<ul>
<li>洗牌   指定范围内的元素随机调整次序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>random_shuffle(iterator beg, iterator end);  </code></p>
<p>// 指定范围内的元素随机调整次序</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打乱顺序</span></span><br><span class="line">	<span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p>
<h4 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h4><p><strong>功能描述：</strong></p>
<ul>
<li>两个容器元素合并，并存储到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 容器元素合并，并存储到另一容器中</p>
<p>// 注意: 两个容器必须是<strong>有序的</strong></p>
<p>// beg1   容器1开始迭代器<br>// end1   容器1结束迭代器<br>// beg2   容器2开始迭代器<br>// end2   容器2结束迭代器<br>// dest    目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vtarget;</span><br><span class="line">	<span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">	vtarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line">	<span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">	<span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p>
<h4 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内元素进行反转</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>reverse(iterator beg, iterator end);  </code></p>
<p>// 反转指定范围的元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>reverse反转区间内元素，面试题可能涉及到</p>
<h3 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的拷贝和替换算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>copy</code>                      // 容器内指定范围的元素拷贝到另一容器中</li>
<li><code>replace</code>                // 将容器内指定范围的旧元素修改为新元素</li>
<li><code>replace_if </code>          // 容器内指定范围满足条件的元素替换为新元素</li>
<li><code>swap</code>                     // 互换两个容器的元素</li>
</ul>
<h4 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h4><p><strong>功能描述：</strong></p>
<ul>
<li>容器内指定范围的元素拷贝到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg  开始迭代器</p>
<p>// end  结束迭代器</p>
<p>// dest 目标起始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间</p>
<h4 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内指定范围的旧元素修改为新元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p>
<p>// 将区间内旧元素 替换成 新元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// oldvalue 旧元素</p>
<p>// newvalue 新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>replace会替换区间内满足条件的元素</p>
<h4 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h4><p><strong>功能描述:</strong>  </p>
<ul>
<li>将区间内满足条件的元素，替换成指定元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p>
<p>// 按条件替换元素，满足条件的替换成指定元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _pred 谓词</p>
<p>// newvalue 替换的新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceGreater30</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p>
<h4 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h4><p><strong>功能描述：</strong></p>
<ul>
<li>互换两个容器的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>swap(container c1, container c2);  </code></p>
<p>// 互换两个容器的元素</p>
<p>// c1容器1</p>
<p>// c2容器2</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(v1, v2);</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>swap交换容器时，注意交换的容器要同种类型</p>
<h3 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的算术生成算法</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><p><code>accumulate</code>      // 计算容器元素累计总和</p>
</li>
<li><p><code>fill</code>                 // 向容器中添加元素</p>
</li>
</ul>
<h4 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h4><p><strong>功能描述：</strong></p>
<ul>
<li> 计算区间内 容器元素累计总和</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>accumulate(iterator beg, iterator end, value);  </code></p>
<p>// 计算容器元素累计总和</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 起始值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>accumulate使用时头文件注意是 numeric，这个算法很实用</p>
<h4 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h4><p><strong>功能描述：</strong></p>
<ul>
<li>向容器中填充指定的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>fill(iterator beg, iterator end, value);  </code></p>
<p>// 向容器中填充元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 填充的值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//填充</span></span><br><span class="line">	<span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>利用fill可以将容器区间内元素填充为 指定的值</p>
<h3 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的集合算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><p><code>set_intersection</code>          // 求两个容器的交集</p>
</li>
<li><p><code>set_union</code>                       // 求两个容器的并集</p>
</li>
<li><p><code>set_difference </code>              // 求两个容器的差集</p>
</li>
</ul>
<h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个容器的交集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 求两个集合的交集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>
<li>set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的并集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 求两个集合的并集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要<strong>两个容器相加</strong></li>
<li>set_union返回值既是并集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3  set_difference"></a>5.6.3  set_difference</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的差集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 求两个集合的差集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v1.<span class="built_in">size</span>() , v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li>
<li>set_difference返回值既是差集中最后一个元素的位置</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题</title>
    <url>/LeetCode%E9%A2%98/</url>
    <content><![CDATA[<p>我刷过的力扣题，我的答案和官方答案</p>
<span id="more"></span>



<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1 两数之和"></a>1 两数之和</h3><p><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashTable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashTable.<span class="built_in">count</span>(target - nums[i]) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;hashTable[target - nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashTable.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2 两数相加"></a>2 两数相加</h3><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="literal">nullptr</span>, * tail = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = n1 + n2 + carry;</span><br><span class="line">            <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">                head = tail = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3 无重复字符的最长字串"></a>3 无重复字符的最长字串</h3><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sub = s.<span class="built_in">find</span>(s[i], pos);</span><br><span class="line">            <span class="keyword">if</span>(sub != i) &#123;</span><br><span class="line">                len = i - pos;</span><br><span class="line">                maxLen = (maxLen &gt; len ? maxLen : len);</span><br><span class="line">                pos = sub + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len = s.<span class="built_in">size</span>() - pos;</span><br><span class="line">        maxLen = (maxLen &gt; len ? maxLen : len);</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4 寻找两个正序数组的中位数"></a>4 寻找两个正序数组的中位数</h3><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.<span class="built_in">size</span>() &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> num = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();  </span><br><span class="line">        <span class="keyword">bool</span> isOdd = num % <span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">int</span> k = num / <span class="number">2</span>;  <span class="comment">//pos1 + pos2 == k或k+1</span></span><br><span class="line">        <span class="keyword">if</span>(isOdd) k++; <span class="comment">// pos1-1 pos2-1     pos1 pos2</span></span><br><span class="line">        <span class="keyword">int</span> pos1 = k, pos2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLeft = <span class="number">0</span>, minRight = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(pos2 &lt;= nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pos2 == <span class="number">0</span>) &#123;</span><br><span class="line">                maxLeft = nums1[pos1 - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(pos1 == <span class="number">0</span>) &#123;</span><br><span class="line">                maxLeft = nums2[pos2 - <span class="number">1</span>]; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                maxLeft = (nums1[pos1 - <span class="number">1</span>] &gt; nums2[pos2 - <span class="number">1</span>] ? nums1[pos1 - <span class="number">1</span>] : nums2[pos2 - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pos1 == nums1.<span class="built_in">size</span>() &amp;&amp; pos2 != nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                minRight = nums2[pos2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pos1 != nums1.<span class="built_in">size</span>() &amp;&amp; pos2 != nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                minRight = (nums1[pos1] &lt; nums2[pos2] ? nums1[pos1] : nums2[pos2]);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(pos1 != nums1.<span class="built_in">size</span>() &amp;&amp; pos2 == nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                minRight = nums1[pos1];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(maxLeft &lt;= minRight) <span class="keyword">break</span>;</span><br><span class="line">            pos1--;</span><br><span class="line">            pos2++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isOdd) <span class="keyword">return</span> maxLeft;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.<span class="built_in">size</span>() &gt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = m;</span><br><span class="line">        <span class="comment">// median1：前一部分的最大值</span></span><br><span class="line">        <span class="comment">// median2：后一部分的最小值</span></span><br><span class="line">        <span class="keyword">int</span> median1 = <span class="number">0</span>, median2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]</span></span><br><span class="line">            <span class="comment">// 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]</span></span><br><span class="line">            <span class="keyword">int</span> i = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = (m + n + <span class="number">1</span>) / <span class="number">2</span> - i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]</span></span><br><span class="line">            <span class="keyword">int</span> nums_im1 = (i == <span class="number">0</span> ? INT_MIN : nums1[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> nums_i = (i == m ? INT_MAX : nums1[i]);</span><br><span class="line">            <span class="keyword">int</span> nums_jm1 = (j == <span class="number">0</span> ? INT_MIN : nums2[j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> nums_j = (j == n ? INT_MAX : nums2[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums_im1 &lt;= nums_j) &#123;</span><br><span class="line">                median1 = <span class="built_in">max</span>(nums_im1, nums_jm1);</span><br><span class="line">                median2 = <span class="built_in">min</span>(nums_i, nums_j);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (m + n) % <span class="number">2</span> == <span class="number">0</span> ? (median1 + median2) / <span class="number">2.0</span> : median1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5 最长回文子串"></a>5 最长回文子串</h3><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br><span class="line"></span><br><span class="line">输入：s = &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> p = i;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &gt;= i; k--, p++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[p] != s[k]) &#123;</span><br><span class="line">                        flag = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                    len = j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; maxLen) &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                maxLen = len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(pos, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案，真的强，回文扩展中心</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">expandAroundCenter</span><span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [left1, right1] = <span class="built_in">expandAroundCenter</span>(s, i, i);</span><br><span class="line">            <span class="keyword">auto</span> [left2, right2] = <span class="built_in">expandAroundCenter</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (right1 - left1 &gt; end - start) &#123;</span><br><span class="line">                start = left1;</span><br><span class="line">                end = right1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right2 - left2 &gt; end - start) &#123;</span><br><span class="line">                start = left2;</span><br><span class="line">                end = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6-Z字形变换"><a href="#6-Z字形变换" class="headerlink" title="6 Z字形变换"></a>6 Z字形变换</h3><p><a href="https://leetcode-cn.com/problems/zigzag-conversion/">6. Z 字形变换 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;A&quot;, numRows = 1</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line"></span><br><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">输出：&quot;PINALSIGYAHRPI&quot;</span><br><span class="line">解释：</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        string cs = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">2</span> * numRows - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || i + <span class="number">1</span> == numRows) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j = j + add) &#123;</span><br><span class="line">                    cs += s[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">int</span> add2 = <span class="number">2</span> * i;</span><br><span class="line">                <span class="keyword">int</span> add1 = add - add2;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(j &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    cs += s[j];</span><br><span class="line">                    <span class="keyword">if</span>(flag) j += add1;</span><br><span class="line">                    <span class="keyword">else</span> j += add2;</span><br><span class="line">                    flag = !flag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7 整数反转"></a>7 整数反转</h3><p><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>反转后整数超过 32 位的有符号整数的范围 [$−2^{31}$,  $2^{31}$ − 1] ，就返回 0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = -123</span><br><span class="line">输出：-321</span><br><span class="line"></span><br><span class="line">输入：x = 120</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN / <span class="number">10</span> || rev &gt; INT_MAX / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8 字符串转换整数(atoi)"></a>8 字符串转换整数(atoi)</h3><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi) - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line"></span><br><span class="line">输入：s = &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br><span class="line"></span><br><span class="line">输入：s = &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line"></span><br><span class="line">输入：s = &quot;words and 987&quot;</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">输入：s = &quot;-91283472332&quot;</span><br><span class="line">输出：-2147483648</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;words and 987&quot;  输出 987   要求没搞清楚</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> re = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// 0 正数  1 负数</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;+&#x27;</span>) &amp;&amp; i &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">if</span>(s[i] &gt; <span class="string">&#x27;9&#x27;</span> &amp;&amp; s[i] &lt; <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> re;</span><br><span class="line">                flag = s[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; i &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            re = re * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(re &gt; INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(re &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> flag == <span class="number">0</span> ? re : -re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> re = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// 0 正数  1 负数</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;+&#x27;</span>) &amp;&amp; i &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                flag = s[i] == <span class="string">&#x27;+&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> re;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; i &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                re = re * <span class="number">10</span> - s[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(re &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                re = re * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(re &gt; INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案，有穷自动机DFA，厉害</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automaton</span> &#123;</span></span><br><span class="line">    string state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>, &#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;signed&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;in_number&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;end&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_col</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table[state][<span class="built_in">get_col</span>(c)];</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">&quot;in_number&quot;</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            ans = sign == <span class="number">1</span> ? <span class="built_in">min</span>(ans, (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MAX) : <span class="built_in">min</span>(ans, -(<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">&quot;signed&quot;</span>)</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str)</span><br><span class="line">            automaton.<span class="built_in">get</span>(c);</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9 回文数"></a>9 回文数</h3><p><a href="https://leetcode-cn.com/problems/palindrome-number/submissions/">9. 回文数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = -121</span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br><span class="line"></span><br><span class="line">输入：x = 121</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(rev &lt; x) &#123;</span><br><span class="line">            rev = rev * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(rev == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev == x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10 正则表达式匹配"></a>10 正则表达式匹配</h3><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> matches = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">f</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    f[i][j] |= f[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">matches</span>(i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">matches</span>(i, j)) &#123;</span><br><span class="line">                        f[i][j] |= f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11 盛最多水的容器"></a>11 盛最多水的容器</h3><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案，双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> area = <span class="built_in">min</span>(height[l], height[r]) * (r - l);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, area);</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt;= height[r]) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12 整数转罗马数字"></a>12 整数转罗马数字</h3><p><a href="https://leetcode-cn.com/problems/integer-to-roman/">12. 整数转罗马数字 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案一</span></span><br><span class="line"><span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, string&gt; valueSymbols[] = &#123;</span><br><span class="line">    &#123;<span class="number">1000</span>, <span class="string">&quot;M&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">900</span>,  <span class="string">&quot;CM&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">500</span>,  <span class="string">&quot;D&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">400</span>,  <span class="string">&quot;CD&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">100</span>,  <span class="string">&quot;C&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">90</span>,   <span class="string">&quot;XC&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">50</span>,   <span class="string">&quot;L&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">40</span>,   <span class="string">&quot;XL&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>,   <span class="string">&quot;X&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>,    <span class="string">&quot;IX&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>,    <span class="string">&quot;V&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,    <span class="string">&quot;IV&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,    <span class="string">&quot;I&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        string roman;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[value, symbol] : valueSymbols) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= value) &#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman += symbol;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roman;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案二</span></span><br><span class="line"><span class="keyword">const</span> string thousands[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> string hundreds[]  = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> string tens[]      = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> string ones[]      = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thousands[num / <span class="number">1000</span>] + hundreds[num % <span class="number">1000</span> / <span class="number">100</span>] + tens[num % <span class="number">100</span> / <span class="number">10</span>] + ones[num % <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13 罗马数字转整数"></a>13 罗马数字转整数</h3><p><a href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; symbolValues = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = symbolValues[s[i]];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; value &lt; symbolValues[s[i + <span class="number">1</span>]]) &#123;</span><br><span class="line">                ans -= value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14 最长公共前缀"></a>14 最长公共前缀</h3><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案一，横向扫描</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            prefix = <span class="built_in">longestCommonPrefix</span>(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (!prefix.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">const</span> string&amp; str1, <span class="keyword">const</span> string&amp; str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">min</span>(str1.<span class="built_in">size</span>(), str2.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1[index] == str2[index]) &#123;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.<span class="built_in">substr</span>(<span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案二，纵向扫描</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> count = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; count; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].<span class="built_in">size</span>() || strs[j][i] != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案三，分治</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">longestCommonPrefix</span>(strs, <span class="number">0</span>, strs.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">const</span> vector&lt;string&gt;&amp; strs, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            string lcpLeft = <span class="built_in">longestCommonPrefix</span>(strs, start, mid);</span><br><span class="line">            string lcpRight = <span class="built_in">longestCommonPrefix</span>(strs, mid + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">commonPrefix</span>(lcpLeft, lcpRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">commonPrefix</span><span class="params">(<span class="keyword">const</span> string&amp; lcpLeft, <span class="keyword">const</span> string&amp; lcpRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minLength = <span class="built_in">min</span>(lcpLeft.<span class="built_in">size</span>(), lcpRight.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLength; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lcpLeft[i] != lcpRight[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> lcpLeft.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcpLeft.<span class="built_in">substr</span>(<span class="number">0</span>, minLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案四，二分查找</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minLength = <span class="built_in">min_element</span>(strs.<span class="built_in">begin</span>(), strs.<span class="built_in">end</span>(), [](<span class="keyword">const</span> string&amp; s, <span class="keyword">const</span> string&amp; t) &#123;<span class="keyword">return</span> s.<span class="built_in">size</span>() &lt; t.<span class="built_in">size</span>();&#125;)-&gt;<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = minLength;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isCommonPrefix</span>(strs, mid)) &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCommonPrefix</span><span class="params">(<span class="keyword">const</span> vector&lt;string&gt;&amp; strs, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        string str0 = strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">int</span> count = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            string str = strs[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str0[j] != str[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15 三数之和"></a>15 三数之和</h3><p><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 和官方的想法一样是排序+双指针，但最终代码只能通过部分测试用例，捋顺官方的代码思路，结合自己写出来的代码修改如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;::iterator sep = <span class="built_in">find_if</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x &gt;= <span class="number">0</span>; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator left = nums.<span class="built_in">begin</span>(); left &lt;= sep; ++left) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; nums.<span class="built_in">begin</span>() &amp;&amp; *left == *(left - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt;::iterator right = nums.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -(*left);</span><br><span class="line">            <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator mid = left + <span class="number">1</span>; mid &lt; nums.<span class="built_in">end</span>() - <span class="number">1</span>; ++mid) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mid &gt; left + <span class="number">1</span> &amp;&amp; *mid == *(mid - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span>(mid &lt; right &amp;&amp; *mid + *right &gt; target) --right;</span><br><span class="line">                <span class="keyword">if</span>(mid == right) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(*mid + *right == target) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;*left, *mid, *right&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案，排序+双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="comment">// 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; n; ++first) &#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// c 对应的指针初始指向数组的最右端</span></span><br><span class="line">            <span class="keyword">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[first];</span><br><span class="line">            <span class="comment">// 枚举 b</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> second = first + <span class="number">1</span>; second &lt; n; ++second) &#123;</span><br><span class="line">                <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">                <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">                <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;</span><br><span class="line">                    --third;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">                <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (second == third) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[second] + nums[third] == target) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16 最接近的三数之和"></a>16 最接近的三数之和</h3><p><a href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> best = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据差值的绝对值来更新答案</span></span><br><span class="line">        <span class="keyword">auto</span> update = [&amp;](<span class="keyword">int</span> cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(cur - target) &lt; <span class="built_in">abs</span>(best - target)) &#123;</span><br><span class="line">                best = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 保证和上一次枚举的元素不相等</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用双指针枚举 b 和 c</span></span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="comment">// 如果和为 target 直接返回答案</span></span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">update</span>(sum);</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="comment">// 如果和大于 target，移动 c 对应的指针</span></span><br><span class="line">                    <span class="keyword">int</span> k0 = k - <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k0 &amp;&amp; nums[k0] == nums[k]) &#123;</span><br><span class="line">                        --k0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    k = k0;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果和小于 target，移动 b 对应的指针</span></span><br><span class="line">                    <span class="keyword">int</span> j0 = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j0 &lt; k &amp;&amp; nums[j0] == nums[j]) &#123;</span><br><span class="line">                        ++j0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j = j0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17 电话号码的字母组合"></a>17 电话号码的字母组合</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; combina;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> combina;</span><br><span class="line">        map&lt;<span class="keyword">char</span>,string&gt; letter = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letter[digits[<span class="number">0</span>]].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            combina.<span class="built_in">push_back</span>(letter[digits[<span class="number">0</span>]].<span class="built_in">substr</span>(i, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; digits.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = digits[i];</span><br><span class="line">            <span class="function">vector&lt;string&gt; <span class="title">temp</span><span class="params">(combina)</span></span>;</span><br><span class="line">            combina.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; letter[c].<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                    combina.<span class="built_in">push_back</span>(temp[j] + letter[c][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> combina;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案，回溯</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; combinations;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, string&gt; phoneMap&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        string combination;</span><br><span class="line">        <span class="built_in">backtrack</span>(combinations, phoneMap, digits, <span class="number">0</span>, combination);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; combinations, <span class="keyword">const</span> unordered_map&lt;<span class="keyword">char</span>, string&gt;&amp; phoneMap, <span class="keyword">const</span> string&amp; digits, <span class="keyword">int</span> index, string&amp; combination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            combinations.<span class="built_in">push_back</span>(combination);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> digit = digits[index];</span><br><span class="line">            <span class="keyword">const</span> string&amp; letters = phoneMap.<span class="built_in">at</span>(digit);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>&amp; letter: letters) &#123;</span><br><span class="line">                combination.<span class="built_in">push_back</span>(letter);</span><br><span class="line">                <span class="built_in">backtrack</span>(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                combination.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18 四数之和"></a>18 四数之和</h3><p><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; n - <span class="number">3</span>; ++first) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> second = first + <span class="number">1</span>; second &lt; n - <span class="number">2</span>; ++second) &#123;</span><br><span class="line">                <span class="keyword">if</span>(second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> fourth = n - <span class="number">1</span>, third = second + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> need = target - nums[first] - nums[second];</span><br><span class="line">                <span class="keyword">while</span>(third &lt; fourth) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(third &gt; second + <span class="number">1</span> &amp;&amp; nums[third] == nums[third - <span class="number">1</span>]) &#123;</span><br><span class="line">                        ++third;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(nums[third] + nums[fourth] &lt; need) &#123; </span><br><span class="line">                        ++third; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(nums[third] + nums[fourth] &gt; need) &#123;</span><br><span class="line">                        --fourth;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        vector&lt;<span class="keyword">int</span>&gt; temp = &#123;nums[first], nums[second], nums[third], nums[fourth]&#125;;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                        ++third;</span><br><span class="line">                        --fourth;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案，排序+双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; quadruplets;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> quadruplets;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>) nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>) nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">long</span>) nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">long</span>) nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        quadruplets.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quadruplets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="19-删除链表的倒数第N个结点"><a href="#19-删除链表的倒数第N个结点" class="headerlink" title="19 删除链表的倒数第N个结点"></a>19 删除链表的倒数第N个结点</h3><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* tail = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tail) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* remove = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head); </span><br><span class="line">        ListNode* nullHead = remove;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pos = <span class="number">0</span>; pos &lt; length - n; ++pos) &#123;</span><br><span class="line">            remove = remove-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        remove-&gt;next = remove-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> nullHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，计算链表长度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head); <span class="comment">// 哑结点，其next指向链表头head</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">getLength</span>(head);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，保存结点至栈中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        stack&lt;ListNode*&gt; stk;</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* prev = stk.<span class="built_in">top</span>();</span><br><span class="line">        prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，双指针，想法太妙了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* second = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first) &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20 有效的括号"></a>20 有效的括号</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> brackets = [&amp;](<span class="keyword">char</span> c) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>: <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>: <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                <span class="keyword">default</span> : <span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">brackets</span>(s[i]) == stk.<span class="built_in">top</span>()) stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案，栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; pairs = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pairs.<span class="built_in">count</span>(ch)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != pairs[ch]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21 合并两个有序链表"></a>21 合并两个有序链表</h3><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode *merge = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *head = merge;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">                merge-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                merge-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            merge = merge-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1 != <span class="literal">nullptr</span>) merge-&gt;next = list1;</span><br><span class="line">        <span class="keyword">else</span> merge-&gt;next = list2;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode* prev = preHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22 括号生成"></a>22 括号生成</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，暴力法递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ++balance;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --balance;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (balance &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> balance == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generate_all</span><span class="params">(string&amp; current, <span class="keyword">int</span> n, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == current.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">valid</span>(current)) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(current);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="built_in">generate_all</span>(current, n, result);</span><br><span class="line">        current.<span class="built_in">pop_back</span>();</span><br><span class="line">        current += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        <span class="built_in">generate_all</span>(current, n, result);</span><br><span class="line">        current.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string current;</span><br><span class="line">        <span class="built_in">generate_all</span>(current, n * <span class="number">2</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，回溯法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; ans, string&amp; cur, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="built_in">size</span>() == n * <span class="number">2</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (open &lt; n) &#123;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="built_in">backtrack</span>(ans, cur, open + <span class="number">1</span>, close, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="built_in">backtrack</span>(ans, cur, open, close + <span class="number">1</span>, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string current;</span><br><span class="line">        <span class="built_in">backtrack</span>(result, current, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; cache[<span class="number">100</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; <span class="built_in">generate</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache[n] != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> cache[n];</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            cache[<span class="number">0</span>] = shared_ptr&lt;vector&lt;string&gt;&gt;(<span class="keyword">new</span> vector&lt;string&gt;&#123;<span class="string">&quot;&quot;</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> result = shared_ptr&lt;vector&lt;string&gt;&gt;(<span class="keyword">new</span> vector&lt;string&gt;);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> lefts = <span class="built_in">generate</span>(i);</span><br><span class="line">                <span class="keyword">auto</span> rights = <span class="built_in">generate</span>(n - i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> string&amp; left : *lefts)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">const</span> string&amp; right : *rights)</span><br><span class="line">                        result -&gt; <span class="built_in">push_back</span>(<span class="string">&quot;(&quot;</span> + left + <span class="string">&quot;)&quot;</span> + right);</span><br><span class="line">            &#125;</span><br><span class="line">            cache[n] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">generate</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23 合并K个升序链表"></a>23 合并K个升序链表</h3><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> lists_num = lists.<span class="built_in">size</span>();</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, lists[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lists_num; ++i) &#123;</span><br><span class="line">            ListNode* front_of_tail = head; <span class="comment">//指向空头，tail的前一个结点</span></span><br><span class="line">            ListNode* tail = front_of_tail-&gt;next;    <span class="comment">//front_of_tail的后一个结点</span></span><br><span class="line">            ListNode* node = lists[i];              <span class="comment">//要插入的结点</span></span><br><span class="line">            <span class="keyword">while</span>(node &amp;&amp; tail) &#123;        </span><br><span class="line">                <span class="keyword">if</span>(node-&gt;val &lt; tail-&gt;val) &#123;   <span class="comment">//如果要插入结点值比tail的值小，插入front_of_tail和tail之间</span></span><br><span class="line">                    front_of_tail-&gt;next = node; </span><br><span class="line">                    node = node-&gt;next;</span><br><span class="line">                    front_of_tail = front_of_tail-&gt;next;</span><br><span class="line">                    front_of_tail-&gt;next = tail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    front_of_tail = front_of_tail-&gt;next;</span><br><span class="line">                    tail = tail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node) front_of_tail-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，顺序合并</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *a, ListNode *b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!a) || (!b)) <span class="keyword">return</span> a ? a : b;</span><br><span class="line">        ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = aPtr; aPtr = aPtr-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = bPtr; bPtr = bPtr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = (aPtr ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; lists.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">mergeTwoLists</span>(ans, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，分治合并</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *a, ListNode *b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!a) || (!b)) <span class="keyword">return</span> a ? a : b;</span><br><span class="line">        ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = aPtr; aPtr = aPtr-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = bPtr; bPtr = bPtr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = (aPtr ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector &lt;ListNode*&gt; &amp;lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">merge</span>(lists, l, mid), <span class="built_in">merge</span>(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，使用优先队列合并</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode *ptr;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Status &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> val &gt; rhs.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue &lt;Status&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node: lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node) q.<span class="built_in">push</span>(&#123;node-&gt;val, node&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head, *tail = &amp;head;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            tail-&gt;next = f.ptr; </span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (f.ptr-&gt;next) q.<span class="built_in">push</span>(&#123;f.ptr-&gt;next-&gt;val, f.ptr-&gt;next&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24 两两交换链表中的节点"></a>24 两两交换链表中的节点</h3><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(head == nullptr || head-&gt;next == nullptr) return head;</span></span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *preFirst = preHead, *first, *second;</span><br><span class="line">        <span class="keyword">while</span>(preFirst) &#123;</span><br><span class="line">            first = preFirst-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(first == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">            second = first-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(second == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">            preFirst-&gt;next = second;</span><br><span class="line">            first-&gt;next = second-&gt;next;</span><br><span class="line">            second-&gt;next = first;</span><br><span class="line">            preFirst = preFirst-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="built_in">swapPairs</span>(newHead-&gt;next);</span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">nullptr</span> &amp;&amp; temp-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* node1 = temp-&gt;next;</span><br><span class="line">            ListNode* node2 = temp-&gt;next-&gt;next;</span><br><span class="line">            temp-&gt;next = node2;</span><br><span class="line">            node1-&gt;next = node2-&gt;next;</span><br><span class="line">            node2-&gt;next = node1;</span><br><span class="line">            temp = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25 K个一组翻转链表"></a>25 K个一组翻转链表</h3><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        stack&lt;ListNode*&gt; sl;</span><br><span class="line">        ListNode* newHead = <span class="built_in">reverseKG</span>(head, k, sl);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKG</span><span class="params">(ListNode* head, <span class="keyword">int</span> &amp;k, stack&lt;ListNode*&gt; &amp;sl)</span> </span>&#123;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        <span class="keyword">int</span> num = k;</span><br><span class="line">        <span class="keyword">while</span>(--num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">            sl.<span class="built_in">push</span>(temp);</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* follow = temp-&gt;next; </span><br><span class="line">        ListNode* newHead = temp;</span><br><span class="line">        <span class="keyword">while</span>(!sl.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            temp-&gt;next = sl.<span class="built_in">top</span>();</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            sl.<span class="built_in">pop</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;next = <span class="built_in">reverseKG</span>(follow, k, sl);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，模拟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 翻转一个子链表，并且返回新的头与尾</span></span><br><span class="line">    <span class="function">pair&lt;ListNode*, ListNode*&gt; <span class="title">myReverse</span><span class="params">(ListNode* head, ListNode* tail)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = tail-&gt;next;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (prev != tail) &#123;</span><br><span class="line">            ListNode* nex = p-&gt;next;</span><br><span class="line">            p-&gt;next = prev;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;tail, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* hair = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        hair-&gt;next = head;</span><br><span class="line">        ListNode* pre = hair;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode* tail = pre;</span><br><span class="line">            <span class="comment">// 查看剩余部分长度是否大于等于 k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!tail) &#123;</span><br><span class="line">                    <span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* nex = tail-&gt;next;</span><br><span class="line">            <span class="comment">// 这里是 C++17 的写法，也可以写成</span></span><br><span class="line">            <span class="comment">// pair&lt;ListNode*, ListNode*&gt; result = myReverse(head, tail);</span></span><br><span class="line">            <span class="comment">// head = result.first;</span></span><br><span class="line">            <span class="comment">// tail = result.second;</span></span><br><span class="line">            <span class="built_in">tie</span>(head, tail) = <span class="built_in">myReverse</span>(head, tail);</span><br><span class="line">            <span class="comment">// 把子链表重新接回原链表</span></span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">            tail-&gt;next = nex;</span><br><span class="line">            pre = tail;</span><br><span class="line">            head = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26 删除有序数组中的重复项"></a>26 删除有序数组中的重复项</h3><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>(), k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>) <span class="keyword">return</span> k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; length &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) ++i;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; length) nums[++k] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，双指针法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">1</span>, slow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27 移除元素"></a>27 移除元素</h3><p><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != val) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">                nums[left] = nums[right - <span class="number">1</span>];</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28 实现strStr()"></a>28 实现strStr()</h3><p><a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr() - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> *next = <span class="keyword">new</span> <span class="keyword">int</span>[needle.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(needle, next);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="built_in">KMP</span>(haystack, needle, next);</span><br><span class="line">        <span class="keyword">delete</span>[] next;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(string &amp;T, <span class="keyword">int</span> *next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = T.<span class="built_in">size</span>(), j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">        next[j] = k;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">-1</span> || T[j] == T[k]) &#123;</span><br><span class="line">                ++j; ++k;</span><br><span class="line">                <span class="keyword">if</span>(T[j] != T[k]) next[j] = k;</span><br><span class="line">                <span class="keyword">else</span> next[j] = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(string &amp;S, string &amp;T, <span class="keyword">int</span>* next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sLen = S.<span class="built_in">size</span>(), tLen = T.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; sLen &amp;&amp; j &lt; tLen) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || S[i] == T[j]) &#123;</span><br><span class="line">                ++i; ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j &lt; tLen ? <span class="number">-1</span> : i - j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，KMP</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.<span class="built_in">size</span>(), m = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">pi</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29 两数相除"></a>29 两数相除</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，二分查找</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (divisor == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">return</span> dividend == INT_MIN ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一般情况，使用二分查找</span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        <span class="keyword">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快速乘</span></span><br><span class="line">        <span class="keyword">auto</span> quickAdd = [](<span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> x) &#123;</span><br><span class="line">            <span class="comment">// x 和 y 是负数，z 是正数</span></span><br><span class="line">            <span class="comment">// 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>, add = y;</span><br><span class="line">            <span class="keyword">while</span> (z) &#123;</span><br><span class="line">                <span class="keyword">if</span> (z &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 result + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (result &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (z != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 add + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (add &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不能使用除法</span></span><br><span class="line">                z &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = INT_MAX, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 注意溢出，并且不能使用除法</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">bool</span> check = <span class="built_in">quickAdd</span>(divisor, mid, dividend);</span><br><span class="line">            <span class="keyword">if</span> (check) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="comment">// 注意溢出</span></span><br><span class="line">                <span class="keyword">if</span> (mid == INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，类二分查找</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (divisor == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">return</span> dividend == INT_MIN ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一般情况，使用类二分查找</span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        <span class="keyword">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; candidates = &#123;divisor&#125;;</span><br><span class="line">        <span class="comment">// 注意溢出</span></span><br><span class="line">        <span class="keyword">while</span> (candidates.<span class="built_in">back</span>() &gt;= dividend - candidates.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            candidates.<span class="built_in">push_back</span>(candidates.<span class="built_in">back</span>() + candidates.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = candidates.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[i] &gt;= dividend) &#123;</span><br><span class="line">                ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                dividend -= candidates[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31 下一个排列"></a>31 下一个排列</h3><p><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172 阶乘后的零"></a>172 阶乘后的零</h3><p><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">172. 阶乘后的零 - 力扣（LeetCode） (leetcode-cn.com)</a> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i += <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = i; x % <span class="number">5</span> == <span class="number">0</span>; x /= <span class="number">5</span>) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">            ans += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258 各位相加"></a>258 各位相加</h3><p><a href="https://leetcode-cn.com/problems/add-digits/">258. 各位相加 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(num) &#123;</span><br><span class="line">                add += num % <span class="number">10</span>;</span><br><span class="line">                num /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(add &lt; <span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">            num = add;</span><br><span class="line">            add = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，模拟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum += num % <span class="number">10</span>;</span><br><span class="line">                num /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案二，妙啊，牛逼</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="393-UTF-8编码验证"><a href="#393-UTF-8编码验证" class="headerlink" title="393 UTF-8编码验证"></a>393 UTF-8编码验证</h3><p><a href="https://leetcode-cn.com/problems/utf-8-validation/">393. UTF-8 编码验证 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validUtf8</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;) &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">128</span>, pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(data[i] &amp; flag) &#123; </span><br><span class="line">                ++pos; </span><br><span class="line">                flag = flag &gt;&gt; <span class="number">1</span> <span class="comment">//4ms，改成flag /= 2;8ms</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos == <span class="number">0</span>) &#123; </span><br><span class="line">                ++i; </span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos == <span class="number">1</span> || pos &gt; <span class="number">4</span> || length - i &lt; pos) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ++i;</span><br><span class="line">            <span class="keyword">bool</span> isFalse = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; pos; ++j, ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!(data[i] &amp; <span class="number">128</span>) || (data[i] &amp; <span class="number">64</span>)) &#123;</span><br><span class="line">                    isFalse = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isFalse) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MASK1 = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MASK2 = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num &amp; MASK2) == MASK1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((num &amp; MASK1) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = MASK1;</span><br><span class="line">        <span class="keyword">while</span> ((num &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &gt;= <span class="number">2</span> ? n : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validUtf8</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; m) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = data[index];</span><br><span class="line">            <span class="keyword">int</span> n = <span class="built_in">getBytes</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">0</span> || index + n &gt; m) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isValid</span>(data[index + i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="420-强密码检验器"><a href="#420-强密码检验器" class="headerlink" title="420 强密码检验器"></a>420 强密码检验器</h3><p><a href="https://leetcode-cn.com/problems/strong-password-checker/">420. 强密码检验器 - 力扣（LeetCode） (leetcode-cn.com)</a> 做不出来，长度大于20不知道怎么处理了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strongPasswordChecker</span><span class="params">(string password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = password.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">bool</span> has_lower = <span class="literal">false</span>, has_upper = <span class="literal">false</span>, has_digit = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: password) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">islower</span>(ch)) &#123;</span><br><span class="line">                has_lower = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isupper</span>(ch)) &#123;</span><br><span class="line">                has_upper = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">                has_digit = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> categories = has_lower + has_upper + has_digit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">6</span> - n, <span class="number">3</span> - categories);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> replace = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">char</span> cur = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch: password) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == cur) &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    replace += cnt / <span class="number">3</span>;</span><br><span class="line">                    cnt = <span class="number">1</span>;</span><br><span class="line">                    cur = ch;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            replace += cnt / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(replace, <span class="number">3</span> - categories);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 替换次数和删除次数</span></span><br><span class="line">            <span class="keyword">int</span> replace = <span class="number">0</span>, remove = n - <span class="number">20</span>;</span><br><span class="line">            <span class="comment">// k mod 3 = 1 的组数，即删除 2 个字符可以减少 1 次替换操作</span></span><br><span class="line">            <span class="keyword">int</span> rm2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">char</span> cur = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch: password) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == cur) &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (remove &gt; <span class="number">0</span> &amp;&amp; cnt &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cnt % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果是 k % 3 = 0 的组，那么优先删除 1 个字符，减少 1 次替换操作</span></span><br><span class="line">                            --remove;</span><br><span class="line">                            --replace;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (cnt % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果是 k % 3 = 1 的组，那么存下来备用</span></span><br><span class="line">                            ++rm2;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// k % 3 = 2 的组无需显式考虑</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    replace += cnt / <span class="number">3</span>;</span><br><span class="line">                    cnt = <span class="number">1</span>;</span><br><span class="line">                    cur = ch;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (remove &gt; <span class="number">0</span> &amp;&amp; cnt &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    --remove;</span><br><span class="line">                    --replace;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cnt % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    ++rm2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            replace += cnt / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 k % 3 = 1 的组的数量，由剩余的替换次数、组数和剩余的删除次数共同决定</span></span><br><span class="line">            <span class="keyword">int</span> use2 = <span class="built_in">min</span>(&#123;replace, rm2, remove / <span class="number">2</span>&#125;);</span><br><span class="line">            replace -= use2;</span><br><span class="line">            remove -= use2 * <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 由于每有一次替换次数就一定有 3 个连续相同的字符（k / 3 决定），因此这里可以直接计算出使用 k % 3 = 2 的组的数量</span></span><br><span class="line">            <span class="keyword">int</span> use3 = <span class="built_in">min</span>(&#123;replace, remove / <span class="number">3</span>&#125;);</span><br><span class="line">            replace -= use3;</span><br><span class="line">            remove -= use3 * <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">return</span> (n - <span class="number">20</span>) + <span class="built_in">max</span>(replace, <span class="number">3</span> - categories);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="432-全O-1-的数据结构"><a href="#432-全O-1-的数据结构" class="headerlink" title="432 全O(1)的数据结构"></a>432 全O(1)的数据结构</h3><p><a href="https://leetcode-cn.com/problems/all-oone-data-structure/">432. 全 O(1) 的数据结构 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllOne</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; hashTable;</span><br><span class="line">    <span class="comment">//vector&lt;pair&lt;string, int&gt;&gt; strKey;</span></span><br><span class="line">    string maxKey = <span class="string">&quot;&quot;</span>;  <span class="comment">//保存数量最多的字符串</span></span><br><span class="line">    string minKey = <span class="string">&quot;&quot;</span>;  <span class="comment">//保存数量最少的字符串</span></span><br><span class="line">    <span class="built_in">AllOne</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(string key)</span> </span>&#123;</span><br><span class="line">        ++hashTable[key];  <span class="comment">// key 对应的数量加 1 </span></span><br><span class="line">        <span class="keyword">if</span>(maxKey == <span class="string">&quot;&quot;</span> || hashTable[key] &gt; hashTable[maxKey]) &#123; </span><br><span class="line">            maxKey = key;</span><br><span class="line">        &#125;  <span class="comment">//如果最多数量字符串为空，或增加的字符串key数量多于maxKey，更新maxKey</span></span><br><span class="line">        <span class="keyword">if</span>(minKey == key) &#123; </span><br><span class="line">            <span class="built_in">minString</span>();</span><br><span class="line">        &#125; <span class="comment">//如果增加的是最少的字符串，调用minString()函数重新遍历查找最小字符串</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(minKey == <span class="string">&quot;&quot;</span> || hashTable[key] &lt; hashTable[minKey]) &#123;</span><br><span class="line">            minKey = key;</span><br><span class="line">        &#125; <span class="comment">//如果最多数量字符串为空，或增加的字符串key数量少于mixKey，更新minKey</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(string key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable[key] == <span class="number">1</span>) &#123; <span class="comment">//如果要删除的key的数量为1，擦除key</span></span><br><span class="line">            hashTable.<span class="built_in">erase</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(key == minKey) &#123;   <span class="comment">//如果被擦除的是最小字符串，重新遍历查找最少数量字符串</span></span><br><span class="line">                <span class="built_in">minString</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;       <span class="comment">//否则key对应的数量减1</span></span><br><span class="line">            --hashTable[key];  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxKey == key) &#123;  <span class="comment">//如果减少的最多字符串，调用maxString()更新maxkey</span></span><br><span class="line">            <span class="built_in">maxString</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minString</span><span class="params">()</span> </span>&#123;    <span class="comment">//遍历hashTable查找最少数量字符串</span></span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = hashTable.<span class="built_in">begin</span>(); it != hashTable.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span>((*it).second &lt; min) &#123;</span><br><span class="line">                min = (*it).second;</span><br><span class="line">                minKey = (*it).first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maxString</span><span class="params">()</span> </span>&#123; <span class="comment">//遍历hashTable查找最多数量字符串</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = hashTable.<span class="built_in">begin</span>(); it != hashTable.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span>((*it).second &gt; max) &#123;</span><br><span class="line">                max = (*it).second;</span><br><span class="line">                maxKey = (*it).first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">getMaxKey</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> maxKey;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">getMinKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your AllOne object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * AllOne* obj = new AllOne();</span></span><br><span class="line"><span class="comment"> * obj-&gt;inc(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;dec(key);</span></span><br><span class="line"><span class="comment"> * string param_3 = obj-&gt;getMaxKey();</span></span><br><span class="line"><span class="comment"> * string param_4 = obj-&gt;getMinKey();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我的一个想法（和上面的解答想法不一样）和官方答案的想法很像。</span><br><span class="line">官方是双向链表+哈希表，</span><br><span class="line">我的想法是哈希表+vector：</span><br><span class="line">哈希表中存放&lt;string, int&gt;，string是关键字，int为string在vector中的下标而不是string的个数</span><br><span class="line">而vector中的元素为pair&lt;string,int&gt;，int是string的个数，</span><br><span class="line">vector按int从高到低排序，每调用一次inc函数对应的key都会和前面一个元素比较或交换，每调用一次dec函数对应的key都会和后面一个元素比较或交换</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案：双向链表+哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllOne</span> &#123;</span></span><br><span class="line">    list&lt;pair&lt;unordered_set&lt;string&gt;, <span class="keyword">int</span>&gt;&gt; lst;</span><br><span class="line">    unordered_map&lt;string, list&lt;pair&lt;unordered_set&lt;string&gt;, <span class="keyword">int</span>&gt;&gt;::iterator&gt; nodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AllOne</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(string key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = nodes[key], nxt = <span class="built_in">next</span>(cur);</span><br><span class="line">            <span class="keyword">if</span> (nxt == lst.<span class="built_in">end</span>() || nxt-&gt;second &gt; cur-&gt;second + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="function">unordered_set&lt;string&gt; <span class="title">s</span><span class="params">(&#123;key&#125;)</span></span>;</span><br><span class="line">                nodes[key] = lst.<span class="built_in">emplace</span>(nxt, s, cur-&gt;second + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nxt-&gt;first.<span class="built_in">emplace</span>(key);</span><br><span class="line">                nodes[key] = nxt;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;first.<span class="built_in">erase</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;first.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                lst.<span class="built_in">erase</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// key 不在链表中</span></span><br><span class="line">            <span class="keyword">if</span> (lst.<span class="built_in">empty</span>() || lst.<span class="built_in">begin</span>()-&gt;second &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                unordered_set&lt;string&gt; <span class="built_in">s</span>(&#123;key&#125;);</span><br><span class="line">                lst.<span class="built_in">emplace_front</span>(s, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lst.<span class="built_in">begin</span>()-&gt;first.<span class="built_in">emplace</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">            nodes[key] = lst.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(string key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = nodes[key];</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;second == <span class="number">1</span>) &#123; <span class="comment">// key 仅出现一次，将其移出 nodes</span></span><br><span class="line">            nodes.<span class="built_in">erase</span>(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> pre = <span class="built_in">prev</span>(cur);</span><br><span class="line">            <span class="keyword">if</span> (cur == lst.<span class="built_in">begin</span>() || pre-&gt;second &lt; cur-&gt;second - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="function">unordered_set&lt;string&gt; <span class="title">s</span><span class="params">(&#123;key&#125;)</span></span>;</span><br><span class="line">                nodes[key] = lst.<span class="built_in">emplace</span>(cur, s, cur-&gt;second - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre-&gt;first.<span class="built_in">emplace</span>(key);</span><br><span class="line">                nodes[key] = pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;first.<span class="built_in">erase</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;first.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            lst.<span class="built_in">erase</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getMaxKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lst.<span class="built_in">empty</span>() ? <span class="string">&quot;&quot;</span> : *lst.<span class="built_in">rbegin</span>()-&gt;first.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getMinKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lst.<span class="built_in">empty</span>() ? <span class="string">&quot;&quot;</span> : *lst.<span class="built_in">begin</span>()-&gt;first.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="440-字典序的第K小数字"><a href="#440-字典序的第K小数字" class="headerlink" title="440 字典序的第K小数字"></a>440 字典序的第K小数字</h3><p><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字典树，超时了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;children = vector&lt;Trie*&gt;(<span class="number">10</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        saveVal = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        string str = <span class="built_in">to_string</span>(val);</span><br><span class="line">        <span class="keyword">int</span> length = str.<span class="built_in">size</span>();</span><br><span class="line">        Trie *temp = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">            <span class="keyword">int</span> ic = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;children[ic] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                temp-&gt;children[ic] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;children[ic];</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;end = <span class="literal">true</span>;</span><br><span class="line">        temp-&gt;saveVal = val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search_k</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="keyword">this</span>, index, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Trie* root, <span class="keyword">int</span> &amp;index, <span class="keyword">const</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;end) ++index;</span><br><span class="line">        <span class="keyword">if</span>(index == k) <span class="keyword">return</span> root-&gt;saveVal;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="built_in">dfs</span>(root-&gt;children[i], index, k);</span><br><span class="line">            <span class="keyword">if</span>(ret) <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Trie *&gt; children;</span><br><span class="line">    <span class="keyword">bool</span> end = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> saveVal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Trie *root = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            root-&gt;<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;<span class="built_in">search_k</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSteps</span><span class="params">(<span class="keyword">int</span> curr, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> first = curr;</span><br><span class="line">        <span class="keyword">long</span> last = curr;</span><br><span class="line">        <span class="keyword">while</span> (first &lt;= n) &#123;</span><br><span class="line">            steps += <span class="built_in">min</span>(last, n) - first + <span class="number">1</span>;</span><br><span class="line">            first = first * <span class="number">10</span>;</span><br><span class="line">            last = last * <span class="number">10</span> + <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">1</span>;</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> steps = <span class="built_in">getSteps</span>(curr, n);</span><br><span class="line">            <span class="keyword">if</span> (steps &lt;= k) &#123;</span><br><span class="line">                k -= steps;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr*<span class="number">10</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="504-七进制数"><a href="#504-七进制数" class="headerlink" title="504 七进制数"></a>504 七进制数</h3><p><a href="https://leetcode-cn.com/problems/base-7/">504. 七进制数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> remainder = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            pos = <span class="number">1</span>;</span><br><span class="line">            num = -num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">            remainder = num % <span class="number">7</span>;</span><br><span class="line">            num /= <span class="number">7</span>;</span><br><span class="line">            result.<span class="built_in">insert</span>(pos, <span class="number">1</span>, <span class="built_in"><span class="keyword">char</span></span>(remainder + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> negative = num &lt; <span class="number">0</span>;</span><br><span class="line">        num = <span class="built_in">abs</span>(num);</span><br><span class="line">        string digits;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            digits.<span class="built_in">push_back</span>(num % <span class="number">7</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            num /= <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (negative) &#123;</span><br><span class="line">            digits.<span class="built_in">push_back</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(digits.<span class="built_in">begin</span>(), digits.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="521-最长特殊子序列-I"><a href="#521-最长特殊子序列-I" class="headerlink" title="521 最长特殊子序列 I"></a>521 最长特殊子序列 I</h3><p><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/">521. 最长特殊序列 Ⅰ - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span> <span class="comment">//不敢相信这么简单</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案，脑筋急转弯</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a != b ? <span class="built_in">max</span>(a.<span class="built_in">length</span>(), b.<span class="built_in">length</span>()) : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="540-有序数组中的单一元素"><a href="#540-有序数组中的单一元素" class="headerlink" title="540 有序数组中的单一元素"></a>540 有序数组中的单一元素</h3><p><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案一，全数组的二分查找</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid ^ <span class="number">1</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案二，偶数下标的二分查找</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            mid -= mid &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="589-N叉树的前序遍历"><a href="#589-N叉树的前序遍历" class="headerlink" title="589 N叉树的前序遍历"></a>589 N叉树的前序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">preOrder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        result.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">preOrder</span>(root-&gt;children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;Node *, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        stack&lt;Node *&gt; st;</span><br><span class="line">        Node * node = root;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() || node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">                st.<span class="built_in">emplace</span>(node);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;children.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt[node] = <span class="number">0</span>;</span><br><span class="line">                    node = node-&gt;children[<span class="number">0</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;         </span><br><span class="line">            &#125;</span><br><span class="line">            node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">int</span> index = (cnt.<span class="built_in">count</span>(node) ? cnt[node] : <span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; node-&gt;children.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                cnt[node] = index;</span><br><span class="line">                node = node-&gt;children[index];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                cnt.<span class="built_in">erase</span>(node);</span><br><span class="line">                node = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，迭代优化，妙啊</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;Node *&gt; st;</span><br><span class="line">        st.<span class="built_in">emplace</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node * node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = node-&gt;children.<span class="built_in">rbegin</span>(); it != node-&gt;children.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">                st.<span class="built_in">emplace</span>(*it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="590-N叉树的后序遍历"><a href="#590-N叉树的后序遍历" class="headerlink" title="590 N叉树的后序遍历"></a>590 N叉树的后序遍历</h3><p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N 叉树的后序遍历 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">postOrder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">postOrder</span>(root-&gt;children[i]);</span><br><span class="line">        &#125;        </span><br><span class="line">        result.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;Node *, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        stack&lt;Node *&gt; st;</span><br><span class="line">        Node * node = root;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() || node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                st.<span class="built_in">emplace</span>(node);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;children.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt[node] = <span class="number">0</span>;</span><br><span class="line">                    node = node-&gt;children[<span class="number">0</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;         </span><br><span class="line">            &#125;</span><br><span class="line">            node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">int</span> index = cnt.<span class="built_in">count</span>(node) ? (cnt[node] + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; node-&gt;children.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                cnt[node] = index;</span><br><span class="line">                node = node-&gt;children[index];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                cnt.<span class="built_in">erase</span>(node);</span><br><span class="line">                node = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，迭代优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;Node *&gt; st;</span><br><span class="line">        unordered_set&lt;Node *&gt; visited;</span><br><span class="line">        st.<span class="built_in">emplace</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node * node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="comment">/* 如果当前节点为叶子节点或者当前节点的子节点已经遍历过 */</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children.<span class="built_in">size</span>() == <span class="number">0</span> || visited.<span class="built_in">count</span>(node)) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = node-&gt;children.<span class="built_in">rbegin</span>(); it != node-&gt;children.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">                st.<span class="built_in">emplace</span>(*it);</span><br><span class="line">            &#125;</span><br><span class="line">            visited.<span class="built_in">emplace</span>(node);</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，利用前序遍历反转，妙啊，前序遍历时子结点从右向左遍历，最后序列翻转</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;Node *&gt; st;</span><br><span class="line">        st.<span class="built_in">emplace</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node * node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : node-&gt;children) &#123;</span><br><span class="line">                st.<span class="built_in">emplace</span>(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>()); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="599-两个列表的最小索引总和"><a href="#599-两个列表的最小索引总和" class="headerlink" title="599 两个列表的最小索引总和"></a>599 两个列表的最小索引总和</h3><p><a href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/">599. 两个列表的最小索引总和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRestaurant</span><span class="params">(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">int</span> length1 = list1.<span class="built_in">size</span>() - <span class="number">1</span>, length2 = list2.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> length = length1 + length2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l1 = <span class="built_in">min</span>(i, length1), l2 = i - l1;</span><br><span class="line">            <span class="keyword">while</span>(l1 &gt;= <span class="number">0</span> &amp;&amp; l2 &lt;= length2) &#123;</span><br><span class="line">                <span class="keyword">if</span>(list1[l1] == list2[l2]) &#123;</span><br><span class="line">                    result.<span class="built_in">emplace_back</span>(list1[l1]);</span><br><span class="line">                &#125;</span><br><span class="line">                --l1; ++l2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!result.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRestaurant</span><span class="params">(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            index[list1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> indexSum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index.<span class="built_in">count</span>(list2[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = index[list2[i]];</span><br><span class="line">                <span class="keyword">if</span> (i + j &lt; indexSum) &#123;</span><br><span class="line">                    ret.<span class="built_in">clear</span>();</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(list2[i]);</span><br><span class="line">                    indexSum = i + j;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + j == indexSum) &#123;</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="606-根据二叉树创建字符串"><a href="#606-根据二叉树创建字符串" class="headerlink" title="606 根据二叉树创建字符串"></a>606 根据二叉树创建字符串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string result;</span><br><span class="line">    <span class="function">string <span class="title">tree2str</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">preOrder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            result += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">            result += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                result += <span class="string">&quot;()&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">            result += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">tree2str</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;(&quot;</span> + <span class="built_in">tree2str</span>(root-&gt;left) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;(&quot;</span> + <span class="built_in">tree2str</span>(root-&gt;left) + <span class="string">&quot;)(&quot;</span> + <span class="built_in">tree2str</span>(root-&gt;right) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">tree2str</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        stack&lt;TreeNode *&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        unordered_set&lt;TreeNode *&gt; vis;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (vis.<span class="built_in">count</span>(node)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != root) &#123;</span><br><span class="line">                    ans += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vis.<span class="built_in">insert</span>(node);</span><br><span class="line">                <span class="keyword">if</span> (node != root) &#123;</span><br><span class="line">                    ans += <span class="string">&quot;(&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += <span class="built_in">to_string</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    ans += <span class="string">&quot;()&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="653-两数之和IV-输入-BST"><a href="#653-两数之和IV-输入-BST" class="headerlink" title="653 两数之和IV - 输入 BST"></a>653 两数之和IV - 输入 BST</h3><p><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; nodeVal;</span><br><span class="line">        <span class="built_in">inOrder</span>(root, nodeVal);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nodeVal.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nodeVal[l] + nodeVal[r];</span><br><span class="line">            <span class="keyword">if</span>(sum == k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; k) --r;</span><br><span class="line">            <span class="keyword">else</span> ++l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; nodeVal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;left, nodeVal);</span><br><span class="line">        nodeVal.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;right, nodeVal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，深度优先搜索+哈希表，哈希表用的妙啊</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; hashTable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hashTable.<span class="built_in">count</span>(k - root-&gt;val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTable.<span class="built_in">insert</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findTarget</span>(root-&gt;left, k) || <span class="built_in">findTarget</span>(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，广度优先搜索+哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; hashTable;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (hashTable.<span class="built_in">count</span>(k - node-&gt;val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hashTable.<span class="built_in">insert</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，深度优先搜索+中序遍历+双指针，我的思路也是这个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(node-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = vec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[left] + vec[right] == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (vec[left] + vec[right] &lt; k) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，迭代+中序遍历+双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">getLeft</span><span class="params">(stack&lt;TreeNode *&gt; &amp;stk)</span> </span>&#123;</span><br><span class="line">        TreeNode *root = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        TreeNode *node = root-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">getRight</span><span class="params">(stack&lt;TreeNode *&gt; &amp;stk)</span> </span>&#123;</span><br><span class="line">        TreeNode *root = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        TreeNode *node = root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(node);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        TreeNode *left = root, *right = root;</span><br><span class="line">        stack&lt;TreeNode *&gt; leftStack, rightStack;</span><br><span class="line">        leftStack.<span class="built_in">push</span>(left);</span><br><span class="line">        <span class="keyword">while</span> (left-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            leftStack.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        rightStack.<span class="built_in">push</span>(right);</span><br><span class="line">        <span class="keyword">while</span> (right-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            rightStack.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val + right-&gt;val == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val + right-&gt;val &lt; k) &#123;</span><br><span class="line">                left = <span class="built_in">getLeft</span>(leftStack);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = <span class="built_in">getRight</span>(rightStack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="661-图片平滑器"><a href="#661-图片平滑器" class="headerlink" title="661 图片平滑器"></a>661 图片平滑器</h3><p><a href="https://leetcode-cn.com/problems/image-smoother/">661. 图片平滑器 - 力扣（LeetCode） (leetcode-cn.com)</a> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">imageSmoother</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; img) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = img.<span class="built_in">size</span>() - <span class="number">1</span>, y = img[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ret</span>(x + <span class="number">1</span>, <span class="built_in">vector</span>(y + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">auto</span> avrge = [=](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = img[i][j];</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum += img[i - <span class="number">1</span>][j];</span><br><span class="line">                ++num;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    sum += img[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    ++num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; x) &#123;</span><br><span class="line">                sum += img[i + <span class="number">1</span>][j]; </span><br><span class="line">                ++num;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; y) &#123;</span><br><span class="line">                    sum += img[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">                    ++num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum += img[i][j - <span class="number">1</span>];</span><br><span class="line">                ++num;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; x) &#123;</span><br><span class="line">                    sum += img[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    ++num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; y) &#123;</span><br><span class="line">                sum += img[i][j + <span class="number">1</span>];</span><br><span class="line">                ++num;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    sum += img[i - <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">                    ++num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum / num;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= x; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= y; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                ret[i][j] = <span class="built_in">avrge</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">imageSmoother</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; img) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = img.<span class="built_in">size</span>(), n = img[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ret</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = i - <span class="number">1</span>; x &lt;= i + <span class="number">1</span>; x++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> y = j - <span class="number">1</span>; y &lt;= j + <span class="number">1</span>; y++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                            num++;</span><br><span class="line">                            sum += img[x][y];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ret[i][j] = sum / num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="682-棒球比赛"><a href="#682-棒球比赛" class="headerlink" title="682 棒球比赛"></a>682 棒球比赛</h3><p><a href="https://leetcode-cn.com/problems/baseball-game/">682. 棒球比赛 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(vector&lt;string&gt;&amp; ops)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; scores;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(string &amp;s : ops)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s == <span class="string">&quot;C&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result -= *(scores.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">                scores.<span class="built_in">erase</span>(scores.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = *(scores.<span class="built_in">end</span>()<span class="number">-1</span>) * <span class="number">2</span>;</span><br><span class="line">                scores.<span class="built_in">emplace_back</span>(tmp);</span><br><span class="line">                result += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;+&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = *(scores.<span class="built_in">end</span>()<span class="number">-1</span>) + *(scores.<span class="built_in">end</span>()<span class="number">-2</span>);</span><br><span class="line">                scores.<span class="built_in">emplace_back</span>(tmp);</span><br><span class="line">                result += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="built_in">stoi</span>(s);</span><br><span class="line">                result += tmp;</span><br><span class="line">                scores.<span class="built_in">emplace_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="693-交替位二进制数"><a href="#693-交替位二进制数" class="headerlink" title="693 交替位二进制数"></a>693 交替位二进制数</h3><p><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">693. 交替位二进制数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = n &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(pre == (n &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pre = n &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> a = n ^ (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (a &amp; (a + <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="720-词典中最长的单词"><a href="#720-词典中最长的单词" class="headerlink" title="720 词典中最长的单词"></a>720 词典中最长的单词</h3><p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">720. 词典中最长的单词 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，哈希集合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestWord</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](<span class="keyword">const</span> string &amp; a, <span class="keyword">const</span> string &amp; b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a &gt; b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        string longest = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        unordered_set&lt;string&gt; cnt;</span><br><span class="line">        cnt.<span class="built_in">emplace</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(word.<span class="built_in">substr</span>(<span class="number">0</span>, word.<span class="built_in">size</span>() - <span class="number">1</span>))) &#123;</span><br><span class="line">                cnt.<span class="built_in">emplace</span>(word);</span><br><span class="line">                longest = word;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，Trie树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;children = vector&lt;Trie *&gt;(<span class="number">26</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> string &amp; word)</span> </span>&#123;</span><br><span class="line">        Trie * node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; ch : word) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[index] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;children[index] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> string &amp; word)</span> </span>&#123;</span><br><span class="line">        Trie * node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; ch : word) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[index] == <span class="literal">nullptr</span> || !node-&gt;children[index]-&gt;isEnd) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Trie *&gt; children;</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestWord</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        Trie trie;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; word : words) &#123;</span><br><span class="line">            trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        string longest = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (trie.<span class="built_in">search</span>(word)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word.<span class="built_in">size</span>() &gt; longest.<span class="built_in">size</span>() || (word.<span class="built_in">size</span>() == longest.<span class="built_in">size</span>() &amp;&amp; word &lt; longest)) &#123;</span><br><span class="line">                    longest = word;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="728-自除数"><a href="#728-自除数" class="headerlink" title="728 自除数"></a>728 自除数</h3><p><a href="https://leetcode-cn.com/problems/self-dividing-numbers/">728. 自除数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSelfDividing</span><span class="params">(<span class="keyword">int</span> digit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = digit;</span><br><span class="line">        <span class="keyword">while</span>(num)  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = num % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">0</span> || digit % tmp != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">selfDividingNumbers</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isSelfDividing</span>(i))</span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="744-寻找比目标字母大的最小字母"><a href="#744-寻找比目标字母大的最小字母" class="headerlink" title="744 寻找比目标字母大的最小字母"></a>744 寻找比目标字母大的最小字母</h3><p><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">744. 寻找比目标字母大的最小字母 - 力扣（LeetCode） (leetcode-cn.com)</a> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(letters.<span class="built_in">back</span>() &lt;= target) <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = letters.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">1</span> &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(letters[left] &gt; target) <span class="keyword">return</span> letters[left];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> letters[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，二分查找，我以为这个二分查找算法官方会自己写，没想到直接用upper_bound</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt; &amp;letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target &lt; letters.<span class="built_in">back</span>() ? *<span class="built_in">upper_bound</span>(letters.<span class="built_in">begin</span>(), letters.<span class="built_in">end</span>() - <span class="number">1</span>, target) : letters[<span class="number">0</span>];  <span class="comment">//upper_bound查找大于target的最小数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="798-得分最高的最小轮调"><a href="#798-得分最高的最小轮调" class="headerlink" title="798 得分最高的最小轮调"></a>798 得分最高的最小轮调</h3><p><a href="https://leetcode-cn.com/problems/smallest-rotation-with-highest-score/">798. 得分最高的最小轮调 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，差分数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bestRotation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">diffs</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = (i + <span class="number">1</span>) % n;</span><br><span class="line">            <span class="keyword">int</span> high = (i - nums[i] + n + <span class="number">1</span>) % n;</span><br><span class="line">            diffs[low]++;</span><br><span class="line">            diffs[high]--;</span><br><span class="line">            <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">                diffs[<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> bestIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxScore = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            score += diffs[i];</span><br><span class="line">            <span class="keyword">if</span> (score &gt; maxScore) &#123;</span><br><span class="line">                bestIndex = i;</span><br><span class="line">                maxScore = score;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bestIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="954-二倍数对数组"><a href="#954-二倍数对数组" class="headerlink" title="954 二倍数对数组"></a>954 二倍数对数组</h3><p><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/">954. 二倍数对数组 - 力扣（LeetCode） (leetcode-cn.com)</a> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，哈希表+排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canReorderDoubled</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : arr) &#123;</span><br><span class="line">            ++cnt[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt[<span class="number">0</span>] % <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; vals;</span><br><span class="line">        vals.<span class="built_in">reserve</span>(cnt.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, _] : cnt) &#123;</span><br><span class="line">            vals.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vals.<span class="built_in">begin</span>(), vals.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> <span class="built_in">abs</span>(a) &lt; <span class="built_in">abs</span>(b); &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : vals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[<span class="number">2</span> * x] &lt; cnt[x]) &#123; <span class="comment">// 无法找到足够的 2x 与 x 配对</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[<span class="number">2</span> * x] -= cnt[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1001-网格照明"><a href="#1001-网格照明" class="headerlink" title="1001 网格照明"></a>1001 网格照明</h3><p><a href="https://leetcode-cn.com/problems/grid-illumination/">1001. 网格照明 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">gridIllumination</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;lamps, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;queries)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; row, col, diagonal, antiDiagonal;</span><br><span class="line">        <span class="keyword">auto</span> hash_p = [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p) -&gt; <span class="keyword">size_t</span> &#123;</span><br><span class="line">            <span class="keyword">static</span> hash&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; hash_ll;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">hash_ll</span>(p.first + (<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(p.second) &lt;&lt; <span class="number">32</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        unordered_set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(hash_p)&gt; <span class="built_in">points</span>(<span class="number">0</span>, hash_p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;lamp : lamps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points.<span class="built_in">count</span>(&#123;lamp[<span class="number">0</span>], lamp[<span class="number">1</span>]&#125;) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            points.<span class="built_in">insert</span>(&#123;lamp[<span class="number">0</span>], lamp[<span class="number">1</span>]&#125;);</span><br><span class="line">            row[lamp[<span class="number">0</span>]]++;</span><br><span class="line">            col[lamp[<span class="number">1</span>]]++;</span><br><span class="line">            diagonal[lamp[<span class="number">0</span>] - lamp[<span class="number">1</span>]]++;</span><br><span class="line">            antiDiagonal[lamp[<span class="number">0</span>] + lamp[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(queries.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = queries[i][<span class="number">0</span>], c = queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (row.<span class="built_in">count</span>(r) &gt; <span class="number">0</span> &amp;&amp; row[r] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret[i] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (col.<span class="built_in">count</span>(c) &gt; <span class="number">0</span> &amp;&amp; col[c] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret[i] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diagonal.<span class="built_in">count</span>(r - c) &gt; <span class="number">0</span> &amp;&amp; diagonal[r - c] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret[i] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (antiDiagonal.<span class="built_in">count</span>(r + c) &gt; <span class="number">0</span> &amp;&amp; antiDiagonal[r + c] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = r - <span class="number">1</span>; x &lt;= r + <span class="number">1</span>; x++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> y = c - <span class="number">1</span>; y &lt;= c + <span class="number">1</span>; y++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= n || y &gt;= n) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">auto</span> p = points.<span class="built_in">find</span>(&#123;x, y&#125;);</span><br><span class="line">                    <span class="keyword">if</span> (p != points.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        points.<span class="built_in">erase</span>(p);</span><br><span class="line">                        row[x]--;</span><br><span class="line">                        col[y]--;</span><br><span class="line">                        diagonal[x - y]--;</span><br><span class="line">                        antiDiagonal[x + y]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="1020-飞地的数量"><a href="#1020-飞地的数量" class="headerlink" title="1020 飞地的数量"></a>1020 飞地的数量</h3><p><a href="https://leetcode-cn.com/problems/number-of-enclaves/">1020. 飞地的数量 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>() - <span class="number">1</span>, n = grid[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[<span class="number">0</span>][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">search</span>(<span class="number">0</span>, i, grid, m, n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(grid[m][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">search</span>(m, i, grid, m, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">search</span>(i, <span class="number">0</span>, grid, m, n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][n] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">search</span>(i, n, grid, m, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            num += <span class="built_in">count</span>(grid[i].<span class="built_in">begin</span>(), grid[i].<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span>&amp; m, <span class="keyword">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">		grid[x][y] = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; grid[x - <span class="number">1</span>][y] == <span class="number">1</span>) <span class="built_in">search</span>(x - <span class="number">1</span>, y, grid, m ,n);</span><br><span class="line">		<span class="keyword">if</span>(x &lt; m &amp;&amp; grid[x + <span class="number">1</span>][y] == <span class="number">1</span>) <span class="built_in">search</span>(x + <span class="number">1</span>, y, grid, m ,n);</span><br><span class="line">		<span class="keyword">if</span>(y &gt; <span class="number">0</span> &amp;&amp; grid[x][y - <span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">search</span>(x, y - <span class="number">1</span>, grid, m ,n);</span><br><span class="line">		<span class="keyword">if</span>(y &lt; n &amp;&amp; grid[x][y + <span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">search</span>(x, y + <span class="number">1</span>, grid, m ,n); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案一，深度优先搜索</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;visited = vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, i, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(grid, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, <span class="number">0</span>, j);</span><br><span class="line">            <span class="built_in">dfs</span>(grid, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> enclaves = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    enclaves++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enclaves;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp; grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= m || col &lt; <span class="number">0</span> || col &gt;= n || grid[row][col] == <span class="number">0</span> || visited[row][col]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[row][col] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; dir : dirs) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, row + dir[<span class="number">0</span>], col + dir[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; visited;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案二，广度优先搜索</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; visited = vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; qu;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                visited[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">                qu.<span class="built_in">emplace</span>(i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][n - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                visited[i][n - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                qu.<span class="built_in">emplace</span>(i, n - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                visited[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">                qu.<span class="built_in">emplace</span>(<span class="number">0</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (grid[m - <span class="number">1</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                visited[m - <span class="number">1</span>][j] = <span class="literal">true</span>;</span><br><span class="line">                qu.<span class="built_in">emplace</span>(m - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [currRow, currCol] = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextRow = currRow + dir[<span class="number">0</span>], nextCol = currCol + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nextRow &gt;= <span class="number">0</span> &amp;&amp; nextRow &lt; m &amp;&amp; nextCol &gt;= <span class="number">0</span> &amp;&amp; nextCol &lt; n &amp;&amp; grid[nextRow][nextCol] == <span class="number">1</span> &amp;&amp; !visited[nextRow][nextCol]) &#123;</span><br><span class="line">                    visited[nextRow][nextCol] = <span class="literal">true</span>;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(nextRow, nextCol);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> enclaves = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    enclaves++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enclaves;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案三，并查集</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp; grid) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = vector&lt;<span class="keyword">int</span>&gt;(m * n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;onEdge = vector&lt;<span class="keyword">bool</span>&gt;(m * n, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;rank = vector&lt;<span class="keyword">int</span>&gt;(m * n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> index = i * n + j;</span><br><span class="line">                    parent[index] = index;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || i == m - <span class="number">1</span> || j == <span class="number">0</span> || j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                        onEdge[index] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[i] != i) &#123;</span><br><span class="line">            parent[i] = <span class="built_in">find</span>(parent[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootx = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rooty = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;</span><br><span class="line">                parent[rooty] = rootx;</span><br><span class="line">                onEdge[rootx] = onEdge[rootx] | onEdge[rooty];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">                parent[rootx] = rooty;</span><br><span class="line">                onEdge[rooty] = onEdge[rooty] | onEdge[rootx];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rooty] = rootx;</span><br><span class="line">                onEdge[rootx] = onEdge[rootx] | onEdge[rooty];</span><br><span class="line">                rank[rootx]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOnEdge</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onEdge[<span class="built_in">find</span>(i)];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; onEdge;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; rank;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(grid)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> index = i * n + j;</span><br><span class="line">                    <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                        uf.<span class="built_in">uni</span>(index, index + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                        uf.<span class="built_in">uni</span>(index, index + n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> enclaves = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !uf.<span class="built_in">isOnEdge</span>(i * n + j)) &#123;</span><br><span class="line">                    enclaves++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enclaves;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="1189-气球的最大数量"><a href="#1189-气球的最大数量" class="headerlink" title="1189 气球的最大数量"></a>1189 气球的最大数量</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-balloons/">1189. “气球” 的最大数量 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拼&quot;balloon&quot;（气球）的个数，每个字母只能用一次</span><br><span class="line">输入：text = &quot;loonbalxballpoon&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNumberOfBalloons</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, l = <span class="number">0</span>, o = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(text[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: ++a; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: ++b; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: ++l; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: ++o; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: ++n; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l /= <span class="number">2</span>;</span><br><span class="line">        o /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a &lt; num) num = a;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; num) num = b;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; num) num = l;</span><br><span class="line">        <span class="keyword">if</span>(o &lt; num) num = o;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; num) num = n;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNumberOfBalloons</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; ch : text) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">                cnt[<span class="number">0</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                cnt[<span class="number">1</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;l&#x27;</span>) &#123;</span><br><span class="line">                cnt[<span class="number">2</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">                cnt[<span class="number">3</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">                cnt[<span class="number">4</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[<span class="number">2</span>] /= <span class="number">2</span>;</span><br><span class="line">        cnt[<span class="number">3</span>] /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






<h3 id="1219-黄金矿工"><a href="#1219-黄金矿工" class="headerlink" title="1219 黄金矿工"></a>1219 黄金矿工</h3><p><a href="https://leetcode-cn.com/problems/path-with-maximum-gold/">1219. 黄金矿工 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,6,0],[5,8,7],[0,9,0]]</span><br><span class="line">输出：24</span><br><span class="line">解释：</span><br><span class="line">[[0,6,0],</span><br><span class="line"> [5,8,7],</span><br><span class="line"> [0,9,0]]</span><br><span class="line">一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxGold = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumGold</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="built_in">search</span>(grid, i, j, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxGold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> gold, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">            maxGold = maxGold &gt; gold ? maxGold : gold;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gold += grid[x][y];</span><br><span class="line">        <span class="keyword">int</span> reserve = grid[x][y];</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// flag    1 向下  2 向上   3 向左   4 向右</span></span><br><span class="line">        <span class="keyword">if</span>(x + <span class="number">1</span> &lt; grid.<span class="built_in">size</span>() &amp;&amp; flag != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">search</span>(grid, x + <span class="number">1</span>, y, gold, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; flag != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">search</span>(grid, x - <span class="number">1</span>, y, gold, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y &gt; <span class="number">0</span> &amp;&amp; flag != <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">search</span>(grid, x, y - <span class="number">1</span>, gold, <span class="number">3</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(y + <span class="number">1</span> &lt; grid[x].<span class="built_in">size</span>() &amp;&amp; flag != <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">search</span>(grid, x, y + <span class="number">1</span>, gold, <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = reserve;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1380-矩阵中的幸运数"><a href="#1380-矩阵中的幸运数" class="headerlink" title="1380 矩阵中的幸运数"></a>1380 矩阵中的幸运数</h3><p><a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/">1380. 矩阵中的幸运数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">luckyNumbers</span> <span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; luck;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> minSub = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] &lt; matrix[i][minSub]) &#123;</span><br><span class="line">                    minSub = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][minSub] &lt; matrix[k][minSub]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                luck.<span class="built_in">push_back</span>(matrix[i][minSub]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> luck;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案，预处理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">luckyNumbers</span> <span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">minRow</span><span class="params">(m, INT_MAX)</span>, <span class="title">maxCol</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                minRow[i] = <span class="built_in">min</span>(minRow[i], matrix[i][j]);</span><br><span class="line">                maxCol[j] = <span class="built_in">max</span>(maxCol[j], matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == minRow[i] &amp;&amp; matrix[i][j] == maxCol[j]) &#123;</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="1405-最长快乐字符串"><a href="#1405-最长快乐字符串" class="headerlink" title="1405 最长快乐字符串"></a>1405 最长快乐字符串</h3><p><a href="https://leetcode-cn.com/problems/longest-happy-string/">1405. 最长快乐字符串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：a = 1, b = 1, c = 7</span><br><span class="line">输出：&quot;ccaccbcc&quot;</span><br><span class="line">解释：&quot;ccbccacc&quot; 也是一种正确答案。</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestDiverseString</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&gt; arr = &#123;&#123;a, <span class="string">&#x27;a&#x27;</span>&#125;, &#123;b, <span class="string">&#x27;b&#x27;</span>&#125;, &#123;c, <span class="string">&#x27;c&#x27;</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">char</span> before = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        string re = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&amp; p1, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&amp; p2)&#123; <span class="keyword">return</span> p1.first &gt; p2.first; &#125;);</span><br><span class="line">			<span class="keyword">if</span>(!(count == <span class="number">2</span> &amp;&amp; before == arr[<span class="number">0</span>].second) &amp;&amp; arr[<span class="number">0</span>].first) &#123;</span><br><span class="line">                <span class="keyword">if</span>(before == arr[<span class="number">0</span>].second) count++;</span><br><span class="line">                <span class="keyword">else</span> count = <span class="number">1</span>;</span><br><span class="line">                before = arr[<span class="number">0</span>].second;</span><br><span class="line">                --arr[<span class="number">0</span>].first;                    </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[<span class="number">1</span>].first)&#123;</span><br><span class="line">                before = arr[<span class="number">1</span>].second;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                --arr[<span class="number">1</span>].first;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			re += before;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 某用户评论</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestDiverseString</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;, cc[<span class="number">3</span>] = &#123;a,b,c&#125;;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">auto</span> get_rank = [&amp;](<span class="keyword">int</span> i)&#123;</span><br><span class="line">            <span class="built_in">sort</span>(idx, idx+<span class="number">3</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;<span class="keyword">return</span> cc[x] &gt; cc[y];&#125;);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> test_insert = [&amp;](<span class="keyword">int</span> i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cc[idx[i]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            --cc[idx[i]], ans.<span class="built_in">push_back</span>(idx[i]+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">test_insert</span>(<span class="built_in">get_rank</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="built_in">test_insert</span>(<span class="built_in">get_rank</span>(<span class="number">0</span>));        </span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">test_insert</span>(<span class="number">1</span>) || <span class="built_in">test_insert</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestDiverseString</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&gt; arr = &#123;&#123;a, <span class="string">&#x27;a&#x27;</span>&#125;, &#123;b, <span class="string">&#x27;b&#x27;</span>&#125;, &#123;c, <span class="string">&#x27;c&#x27;</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; &amp; p1, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; &amp; p2) &#123;</span><br><span class="line">                <span class="keyword">return</span> p1.first &gt; p2.first;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">bool</span> hasNext = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; [freq, ch] : arr) &#123;</span><br><span class="line">                <span class="keyword">int</span> m = res.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">if</span> (freq &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (m &gt;= <span class="number">2</span> &amp;&amp; res[m - <span class="number">2</span>] == ch &amp;&amp; res[m - <span class="number">1</span>] == ch) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hasNext = <span class="literal">true</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(ch);</span><br><span class="line">                freq--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!hasNext) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="1414-和为-K-的最少斐波那契数字数目"><a href="#1414-和为-K-的最少斐波那契数字数目" class="headerlink" title="1414 和为 K 的最少斐波那契数字数目"></a>1414 和为 K 的最少斐波那契数字数目</h3><p><a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/">1414. 和为 K 的最少斐波那契数字数目 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：k = 7</span><br><span class="line">输出：2 </span><br><span class="line">解释：斐波那契数字为：1，1，2，3，5，8，13，……</span><br><span class="line">对于 k = 7 ，我们可以得到 2 + 5 = 7 。</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinFibonacciNumbers</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">fibonacci</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> top = fibonacci.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fibonacci[top] &lt;= k) &#123;</span><br><span class="line">            fibonacci.<span class="built_in">push_back</span>(fibonacci[top] + fibonacci[top - <span class="number">1</span>]);</span><br><span class="line">            top++;</span><br><span class="line">        &#125;</span><br><span class="line">		top--;</span><br><span class="line">		fibonacci.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> findNum = k - fibonacci[top];</span><br><span class="line">		<span class="keyword">if</span> (findNum == <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(fibonacci.<span class="built_in">begin</span>(), fibonacci.<span class="built_in">end</span>(), findNum);</span><br><span class="line">            <span class="keyword">if</span>(it == fibonacci.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (findNum &gt; fibonacci[i]) &#123;</span><br><span class="line">                        findNum -= fibonacci[i];</span><br><span class="line">                        num++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1447-最简分数"><a href="#1447-最简分数" class="headerlink" title="1447 最简分数"></a>1447 最简分数</h3><p><a href="https://leetcode-cn.com/problems/simplified-fractions/">1447. 最简分数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：[&quot;1/2&quot;,&quot;1/3&quot;,&quot;1/4&quot;,&quot;2/3&quot;,&quot;3/4&quot;]</span><br><span class="line">解释：&quot;2/4&quot; 不是最简分数，因为它可以化简为 &quot;1/2&quot; 。</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">simplifiedFractions</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; re;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> simplestfraction = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= j / <span class="number">2</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % k == <span class="number">0</span> &amp;&amp; j % k == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">simplestfraction</span>(i, j)) <span class="keyword">continue</span>;</span><br><span class="line">                string temp = <span class="built_in">to_string</span>(i) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">to_string</span>(j);</span><br><span class="line">                re.<span class="built_in">push_back</span>(temp);                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">simplifiedFractions</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> denominator = <span class="number">2</span>; denominator &lt;= n; ++denominator) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> numerator = <span class="number">1</span>; numerator &lt; denominator; ++numerator) &#123;</span><br><span class="line">                <span class="keyword">if</span> (__gcd(numerator, denominator) == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans.<span class="built_in">emplace_back</span>(<span class="built_in">to_string</span>(numerator) + <span class="string">&quot;/&quot;</span> + <span class="built_in">to_string</span>(denominator));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1601-最多可达成的换楼请求数目"><a href="#1601-最多可达成的换楼请求数目" class="headerlink" title="1601 最多可达成的换楼请求数目"></a>1601 最多可达成的换楼请求数目</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/">1601. 最多可达成的换楼请求数目 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案，DFS+回溯</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; delta;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>, zero, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;requests, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == requests.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (zero == n) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选 requests[pos]</span></span><br><span class="line">        <span class="built_in">dfs</span>(requests, pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选 requests[pos]</span></span><br><span class="line">        <span class="keyword">int</span> z = zero;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">auto</span> &amp;r = requests[pos];</span><br><span class="line">        <span class="keyword">int</span> x = r[<span class="number">0</span>], y = r[<span class="number">1</span>];</span><br><span class="line">        zero -= delta[x] == <span class="number">0</span>;</span><br><span class="line">        --delta[x];</span><br><span class="line">        zero += delta[x] == <span class="number">0</span>;</span><br><span class="line">        zero -= delta[y] == <span class="number">0</span>;</span><br><span class="line">        ++delta[y];</span><br><span class="line">        zero += delta[y] == <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(requests, pos + <span class="number">1</span>);</span><br><span class="line">        --delta[y];</span><br><span class="line">        ++delta[x];</span><br><span class="line">        --cnt;</span><br><span class="line">        zero = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumRequests</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;requests)</span> </span>&#123;</span><br><span class="line">        delta.<span class="built_in">resize</span>(n);</span><br><span class="line">        zero = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">dfs</span>(requests, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案，二进制枚举</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumRequests</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;requests)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">delta</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, m = requests.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; m); ++mask) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = __builtin_popcount(mask);</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= ans) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">fill</span>(delta.<span class="built_in">begin</span>(), delta.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mask &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                    ++delta[requests[i][<span class="number">0</span>]];</span><br><span class="line">                    --delta[requests[i][<span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">all_of</span>(delta.<span class="built_in">begin</span>(), delta.<span class="built_in">end</span>(), [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x == <span class="number">0</span>; &#125;)) &#123;</span><br><span class="line">                ans = cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1606-找到处理最多请求的服务器"><a href="#1606-找到处理最多请求的服务器" class="headerlink" title="1606 找到处理最多请求的服务器"></a>1606 找到处理最多请求的服务器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，模拟+有序集合+优先队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">busiestServers</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt; &amp;arrival, vector&lt;<span class="keyword">int</span>&gt; &amp;load)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; available;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            available.<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;&gt;&gt; busy;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">requests</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrival.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!busy.<span class="built_in">empty</span>() &amp;&amp; busy.<span class="built_in">top</span>().first &lt;= arrival[i]) &#123;</span><br><span class="line">                available.<span class="built_in">insert</span>(busy.<span class="built_in">top</span>().second);</span><br><span class="line">                busy.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (available.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> p = available.<span class="built_in">lower_bound</span>(i % k);</span><br><span class="line">            <span class="keyword">if</span> (p == available.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                p = available.<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            requests[*p]++;</span><br><span class="line">            busy.<span class="built_in">emplace</span>(arrival[i] + load[i], *p);</span><br><span class="line">            available.<span class="built_in">erase</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxRequest = *<span class="built_in">max_element</span>(requests.<span class="built_in">begin</span>(), requests.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requests[i] == maxRequest) &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，模拟+双优先队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">busiestServers</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt; &amp;arrival, vector&lt;<span class="keyword">int</span>&gt; &amp;load)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; available;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            available.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; busy;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">requests</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrival.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!busy.<span class="built_in">empty</span>() &amp;&amp; busy.<span class="built_in">top</span>().first &lt;= arrival[i]) &#123;</span><br><span class="line">                <span class="keyword">auto</span>[_, id] = busy.<span class="built_in">top</span>();</span><br><span class="line">                busy.<span class="built_in">pop</span>();</span><br><span class="line">                available.<span class="built_in">push</span>(i + ((id - i) % k + k) % k); <span class="comment">// 保证得到的是一个不小于 i 的且与 id 同余的数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (available.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> id = available.<span class="built_in">top</span>() % k;</span><br><span class="line">            available.<span class="built_in">pop</span>();</span><br><span class="line">            requests[id]++;</span><br><span class="line">            busy.<span class="built_in">push</span>(&#123;arrival[i] + load[i], id&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxRequest = *<span class="built_in">max_element</span>(requests.<span class="built_in">begin</span>(), requests.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requests[i] == maxRequest) &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="1725-可以形成最大正方形的矩形数目"><a href="#1725-可以形成最大正方形的矩形数目" class="headerlink" title="1725 可以形成最大正方形的矩形数目"></a>1725 可以形成最大正方形的矩形数目</h3><p><a href="https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/">1725. 可以形成最大正方形的矩形数目 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：rectangles = [[5,8],[3,9],[5,12],[16,5]]</span><br><span class="line">输出：3</span><br><span class="line">解释：能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。</span><br><span class="line">最大正方形的边长为 5 ，可以由 3 个矩形切分得到。</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodRectangles</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxRec=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rectangles.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rec = rectangles[i][<span class="number">0</span>]&lt;rectangles[i][<span class="number">1</span>]?rectangles[i][<span class="number">0</span>]:rectangles[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (maxRec == rec) &#123;</span><br><span class="line">                ++maxLen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(maxRec &lt; rec) &#123;</span><br><span class="line">                maxLen=<span class="number">1</span>;</span><br><span class="line">                maxRec=rec;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1748-唯一元素的和"><a href="#1748-唯一元素的和" class="headerlink" title="1748 唯一元素的和"></a>1748 唯一元素的和</h3><p><a href="https://leetcode-cn.com/problems/sum-of-unique-elements/">1748. 唯一元素的和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：唯一元素为 [1,3] ，和为 4 。</span><br><span class="line"></span><br><span class="line">输入：nums = [1,1,1,1,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：没有唯一元素，和为 0 </span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfUnique</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>(), nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it == temp.<span class="built_in">end</span>() || temp.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = <span class="built_in">count</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>(), nums[i]);</span><br><span class="line">                <span class="keyword">if</span>(num) &#123;</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sum += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfUnique</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; state;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state[num] == <span class="number">0</span>) &#123;</span><br><span class="line">                ans += num;</span><br><span class="line">                state[num] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state[num] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans -= num;</span><br><span class="line">                state[num] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="1763-最长的美好字符串"><a href="#1763-最长的美好字符串" class="headerlink" title="1763 最长的美好字符串"></a>1763 最长的美好字符串</h3><p><a href="https://leetcode-cn.com/problems/longest-nice-substring/">1763. 最长的美好子字符串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;YazaAay&quot;</span><br><span class="line">输出：&quot;aAa&quot;</span><br><span class="line">解释：&quot;aAa&quot; 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 &#x27;a&#x27; 和大写形式 &#x27;A&#x27; 也同时出现了。</span><br><span class="line">&quot;aAa&quot; 是最长的美好子字符串。</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestNiceSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leng = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxPos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leng; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> lower = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> upper = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; leng; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">islower</span>(s[j])) &#123;</span><br><span class="line">                    lower |= <span class="number">1</span> &lt;&lt; (s[j] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isupper</span>(s[j])) &#123;</span><br><span class="line">                    upper |= <span class="number">1</span> &lt;&lt; (s[j] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(lower == upper &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxPos = i;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(maxPos, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="1984-学生分数的最小差值"><a href="#1984-学生分数的最小差值" class="headerlink" title="1984 学生分数的最小差值"></a>1984 学生分数的最小差值</h3><p><a href="https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/">1984. 学生分数的最小差值 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [9,4,1,7], k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：选出 2 名学生的分数，有 6 种方法：</span><br><span class="line">- [9,4, , ] 最高分和最低分之间的差值是 9 - 4 = 5</span><br><span class="line">- [9, ,1, ] 最高分和最低分之间的差值是 9 - 1 = 8</span><br><span class="line">- [9, , ,7] 最高分和最低分之间的差值是 9 - 7 = 2</span><br><span class="line">- [ ,4,1, ] 最高分和最低分之间的差值是 4 - 1 = 3</span><br><span class="line">- [ ,4, ,7] 最高分和最低分之间的差值是 7 - 4 = 3</span><br><span class="line">- [ , ,1,7] 最高分和最低分之间的差值是 7 - 1 = 6</span><br><span class="line">可能的最小差值是 2</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDifference</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; n; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, nums[i + k - <span class="number">1</span>] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2006-差的绝对值为K的数对数目"><a href="#2006-差的绝对值为K的数对数目" class="headerlink" title="2006 差的绝对值为K的数对数目"></a>2006 差的绝对值为K的数对数目</h3><p><a href="https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k/">2006. 差的绝对值为 K 的数对数目 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,2,1], k = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：差的绝对值为 1 的数对为：</span><br><span class="line">- [1,2, , ]</span><br><span class="line">- [1, ,2, ]</span><br><span class="line">- [ ,2, ,1]</span><br><span class="line">- [ , ,2,1]</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countKDifference</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            res += (cnt.<span class="built_in">count</span>(nums[j] - k) ? cnt[nums[j] - k] : <span class="number">0</span>);</span><br><span class="line">            res += (cnt.<span class="built_in">count</span>(nums[j] + k) ? cnt[nums[j] + k] : <span class="number">0</span>);</span><br><span class="line">            ++cnt[nums[j]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2024-考试的最大困扰度"><a href="#2024-考试的最大困扰度" class="headerlink" title="2024 考试的最大困扰度"></a>2024 考试的最大困扰度</h3><p><a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/">2024. 考试的最大困扰度 - 力扣（LeetCode） (leetcode-cn.com)</a> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，滑动窗口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxConsecutiveChar</span><span class="params">(string&amp; answerKey, <span class="keyword">int</span> k, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = answerKey.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            sum += answerKey[right] != ch;</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; k) &#123;</span><br><span class="line">                sum -= answerKey[left++] != ch;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxConsecutiveAnswers</span><span class="params">(string answerKey, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxConsecutiveChar</span>(answerKey, k, <span class="string">&#x27;T&#x27;</span>),</span><br><span class="line">                   <span class="built_in">maxConsecutiveChar</span>(answerKey, k, <span class="string">&#x27;F&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//评论区的答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxConsecutiveAnswers</span><span class="params">(string answerKey, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = answerKey.<span class="built_in">size</span>(),<span class="keyword">sum_t</span> = <span class="number">0</span>,sum_f = <span class="number">0</span>;        <span class="comment">//实时记录对应的t和f的总数</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">left_t</span> = <span class="number">0</span>,left_f = <span class="number">0</span>,max_sum = <span class="number">0</span>;                 <span class="comment">//遍历过程中t数列和f数列的左边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;            <span class="comment">//i可以理解为右边界</span></span><br><span class="line">            <span class="keyword">if</span>(answerKey[i] == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">               sum_f++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">sum_t</span>++;</span><br><span class="line">            <span class="comment">//把T理解为主数列，那么F就是冗余项，需要判断实时的数量，不能超过k</span></span><br><span class="line">            <span class="comment">//如果超过了，就要左边界向右移动，直到F的数量恢复正常标准</span></span><br><span class="line">            <span class="keyword">while</span>(sum_f &gt; k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(answerKey[<span class="keyword">left_t</span>] == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">                   sum_f--;</span><br><span class="line">                <span class="keyword">left_t</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//同理，把F理解为主数列，那么T就是冗余项</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">sum_t</span> &gt; k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(answerKey[left_f] == <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">                   <span class="keyword">sum_t</span>--;</span><br><span class="line">                left_f++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较取最大值</span></span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum,<span class="built_in">max</span>(i-<span class="keyword">left_t</span>,i-left_f)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2028-找出缺失的数据"><a href="#2028-找出缺失的数据" class="headerlink" title="2028 找出缺失的数据"></a>2028 找出缺失的数据</h3><p><a href="https://leetcode-cn.com/problems/find-missing-observations/">2028. 找出缺失的观测数据 - 力扣（LeetCode） (leetcode-cn.com)</a> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">missingRolls</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; rolls, <span class="keyword">int</span> mean, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = rolls.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sum = (n + m) * mean;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i : rolls)</span><br><span class="line">        &#123;</span><br><span class="line">            sum -= i;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">double</span> avr = (<span class="keyword">double</span>)sum / n;</span><br><span class="line">        <span class="keyword">if</span>(avr &gt; <span class="number">6</span> || avr &lt; <span class="number">1</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> avrge = (<span class="keyword">int</span>)avr;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(n, avrge)</span></span>;</span><br><span class="line">        sum -= avrge * n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">6</span> - ret[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                sum -= tmp;</span><br><span class="line">                ret[i] = <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ret[i] += sum;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2038"><a href="#2038" class="headerlink" title="2038"></a>2038</h3><p><a href="https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/">2038. 如果相邻两个颜色均相同则删除当前颜色 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">winnerOfGame</span><span class="params">(string colors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = colors.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> Anum = <span class="number">0</span>, Bnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(colors[i - <span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; colors[i] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; colors[i + <span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++Anum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(colors[i - <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; colors[i] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; colors[i + <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++Bnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Anum &gt; Bnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">winnerOfGame</span><span class="params">(string colors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> freq[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> cur = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : colors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != cur) &#123;</span><br><span class="line">                cur = c;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (++cnt &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                ++freq[cur - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="keyword">return</span> freq[<span class="number">0</span>] &gt; freq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2039-网络空闲的时刻"><a href="#2039-网络空闲的时刻" class="headerlink" title="2039 网络空闲的时刻"></a>2039 网络空闲的时刻</h3><p><a href="https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/">2039. 网络空闲的时刻 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkBecomesIdle</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="keyword">int</span>&gt;&amp; patience)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = patience.<span class="built_in">size</span>();       </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visit</span><span class="params">(n, <span class="literal">false</span>)</span></span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; v : edges) &#123;  </span><br><span class="line">            adj[v[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(v[<span class="number">1</span>]);</span><br><span class="line">            adj[v[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        qu.<span class="built_in">emplace</span>(<span class="number">0</span>);</span><br><span class="line">        visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = qu.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> curr = qu.<span class="built_in">front</span>();</span><br><span class="line">                qu.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; v : adj[curr]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visit[v]) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(v);</span><br><span class="line">                    <span class="keyword">int</span> time = patience[v] * ((<span class="number">2</span> * dist - <span class="number">1</span>) / patience[v]) + <span class="number">2</span> * dist + <span class="number">1</span>;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, time);</span><br><span class="line">                    visit[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dist++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2043-简易银行系统"><a href="#2043-简易银行系统" class="headerlink" title="2043 简易银行系统"></a>2043 简易银行系统</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; balance;</span><br><span class="line">    <span class="keyword">int</span> accountNum;</span><br><span class="line">    <span class="built_in">Bank</span>(vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&amp; balance) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;balance = balance;</span><br><span class="line">        accountNum = balance.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> account1, <span class="keyword">int</span> account2, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(account1 &gt; accountNum || account2 &gt; accountNum || balance[account1 - <span class="number">1</span>] &lt; money)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        balance[account1 - <span class="number">1</span>] -= money;</span><br><span class="line">        balance[account2 - <span class="number">1</span>] += money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> account, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(account &gt; accountNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        balance[account - <span class="number">1</span>] += money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> account, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(account &gt; accountNum || balance[account - <span class="number">1</span>] &lt; money)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        balance[account - <span class="number">1</span>] -= money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Bank object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Bank* obj = new Bank(balance);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;transfer(account1,account2,money);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;deposit(account,money);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;withdraw(account,money);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bank</span>(vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&amp; balance) : <span class="built_in">balance</span>(balance) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> account1, <span class="keyword">int</span> account2, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (account1 &gt; balance.<span class="built_in">size</span>() || account2 &gt; balance.<span class="built_in">size</span>() || balance[account1 - <span class="number">1</span>] &lt; money) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        balance[account1 - <span class="number">1</span>] -= money;</span><br><span class="line">        balance[account2 - <span class="number">1</span>] += money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> account, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (account &gt; balance.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        balance[account - <span class="number">1</span>] += money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> account, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (account &gt; balance.<span class="built_in">size</span>() || balance[account - <span class="number">1</span>] &lt; money) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        balance[account - <span class="number">1</span>] -= money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2044-统计按位或能得到最大值的子集数目"><a href="#2044-统计按位或能得到最大值的子集数目" class="headerlink" title="2044 统计按位或能得到最大值的子集数目"></a>2044 统计按位或能得到最大值的子集数目</h3><p><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">2044. 统计按位或能得到最大值的子集数目 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxOr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countMaxOrSubsets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            maxOr |= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfsEnum</span>(nums, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfsEnum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> pos, <span class="keyword">int</span> numOr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(numOr == maxOr) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfsEnum</span>(nums, pos + <span class="number">1</span>, numOr);</span><br><span class="line">        numOr |= nums[pos];</span><br><span class="line">        <span class="built_in">dfsEnum</span>(nums, pos + <span class="number">1</span>, numOr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，位运算</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countMaxOrSubsets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), maxValue = <span class="number">0</span>, cnt = <span class="number">0</span>, stateNumber = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stateNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    cur |= nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur == maxValue) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt; maxValue) &#123;</span><br><span class="line">                maxValue = cur;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，回溯</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countMaxOrSubsets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">this</span>-&gt;maxOr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> orVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (orVal &gt; maxOr) &#123;</span><br><span class="line">                maxOr = orVal;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orVal == maxOr) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(pos + <span class="number">1</span>, orVal| nums[pos]);</span><br><span class="line">        <span class="built_in">dfs</span>(pos + <span class="number">1</span>, orVal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">int</span> maxOr, cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2055-蜡烛之间的盘子"><a href="#2055-蜡烛之间的盘子" class="headerlink" title="2055 蜡烛之间的盘子"></a>2055 蜡烛之间的盘子</h3><p><a href="https://leetcode-cn.com/problems/plates-between-candles/">2055. 蜡烛之间的盘子 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，预处理+模拟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">platesBetweenCandles</span><span class="params">(string s, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preSum</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            preSum[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, l = <span class="number">-1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;|&#x27;</span>) &#123;</span><br><span class="line">                l = i;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, r = <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;|&#x27;</span>) &#123;</span><br><span class="line">                r = i;</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = r;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; query : queries) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = right[query[<span class="number">0</span>]], y = left[query[<span class="number">1</span>]];</span><br><span class="line">            ans.<span class="built_in">push_back</span>(x == <span class="number">-1</span> || y == <span class="number">-1</span> || x &gt;= y ? <span class="number">0</span> : preSum[y] - preSum[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="2100-适合打劫银行的日子"><a href="#2100-适合打劫银行的日子" class="headerlink" title="2100 适合打劫银行的日子"></a>2100 适合打劫银行的日子</h3><p><a href="https://leetcode-cn.com/problems/find-good-days-to-rob-the-bank/">2100. 适合打劫银行的日子 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">goodDaysToRobBank</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; security, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = security.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(length &lt; time) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> *later = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        later[length - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(security[i] &lt;= security[i + <span class="number">1</span>]) later[i] = later[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> later[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length - time; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(security[i] &lt;= security[i - <span class="number">1</span>]) front++;</span><br><span class="line">            <span class="keyword">else</span> front = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(front &gt;= time &amp;&amp; later[i] &gt;= time) result.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] later;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">goodDaysToRobBank</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; security, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = security.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (security[i] &lt;= security[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (security[n - i - <span class="number">1</span>] &lt;= security[n - i]) &#123;</span><br><span class="line">                right[n - i - <span class="number">1</span>] = right[n - i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = time; i &lt; n - time; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i] &gt;= time &amp;&amp; right[i] &gt;= time) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="2104-子数组范围和"><a href="#2104-子数组范围和" class="headerlink" title="2104 子数组范围和"></a>2104 子数组范围和</h3><p><a href="https://leetcode-cn.com/problems/sum-of-subarray-ranges/">2104. 子数组范围和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">subArrayRanges</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxNum = nums[i], minNum = nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; length - i; ++j) &#123;</span><br><span class="line">                maxNum = <span class="built_in">max</span>(maxNum, nums[i + j]);</span><br><span class="line">                minNum = <span class="built_in">min</span>(minNum, nums[i + j]);</span><br><span class="line">                result += maxNum - minNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，遍历子数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">subArrayRanges</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minVal = INT_MAX, maxVal = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                minVal = <span class="built_in">min</span>(minVal, nums[j]);</span><br><span class="line">                maxVal = <span class="built_in">max</span>(maxVal, nums[j]);</span><br><span class="line">                ret += maxVal - minVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方答案，单调栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">subArrayRanges</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">minLeft</span><span class="params">(n)</span>, <span class="title">minRight</span><span class="params">(n)</span>, <span class="title">maxLeft</span><span class="params">(n)</span>, <span class="title">maxRight</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; minStack, maxStack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!minStack.<span class="built_in">empty</span>() &amp;&amp; nums[minStack.<span class="built_in">top</span>()] &gt; nums[i]) &#123;</span><br><span class="line">                minStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            minLeft[i] = minStack.<span class="built_in">empty</span>() ? <span class="number">-1</span> : minStack.<span class="built_in">top</span>();</span><br><span class="line">            minStack.<span class="built_in">push</span>(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 nums[maxStack.top()] == nums[i], 那么根据定义，</span></span><br><span class="line">            <span class="comment">// nums[maxStack.top()] 逻辑上小于 nums[i]，因为 maxStack.top() &lt; i</span></span><br><span class="line">            <span class="keyword">while</span> (!maxStack.<span class="built_in">empty</span>() &amp;&amp; nums[maxStack.<span class="built_in">top</span>()] &lt;= nums[i]) &#123; </span><br><span class="line">                maxStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            maxLeft[i] = maxStack.<span class="built_in">empty</span>() ? <span class="number">-1</span> : maxStack.<span class="built_in">top</span>();</span><br><span class="line">            maxStack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        minStack = stack&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        maxStack = stack&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 如果 nums[minStack.top()] == nums[i], 那么根据定义，</span></span><br><span class="line">            <span class="comment">// nums[minStack.top()] 逻辑上大于 nums[i]，因为 minStack.top() &gt; i</span></span><br><span class="line">            <span class="keyword">while</span> (!minStack.<span class="built_in">empty</span>() &amp;&amp; nums[minStack.<span class="built_in">top</span>()] &gt;= nums[i]) &#123; </span><br><span class="line">                minStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            minRight[i] = minStack.<span class="built_in">empty</span>() ? n : minStack.<span class="built_in">top</span>();</span><br><span class="line">            minStack.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!maxStack.<span class="built_in">empty</span>() &amp;&amp; nums[maxStack.<span class="built_in">top</span>()] &lt; nums[i]) &#123;</span><br><span class="line">                maxStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            maxRight[i] = maxStack.<span class="built_in">empty</span>() ? n : maxStack.<span class="built_in">top</span>();</span><br><span class="line">            maxStack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sumMax = <span class="number">0</span>, sumMin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sumMax += <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(maxRight[i] - i) * (i - maxLeft[i]) * nums[i];</span><br><span class="line">            sumMin += <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(minRight[i] - i) * (i - minLeft[i]) * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumMax - sumMin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>

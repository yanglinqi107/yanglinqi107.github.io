<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yanglinqi107.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"/node_modules/hexo-generator-searchdb/search.xml"};
  </script>

  <meta name="description" content="线性表，栈和队列，串，数组，广义表，树，二叉树，图">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构上">
<meta property="og:url" content="http://yanglinqi107.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/index.html">
<meta property="og:site_name" content="杨的个人博客">
<meta property="og:description" content="线性表，栈和队列，串，数组，广义表，树，二叉树，图">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171848751.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171851002.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171851216.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171851384.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171851071.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171851973.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171852069.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171852398.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171852396.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171852499.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171853468.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171853639.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171853956.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171853586.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171853381.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171854066.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171855916.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171857101.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171901464.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171901233.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171901741.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171901601.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171901556.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171901916.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171902798.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171902610.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171902143.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171903316.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171903708.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171903117.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171906944.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171906489.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171906051.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171906374.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171907706.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171908575.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171909519.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171909031.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171909737.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171909051.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171910072.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171910614.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171910780.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171910228.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171910510.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171911339.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171911892.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171912797.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171912283.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171912535.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171913586.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171913456.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171913653.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171913802.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171914006.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171915818.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171915291.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171916056.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171916422.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171916865.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171917184.png">
<meta property="og:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171917790.png">
<meta property="article:published_time" content="2022-02-26T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-18T06:00:02.412Z">
<meta property="article:author" content="yanglinqi">
<meta property="article:tag" content="数据结构和算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/yanglinqi107/images/raw/master/res/202205171848751.png">

<link rel="canonical" href="http://yanglinqi107.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构上 | 杨的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杨的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">碎片化学习令人焦虑，系统化学习使人进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">19</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">88</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yanglinqi107.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headpic.jpg">
      <meta itemprop="name" content="yanglinqi">
      <meta itemprop="description" content="用于做笔记，对学过的知识总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构上
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-27 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-27T00:00:00+08:00">2022-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-18 14:00:02" itemprop="dateModified" datetime="2022-05-18T14:00:02+08:00">2022-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>线性表，栈和队列，串，数组，广义表，树，二叉树，图</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h3><p>1、按某种逻辑关系组织起来的一批数据（逻辑结构）例如：线性表、树、图</p>
<p>2、以一定的方式存于计算机中（存储结构）例如：数组、链表等</p>
<p>3、在这组数据上定义了运算的集合。例如：插入、删除、查找、排序等   </p>
<p><strong>程序 = 数据结构 + 算法</strong></p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p><strong>数据 data</strong>：能够输入到计算机中并被计算机程序处理的信息，包括文字、表格、图像等，都称为数据。</p>
<p><strong>数据元素 data element</strong>：数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素包含若干个<strong>数据项data item</strong>。</p>
<p>数据元素、数据项和数据的逻辑结构在计算机中的表示又称为结点、数据域和存储（物理）结构。</p>
<p><strong>数据对象</strong>：性质相同的数据元素的集合，是数据的一个子集。</p>
<p><strong>数据类型</strong>：一个值的集合及定义在这个值集上的一组操作的总称。</p>
<p>**抽象数据类型 ADT(Abstract Data Type)**：一个数学模型以及定义在此数学模型上的一组操作。</p>
<p><strong>数据的逻辑结构</strong>：数据元素之间的逻辑关系。</p>
<ul>
<li><strong>线性结构</strong>：元素之间的关系是一对一的。表，栈，队列，串等</li>
<li><strong>非线性结构</strong><ul>
<li><strong>树型结构</strong>：元素之间的关系是一对多的。二叉树，Huffman树等</li>
<li><strong>图状结构</strong>：元素之间的关系是多对多的。有向图，无向图等</li>
</ul>
</li>
</ul>
<p><strong>数据的存储结构</strong>：数据在计算机中的存储表示。逻辑结构到物理存储的映射。</p>
<ul>
<li><p><strong>顺序存储</strong>：数组</p>
</li>
<li><p><strong>非顺序存储</strong>：链式</p>
</li>
<li><p><strong>索引存储</strong>：</p>
</li>
<li><p><strong>散列存储</strong>：hash</p>
</li>
</ul>
<h3 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h3><p><strong>算法 algorithm</strong>：算法是对特定问题求解步骤的一种描述，是指令的有限序列。也即解决问题的一种方法（策略）或一个过程。</p>
<p><strong>程序</strong>：用计算机语言实现算法。</p>
<p><strong>算法的五个特性</strong>：有穷性，可行性，确定性，输入和输出。 </p>
<p><strong>算法分析（设计）的要求</strong>：正确性 correctness，可读性 readability，健壮性 robustness，高效率与低存储</p>
<p><strong>算法分析</strong>：</p>
<ul>
<li><strong>时间复杂度 time complexity</strong>：算法中各语句执行时间的总和。</li>
<li><strong>空间复杂度 space complesity</strong>：算法中所需占用的==辅助==空间。</li>
</ul>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><strong>线性表逻辑结构</strong></p>
<p>$(a_1,a_2,…,a_n)$  $n(n&gt;=0)$ 个元素的有限集。 每个元素的类型是相同的，元素之间的位置关系是一维(线性)的。</p>
<p><strong>线性表存储结构</strong></p>
<ul>
<li>顺序存储——顺序表</li>
<li>链式存储——链表</li>
</ul>
<p><strong>线性表的操作</strong></p>
<p>插入，删除，定位，查找，排序等</p>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>线性表的顺序存储</p>
<p>注意：有容量和表长，容量是线性表的最多保存的数据元素的个数，表长是当前顺序表保存的数据元素个数。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>线性表的链式存储。</p>
<p><strong>单向链表</strong></p>
<p>头指针，尾指针，空指针，数据域，指针域，空表，带表头节点的单向链表</p>
<p><font color="#ff000">注意：头指针可能包含数据，也可能置空。类似于数组的第0位可能不用，也可能存数据</font></p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171848751.png" alt="image-20220220153401793"></p>
<p><strong>单向循环链表</strong></p>
<p>只有尾指针，尾指针就是头指针</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171851002.png" alt="image-20220220153555966"></p>
<p><strong>双向链表</strong></p>
<p>两个指针域和一个数据域，  <code>prior data next</code></p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171851216.png" alt="image-20220220153643987"></p>
<p><strong>双向循环链表</strong></p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171851384.png" alt="image-20220220153836405"></p>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈和队列是特殊的线性表，是<strong>操作受限</strong>的线性表。</p>
<p>对于栈，所有的插入和删除操作都限制在线性表的同一端进行，是一种后进先出的线性表。</p>
<p>对于队列，所有的插入操作限制在线性表的一端进行，所有的删除操作限制在线性表的另一端进行，是一种先进先出的线性表。</p>
<p><strong>栈</strong>是限定在一端（表尾）进行插入或删除操作的线性表。<strong>表尾端称栈顶</strong>，表头端称栈底</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171851071.png" alt="image-20220220190949091"></p>
<p>栈对应线性表的两种类型</p>
<p><strong>顺序栈</strong></p>
<p>栈满：<code>top == MAXSIZE - 1</code></p>
<p>栈空：<code>top == -1</code></p>
<p><strong>链式栈</strong></p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171851973.png" alt="image-20220220193032534"></p>
<p><strong>队列</strong>是限定在表的一端（队尾）进行插入，另一端（队头）进行删除的线性表。<strong>出队列的一端称队头</strong>，进队列的一端称队尾。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171852069.png" alt="image-20220220191822593"></p>
<p><strong>循环队列</strong>——顺序存储</p>
<p>1）解决假溢出问题。2）提高效率。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171852398.png" alt="image-20220220192606716"></p>
<p><strong>链式队列</strong>——非顺序存储</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171852396.png" alt="image-20220220192406216"></p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为<strong>字符集</strong>。</p>
<p>但是串的基本操作和线性表却有很大差别。<font color="#ff000">在线性表的基本操作中，大多以“单个元素”作为操作对象</font>。如：在线性表中查找某个元素、求取某个元素、在某个位置上插入一个元素和删除一个元素等；而<font color="#ff000">在串的基本操作中，通常以“串的整体”作为操作对象</font>，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。</p>
<h3 id="串的基本概念"><a href="#串的基本概念" class="headerlink" title="串的基本概念"></a>串的基本概念</h3><p>**串(string)**也称字符串，是由零个或多个字符组成的有限序列。一般记为$S$ = “$a_1a_2…a_n$”。</p>
<ul>
<li>$S$是串的名字</li>
<li>引号里面是串的内容</li>
<li>$a_i$是串的第$i$个字符</li>
<li>串中字符个数$n$为串长，$n=0$为空串</li>
</ul>
<p>**子串(substring)**：一个串中任意个连续字符组成的子序列（含空串）称为该串的子串。</p>
<p><strong>真字串</strong>：非空且不为自身的字串。</p>
<p><strong>字符在串中的位置</strong>：</p>
<p><strong>子串在主串中的位置</strong>：以子串的第一个字符在主串中出现的位置表示。</p>
<p><strong>前缀</strong>：起始于位置1的字串</p>
<p><strong>后缀</strong>：终止于位置n的字串</p>
<p><strong>真前缀和真后缀</strong>：字符串本身之外的所有非空前缀和后缀，分别称为真前缀和真后缀。</p>
<p><strong>串相等</strong>：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。</p>
<p><strong>C标准函数库</strong> #include &lt;string. h&gt;  <strong>C++</strong> #include &lt;cstring&gt;</p>
<ul>
<li>求串长 <code>int strlen(char *s);</code></li>
<li>串复制 <code>char* strcpy(char*s1,char*s2);</code></li>
<li>串拼接 <code>char* strcat(char*s1,char*s2);</code></li>
<li>串比较 <code>int strcmp(char*s1,char*s2;</code></li>
<li>定位 <code>char* strchr(char*s, char c);</code></li>
<li>右定位 <code>char* strrchr(char*s, char c);</code></li>
<li>求子串 <code>char* strstr(const char*str1, const char*str2);</code></li>
</ul>
<h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><hr>
<p><strong>行结构</strong></p>
<p><strong>定长顺序存储</strong>：按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，通常用定长字符数组来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSTRLEN 1000		<span class="comment">// 定义最长串长1000</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[MAXSTRLEN]; <span class="comment">// 存放字符</span></span><br><span class="line">    <span class="keyword">int</span> length;				<span class="comment">// 串的实际长度</span></span><br><span class="line">&#125;SqString;</span><br></pre></td></tr></table></figure>

<p><font color="#00f">注意：隐式存储：在串值后面加一个不计入串长的结東标记字符，如C语言中的”0”。此时串长为隐含值，不便于实现涉及串长的操作</font></p>
<hr>
<p><strong>堆结构</strong></p>
<p><strong>堆分配存储</strong>：仍以一组地址连续的存储单元存放串值，但存储空间是在程序执行过程中动态分配而得。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* data;		<span class="comment">//若是非空串，则按串实际长度分配存储区，否则data为NULL</span></span><br><span class="line">    <span class="keyword">int</span> length;		<span class="comment">//串长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>块链存储</strong></p>
<p>串采用链式存储结构存储时称为<strong>链串</strong>。链串中的一个结点可以存储多个字符。通常将链串中<strong>每个结点所存储的字符个数称为结点大小</strong>。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171852499.png" alt="image-20220220210247787"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE 80	<span class="comment">//可由用户定义的结点大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>	//自定义结点（数据元素）</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data[CHUNKSIZE];	<span class="comment">//存放字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>* <span class="title">next</span>;</span>		<span class="comment">//指针域</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Chunk *head, *tail;		<span class="comment">//串的头指针和尾指针</span></span><br><span class="line">    <span class="keyword">int</span> length;				<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure>



<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p><strong>模式匹配</strong>：子串在主串中的定位运算(index)。设S和T是给定的两个串，在主串S中查找子串T (T也称为模式串) 的过程称为模式匹配。</p>
<p><strong>匹配结果</strong></p>
<ul>
<li>匹配成功：即在主串S中找到一个模式串T。T是S的子串，返回T在S中第一次出现的位置。</li>
<li>匹配不成功：即主串S中不存在模式串T。T不是S的子串，返回0</li>
</ul>
<p><strong>模式匹配的算法</strong></p>
<ul>
<li>朴素算法——<strong>BF(Brute- Force)算法</strong></li>
<li>快速算法——<strong>KMP算法</strong></li>
</ul>
<hr>
<h4 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h4><p>采用穷举策略，基本思想：</p>
<ul>
<li><p>从主串S的第1个字符开始和模式串T的第1个字符进行比较</p>
</li>
<li><p>若相等，继续比较两者的后续字符；</p>
</li>
<li><p>若不等，从主串S的下ー字符开始和模式T的第一个字符进行比较</p>
</li>
<li><p>直到T中的每个字符依次和S中的一个连续的字符序列相等，则匹配成功，返回T在S中第一次出现的位置，否则匹配失败，返回0。</p>
</li>
</ul>
<p>主串指针回溯，效率低。</p>
<p><strong>BF算法</strong>的**C/C++**实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S：主串  T：模式串  sLen：S的长度  tLen：T的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BF</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">char</span> T[], <span class="keyword">int</span> sLen, <span class="keyword">int</span> tLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; sLen &amp;&amp; j &lt; tLen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == T[j]) &#123; ++i; ++j; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; i = i - j + <span class="number">1</span>; j = <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == tLen) <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>设计思想：</p>
<p>每当出现失配时，指针不回溯，而是利用已经得到的“部分匹配”结果将模式串向右“滑动”尽可能远的一段距离后，继续<br>比较。从而提高算法的效率。</p>
<p><strong>示例</strong>：主串 $S=$ “$ababcabcacbab$” ，模式串$T=$ “$abcac$” 。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171853468.png" alt="image-20220220215002839"></p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171853639.png" alt="image-20220220215715609"></p>
<p><font color="#00f">问题一：某趟在 $S_i$ 和 $T_j$ “失配”时，模式串”向右滑动”的可行距离有多远，即下一步 $S_i$ 应该与模式串中的哪个字符比较？</font></p>
<p>设模式串最远滑动到第 $k$ 个字符，此时要满足：（下面字符串下标从1开始，在程序中一般下标一般是0开始）</p>
<p>$T_1$ ~ $T_{k-1}$ $=$ $S_{i-k+1}$ ~ $S_{i-1}$   和    $T_{j-k+1}$ ~ $T_{j-1}$ $=$ $S_{i-k+1}$ ~ $S_{i-1}$ </p>
<p>联立得：$T_1$ ~ $T_{k-1}$ $=$ $T_{j-k+1}$ ~ $T_{j-1}$  $k=max{k|1&lt;k&lt;j且T_1…T_{k-1}=T_{j-k+1}…T_{j-1}}$</p>
<p>即：模式中的前$k-1$个字符（最大真前缀）与模式中$T_j$字符前面的$k-1$个字符（最大真后缀）相等时，模式$T$就可以向右”滑动”至使$T_k$和$S_i$对准，继续向右进行比较即可。</p>
<p><font color="#00f">问题二：求$k$值?</font></p>
<ol>
<li><p>$k$和$j$存在函数关系，模式串中的每一个$T_j$都对应一个$k$值，由当前失配位置$j$,可以计算出滑动位置$k$;</p>
</li>
<li><p>滑动位置$k$仅与模式串$T$有关，因此可以预先为模式串设定一个next数组，若令<code>next[j]=k</code>,则<code>next[j]</code>表明当模式串中的第$j$个字符与主串中相应字符“失配”时，模式串中需要重新和主串中该字符进行比较的字符的位置。</p>
</li>
</ol>
<p>$$ next[j]=\begin{cases} -1 \quad\quad\quad j=0 \ max{k|0&lt;k&lt;j且T_0…T_{k-1}=T_{j-k+1}…T_{j-1}} \ 0 \quad\quad\quad 其他情况 \end{cases}$$</p>
<p>计算<code>next[j]</code></p>
<ul>
<li><p><code>next[0] = -1</code> ，第0个字符不等时，前面没有字符，$i$后移，$j$还是0</p>
</li>
<li><p><code>next[1] = 0</code>，第1个字符不等时，前面只有第0个字符，$i$不变，$j$变1</p>
</li>
<li><p><code>next[j] = k</code>，说明$T_0…T_{k-1}=T_{j-k+1}…T_{j-1}$，则<code>next[j+1]</code>有两种可能</p>
<ul>
<li><p>1、$T_k = T_j$ ：<code>next[j+1] = next[j] + 1 = k + 1</code></p>
</li>
<li><p>2、$T_k\neq T_j$：此时可以把求next函数值问题看成是一个模式匹配问题，整个模式串即是主串又是模式串。设$k’=next[k]$，将模式向右滑动，将$T_j$与$T_k’$进行比较。此时仍会出现两种情况</p>
<ul>
<li>$T_k’ = T_j$ ：与情况①类似，$next[j+1]=k’+1$ </li>
<li>$T_k’\neq T_j$：与情况②类似，重复②的过程，直到$T_j$与模式中某个字符匹配成功或者不存在可匹配的子串，则$next[j+1]=0$。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例：模式$T =$ “$abaababc$”</p>
<table>
<thead>
<tr>
<th>sub</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>T</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>b</td>
<td>c</td>
</tr>
<tr>
<td>next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>2</td>
</tr>
</tbody></table>
<p>求<strong>next</strong>的**C/C++**实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T是模式串，tLen是T的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">char</span> T[], <span class="keyword">int</span> next[], <span class="keyword">int</span> tLen)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; tLen - <span class="number">1</span>)	<span class="comment">// 第j个数决定j+1，所以tLen减1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || T[j] == T[k]) &#123;</span><br><span class="line">			++k; ++j;</span><br><span class="line">			next[j] = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>C++<strong>测试</strong>next</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> T[] = <span class="string">&quot;abaababc&quot;</span>;  <span class="comment">// -1 0 0 1 1 2 3 2</span></span><br><span class="line">    <span class="comment">// 计算T的大小，注意：动态数组无法用sizeof()计算大小</span></span><br><span class="line">	<span class="keyword">int</span> tLen = <span class="built_in"><span class="keyword">sizeof</span></span>(T) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) - <span class="number">1</span>; <span class="comment">// C风格字符串尾还有一个&#x27;\0&#x27;，所以长度是9不是8，要减1</span></span><br><span class="line">	<span class="comment">//int next[8] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="keyword">int</span>* next = <span class="keyword">new</span> <span class="keyword">int</span>[tLen];</span><br><span class="line">	<span class="built_in">getnext</span>(T, next, tLen);	<span class="comment">// 上面的next函数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">		cout &lt;&lt; next[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] next;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>KMP算法</strong>的**C/C++**实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S：主串  T：模式串  next：滑动到的字符下标  sLen：S的长度  tLen：T的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">char</span> T[], <span class="keyword">int</span> next[], <span class="keyword">int</span> sLen, <span class="keyword">int</span> tLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; tLen)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == T[j]) &#123;</span><br><span class="line">			++i; ++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j == tLen) <span class="keyword">return</span> i - j;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>C++<strong>测试</strong>KMP算法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> T[] = <span class="string">&quot;abaababc&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> S[] = <span class="string">&quot;abacabaababcabc&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> tLen = <span class="built_in"><span class="keyword">sizeof</span></span>(T) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> sLen = <span class="built_in"><span class="keyword">sizeof</span></span>(S) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>* next = <span class="keyword">new</span> <span class="keyword">int</span>[tLen];</span><br><span class="line">	<span class="built_in">getnext</span>(T, next, tLen);		<span class="comment">// 前面的getnext函数</span></span><br><span class="line">	<span class="keyword">int</span> pos = <span class="built_in">KMP</span>(S, T, next, sLen, tLen);	<span class="comment">// 前面的KMP函数</span></span><br><span class="line">	cout &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] next;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>next函数的改进</strong></p>
<p>如果<code>next[j]=k</code>且$T_k=T_j$，当 $S_i≠T_j$失配时，不需要再和$T_k$进行比较，而直接和$T_{next[k]}$进行比较，即应使<code>next[j]=next[k]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T是模式串，tLen是T的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">char</span> T[], <span class="keyword">int</span> next[], <span class="keyword">int</span> tLen)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; tLen - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || T[j] == T[k]) &#123;</span><br><span class="line">			++k; ++j;</span><br><span class="line">            <span class="keyword">if</span>(T[j] != T[k]) next[j] = k;</span><br><span class="line">            <span class="keyword">else</span> next[j] = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p><strong>数组(Array)<strong>：是元素数量和元素类型固定的有序序列，可以将它看成是</strong>线性表的推广</strong>。</p>
<p><strong>一维数组</strong>：是$n(n&gt;1)$个相同类型数据元素构成的有限序列，其逻辑表示为 $A = (a_0,a_1,…,a_{n-1})$ 。</p>
<p><strong>二维数组</strong>：可以看成是每个数据元素都是相同类型的一维数组的一维数组。</p>
<p>$$A_{mn}\left[<br>\begin{matrix}<br>a_{0,0} &amp; a_{0,1} &amp;\cdots &amp; a_{0,n-1} \ a_{1,0} &amp; a_{1,1} &amp;\cdots &amp; a_{1,n-1} \ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \ a_{m-1,0} &amp; a_{m-1,1} &amp;\cdots &amp; a_{m-1,n-1} \end{matrix} \right]$$</p>
<p>$$可以看成长度为m的线性表$$ </p>
<p>$$B = (b_0,b_2,…b_{m-1}) \quad\quad 其中b_i = (a_{i,0},…a_{i,n-1})$$</p>
<p><strong>n维数组</strong>：可以看成是数据元素为$n-1$维数组的一维数组。</p>
<h3 id="数组的顺序存储"><a href="#数组的顺序存储" class="headerlink" title="数组的顺序存储"></a>数组的顺序存储</h3><p><strong>数组的顺序存储</strong>：由于数组一般不做插入或刪除操作，因此，通常采用顺序存储结构，将数组的所有元素存储在一块地址连续的内存单元中。</p>
<ul>
<li><p><strong>一维数组的顺序存储</strong>：对于一维数组$A=(a_0,a_1,…a_{n-1})$可以直接按照元素顺序依次存储到一块地址连续的内存单元中。</p>
<p><strong>数据元素存储位置计算公式</strong>：一旦$a_0$的存储地址$LOC(a_0)$确定，并假设每个数据元素占用$L$个存储单元，则任一数据元素$a_i$的存储地址$LOC(a_i)$就可由以下公式求出：$LOC(a_i)=LOC(a_0)+i*L \quad (0&lt;=i&lt;n)$ </p>
</li>
<li><p><strong>二维数组的顺序存储</strong>：对于一个$m$行$n$列的二维数组$A_{m,n}$,其存储方式有两种</p>
<ul>
<li><p><strong>行优先</strong>——以行序为主序的存储： $$A=((\underbrace{a_{0,0},a_{0,1},…a_{0,n-1}}<em>{第0行}),(\underbrace{a</em>{1,0},a_{1,1},…a_{1,n-1}}<em>{第1行}),…,(\underbrace{a</em>{m-1,0},a_{m-1,1},…a_{m-1,n-1}}_{第m-1行}))$$ </p>
<p><strong>数据元素存储位置计算公式</strong>：$LOC(a_{i,j})=LOC(a_{0,0})+(i*n+j)*L \quad (0&lt;=i&lt;m,0&lt;=j&lt;n)$  </p>
</li>
<li><p><strong>列优先</strong>——以列序为主序的存储 $$A=((\underbrace{a_{0,0},a_{1,0},…a_{m-1,0}}<em>{第0列}),(\underbrace{a</em>{0,1},a_{1,1},…a_{m-1,1}}<em>{第1列}),…,(\underbrace{a</em>{0,n-1},a_{1,n-1},…a_{m-1,n-1}}_{第n-1行}))$$ </p>
<p><strong>数据元素存储位置计算公式</strong>：$LOC(a_{i,j})=LOC(a_{0,0})+(j*m+i)*L \quad (0&lt;=i&lt;m,0&lt;=j&lt;n)$  </p>
</li>
</ul>
</li>
</ul>
<h3 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h3><p><strong>矩阵的压缩存储</strong>：</p>
<ul>
<li>为多个值相同的非零元只分配一个存储空间</li>
<li>对零元不分配空间</li>
</ul>
<p><strong>需压缩存储的两类矩阵</strong>：</p>
<ul>
<li><p><strong>特殊矩阵</strong>：值相同的元素或零元素在矩阵中的分布有一定规律。如：<strong>对称矩阵、三角矩阵、对角矩阵</strong></p>
</li>
<li><p><strong>稀疏矩阵</strong>：非零元较零元少，且分布没有一定规律。</p>
</li>
</ul>
<h4 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h4><p><strong>对称矩阵</strong>：若一个$n$阶方阵$A$中的元素满足$a_{i,j}=a_{j,i}(0≤i,j&lt;n)$,则称其为$n$阶对称矩阵。</p>
<ul>
<li><p><strong>压缩存储</strong>：以行序为主序存储下三角+主对角线的元素。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171853956.png" alt="image-20220221144919380"></p>
<p><strong>压缩地址计算公式</strong>：$a_{i,j} = B_k \quad k = i*(i+1)/2+j \quad (i&lt;=j)$ </p>
</li>
</ul>
<p><strong>三角矩阵</strong>：分为上三角矩阵和下三角矩阵。</p>
<ul>
<li><p><strong>上三角矩阵</strong>是指矩阵的下三角（不包括对角线）中的元素均为常数$c$或$0$的$n$阶方阵。</p>
</li>
<li><p><strong>下三角矩阵</strong>是指矩阵的上三角（不包括对角线）中的元素均为常数$c$或$0$的$n$阶方阵。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171853586.png" alt="image-20220221145944262"></p>
<p><strong>下三角矩阵的压缩存储方法</strong>：以行序为主序存储下三角+主对角线的元素，最后用一个存储单元存储常数$c$,并<br>将压缩结果存储在一维数组$B$中。</p>
<p><strong>压缩地址计算公式</strong>：$k=\begin{cases} i*(i+1)/2+j &amp; i&lt;=j \ n*(n+1)/2 &amp; i&gt;j \quad常数c\end{cases}$</p>
</li>
</ul>
<p><strong>对角矩阵</strong>：若一个$n$阶方阵$A$满足其所有的非零元素集中在以主对角线为中心的带状区域中，则称其为$n$阶对角矩阵。其主对角线上、下方各有$b$条非零元素构成的次对角线，称$b$为矩阵半带宽，$(2b+1)$为矩阵的带宽。</p>
<img src="https://github.com/yanglinqi107/images/raw/master/res/202205171853381.png" alt="image-20220221151234876" style="zoom:80%;">

<ul>
<li><p><strong>三对角矩阵</strong>：当$b=1$时</p>
<p><strong>压缩存储</strong>：以行序为主序将$A$带宽中的数据存入一维数组中。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171854066.png" alt="image-20220221151615976"></p>
<p><strong>压缩地址计算公式</strong>：$k=2*i+j$ </p>
</li>
</ul>
<h4 id="稀疏矩阵的压缩存储"><a href="#稀疏矩阵的压缩存储" class="headerlink" title="稀疏矩阵的压缩存储"></a>稀疏矩阵的压缩存储</h4><p><strong>稀疏矩阵</strong>：假设在一个$m\times n$的矩阵中有$t$个非零元，令$δ=t/(m\times n)$,$δ$称为稀疏因子，通常认为$δ≤0.05$时该矩阵为稀疏矩阵。</p>
<p><strong>压缩存储方法</strong>：只存储非零元素。稀疏矩阵中的每一个非零元素需由<strong>三元组</strong>$(i,j,a_{i,j})$唯一确定，所有非零元素（通常以行序为主序顺序排列）构成<strong>三元组线性表</strong>（筒称<strong>三元组表</strong>）。</p>
<p>稀疏矩阵可由表示非零元的<strong>三元组表</strong>以及其<strong>行列数</strong>来唯一确定。</p>
<p><strong>三元组表的两种存储方法</strong>：顺序表表示法、十字链表表示法。</p>
<p><strong>三元组顺序表存储表示</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j; 	<span class="comment">// 第i行j列</span></span><br><span class="line">    ElemType e;	<span class="comment">// e:非0值</span></span><br><span class="line">&#125;Triple;	<span class="comment">//三元组类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Triple data[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> mu, nu, tu;	<span class="comment">// mu行，nu列，tu个非0元</span></span><br><span class="line">&#125;TSMarix;	<span class="comment">//稀疏矩阵</span></span><br></pre></td></tr></table></figure>



<p><strong>十字链表</strong>：每个非零元用一个结点表示，结点中除了<font color="#00f">表示非零元所在的行、列和值的三元组$(i,j,e)$</font>外，增加<font color="#00f">两个指针域</font>。<font color="#00f">行指针域(right)</font>：用来指向本行中下一个非零元素；<font color="#00f">列指针域(down)</font>：用来指向本列中下一个非零元素。稀疏矩阵中同一行的非零元通过向右的 right指针链接成了一个线性链表。同一列的非零元也通过down指针链接成了ー个线性链表。每个非零元既是第$i$行链表中的一个结点，又是第$j$列链表中的一个结点，相当于处在一个十字交叉路口，故称这样的存储结构为十字链表。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171855916.png" alt="image-20220221154547201"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j;	<span class="comment">// 该非0元素的行和列下标</span></span><br><span class="line">    ElemType e;	<span class="comment">// 同上面的自定义，就是int型</span></span><br><span class="line">    stuct OLNode *right, *down;	<span class="comment">// 非0元素所在行表和列表的后继</span></span><br><span class="line">&#125;OLNode, *OLink;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    OLink *rhead, *chead;	<span class="comment">// 行和列链表头指针向量</span></span><br><span class="line">    <span class="keyword">int</span> mu, nu, tu;	<span class="comment">// 稀疏矩阵的行数、列数、非0元个数</span></span><br><span class="line">&#125;CrossList;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171857101.png" alt="image-20220221155156147"></p>
<h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><h3 id="广义表的基本概念"><a href="#广义表的基本概念" class="headerlink" title="广义表的基本概念"></a>广义表的基本概念</h3><p>**广义表(Generalized Lists)**：广义表是线性表的推广，是$n$个数据元素$(a_1,a_2,…,a_i,…,a_n)$的有限序列，但不同的是，广义表中的$a$既可以是单个元素，还可以是一个广义表，通常记作：$LS=(a_1,a_2,…,a_i,…,a_n)$ </p>
<ul>
<li>LS是广义表的名字</li>
<li>$n$是广义表的长度，$n=0$时称为空表</li>
<li>若$a$是单个元素，则称$a$为广义表$LS$的<strong>原子(atom)<strong>，若$a$是一个广义表，则称$a$是广义表$LS$的</strong>子表(sublist)</strong></li>
<li>为了区别原子和子表，通常用大写字母表示广义表的名称，用小写字母表示原子。</li>
</ul>
<p><strong>广义表的长度</strong>：广义表最外层包含的元素个数</p>
<p><strong>广义表的深度</strong>：广义表中所含括号的重数</p>
<p><strong>广义表的表头和表尾</strong>：当广义表<strong>非空</strong>时，即$LS=(a_1,a_2,…,a_n)$，第一个表元素$a_1$称为广义表的**表头(head)<strong>，其余元素组成的表$(a_2,…,a_n)$称为广义表的</strong>表尾(tail)**。</p>
<p>示例：</p>
<ul>
<li>$A=(a,(b,c,(d)),d,(d))$：长度4，深度3，$head=(a)$，$tail=((b,c,(d)),d,(d))$</li>
<li>$B=()$：长度0，深度1，空表无表头表尾</li>
<li>$C=(e)$：长度1，深度1，$head=(e)$，$tail=()$ </li>
<li>$E=(a,E)$：递归的表，长度2，深度无穷值，$head=()$，$tail=(E)$  </li>
</ul>
<h3 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h3><p><strong>广义表的存储结构</strong>：由于广义表$(a_1,a_2,…,a_n)$是一种<strong>递归的数据结构</strong>，且其中的数据元素可以具有不同的结构(或是原子，或是列表)，因此难以用顺序存储结构表示，通常采用<strong>链式存储结构</strong>，每个数据元素可用一个结点表示，分别为表结点和原子结点。</p>
<p><strong>链式存储方法</strong>：1）头尾链表表示法  2）扩展线性链表表示法</p>
<p><strong>头尾链表表示法</strong>：</p>
<ul>
<li><p>存储方法：任一非空列表可以分解为表头和表尾，反之，一对确定的表头和表尾可以唯一确定一个广义表。</p>
</li>
<li><p>原子结点：由标志域和值域组成。</p>
</li>
<li><p>表结点：由标志域、指示表头的指针域和指示表尾的指针域组成</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171901464.png" alt="image-20220221165024995"></p>
<p>$tag=0$，原子结点；$tag=1$，表/子表结点</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>ATOM, LIST&#125; ElemTag;	<span class="comment">// 0 原子 1 子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemTag tag;	<span class="comment">// 标志域，公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="comment">//union类似于enum。不同的是enum实质上是int类型的，而union可以用于所有类型</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>	// 原子结点和表结点的联合部分</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        AtomType atom;	<span class="comment">//atom是原子结点的值域，AtomType由用户自定义</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>, *<span class="title">tp</span>;</span> &#125;ptr;	<span class="comment">// 表结点的表头和表尾指针域</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;*GList;	<span class="comment">//广义表类型</span></span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171901233.png" alt="image-20220221170301844"></p>
<p>除空表的表头指针为空外，任何非空广义表的表头指针均指向一个表结点，且其hp指向该表的表头，tp指向该表的表尾</p>
<p><strong>扩展线性链表表示法</strong>：</p>
<ul>
<li><p>表结点：由标志域、指示表头的指针域和指示下一元素的指针域组成。</p>
</li>
<li><p>原子结点：由标志域、值域和指示下一元素的指针域组成。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171901741.png" alt="image-20220221170919342"></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>ATOM, LIST&#125; ElemTag; <span class="comment">// 0 原子  1 子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemTag tag;	<span class="comment">// 标志域，分原子结点和表结点</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>		// 原子结点和表结点的联合部分</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        AtomType atom; <span class="comment">//atom是原子结点的值域，AtomType由用户自定义</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>;</span> <span class="comment">// 表结点的表头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">tp</span>;</span>	<span class="comment">//相当于线性链表的next,指向下一个元素结点</span></span><br><span class="line">&#125;*GList;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171901601.png" alt="image-20220221171457502"></p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>**树(Tree)**是$n(n&gt;=0)$个结点的有限集。</p>
<p>在任意一棵非空树中<br>(1)有且仅有一个根结点<br>(2)除根结点外，其余结点可分为$m(m&gt;=0)$个互不相交的有限集$T_1,T_2,…,T_m$,其中每个集合本身又是一棵树，称为根的子树。</p>
<p><strong>基本术语</strong>：</p>
<ul>
<li>结点<ul>
<li>父结点、子结点</li>
<li>兄弟、堂兄弟</li>
<li>分枝结点、叶子</li>
</ul>
</li>
<li>结点的度：一个结点拥有子树的个数</li>
<li>树的度</li>
<li>祖先、子孙</li>
<li>层数</li>
<li>树的高度或深度</li>
<li>路径和路径长度</li>
<li>有序树与无序树</li>
</ul>
<p><strong>森林</strong>是$m(m&gt;=0)$棵互不相交的树的集合。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>双亲数组存储表示</p>
<img src="https://github.com/yanglinqi107/images/raw/master/res/202205171901556.png" alt="image-20220222145320646" style="zoom:80%;">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n0 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dataType char</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> &#123;</span></span><br><span class="line">    dataType data;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> <span class="title">t</span>[<span class="title">n0</span>+1];</span></span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>孩子链表存储表示</p>
<img src="https://github.com/yanglinqi107/images/raw/master/res/202205171901916.png" alt="image-20220222150000605" style="zoom:80%;">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dataType char</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sub;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> &#123;</span></span><br><span class="line">    dataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">children</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> <span class="title">t</span>[<span class="title">n</span> + 1];</span></span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>孩子——兄弟链存储表示</p>
<img src="https://github.com/yanglinqi107/images/raw/master/res/202205171902798.png" alt="image-20220222152052142" style="zoom:80%;">





<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树分类"><a href="#二叉树分类" class="headerlink" title="二叉树分类"></a>二叉树分类</h3><p><strong>二叉树</strong>：由一个根结点和两棵互不相交的、分别称为这个根的<strong>左子树</strong>和<strong>右子树</strong>的二叉树组成。</p>
<p><strong>满二叉树</strong>：有$2^k-1 \quad(k&gt;0)$ 个结点的二叉树，即所有的叶子都在同一层。</p>
<p><strong>完全二叉树</strong>：至多只有最下面的两层结点度数可以小于2，并且最下面一层的结点都集中在该层最左边的若干位置上</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171902610.png" alt="image-20220221212456927"></p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul>
<li>在二叉树的第$i(i&gt;0)$层上至多有$2^{i-1}$个结点。</li>
<li>深度为$k$的二叉树中至多有$2^k-1$个结点$(k&gt;0)$</li>
<li>对任何二叉树，若其终端结点数为$n0$，度数为2的结点数为$n2$，则$n0 = n2 + 1$。</li>
<li>有$n$个结点的完全二叉树的深度为 $d+1 \quad d为&lt;=log_2n的最大整数$ </li>
<li>对有$n$个结点的完全二叉树按层序从$1$开始编号，对任一结点$i$ $(1&lt;=i&lt;=n)$：<ul>
<li>$i=1$是根结点；$i&gt;1$，父节点是$i/2$ </li>
<li>$2<em>i&lt;=n$，左孩子是$2</em>i$</li>
<li>$2<em>i+1&lt;=n$，左孩子是$2</em>i$，右孩子是$2*i+1$ </li>
</ul>
</li>
</ul>
<h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><ul>
<li>顺序存储</li>
<li>二叉链存储<ul>
<li>静态二叉链</li>
<li>动态二叉链</li>
</ul>
</li>
</ul>
<p><strong>顺序存储</strong>：用数组，按完全二叉树的顺序存储；对于一般的二叉树，在二叉树中补上虚拟结点使其成为完全二叉树。注意数组空出第0位。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171902143.png" alt="image-20220221222838480"></p>
<p><strong>二叉链存储</strong>：每个结点包括数据域和指针域。数据域存储结点的数据，指针域有两个分别指向左孩子和右孩子的指针。</p>
<img src="https://github.com/yanglinqi107/images/raw/master/res/202205171903316.png" alt="image-20220221223915686" style="zoom:80%;">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">btnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    dataType data;	<span class="comment">// 用户定义的数据类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">btnode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTnode, *BiTree;</span><br></pre></td></tr></table></figure>

<p><strong>静态二叉链</strong></p>
<img src="https://github.com/yanglinqi107/images/raw/master/res/202205171903708.png" alt="image-20220221225133876" style="zoom:80%;">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbtnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    dataType data;		<span class="comment">//数值字段</span></span><br><span class="line">    <span class="keyword">int</span> llink, rlink;	<span class="comment">//指针字段</span></span><br><span class="line">&#125;tree[n + <span class="number">1</span>];	<span class="comment">// n：二叉树的结点个数，不能这样直接创建数组tree[n+1]</span></span><br></pre></td></tr></table></figure>



<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p><strong>二叉树的遍历</strong>：按某条搜索路径访问二叉树中每一个结点，使得每个结点被访问一次且仅被访问一次。</p>
<p>遍历方法：<strong>先序遍历、中序遍历、后序遍历、层次遍历</strong>。</p>
<p><strong>先序遍历</strong>：根——&gt;左子树——&gt;右子树</p>
<p><strong>中序遍历</strong>：左子树——&gt;根——&gt;右子树</p>
<p><strong>后序遍历</strong>：左子树——&gt;右子树——&gt;根</p>
<p><strong>层次遍历</strong>：按层次，每层从左到右遍历</p>
<p>示例：</p>
<img src="https://github.com/yanglinqi107/images/raw/master/res/202205171903117.png" alt="image-20220221230924269" style="zoom:80%;">

<p>注：已知二叉树的先序遍历和中序遍历，则该二叉树能唯一确定</p>
<h3 id="遍历算法实现"><a href="#遍历算法实现" class="headerlink" title="遍历算法实现"></a><strong>遍历算法实现</strong></h3><p><strong>层次遍历</strong>伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initqueue(q);	<span class="comment">// 创建一个空队列</span></span><br><span class="line">    enqueue(q, T);		<span class="comment">// T入队</span></span><br><span class="line">    <span class="keyword">while</span>(!empty(q))</span><br><span class="line">    &#123;</span><br><span class="line">        dequeue(q, T);	<span class="comment">// q的队首结点出队给T</span></span><br><span class="line">     	visite(T-&gt;data);	<span class="comment">//访问结点T;</span></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;lchild) enqueue(q, T-&gt;lchild); <span class="comment">//如果T存在左孩子，左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;rchild) enqueue(q, T-&gt;rchild); <span class="comment">//如果T存在右孩子，右孩子入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归实现</strong></p>
<ul>
<li><p><strong>先序遍历</strong>递归伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先序遍历以T为根的二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        visite(T-&gt;data);		<span class="comment">//访问根结点</span></span><br><span class="line">        preOrder(T-&gt;lchild);	<span class="comment">//先序遍历左子树</span></span><br><span class="line">        preOrder(T-&gt;rchild);	<span class="comment">//先序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>中序遍历</strong>递归伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历以T为根的二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(T) &#123;</span><br><span class="line">        inOrder(T-&gt;lchild);	<span class="comment">//中序遍历左子树</span></span><br><span class="line">        visite(T-&gt;data);	<span class="comment">//访问根节点</span></span><br><span class="line">        inOrder(T-&gt;rchild);	<span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>后序遍历</strong>递归伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 后序遍历以T为根的二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(T) &#123;</span><br><span class="line">        postOrder(T-&gt;lchild);	<span class="comment">//后序遍历左子树</span></span><br><span class="line">        postOrder(T-&gt;rchild);	<span class="comment">//后序遍历右子树</span></span><br><span class="line">        visite(T-&gt;data);		<span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>非递归实现</strong></p>
<ul>
<li><p><strong>先序遍历</strong>的非递归伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initstack(s);	<span class="comment">// 创建一个空栈s</span></span><br><span class="line">    <span class="keyword">while</span>(T || !empty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T) &#123;	<span class="comment">// 若T不空，访问T</span></span><br><span class="line">        	visite(T-&gt;data);	<span class="comment">//访问根结点</span></span><br><span class="line">            push(s, T);			<span class="comment">//T入栈</span></span><br><span class="line">            T = T-&gt;lchild;		<span class="comment">//沿左子树遍历</span></span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pop(s, T);			<span class="comment">//栈顶元素出栈给T</span></span><br><span class="line">            T = T-&gt;rchild;		<span class="comment">//沿右子树遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>中序遍历</strong>的非递归伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initstack(s);	<span class="comment">// 创建一个空栈s</span></span><br><span class="line">    <span class="keyword">while</span>(T || !empty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T) &#123; 	<span class="comment">// 若T不空，T入栈，出栈的时候访问</span></span><br><span class="line">            push(s,T);	</span><br><span class="line">            T = T-&gt;lchild;	<span class="comment">//沿左子树遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pop(s, T);		<span class="comment">//栈顶元素出栈给T</span></span><br><span class="line">            visite(T-&gt;data);</span><br><span class="line">            T = T-&gt;rchild;	<span class="comment">//沿右子树遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>后序遍历</strong>的非递归伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initstack(s);</span><br><span class="line">    initstack(tag);	<span class="comment">// 存放0和1，用于判断是否读取s出栈结点的data，1表示从左子树回退，0表示从右子树回退</span></span><br><span class="line">    <span class="keyword">while</span>(T || !empty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T) &#123;</span><br><span class="line">            push(s, T);</span><br><span class="line">            push(tag, LEFT);	<span class="comment">//LEFT是1</span></span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        pop(s, T);				<span class="comment">//将s中的栈顶结点弹给T</span></span><br><span class="line">        pop(tag, flag);			<span class="comment">//将T对应的标识弹出</span></span><br><span class="line">        <span class="keyword">if</span>(flag == LEFT) &#123;		<span class="comment">//如果从左子树回来</span></span><br><span class="line">            push(tag, RIGHT);	<span class="comment">//标识改为右子树入栈</span></span><br><span class="line">            push(s, T);			<span class="comment">//T也入栈</span></span><br><span class="line">            T = T-&gt;rchild;		<span class="comment">//T指向右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;					<span class="comment">//如果从右子树回来</span></span><br><span class="line">            visite(T-&gt;data);	<span class="comment">//读取数据</span></span><br><span class="line">            T = <span class="literal">NULL</span>;			<span class="comment">// T值空，继续弹栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><strong>遍历二叉树</strong>是按一定的规则将二叉树中结点排列成一个线性序列；这实际上是把一个非线性结构进行线性化的操作。</p>
<p><strong>线索二叉树</strong>也是一种用来表示二叉树的二叉链表。在这种二叉链表中，每个结点的空的左孩子指针域中放入了在某种遍历次序下该结点的前驱结点的地址；每个结点的空的右孩子指针域中放入了在这种遍历次序下该结点的后继结点的地址。这种附加的指针值称为<strong>线索</strong>。给二叉树的二叉链表存储结构加上线索的过程称为<strong>线索化</strong>二叉树。这个过程可通过对二叉树进行相应次序的遍历来实现。根据遍历方法的不同，线索二叉树一般分<strong>前序线索二叉树</strong>、<strong>中序线索二叉树</strong>和<strong>后序线索二叉树</strong>三种。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171906944.png" alt="image-20220222202712310"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThrTreeNode</span> &#123;</span></span><br><span class="line">   	<span class="comment">// 线索二叉树中每个结点的结构 </span></span><br><span class="line">   	TElemType data;</span><br><span class="line">   	ThrTreeNode *lchild,*rchild;</span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>先序线索二叉树</strong>和<strong>先序线索二叉树链</strong> （先序遍历序列：$abcdfge$）</p>
<p>前驱和后继是按先序的规则来确定的，如图中的$g$前驱指向$f$，后继指向$e$，对应顺序$gfe$</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171906489.png" alt="image-20220222203008574"></p>
<ul>
<li>以上结构构成的二叉链表作为二叉树的存储结构，叫做<strong>线索二叉链</strong></li>
<li>指向结点前驱或后继的指针叫做<strong>线索</strong> </li>
<li>加上线索的二叉树叫<strong>线索二叉树</strong></li>
<li>对二叉树以某种次序遍历使其变为线索二叉树的过程叫做<strong>线索化</strong></li>
</ul>
<p><strong>中序线索二叉树</strong>（中序遍历序列：DGBAEHCF）</p>
<p>前驱和后继是按中序的规则来确定的，如图中的$H$前驱指向$E$，后继指向$C$，对应顺序$EHC$</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171906051.png" alt="image-20220222203352488"></p>
<p><strong>先序遍历</strong>伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(struct ThrTreeNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先序遍历以p为根的线索二叉树</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        visite(p-&gt;data);	<span class="comment">//访问根结点</span></span><br><span class="line">        p = p-&gt;lchild;		<span class="comment">//p指向左孩子或前驱结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中序遍历</strong>伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(struct ThrTreeNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历以p为根的线索二叉树</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild;	<span class="comment">//从根开始找到一个无前驱的结点p</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     	visite(p-&gt;data);	<span class="comment">// 访问根结点</span></span><br><span class="line">        p = p-&gt;rchild;		<span class="comment">// p指向右孩子或后继结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>静态线索二叉链</strong>：$+$：左、右孩子；$-$：前驱、后继线索</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171906374.png" alt="image-20220222210752113"></p>
<h3 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h3><p><strong>二叉树的带权路径长度</strong>：$WPL=\sum_{k=1}^nw_kl_k$ ，其中:</p>
<ul>
<li>$n$：树叶结点的个</li>
<li>$w_k$：第$k$个结点的权</li>
<li>$l_k$：第$k$个叶子到根的路径长度</li>
</ul>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171907706.png" alt="image-20220222161238235"></p>
<p><strong>Huffman树</strong>是一个带权路径长度最小的二叉树，又称<strong>最优二叉树</strong>。构建方法：</p>
<ul>
<li>将${w_1,w_2,…,w_n}$看成$n$个二叉树</li>
<li>选择2个根结点最小的二叉树，构造新的二叉树，重复至剩1个树</li>
</ul>
<p>例：$Z:2,K:7,M:24,C:32,U:37,D:42,L:42,E:120$ </p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171908575.png" alt="image-20220222162202306"></p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171909519.png" alt="image-20220222162223523"></p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171909031.png" alt="image-20220222162328619"></p>
<p><strong>静态三叉链</strong>：</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171909737.png" alt="image-20220222195332551"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 5</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">htnode</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> weight;</span><br><span class="line">    <span class="keyword">int</span> llink, rlink, plink; <span class="comment">// 左孩子 右孩子 双亲</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>Huffman编码</strong></p>
<p>Huffman编码是广泛地用于数据文件压缩的十分有效的编码方法。其压缩率通常在20%~90%之间。Huffman编码算法用字符在文件中出现的频率表来建立一个用0,1串表示各字符的最优表示方式。给出现频率高的字符较短的编码，出现频率较低的字符以较长的编码，可以大大缩短总码长。</p>
<p><strong>前缀码</strong>：对每一个字符规定一个0,1串作为其代码，并要求任一字符的代码都不是其它字符代码的前缀，这种编码称为前缀码。</p>
<p>二叉树C的Huffman编码是：$E:0,U:100,D:101,L:110,C:1110,Z:111100,K:111101,F:11111$ </p>
<h3 id="树、森林转换二叉树"><a href="#树、森林转换二叉树" class="headerlink" title="树、森林转换二叉树"></a>树、森林转换二叉树</h3><p><strong>树转换成二叉树</strong></p>
<img src="https://github.com/yanglinqi107/images/raw/master/res/202205171909051.png" alt="image-20220222153139457">

<p><strong>森林转换成二叉树</strong></p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171910072.png" alt="image-20220222154146235"></p>
<p>树A的先序遍历：oabcdfeg   对应   二叉树B的先序遍历：oabcdfeg</p>
<p>树A的后序遍历：bafdecgo   对应   二叉树B的中序遍历：bafdecgo</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p>**图(Graph)**是一种较线性结构和树更为复杂的数据结构。对于图来说，图中任意两个结点之间都可以直接相关。</p>
<p>图是一个二元组，$G=(V,E)$。其中，  $V$：顶点的有限集, $E$：关系(边)的有限集。</p>
<p>例：<img src="https://github.com/yanglinqi107/images/raw/master/res/202205171910614.png" alt="image-20220222214654118"></p>
<p>无向图  $G1=(V,E)\quad V＝{v_1, v_2, v_3, v_4, v_5}\quad E＝{(v_1,v_2), (v_1,v_4),  (v_2,v_3), (v_2,v_5),  (v_3,v_4), (v_3,v_5)}$ </p>
<p>有向图  $G2=(V,E)\quad V＝{v_1, v_2, v_3, v_4}\quad E＝{&lt;v_1,v_2&gt;, &lt;v_1,v_3&gt;,  &lt;v_3,v_4&gt;, &lt;v_4,v_1&gt;}$ </p>
<p>图是一种网状的数据结构，其中的结点之间的关系是任意的，即图中任何两个结点之间都可能直接相关。</p>
<p><strong>顶点</strong>：图中的数据元素</p>
<p><strong>边</strong>：两个顶点之间的关系。</p>
<ul>
<li>对于无向图，图中的顶点偶对（边）是无序的</li>
<li>而对于有向图，图中的顶点偶对（弧）是有序的<img src="https://github.com/yanglinqi107/images/raw/master/res/202205171910780.png" alt="image-20220222215421328" style="zoom: 67%;"></li>
</ul>
<p><strong>完全图</strong>：有$n(n-1)/2$条边的无向图，即每个结点之间都有且只有一条边。</p>
<p><strong>有向完全图</strong>：有$n(n-1)$条边的有向图。</p>
<p><strong>稠密图</strong>：有很少的边或弧的图。</p>
<p><strong>稀疏图</strong>：有很多的边或弧的图。</p>
<p><strong>权</strong>：与图的边相关的数值。</p>
<p><strong>网</strong>：带权的图。</p>
<p><strong>子图</strong>：设两个图$G＝(V, E)$和$G’=(V’,E’)$，如果$V’\subseteq V$且$E’\subseteq  E$，则称$G’$为$G$的子图。</p>
<img src="https://github.com/yanglinqi107/images/raw/master/res/202205171910228.png" alt="image-20220222222143650" style="zoom:67%;">

<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171910510.png" alt="image-20220222220552674"></p>
<p><strong>邻接点</strong>：</p>
<ul>
<li>对于无向图$G＝(V,E)$，若存在顶点对$(x,y)\in E$，则称顶点$x$和$y$互为邻接顶点。即$x$和$y$相邻接（相关联）。</li>
<li>对于有向图$G＝(V,E)$，若存在顶点对$&lt;x,y&gt;\in E$，则称顶点$x$邻接到顶点$y$，顶点$y$邻接于到顶点$x$。</li>
</ul>
<p><strong>顶点的度</strong>：</p>
<ul>
<li>在无向图中，和该顶点相关联的边的数目称为顶点的度。</li>
<li>在有向图中，若$&lt;x,y&gt;$是一条弧，以$x$为尾的弧的数目称为顶点$x$的<strong>出度</strong>；以$x$为头的弧的数目称为顶点$x$<br>的<strong>入度</strong>。<strong>顶点的度等于该顶点的入度与出度之和</strong>。</li>
</ul>
<p><strong>路径</strong>：  在图$G＝( V, E )$中, 若从顶点 $x$ 出发，经过一些顶点 $v_1, v_2, … , v_m$ 到达顶点$y$。则称顶点序列 $(x,v_1,v_2, … ,V_m, y)$ 为从顶点 $x$ 到顶点 $y$ 的路径。</p>
<p><strong>路径长度</strong>：</p>
<ul>
<li>非带权图的路径长度是指此路径上边的条数。</li>
<li>带权图的路径长度是指路径上各边的权之和。</li>
</ul>
<p><strong>简单路径</strong>：序列中顶点不重复出现的路径。</p>
<p>**回路(环)**：第一个顶点和最后一个顶点相同的路径。</p>
<p>**简单回路(环)**：除第一个和最后一个顶点，其余顶点不重复出现的路径。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171911339.png" alt="image-20220222230204252"></p>
<p><strong>连通</strong>：在无向图中，如果从$x$到$y$存在路径，则称$x$和$y$是连通的。</p>
<p><strong>连通图</strong>：无向图$G$中如果任意两个顶点$x,y$之间都是连通的，则称图$G$是连通图。</p>
<p><strong>强连通图</strong>：有向图$G$中任意两个顶点$x,y$之间都是相互可达的。称图$G$是强连通图。</p>
<p><strong>连通分量</strong>：无向图中的<strong>极大连通子图</strong>（即把原图中任意一个不在子图中顶点加进去，子图从连通变为不连通，则为极大连通子图）。</p>
<p><strong>强连通分量</strong>：有向图中的极大连通子图。</p>
<p><strong>树图</strong>：极小连通子图（无环图），在$n$个顶点的情形下，有$n-1$条边。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171911892.png" alt="image-20220222232125649"></p>
<h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>数组表示法（邻接矩阵）</strong></p>
<p>图需要存储的信息：顶点和边。</p>
<p><strong>邻接矩阵</strong>：表示顶点之间相邻关系的矩阵。$a_{ij}=\begin{cases}1\quad &lt;v_i,v_j&gt;\in E \ 0\quad others \end{cases}$ </p>
<p><strong>网的邻接矩阵</strong>：$A[i][j]=\begin{cases}W_{i,j}\quad &lt;v_i,v_j&gt;\in E \ 0\quad i=j \ \infty \quad others \end{cases}$</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171912797.png" alt="image-20220222234321262"></p>
<p>邻接矩阵的特点：</p>
<ul>
<li>无向图的邻接矩阵一定是一个对称矩阵。</li>
<li>无向图的邻接矩阵的第$i$行（或第$i$列）非零元素（或非$\infty$元素）个数为第$i$个顶点的度$D(v_i)$。</li>
<li>有向图的邻接矩阵的第$i$行非零元素（或非$\infty$元素）个数为第$i$个顶点的出度$OD(v_i)$，第$i$列非零元素（或非$\infty$元素）个数就是第$i$个顶点的入度$ID(v_i)$。</li>
</ul>
<p><strong>邻接表（邻接链表）</strong></p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171912283.png" alt="image-20220223000152339"></p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171912535.png" alt="image-20220223001012587"></p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171913586.png" alt="image-20220223002436155"></p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171913456.png" alt="image-20220223001557967"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> info;</span><br><span class="line">    <span class="keyword">int</span> vertex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span>* <span class="title">nextarc</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> degree;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">acrnode</span>* <span class="title">firstarc</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历：从图中某一顶点出发访遍图中其余结点，使每一个结点被访问且仅被访问一次。</p>
<p>图的遍历通常有两种方法：<strong>深度优先搜索</strong>和<strong>广度优先搜索</strong>。它们对有向图和无向图都适用。</p>
<h4 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索(Depth First Search)"></a><strong>深度优先搜索(Depth First Search)</strong></h4><blockquote>
<p>类似于树的先根遍历，是树的先根遍历的推广。</p>
</blockquote>
<pre><code>  从图中某个顶点v出发，访问此顶点，然后依次从v的未被访问的邻接点出发深度优先遍历图,   直至所有与v有通路的顶点都被访问到；若此时图中还有顶点未被访问到，则另选图中未被访问的顶点作起点，重复上述过程，直到图中所有顶点都被访问到为止。
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(graph g, vtxptr v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从v0出发深度优先遍历图g,</span></span><br><span class="line">    <span class="comment">// g是连通图 或 非连通图中的一个连通分量访问v0;</span></span><br><span class="line">    w = v0的第一个连接点;</span><br><span class="line">    <span class="keyword">while</span>(当邻接点w存在时) &#123;</span><br><span class="line">        <span class="keyword">if</span>(w未访) dfs(g, w);</span><br><span class="line">        w = 下一邻接点;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="广度优先搜索-Breadth-First-Search"><a href="#广度优先搜索-Breadth-First-Search" class="headerlink" title="广度优先搜索(Breadth First Search)"></a><strong>广度优先搜索(Breadth First Search)</strong></h4><blockquote>
<p>类似于树的层次遍历。</p>
</blockquote>
<pre><code>  从图中某个顶点v出发，在访问了v之后，依次访问v的各个未曾访问过的邻接点(并保证先被访问的顶点的邻接点“要先于”后被访问的顶点的邻接点被访问),     直至图中所有已被访问的顶点的邻接点都被访问到。若此时图中还有未被访问的顶点，则任选其中之一作为起点，重新开始上述过程，直至图中所有顶点都被访问到。
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(graph g, vtxptr v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从v0出发广度优先遍历图g（g是连通图或连通分量）</span></span><br><span class="line">    visite(v0); mark[v0] = <span class="number">1</span>;</span><br><span class="line">    initqueue(Q);</span><br><span class="line">    enqueue(Q, v0); <span class="comment">// v0进队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!empty(Q)) &#123;</span><br><span class="line">        dequeue(Q, v);</span><br><span class="line">        w = v的第一个邻接点;</span><br><span class="line">        <span class="keyword">while</span>(w存在) &#123;</span><br><span class="line">            <span class="keyword">if</span>(w未访) &#123;</span><br><span class="line">            	visite(w); mark[w] = <span class="number">1</span>; enqueue(Q, w);</span><br><span class="line">                w = 下一邻接点;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171913653.png" alt="image-20220228104959785"></p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><strong>生成树</strong>：按深度遍历得到的生成树称为深度优先生成树；按广度遍历得到的生成树称为广度优先生成树。</p>
<p>连通图或有根有向图可以生成树。</p>
<p><strong>有根的图</strong>：存在一个顶点X,从该顶点出发可以沿着有向路径到达图中其余各顶点的有向图。顶点X为图的根。</p>
<p><strong>生成树林</strong>：从非连通图中任意一个顶点出发，或者从非强连通图中任意一个非根顶点出发，都不可能沿着边<br>访问到图中的所有顶点。</p>
<p><strong>最小生成树</strong>：生成树中边的权值（代价）之和最小的树。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171913802.png" alt="image-20220228110032759"></p>
<h4 id="Kruscal算法"><a href="#Kruscal算法" class="headerlink" title="Kruscal算法"></a><strong>Kruscal算法</strong></h4><p>基本思想：设$T=(U,TE)$是$G=(V,E)$的最小生成树，$U$的初值等于$V$，$TE$的初值为空集。将图中的<font color="#ff0000">边按权值从小到大的顺序依次选取</font>，若选取的边使生成树$T$不形成回路，则把它并入$TE$中，保留作为$T$的一条边；若选取的边使生成树T形成回路，则将其舍去。如此进行下去，直到$TE$中包含有$n-1$条边为止。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171914006.png" alt="image-20220228111700867"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T = &#123;V, E&#125;;</span><br><span class="line"><span class="keyword">while</span>(T的边数 &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">    在E中选择代价最小的边(u, v);</span><br><span class="line">    并置 E = E - (u, v);</span><br><span class="line">    <span class="keyword">if</span>(不构成回路) &#123;</span><br><span class="line">        T = T + &#123;u, v&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a><strong>prim算法</strong></h4><p>从某一顶点开始，找$n-1$条不构成回路的最小边（顶点偶对）。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171915818.png" alt="image-20220228112316673"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minispantree_prim</span><span class="params">(graph g, <span class="keyword">int</span> u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从u出发构造网g的最小生成树</span></span><br><span class="line">	<span class="keyword">for</span>(v = <span class="number">1</span>; v &lt;= vtxnum; v++) &#123; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">if</span>(v != u) &#123;</span><br><span class="line">            closedge[v].vex = u;</span><br><span class="line">            closedge[v].lowcost = g[u][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= vtxnum - <span class="number">1</span>; ++i) &#123; </span><br><span class="line">        k=最小边所在下标位置;输出生成树的边;</span><br><span class="line">        closedge[k].lowcost = <span class="number">0</span>; <span class="comment">////顶点k并入U集</span></span><br><span class="line">        <span class="keyword">for</span>(v = <span class="number">1</span> ; v &lt;= vtxnum; ++v) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(g[k][v] &lt; closedge[v].lowcost) &#123; <span class="comment">// 选择具有最小代价的边</span></span><br><span class="line">   				closedge[v].lowcost=g[k][v]; </span><br><span class="line">                closedge[v].vex=k;  </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>用顶点边表示活动的网络，简称<strong>AOV网络(Activity On Vertices)</strong></p>
<p><strong>顶点</strong>：一个工程中的活动(Activity)</p>
<p><strong>边</strong>：活动的顶点间的优先关系(Relation)</p>
<p>可以用有向图表示一个工程。在这种有向图中，用顶点表示活动。有向边$&lt;V_i,V_j&gt;$表示：$V_i$必须先于活动$V_j$进行。这种有向图叫做顶点表示活动的<strong>AOV网络(Activity On Vertices)</strong></p>
<p>在AOV网络中，如果活动$V_i$，必须在活动$V_j$，之前进行，则存在有向边$&lt;V_i,V_j&gt;$，AOV网络中不能出现有向回路，即有向环。在AOV网络中如果出现了有向环，则意味着某项活动应以自己作为先决条件。因此，对给定的AOV网络，必须先判断它是否存在有向环。</p>
<p>将各个顶点（代表各个活动）排列成一个线性有序的序列，使得AOV网络中所有应存在的前驱和后继关系<br>都能得到满足——<strong>拓扑序列</strong>。</p>
<p>这种构造AOV网络全部顶点的拓扑有序序列的运算就叫做<strong>拓扑排序</strong>。</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171915291.png" alt="image-20220228165540390"></p>
<p><strong>存储结构（邻接表）：</strong></p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171916056.png" alt="image-20220228170107169"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;</span><br><span class="line">    arcnode *nextarc;</span><br><span class="line">&#125;* pointer;	<span class="comment">// 表结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> vexdata;</span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">// 顶点的入度</span></span><br><span class="line">    pointer firstarc;</span><br><span class="line">&#125;dig[<span class="number">100</span>];	<span class="comment">//一组头结点</span></span><br></pre></td></tr></table></figure>



<p><strong>拓扑排序的方法</strong>：</p>
<p>首先建立(n个顶点的)AOV网。</p>
<p>1、在AOV网络中选一个没有直接前驱的项点（入度为0的顶点），并输出之；</p>
<p>2、从图中删去该顶点，同时删去所有它发出的边；</p>
<p>重复(1)和(2)，直到全部顶点均已输出，</p>
<p>拓扑有序序列形成，拓扑排序完成：</p>
<p>若图中还有未输出的顶点，但已跳出处理循环。这说明图中存在环</p>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171916422.png" alt="image-20220228170619932"></p>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>用边表示活动的网络，简称 **AOE网络 (Activity On Edges) **</p>
<p><strong>边</strong>：一个工程中的活动(Activity)</p>
<p><strong>边上权值</strong>：活动持续时间(Duration)</p>
<p><strong>顶点</strong>：事件 (Event)</p>
<p>完成整个工程所需的时间取决于从源点到汇点的最长路径长度，即在这条路径上所有活动的持续时间之和。这条路径长度最长的路径就叫做**关键路径(Critical Path)**。</p>
<p>1）先求所有事件的$Ve$ $\quad$  2）通过$Ve$反向求所有事件$Vl$</p>
<p>事件$V_j$的最早可能开始时间$Ve[j]$——从源点$V1$ 到顶点$V_j$的最长路径长度。</p>
<ul>
<li>$Ve(1)=0$                             </li>
<li>$Ve(j)=max{Ve(i)+&lt;i,j&gt;的权} $</li>
</ul>
<p>事件$V_i$ 的最迟允许开始时间$Vl[i]$ ——在保证汇点$Vn$ 在$Ve[n]$时刻完成的前提下，事件$V_i$的允许的最迟开始时间。</p>
<ul>
<li> $Vl(n)=Ve(n)$</li>
<li> $Vl(i)=min{Vl(j)-&lt;i,j&gt;的权}$</li>
</ul>
<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171916865.png" alt="image-20220228172012931"></p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>最短路径问题：如果从图中某一顶点(称为源点)到达另一顶点（称为终点）的路径可能不止一条，如何找到一条路径使得<br>沿此路径上各边上的权值总和达到最小。</p>
<p>解法：</p>
<ul>
<li>单源最短路径问题——Dijkstra算法</li>
<li>所有顶点之间的最短路径——Floyd算法</li>
</ul>
<h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p><strong>单源最短路径问题</strong>：给定一个带权有向图D与源点v，求从v到D中其它顶点的最短路径（限定各边上的权值大于或等于0） 。</p>
<p>按路径长度的递增次序，逐步产生最短路径。首先求出长度最短的一条最短路径，再参照它求出长度次短的一条最短路径，依次类推，直到从顶点v到其它各顶点的最短路径全部求出为止。</p>
<ul>
<li>引入一个辅助数组$dist$。它的每一个分量$dist[i]$表示当前找到的从源点$v_0$到终点$v_i$的最短路径的长度。初始状态：<ul>
<li>若从源点$v_0$到顶点$v_i$有边，则$dist[i]$为该边上的权值</li>
<li>若从源点$v_0$到顶点$v_i$没有边，则$dist[i]$为$+\infty$</li>
</ul>
</li>
<li>假设 $S$ 是已求得的最短路径的终点的集合。</li>
<li>首先，在 $dist$ 数组中求最小值$v_k(v_k\in V-S)$ ，将$v_k$加入集合 $S$</li>
<li>然后，对所有的$v_i\in V-S$，修改其$dist[i]$值（$v_0-&gt;v_i$短，还是$v_0-&gt;v_k-&gt;v_i$更短）</li>
<li>重复上述过程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//a[i][j]:(vi,vj)的权，dist[j]:当前求到的从顶点v 到顶点j的最短路径长度, </span></span><br><span class="line">	<span class="comment">//同时用数组path[j]:存放求到的最短路径, 0 &lt;= j &lt; n</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dist[i] = a[v][i];	<span class="comment">// dist数组初始化</span></span><br><span class="line">        S[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i != v &amp;&amp; dist[i] &lt; MAXNUM) path[i] = v;</span><br><span class="line">        <span class="keyword">else</span> path[i] = <span class="number">-1</span>;	<span class="comment">//path数组初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    S[v] = <span class="number">1</span>; 	<span class="comment">// 顶点v加入顶点集合</span></span><br><span class="line">    dist[v] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ ) &#123;			</span><br><span class="line">		u = 当前不在集合S中且具有最短路径的顶点;</span><br><span class="line">		S[u] = <span class="number">1</span>;  <span class="comment">//将顶点u加入集合S</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++)  &#123;  <span class="comment">//修改 </span></span><br><span class="line">			<span class="keyword">if</span> ( !S[w] &amp;&amp; a[u][w] &lt; MAXNUM &amp;&amp; dist[u] + a[u][w] &lt; dist[w] ) &#123;</span><br><span class="line">				dist[w] = dist[u] + a[u][w]; </span><br><span class="line">				path[w] = u;</span><br><span class="line">            &#125; </span><br><span class="line">      	&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171917184.png" alt="image-20220228180249428"></p>
<h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><p><strong>所有顶点之间的最短路径</strong>：对每一对顶点$v_i\neq v_j$，要求求出$v_i$与$v_j$之间的最短路径和最短路径长度。</p>
<p><strong>Floyd算法的基本思想</strong>：</p>
<p>定义一个$n$阶方阵序列：$A^{(0)},A^{(1)},…,A^{(n)}$ </p>
<p>其中 $A^{(0)}[i][j] = a[i][j] \ A^{(k)}[i][j] = min{A^{(k-1)}[i][j],A^{(k-1)}[i][k] + A^{(k-1)}[k][j]} \quad k = 1,2,…, n $   </p>
<p>$A^{(k)}[i][j]$是从顶点$v_i$到$v_j$，中间顶点的序号不大于$k$的最短路径的长度，$A^{(n)}[i][j]$是从顶点$v_i$到$v_j$的最短路径长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>, i &lt;= n; ++i) &#123;	<span class="comment">//矩阵a与path初始化</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != j &amp;&amp; a[i][j] &lt; MAXINT) &#123;</span><br><span class="line">                path[i][j] = i;	<span class="comment">// i到j有路径</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                path[i][j] = <span class="number">0</span>;	<span class="comment">// i到j无路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; ++k) &#123; <span class="comment">//产生a(k)及path(k)</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( a[i][k] + a[k][j] &lt; a[i][j] ) &#123; </span><br><span class="line">					a[i][j] = a[i][k] + a[k][j];</span><br><span class="line">		  			path[i][j] = k;</span><br><span class="line">                &#125;   <span class="comment">//缩短路径长度(i-- k -- j )</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/yanglinqi107/images/raw/master/res/202205171917790.png" alt="image-20220302104402103"></p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构和算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/C++%E6%97%B6%E9%97%B4/" rel="prev" title="C++ 日期和时间">
      <i class="fa fa-chevron-left"></i> C++ 日期和时间
    </a></div>
      <div class="post-nav-item">
    <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/" rel="next" title="数据结构下">
      数据结构下 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">什么是数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.2.</span> <span class="nav-text">术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">1.3.</span> <span class="nav-text">算法和算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">顺序表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">2.2.</span> <span class="nav-text">链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">栈和队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2"><span class="nav-number">4.</span> <span class="nav-text">串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">串的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.</span> <span class="nav-text">串的存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">4.3.</span> <span class="nav-text">模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BF%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.1.</span> <span class="nav-text">BF算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.2.</span> <span class="nav-text">KMP算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">5.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">5.1.</span> <span class="nav-text">数组的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-number">5.2.</span> <span class="nav-text">数组的顺序存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-number">5.3.</span> <span class="nav-text">矩阵的压缩存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-number">5.3.1.</span> <span class="nav-text">特殊矩阵的压缩存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-number">5.3.2.</span> <span class="nav-text">稀疏矩阵的压缩存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-number">6.</span> <span class="nav-text">广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">6.1.</span> <span class="nav-text">广义表的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.</span> <span class="nav-text">广义表的存储结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">7.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-number">7.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">7.2.</span> <span class="nav-text">存储结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">8.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%86%E7%B1%BB"><span class="nav-number">8.1.</span> <span class="nav-text">二叉树分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">8.2.</span> <span class="nav-text">二叉树的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-number">8.3.</span> <span class="nav-text">二叉树的存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">8.4.</span> <span class="nav-text">二叉树的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.5.</span> <span class="nav-text">遍历算法实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">8.6.</span> <span class="nav-text">线索二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Huffman%E6%A0%91"><span class="nav-number">8.7.</span> <span class="nav-text">Huffman树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">8.8.</span> <span class="nav-text">树、森林转换二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">9.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="nav-number">9.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-1"><span class="nav-number">9.2.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">9.3.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-Depth-First-Search"><span class="nav-number">9.3.1.</span> <span class="nav-text">深度优先搜索(Depth First Search)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-Breadth-First-Search"><span class="nav-number">9.3.2.</span> <span class="nav-text">广度优先搜索(Breadth First Search)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">9.4.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruscal%E7%AE%97%E6%B3%95"><span class="nav-number">9.4.1.</span> <span class="nav-text">Kruscal算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prim%E7%AE%97%E6%B3%95"><span class="nav-number">9.4.2.</span> <span class="nav-text">prim算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">9.5.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-number">9.6.</span> <span class="nav-text">关键路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">9.7.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">9.7.1.</span> <span class="nav-text">Dijkstra算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Floyd%E7%AE%97%E6%B3%95"><span class="nav-number">9.7.2.</span> <span class="nav-text">Floyd算法</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yanglinqi"
      src="/images/headpic.jpg">
  <p class="site-author-name" itemprop="name">yanglinqi</p>
  <div class="site-description" itemprop="description">用于做笔记，对学过的知识总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">88</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yanglinqi107" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanglinqi107" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yanglinqi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


  <script async src="/js/cursor/fireworks.js"></script>


</body>
</html>

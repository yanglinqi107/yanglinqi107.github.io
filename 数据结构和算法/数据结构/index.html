<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yanglinqi107.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="线性表，栈和队列，串，数组，广义表，树，二叉树，图，查找，内部排序，外排序，Trie结构，红黑树，伸展树">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://yanglinqi107.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="杨记">
<meta property="og:description" content="线性表，栈和队列，串，数组，广义表，树，二叉树，图，查找，内部排序，外排序，Trie结构，红黑树，伸展树">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171848751.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171851002.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171851216.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171851384.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171851071.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171851973.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171852069.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171852398.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171852396.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171852499.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171853468.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171853639.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171853956.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171853586.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171853381.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171854066.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171855916.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171857101.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171901464.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171901233.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171901741.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171901601.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171901556.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171901916.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171902798.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171902610.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171902143.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171903316.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171903708.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171903117.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171906944.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171906489.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171906051.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171906374.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171907706.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171908575.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171909519.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171909031.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171909737.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171909051.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171910072.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171910614.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171910780.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171910228.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171910510.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171911339.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171911892.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171912797.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171912283.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171912535.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171913586.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171913456.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171913653.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171913802.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171914006.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171915818.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171915291.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171916056.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171916422.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171916865.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171917184.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171917790.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171917722.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171918530.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171918576.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171918605.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171918588.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171918422.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171919254.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171919878.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171919682.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171919052.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171920180.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171920402.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171920649.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171922611.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171922442.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171922648.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171922200.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171922652.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171923322.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171923828.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171923235.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171923065.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171924301.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171924894.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171924785.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171924931.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171924874.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171925090.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171925558.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171926257.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171926811.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171926460.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171926993.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171926146.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171927293.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171927781.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171933337.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171934986.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171934885.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171935199.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171935282.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171935573.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171935891.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171936716.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171936625.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171936006.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171936821.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171941688.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171941465.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171942584.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171942714.jpg">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171943649.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171943567.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171943712.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171943321.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171943937.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171944624.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171944838.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171944276.jpeg">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171944651.jpeg">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171944825.jpeg">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171945003.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171945553.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171947752.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171947889.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171947725.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171947490.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171948286.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171948166.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171948789.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171949370.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171949351.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171949277.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171949652.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171949327.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171949489.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171950601.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171950004.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171950516.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171951821.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171951241.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171951301.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171951404.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171952589.png">
<meta property="og:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171953516.png">
<meta property="article:published_time" content="2022-02-26T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-06T06:37:44.640Z">
<meta property="article:author" content="yanglinqi">
<meta property="article:tag" content="数据结构和算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171848751.png">

<link rel="canonical" href="http://yanglinqi107.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构 | 杨记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杨记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">碎片化学习令人焦虑，系统化学习使人进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">30</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">100</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yanglinqi107.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headpic.jpg">
      <meta itemprop="name" content="yanglinqi">
      <meta itemprop="description" content="用于做笔记，对学过的知识总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-27 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-27T00:00:00+08:00">2022-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-06 14:37:44" itemprop="dateModified" datetime="2023-08-06T14:37:44+08:00">2023-08-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>线性表，栈和队列，串，数组，广义表，树，二叉树，图，查找，内部排序，外排序，Trie结构，红黑树，伸展树</p>
<span id="more"></span>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h3><p>1、按某种逻辑关系组织起来的一批数据（逻辑结构）例如：线性表、树、图</p>
<p>2、以一定的方式存于计算机中（存储结构）例如：数组、链表等</p>
<p>3、在这组数据上定义了运算的集合。例如：插入、删除、查找、排序等   </p>
<p><strong>程序 = 数据结构 + 算法</strong></p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p><strong>数据 data</strong>：能够输入到计算机中并被计算机程序处理的信息，包括文字、表格、图像等，都称为数据。</p>
<p><strong>数据元素 data element</strong>：数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素包含若干个<strong>数据项data item</strong>。</p>
<p>数据元素、数据项和数据的逻辑结构在计算机中的表示又称为结点、数据域和存储（物理）结构。</p>
<p><strong>数据对象</strong>：性质相同的数据元素的集合，是数据的一个子集。</p>
<p><strong>数据类型</strong>：一个值的集合及定义在这个值集上的一组操作的总称。</p>
<p><strong>抽象数据类型 ADT(Abstract Data Type)</strong>：一个数学模型以及定义在此数学模型上的一组操作。</p>
<p><strong>数据的逻辑结构</strong>：数据元素之间的逻辑关系。</p>
<ul>
<li><strong>线性结构</strong>：元素之间的关系是一对一的。表，栈，队列，串等</li>
<li><strong>非线性结构</strong><ul>
<li><strong>树型结构</strong>：元素之间的关系是一对多的。二叉树，Huffman树等</li>
<li><strong>图状结构</strong>：元素之间的关系是多对多的。有向图，无向图等</li>
</ul>
</li>
</ul>
<p><strong>数据的存储结构</strong>：数据在计算机中的存储表示。逻辑结构到物理存储的映射。</p>
<ul>
<li><strong>顺序存储</strong>：数组</li>
<li><strong>非顺序存储</strong>：链式</li>
<li><p><strong>索引存储</strong>：</p>
</li>
<li><p><strong>散列存储</strong>：hash</p>
</li>
</ul>
<h3 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h3><p><strong>算法 algorithm</strong>：算法是对特定问题求解步骤的一种描述，是指令的有限序列。也即解决问题的一种方法（策略）或一个过程。</p>
<p><strong>程序</strong>：用计算机语言实现算法。</p>
<p><strong>算法的五个特性</strong>：有穷性，可行性，确定性，输入和输出。 </p>
<p><strong>算法分析（设计）的要求</strong>：正确性 correctness，可读性 readability，健壮性 robustness，高效率与低存储</p>
<p><strong>算法分析</strong>：</p>
<ul>
<li><strong>时间复杂度 time complexity</strong>：算法中各语句执行时间的总和。</li>
<li><strong>空间复杂度 space complesity</strong>：算法中所需占用的==辅助==空间。</li>
</ul>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><strong>线性表逻辑结构</strong></p>
<p>$(a_1,a_2,…,a_n)$  $n(n&gt;=0)$ 个元素的有限集。 每个元素的类型是相同的，元素之间的位置关系是一维(线性)的。</p>
<p><strong>线性表存储结构</strong></p>
<ul>
<li>顺序存储——顺序表</li>
<li>链式存储——链表</li>
</ul>
<p><strong>线性表的操作</strong></p>
<p>插入，删除，定位，查找，排序等</p>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>线性表的顺序存储</p>
<p>注意：有容量和表长，容量是线性表的最多保存的数据元素的个数，表长是当前顺序表保存的数据元素个数。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>线性表的链式存储。</p>
<p><strong>单向链表</strong></p>
<p>头指针，尾指针，空指针，数据域，指针域，空表，带表头节点的单向链表</p>
<font color=#ff000>注意：头指针可能包含数据，也可能置空。类似于数组的第0位可能不用，也可能存数据</font>

<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171848751.png" alt="image-20220220153401793"></p>
<p><strong>单向循环链表</strong></p>
<p>只有尾指针，尾指针就是头指针</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171851002.png" alt="image-20220220153555966"></p>
<p><strong>双向链表</strong></p>
<p>两个指针域和一个数据域，  <code>prior data next</code></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171851216.png" alt="image-20220220153643987"></p>
<p><strong>双向循环链表</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171851384.png" alt="image-20220220153836405"></p>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈和队列是特殊的线性表，是<strong>操作受限</strong>的线性表。</p>
<p>对于栈，所有的插入和删除操作都限制在线性表的同一端进行，是一种后进先出的线性表。</p>
<p>对于队列，所有的插入操作限制在线性表的一端进行，所有的删除操作限制在线性表的另一端进行，是一种先进先出的线性表。</p>
<p><strong>栈</strong>是限定在一端（表尾）进行插入或删除操作的线性表。<strong>表尾端称栈顶</strong>，表头端称栈底</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171851071.png" alt="image-20220220190949091"></p>
<p>栈对应线性表的两种类型</p>
<p><strong>顺序栈</strong></p>
<p>栈满：<code>top == MAXSIZE - 1</code></p>
<p>栈空：<code>top == -1</code></p>
<p><strong>链式栈</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171851973.png" alt="image-20220220193032534"></p>
<p><strong>队列</strong>是限定在表的一端（队尾）进行插入，另一端（队头）进行删除的线性表。<strong>出队列的一端称队头</strong>，进队列的一端称队尾。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171852069.png" alt="image-20220220191822593"></p>
<p><strong>循环队列</strong>——顺序存储</p>
<p>1）解决假溢出问题。2）提高效率。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171852398.png" alt="image-20220220192606716"></p>
<p><strong>链式队列</strong>——非顺序存储</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171852396.png" alt="image-20220220192406216"></p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为<strong>字符集</strong>。</p>
<p>但是串的基本操作和线性表却有很大差别。在线性表的基本操作中，大多以“单个元素”作为操作对象。如：在线性表中查找某个元素、求取某个元素、在某个位置上插入一个元素和删除一个元素等；而在串的基本操作中，通常以“串的整体”作为操作对象，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。</p>
<h3 id="串的基本概念"><a href="#串的基本概念" class="headerlink" title="串的基本概念"></a>串的基本概念</h3><p><strong>串(string)</strong>也称字符串，是由零个或多个字符组成的有限序列。一般记为$S$ = “$a_1a_2…a_n$”。</p>
<ul>
<li>$S$是串的名字</li>
<li>引号里面是串的内容</li>
<li>$a_i$是串的第$i$个字符</li>
<li>串中字符个数$n$为串长，$n=0$为空串</li>
</ul>
<p><strong>子串(substring)</strong>：一个串中任意个连续字符组成的子序列（含空串）称为该串的子串。</p>
<p><strong>真字串</strong>：非空且不为自身的字串。</p>
<p><strong>字符在串中的位置</strong>：</p>
<p><strong>子串在主串中的位置</strong>：以子串的第一个字符在主串中出现的位置表示。</p>
<p><strong>前缀</strong>：起始于位置1的字串</p>
<p><strong>后缀</strong>：终止于位置n的字串</p>
<p><strong>真前缀和真后缀</strong>：字符串本身之外的所有非空前缀和后缀，分别称为真前缀和真后缀。</p>
<p><strong>串相等</strong>：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。</p>
<p><strong>C标准函数库</strong> #include \<string. h>  <strong>C++</strong> #include \<cstring></p>
<ul>
<li>求串长 <code>int strlen(char *s);</code></li>
<li>串复制 <code>char* strcpy(char*s1,char*s2);</code></li>
<li>串拼接 <code>char* strcat(char*s1,char*s2);</code></li>
<li>串比较 <code>int strcmp(char*s1,char*s2;</code></li>
<li>定位 <code>char* strchr(char*s, char c);</code></li>
<li>右定位 <code>char* strrchr(char*s, char c);</code></li>
<li>求子串 <code>char* strstr(const char*str1, const char*str2);</code></li>
</ul>
<h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><hr>
<p><strong>行结构</strong></p>
<p><strong>定长顺序存储</strong>：按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，通常用定长字符数组来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSTRLEN 1000		<span class="comment">// 定义最长串长1000</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[MAXSTRLEN]; <span class="comment">// 存放字符</span></span><br><span class="line">    <span class="keyword">int</span> length;				<span class="comment">// 串的实际长度</span></span><br><span class="line">&#125;SqString;</span><br></pre></td></tr></table></figure>
<font color=#00f>注意：隐式存储：在串值后面加一个不计入串长的结東标记字符，如C语言中的"0"。此时串长为隐含值，不便于实现涉及串长的操作</font>

<hr>
<p><strong>堆结构</strong></p>
<p><strong>堆分配存储</strong>：仍以一组地址连续的存储单元存放串值，但存储空间是在程序执行过程中动态分配而得。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* data;		<span class="comment">//若是非空串，则按串实际长度分配存储区，否则data为NULL</span></span><br><span class="line">    <span class="keyword">int</span> length;		<span class="comment">//串长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>块链存储</strong></p>
<p>串采用链式存储结构存储时称为<strong>链串</strong>。链串中的一个结点可以存储多个字符。通常将链串中<strong>每个结点所存储的字符个数称为结点大小</strong>。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171852499.png" alt="image-20220220210247787"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE 80	<span class="comment">//可由用户定义的结点大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>	//自定义结点（数据元素）</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data[CHUNKSIZE];	<span class="comment">//存放字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>* <span class="title">next</span>;</span>		<span class="comment">//指针域</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Chunk *head, *tail;		<span class="comment">//串的头指针和尾指针</span></span><br><span class="line">    <span class="keyword">int</span> length;				<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p><strong>模式匹配</strong>：子串在主串中的定位运算(index)。设S和T是给定的两个串，在主串S中查找子串T (T也称为模式串) 的过程称为模式匹配。</p>
<p><strong>匹配结果</strong></p>
<ul>
<li>匹配成功：即在主串S中找到一个模式串T。T是S的子串，返回T在S中第一次出现的位置。</li>
<li>匹配不成功：即主串S中不存在模式串T。T不是S的子串，返回0</li>
</ul>
<p><strong>模式匹配的算法</strong></p>
<ul>
<li>朴素算法——<strong>BF(Brute- Force)算法</strong></li>
<li>快速算法——<strong>KMP算法</strong></li>
</ul>
<hr>
<h4 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h4><p>采用穷举策略，基本思想：</p>
<ul>
<li><p>从主串S的第1个字符开始和模式串T的第1个字符进行比较</p>
</li>
<li><p>若相等，继续比较两者的后续字符；</p>
</li>
<li><p>若不等，从主串S的下ー字符开始和模式T的第一个字符进行比较</p>
</li>
<li><p>直到T中的每个字符依次和S中的一个连续的字符序列相等，则匹配成功，返回T在S中第一次出现的位置，否则匹配失败，返回0。</p>
</li>
</ul>
<p>主串指针回溯，效率低。</p>
<p><strong>BF算法</strong>的<strong>C/C++</strong>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S：主串  T：模式串  sLen：S的长度  tLen：T的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BF</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">char</span> T[], <span class="keyword">int</span> sLen, <span class="keyword">int</span> tLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; sLen &amp;&amp; j &lt; tLen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == T[j]) &#123; ++i; ++j; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; i = i - j + <span class="number">1</span>; j = <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == tLen) <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>设计思想：</p>
<p>每当出现失配时，指针不回溯，而是利用已经得到的“部分匹配”结果将模式串向右“滑动”尽可能远的一段距离后，继续<br>比较。从而提高算法的效率。</p>
<p><strong>示例</strong>：主串 $S=$ “$ababcabcacbab$” ，模式串$T=$ “$abcac$” 。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171853468.png" alt="image-20220220215002839"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171853639.png" alt="image-20220220215715609"></p>
<p>问题一：某趟在 $S_i$ 和 $T_j$ “失配”时，模式串”向右滑动”的可行距离有多远，即下一步 $S_i$ 应该与模式串中的哪个字符比较？</p>
<p>设模式串最远滑动到第 $k$ 个字符，此时要满足：（下面字符串下标从1开始，在程序中一般下标一般是0开始）</p>
<p>$T_1$ ~ $T_{k-1}$ $=$ $S_{i-k+1}$ ~ $S_{i-1}$   和    $T_{j-k+1}$ ~ $T_{j-1}$ $=$ $S_{i-k+1}$ ~ $S_{i-1}$ </p>
<p>联立得：$T_1$ ~ $T_{k-1}$ $=$ $T_{j-k+1}$ ~ $T_{j-1}$  $k=max\{k|1&lt;k&lt;j且T_1…T_{k-1}=T_{j-k+1}…T_{j-1}\}$</p>
<p>即：模式中的前$k-1$个字符（最大真前缀）与模式中$T_j$字符前面的$k-1$个字符（最大真后缀）相等时，模式$T$就可以向右”滑动”至使$T_k$和$S_i$对准，继续向右进行比较即可。</p>
<p>问题二：求$k$值?</p>
<p>1) $k$和$j$存在函数关系，模式串中的每一个$T_j$都对应一个$k$值，由当前失配位置$j$,可以计算出滑动位置$k$;</p>
<p>2) 滑动位置$k$仅与模式串$T$有关，因此可以预先为模式串设定一个next数组，若令<code>next[j]=k</code>,则<code>next[j]</code>表明当模式串中的第$j$个字符与主串中相应字符“失配”时，模式串中需要重新和主串中该字符进行比较的字符的位置。</p>
<script type="math/tex; mode=display">next[j]=\begin{cases} -1 \quad\quad\quad j=0 \\ max\{k|0<k<j且T_0...T_{k-1}=T_{j-k+1}...T_{j-1}\} \\ 0 \quad\quad\quad 其他情况 \end{cases}</script><p>计算<code>next[j]</code></p>
<ul>
<li><p><code>next[0] = -1</code> ，第0个字符不等时，前面没有字符，$i$后移，$j$还是0</p>
</li>
<li><p><code>next[1] = 0</code>，第1个字符不等时，前面只有第0个字符，$i$不变，$j$变1</p>
</li>
<li><p><code>next[j] = k</code>，说明$T_0…T_{k-1}=T_{j-k+1}…T_{j-1}$，则<code>next[j+1]</code>有两种可能</p>
<ul>
<li><p>1、$T_k = T_j$ ：<code>next[j+1] = next[j] + 1 = k + 1</code></p>
</li>
<li><p>2、$T_k\neq T_j$：此时可以把求next函数值问题看成是一个模式匹配问题，整个模式串即是主串又是模式串。设$k’=next[k]$，将模式向右滑动，将$T_j$与$T_k’$进行比较。此时仍会出现两种情况</p>
<ul>
<li>$T_k’ = T_j$ ：与情况①类似，$next[j+1]=k’+1$ </li>
<li>$T_k’\neq T_j$：与情况②类似，重复②的过程，直到$T_j$与模式中某个字符匹配成功或者不存在可匹配的子串，则$next[j+1]=0$。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例：模式$T =$ “$abaababc$”</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>sub</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>b</td>
<td>c</td>
</tr>
<tr>
<td>next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>求<strong>next</strong>的<strong>C/C++</strong>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T是模式串，tLen是T的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">char</span> T[], <span class="keyword">int</span> next[], <span class="keyword">int</span> tLen)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; tLen - <span class="number">1</span>)	<span class="comment">// 第j个数决定j+1，所以tLen减1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || T[j] == T[k]) &#123;</span><br><span class="line">			++k; ++j;</span><br><span class="line">			next[j] = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C++</strong>测试<strong>next</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> T[] = <span class="string">&quot;abaababc&quot;</span>;  <span class="comment">// -1 0 0 1 1 2 3 2</span></span><br><span class="line">    <span class="comment">// 计算T的大小，注意：动态数组无法用sizeof()计算大小</span></span><br><span class="line">	<span class="keyword">int</span> tLen = <span class="built_in"><span class="keyword">sizeof</span></span>(T) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) - <span class="number">1</span>; <span class="comment">// C风格字符串尾还有一个&#x27;\0&#x27;，所以长度是9不是8，要减1</span></span><br><span class="line">	<span class="comment">//int next[8] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="keyword">int</span>* next = <span class="keyword">new</span> <span class="keyword">int</span>[tLen];</span><br><span class="line">	<span class="built_in">getnext</span>(T, next, tLen);	<span class="comment">// 上面的next函数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">		cout &lt;&lt; next[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] next;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>KMP算法</strong>的<strong>C/C++</strong>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S：主串  T：模式串  next：滑动到的字符下标  sLen：S的长度  tLen：T的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">char</span> T[], <span class="keyword">int</span> next[], <span class="keyword">int</span> sLen, <span class="keyword">int</span> tLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; tLen)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == T[j]) &#123;</span><br><span class="line">			++i; ++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j == tLen) <span class="keyword">return</span> i - j;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C++</strong>测试<strong>KMP算法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> T[] = <span class="string">&quot;abaababc&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> S[] = <span class="string">&quot;abacabaababcabc&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> tLen = <span class="built_in"><span class="keyword">sizeof</span></span>(T) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> sLen = <span class="built_in"><span class="keyword">sizeof</span></span>(S) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>* next = <span class="keyword">new</span> <span class="keyword">int</span>[tLen];</span><br><span class="line">	<span class="built_in">getnext</span>(T, next, tLen);		<span class="comment">// 前面的getnext函数</span></span><br><span class="line">	<span class="keyword">int</span> pos = <span class="built_in">KMP</span>(S, T, next, sLen, tLen);	<span class="comment">// 前面的KMP函数</span></span><br><span class="line">	cout &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] next;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>next函数的改进</strong></p>
<p>如果<code>next[j]=k</code>且$T_k=T_j$，当 $S_i≠T_j$失配时，不需要再和$T_k$进行比较，而直接和$T_{next[k]}$进行比较，即应使<code>next[j]=next[k]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T是模式串，tLen是T的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">char</span> T[], <span class="keyword">int</span> next[], <span class="keyword">int</span> tLen)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; tLen - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || T[j] == T[k]) &#123;</span><br><span class="line">			++k; ++j;</span><br><span class="line">            <span class="keyword">if</span>(T[j] != T[k]) next[j] = k;</span><br><span class="line">            <span class="keyword">else</span> next[j] = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p><strong>数组(Array)</strong>：是元素数量和元素类型固定的有序序列，可以将它看成是<strong>线性表的推广</strong>。</p>
<p><strong>一维数组</strong>：是$n(n&gt;1)$个相同类型数据元素构成的有限序列，其逻辑表示为 $A = (a_0,a_1,…,a_{n-1})$ 。</p>
<p><strong>二维数组</strong>：可以看成是每个数据元素都是相同类型的一维数组的一维数组。</p>
<script type="math/tex; mode=display">A_{mn}\left[ 
\begin{matrix} 
a_{0,0} & a_{0,1} &\cdots & a_{0,n-1} \\ a_{1,0} & a_{1,1} &\cdots & a_{1,n-1} \\ \vdots &\vdots &\ddots &\vdots \\ a_{m-1,0} & a_{m-1,1} &\cdots & a_{m-1,n-1} \end{matrix} \right]</script><script type="math/tex; mode=display">可以看成长度为m的线性表</script><script type="math/tex; mode=display">B = (b_0,b_2,...b_{m-1}) \quad\quad 其中b_i = (a_{i,0},...a_{i,n-1})</script><p><strong>n维数组</strong>：可以看成是数据元素为$n-1$维数组的一维数组。</p>
<h3 id="数组的顺序存储"><a href="#数组的顺序存储" class="headerlink" title="数组的顺序存储"></a>数组的顺序存储</h3><p><strong>数组的顺序存储</strong>：由于数组一般不做插入或刪除操作，因此，通常采用顺序存储结构，将数组的所有元素存储在一块地址连续的内存单元中。</p>
<ul>
<li><p><strong>一维数组的顺序存储</strong>：对于一维数组$A=(a_0,a_1,…a_{n-1})$可以直接按照元素顺序依次存储到一块地址连续的内存单元中。</p>
<p><strong>数据元素存储位置计算公式</strong>：一旦$a_0$的存储地址$LOC(a_0)$确定，并假设每个数据元素占用$L$个存储单元，则任一数据元素$a_i$的存储地址$LOC(a_i)$就可由以下公式求出：$LOC(a_i)=LOC(a_0)+i*L \quad (0&lt;=i&lt;n)$ </p>
</li>
<li><p><strong>二维数组的顺序存储</strong>：对于一个$m$行$n$列的二维数组$A_{m,n}$,其存储方式有两种</p>
<ul>
<li><p><strong>行优先</strong>——以行序为主序的存储： <script type="math/tex">A=((\underbrace{a_{0,0},a_{0,1},...a_{0,n-1}}_{第0行}),(\underbrace{a_{1,0},a_{1,1},...a_{1,n-1}}_{第1行}),...,(\underbrace{a_{m-1,0},a_{m-1,1},...a_{m-1,n-1}}_{第m-1行}))</script> </p>
<p><strong>数据元素存储位置计算公式</strong>：$LOC(a_{i,j})=LOC(a_{0,0})+(i<em>n+j)</em>L \quad (0&lt;=i&lt;m,0&lt;=j&lt;n)$  </p>
</li>
<li><p><strong>列优先</strong>——以列序为主序的存储 <script type="math/tex">A=((\underbrace{a_{0,0},a_{1,0},...a_{m-1,0}}_{第0列}),(\underbrace{a_{0,1},a_{1,1},...a_{m-1,1}}_{第1列}),...,(\underbrace{a_{0,n-1},a_{1,n-1},...a_{m-1,n-1}}_{第n-1行}))</script> </p>
<p><strong>数据元素存储位置计算公式</strong>：$LOC(a_{i,j})=LOC(a_{0,0})+(j<em>m+i)</em>L \quad (0&lt;=i&lt;m,0&lt;=j&lt;n)$  </p>
</li>
</ul>
</li>
</ul>
<h3 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h3><p><strong>矩阵的压缩存储</strong>：</p>
<ul>
<li>为多个值相同的非零元只分配一个存储空间</li>
<li>对零元不分配空间</li>
</ul>
<p><strong>需压缩存储的两类矩阵</strong>：</p>
<ul>
<li><p><strong>特殊矩阵</strong>：值相同的元素或零元素在矩阵中的分布有一定规律。如：<strong>对称矩阵、三角矩阵、对角矩阵</strong></p>
</li>
<li><p><strong>稀疏矩阵</strong>：非零元较零元少，且分布没有一定规律。</p>
</li>
</ul>
<h4 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h4><p><strong>对称矩阵</strong>：若一个$n$阶方阵$A$中的元素满足$a_{i,j}=a_{j,i}(0≤i,j&lt;n)$,则称其为$n$阶对称矩阵。</p>
<ul>
<li><p><strong>压缩存储</strong>：以行序为主序存储下三角+主对角线的元素。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171853956.png" alt="image-20220221144919380"></p>
<p><strong>压缩地址计算公式</strong>：$a_{i,j} = B_k \quad k = i*(i+1)/2+j \quad (i&lt;=j)$ </p>
</li>
</ul>
<p><strong>三角矩阵</strong>：分为上三角矩阵和下三角矩阵。</p>
<ul>
<li><p><strong>上三角矩阵</strong>是指矩阵的下三角（不包括对角线）中的元素均为常数$c$或$0$的$n$阶方阵。</p>
</li>
<li><p><strong>下三角矩阵</strong>是指矩阵的上三角（不包括对角线）中的元素均为常数$c$或$0$的$n$阶方阵。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171853586.png" alt="image-20220221145944262"></p>
<p><strong>下三角矩阵的压缩存储方法</strong>：以行序为主序存储下三角+主对角线的元素，最后用一个存储单元存储常数$c$,并<br>将压缩结果存储在一维数组$B$中。</p>
<p><strong>压缩地址计算公式</strong>：$k=\begin{cases} i<em>(i+1)/2+j &amp; i&lt;=j \\ n</em>(n+1)/2 &amp; i&gt;j \quad常数c\end{cases}$</p>
</li>
</ul>
<p><strong>对角矩阵</strong>：若一个$n$阶方阵$A$满足其所有的非零元素集中在以主对角线为中心的带状区域中，则称其为$n$阶对角矩阵。其主对角线上、下方各有$b$条非零元素构成的次对角线，称$b$为矩阵半带宽，$(2b+1)$为矩阵的带宽。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171853381.png" alt="image-20220221151234876" style="zoom:80%;" /></p>
<ul>
<li><p><strong>三对角矩阵</strong>：当$b=1$时</p>
<p><strong>压缩存储</strong>：以行序为主序将$A$带宽中的数据存入一维数组中。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171854066.png" alt="image-20220221151615976"></p>
<p><strong>压缩地址计算公式</strong>：$k=2*i+j$ </p>
</li>
</ul>
<h4 id="稀疏矩阵的压缩存储"><a href="#稀疏矩阵的压缩存储" class="headerlink" title="稀疏矩阵的压缩存储"></a>稀疏矩阵的压缩存储</h4><p><strong>稀疏矩阵</strong>：假设在一个$m\times n$的矩阵中有$t$个非零元，令$δ=t/(m\times n)$,$δ$称为稀疏因子，通常认为$δ≤0.05$时该矩阵为稀疏矩阵。</p>
<p><strong>压缩存储方法</strong>：只存储非零元素。稀疏矩阵中的每一个非零元素需由<strong>三元组</strong>$(i,j,a_{i,j})$唯一确定，所有非零元素（通常以行序为主序顺序排列）构成<strong>三元组线性表</strong>（筒称<strong>三元组表</strong>）。</p>
<p>稀疏矩阵可由表示非零元的<strong>三元组表</strong>以及其<strong>行列数</strong>来唯一确定。</p>
<p><strong>三元组表的两种存储方法</strong>：顺序表表示法、十字链表表示法。</p>
<p><strong>三元组顺序表存储表示</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j; 	<span class="comment">// 第i行j列</span></span><br><span class="line">    ElemType e;	<span class="comment">// e:非0值</span></span><br><span class="line">&#125;Triple;	<span class="comment">//三元组类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Triple data[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> mu, nu, tu;	<span class="comment">// mu行，nu列，tu个非0元</span></span><br><span class="line">&#125;TSMarix;	<span class="comment">//稀疏矩阵</span></span><br></pre></td></tr></table></figure>
<p><strong>十字链表</strong>：每个非零元用一个结点表示，结点中除了<strong>表示非零元所在的行、列和值的三元组$(i,j,e)$</strong>外，增加<strong>两个指针域</strong>。<strong>行指针域(right)</strong>：用来指向本行中下一个非零元素；<strong>列指针域(down)</strong>：用来指向本列中下一个非零元素。稀疏矩阵中同一行的非零元通过向右的 right指针链接成了一个线性链表。同一列的非零元也通过down指针链接成了ー个线性链表。每个非零元既是第$i$行链表中的一个结点，又是第$j$列链表中的一个结点，相当于处在一个十字交叉路口，故称这样的存储结构为十字链表。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171855916.png" alt="image-20220221154547201"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j;	<span class="comment">// 该非0元素的行和列下标</span></span><br><span class="line">    ElemType e;	<span class="comment">// 同上面的自定义，就是int型</span></span><br><span class="line">    stuct OLNode *right, *down;	<span class="comment">// 非0元素所在行表和列表的后继</span></span><br><span class="line">&#125;OLNode, *OLink;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    OLink *rhead, *chead;	<span class="comment">// 行和列链表头指针向量</span></span><br><span class="line">    <span class="keyword">int</span> mu, nu, tu;	<span class="comment">// 稀疏矩阵的行数、列数、非0元个数</span></span><br><span class="line">&#125;CrossList;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171857101.png" alt="image-20220221155156147"></p>
<h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><h3 id="广义表的基本概念"><a href="#广义表的基本概念" class="headerlink" title="广义表的基本概念"></a>广义表的基本概念</h3><p><strong>广义表(Generalized Lists)</strong>：广义表是线性表的推广，是$n$个数据元素$(a_1,a_2,…,a_i,…,a_n)$的有限序列，但不同的是，广义表中的$a$既可以是单个元素，还可以是一个广义表，通常记作：$LS=(a_1,a_2,…,a_i,…,a_n)$ </p>
<ul>
<li>LS是广义表的名字</li>
<li>$n$是广义表的长度，$n=0$时称为空表</li>
<li>若$a$是单个元素，则称$a$为广义表$LS$的<strong>原子(atom)</strong>，若$a$是一个广义表，则称$a$是广义表$LS$的<strong>子表(sublist)</strong></li>
<li>为了区别原子和子表，通常用大写字母表示广义表的名称，用小写字母表示原子。</li>
</ul>
<p><strong>广义表的长度</strong>：广义表最外层包含的元素个数</p>
<p><strong>广义表的深度</strong>：广义表中所含括号的重数</p>
<p><strong>广义表的表头和表尾</strong>：当广义表<strong>非空</strong>时，即$LS=(a_1,a_2,…,a_n)$，第一个表元素$a_1$称为广义表的<strong>表头(head)</strong>，其余元素组成的表$(a_2,…,a_n)$称为广义表的<strong>表尾(tail)</strong>。</p>
<p>示例：</p>
<ul>
<li>$A=(a,(b,c,(d)),d,(d))$：长度4，深度3，$head=(a)$，$tail=((b,c,(d)),d,(d))$</li>
<li>$B=()$：长度0，深度1，空表无表头表尾</li>
<li>$C=(e)$：长度1，深度1，$head=(e)$，$tail=()$ </li>
<li>$E=(a,E)$：递归的表，长度2，深度无穷值，$head=()$，$tail=(E)$  </li>
</ul>
<h3 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h3><p><strong>广义表的存储结构</strong>：由于广义表$(a_1,a_2,…,a_n)$是一种<strong>递归的数据结构</strong>，且其中的数据元素可以具有不同的结构(或是原子，或是列表)，因此难以用顺序存储结构表示，通常采用<strong>链式存储结构</strong>，每个数据元素可用一个结点表示，分别为表结点和原子结点。</p>
<p><strong>链式存储方法</strong>：1）头尾链表表示法  2）扩展线性链表表示法</p>
<p><strong>头尾链表表示法</strong>：</p>
<ul>
<li><p>存储方法：任一非空列表可以分解为表头和表尾，反之，一对确定的表头和表尾可以唯一确定一个广义表。</p>
</li>
<li><p>原子结点：由标志域和值域组成。</p>
</li>
<li><p>表结点：由标志域、指示表头的指针域和指示表尾的指针域组成</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171901464.png" alt="image-20220221165024995"></p>
<p>$tag=0$，原子结点；$tag=1$，表/子表结点</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>ATOM, LIST&#125; ElemTag;	<span class="comment">// 0 原子 1 子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemTag tag;	<span class="comment">// 标志域，公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="comment">//union类似于enum。不同的是enum实质上是int类型的，而union可以用于所有类型</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>	// 原子结点和表结点的联合部分</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        AtomType atom;	<span class="comment">//atom是原子结点的值域，AtomType由用户自定义</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>, *<span class="title">tp</span>;</span> &#125;ptr;	<span class="comment">// 表结点的表头和表尾指针域</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;*GList;	<span class="comment">//广义表类型</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171901233.png" alt="image-20220221170301844"></p>
<p>除空表的表头指针为空外，任何非空广义表的表头指针均指向一个表结点，且其hp指向该表的表头，tp指向该表的表尾</p>
<p><strong>扩展线性链表表示法</strong>：</p>
<ul>
<li><p>表结点：由标志域、指示表头的指针域和指示下一元素的指针域组成。</p>
</li>
<li><p>原子结点：由标志域、值域和指示下一元素的指针域组成。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171901741.png" alt="image-20220221170919342"></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>ATOM, LIST&#125; ElemTag; <span class="comment">// 0 原子  1 子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemTag tag;	<span class="comment">// 标志域，分原子结点和表结点</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>		// 原子结点和表结点的联合部分</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        AtomType atom; <span class="comment">//atom是原子结点的值域，AtomType由用户自定义</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>;</span> <span class="comment">// 表结点的表头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">tp</span>;</span>	<span class="comment">//相当于线性链表的next,指向下一个元素结点</span></span><br><span class="line">&#125;*GList;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171901601.png" alt="image-20220221171457502"></p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>树(Tree)</strong>是$n(n&gt;=0)$个结点的有限集。</p>
<p>在任意一棵非空树中<br>(1)有且仅有一个根结点<br>(2)除根结点外，其余结点可分为$m(m&gt;=0)$个互不相交的有限集$T_1,T_2,…,T_m$,其中每个集合本身又是一棵树，称为根的子树。</p>
<p><strong>基本术语</strong>：</p>
<ul>
<li>结点<ul>
<li>父结点、子结点</li>
<li>兄弟、堂兄弟</li>
<li>分枝结点、叶子</li>
</ul>
</li>
<li>结点的度：一个结点拥有子树的个数</li>
<li>树的度</li>
<li>祖先、子孙</li>
<li>层数</li>
<li>树的高度或深度</li>
<li>路径和路径长度</li>
<li>有序树与无序树</li>
</ul>
<p><strong>森林</strong>是$m(m&gt;=0)$棵互不相交的树的集合。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>双亲数组存储表示</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171901556.png" alt="image-20220222145320646" style="zoom:80%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n0 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dataType char</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> &#123;</span></span><br><span class="line">    dataType data;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> <span class="title">t</span>[<span class="title">n0</span>+1];</span></span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>孩子链表存储表示</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171901916.png" alt="image-20220222150000605" style="zoom:80%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dataType char</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sub;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> &#123;</span></span><br><span class="line">    dataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">children</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> <span class="title">t</span>[<span class="title">n</span> + 1];</span></span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>孩子——兄弟链存储表示</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171902798.png" alt="image-20220222152052142" style="zoom:80%;" /></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树分类"><a href="#二叉树分类" class="headerlink" title="二叉树分类"></a>二叉树分类</h3><p><strong>二叉树</strong>：由一个根结点和两棵互不相交的、分别称为这个根的<strong>左子树</strong>和<strong>右子树</strong>的二叉树组成。</p>
<p><strong>满二叉树</strong>：有$2^k-1 \quad(k&gt;0)$ 个结点的二叉树，即所有的叶子都在同一层。</p>
<p><strong>完全二叉树</strong>：至多只有最下面的两层结点度数可以小于2，并且最下面一层的结点都集中在该层最左边的若干位置上</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171902610.png" alt="image-20220221212456927"></p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul>
<li>在二叉树的第$i(i&gt;0)$层上至多有$2^{i-1}$个结点。</li>
<li>深度为$k$的二叉树中至多有$2^k-1$个结点$(k&gt;0)$</li>
<li>对任何二叉树，若其终端结点数为$n0$，度数为2的结点数为$n2$，则$n0 = n2 + 1$。</li>
<li>有$n$个结点的完全二叉树的深度为 $d+1 \quad d为&lt;=log_2n的最大整数$ </li>
<li>对有$n$个结点的完全二叉树按层序从$1$开始编号，对任一结点$i$ $(1&lt;=i&lt;=n)$：<ul>
<li>$i=1$是根结点；$i&gt;1$，父节点是$i/2$ </li>
<li>$2<em>i&lt;=n$，左孩子是$2</em>i$</li>
<li>$2<em>i+1&lt;=n$，左孩子是$2</em>i$，右孩子是$2*i+1$ </li>
</ul>
</li>
</ul>
<h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><ul>
<li>顺序存储</li>
<li>二叉链存储<ul>
<li>静态二叉链</li>
<li>动态二叉链</li>
</ul>
</li>
</ul>
<p><strong>顺序存储</strong>：用数组，按完全二叉树的顺序存储；对于一般的二叉树，在二叉树中补上虚拟结点使其成为完全二叉树。注意数组空出第0位。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171902143.png" alt="image-20220221222838480"></p>
<p><strong>二叉链存储</strong>：每个结点包括数据域和指针域。数据域存储结点的数据，指针域有两个分别指向左孩子和右孩子的指针。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171903316.png" alt="image-20220221223915686" style="zoom:80%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">btnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    dataType data;	<span class="comment">// 用户定义的数据类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">btnode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTnode, *BiTree;</span><br></pre></td></tr></table></figure>
<p><strong>静态二叉链</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171903708.png" alt="image-20220221225133876" style="zoom:80%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbtnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    dataType data;		<span class="comment">//数值字段</span></span><br><span class="line">    <span class="keyword">int</span> llink, rlink;	<span class="comment">//指针字段</span></span><br><span class="line">&#125;tree[n + <span class="number">1</span>];	<span class="comment">// n：二叉树的结点个数，不能这样直接创建数组tree[n+1]</span></span><br></pre></td></tr></table></figure>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p><strong>二叉树的遍历</strong>：按某条搜索路径访问二叉树中每一个结点，使得每个结点被访问一次且仅被访问一次。</p>
<p>遍历方法：<strong>先序遍历、中序遍历、后序遍历、层次遍历</strong>。</p>
<p><strong>先序遍历</strong>：根——&gt;左子树——&gt;右子树</p>
<p><strong>中序遍历</strong>：左子树——&gt;根——&gt;右子树</p>
<p><strong>后序遍历</strong>：左子树——&gt;右子树——&gt;根</p>
<p><strong>层次遍历</strong>：按层次，每层从左到右遍历</p>
<p>示例：</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171903117.png" alt="image-20220221230924269" style="zoom:80%;" /></p>
<p>注：已知二叉树的先序遍历和中序遍历，则该二叉树能唯一确定</p>
<h3 id="遍历算法实现"><a href="#遍历算法实现" class="headerlink" title="遍历算法实现"></a><strong>遍历算法实现</strong></h3><p><strong>层次遍历</strong>伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initqueue(q);	<span class="comment">// 创建一个空队列</span></span><br><span class="line">    enqueue(q, T);		<span class="comment">// T入队</span></span><br><span class="line">    <span class="keyword">while</span>(!empty(q))</span><br><span class="line">    &#123;</span><br><span class="line">        dequeue(q, T);	<span class="comment">// q的队首结点出队给T</span></span><br><span class="line">     	visite(T-&gt;data);	<span class="comment">//访问结点T;</span></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;lchild) enqueue(q, T-&gt;lchild); <span class="comment">//如果T存在左孩子，左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;rchild) enqueue(q, T-&gt;rchild); <span class="comment">//如果T存在右孩子，右孩子入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归实现</strong></p>
<ul>
<li><p><strong>先序遍历</strong>递归伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先序遍历以T为根的二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        visite(T-&gt;data);		<span class="comment">//访问根结点</span></span><br><span class="line">        preOrder(T-&gt;lchild);	<span class="comment">//先序遍历左子树</span></span><br><span class="line">        preOrder(T-&gt;rchild);	<span class="comment">//先序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>中序遍历</strong>递归伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历以T为根的二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(T) &#123;</span><br><span class="line">        inOrder(T-&gt;lchild);	<span class="comment">//中序遍历左子树</span></span><br><span class="line">        visite(T-&gt;data);	<span class="comment">//访问根节点</span></span><br><span class="line">        inOrder(T-&gt;rchild);	<span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>后序遍历</strong>递归伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 后序遍历以T为根的二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(T) &#123;</span><br><span class="line">        postOrder(T-&gt;lchild);	<span class="comment">//后序遍历左子树</span></span><br><span class="line">        postOrder(T-&gt;rchild);	<span class="comment">//后序遍历右子树</span></span><br><span class="line">        visite(T-&gt;data);		<span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>非递归实现</strong></p>
<ul>
<li><p><strong>先序遍历</strong>的非递归伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initstack(s);	<span class="comment">// 创建一个空栈s</span></span><br><span class="line">    <span class="keyword">while</span>(T || !empty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T) &#123;	<span class="comment">// 若T不空，访问T</span></span><br><span class="line">        	visite(T-&gt;data);	<span class="comment">//访问根结点</span></span><br><span class="line">            push(s, T);			<span class="comment">//T入栈</span></span><br><span class="line">            T = T-&gt;lchild;		<span class="comment">//沿左子树遍历</span></span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pop(s, T);			<span class="comment">//栈顶元素出栈给T</span></span><br><span class="line">            T = T-&gt;rchild;		<span class="comment">//沿右子树遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>中序遍历</strong>的非递归伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initstack(s);	<span class="comment">// 创建一个空栈s</span></span><br><span class="line">    <span class="keyword">while</span>(T || !empty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T) &#123; 	<span class="comment">// 若T不空，T入栈，出栈的时候访问</span></span><br><span class="line">            push(s,T);	</span><br><span class="line">            T = T-&gt;lchild;	<span class="comment">//沿左子树遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pop(s, T);		<span class="comment">//栈顶元素出栈给T</span></span><br><span class="line">            visite(T-&gt;data);</span><br><span class="line">            T = T-&gt;rchild;	<span class="comment">//沿右子树遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>后序遍历</strong>的非递归伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BiTree* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initstack(s);</span><br><span class="line">    initstack(tag);	<span class="comment">// 存放0和1，用于判断是否读取s出栈结点的data，1表示从左子树回退，0表示从右子树回退</span></span><br><span class="line">    <span class="keyword">while</span>(T || !empty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T) &#123;</span><br><span class="line">            push(s, T);</span><br><span class="line">            push(tag, LEFT);	<span class="comment">//LEFT是1</span></span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        pop(s, T);				<span class="comment">//将s中的栈顶结点弹给T</span></span><br><span class="line">        pop(tag, flag);			<span class="comment">//将T对应的标识弹出</span></span><br><span class="line">        <span class="keyword">if</span>(flag == LEFT) &#123;		<span class="comment">//如果从左子树回来</span></span><br><span class="line">            push(tag, RIGHT);	<span class="comment">//标识改为右子树入栈</span></span><br><span class="line">            push(s, T);			<span class="comment">//T也入栈</span></span><br><span class="line">            T = T-&gt;rchild;		<span class="comment">//T指向右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;					<span class="comment">//如果从右子树回来</span></span><br><span class="line">            visite(T-&gt;data);	<span class="comment">//读取数据</span></span><br><span class="line">            T = <span class="literal">NULL</span>;			<span class="comment">// T值空，继续弹栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><strong>遍历二叉树</strong>是按一定的规则将二叉树中结点排列成一个线性序列；这实际上是把一个非线性结构进行线性化的操作。</p>
<p><strong>线索二叉树</strong>也是一种用来表示二叉树的二叉链表。在这种二叉链表中，每个结点的空的左孩子指针域中放入了在某种遍历次序下该结点的前驱结点的地址；每个结点的空的右孩子指针域中放入了在这种遍历次序下该结点的后继结点的地址。这种附加的指针值称为<strong>线索</strong>。给二叉树的二叉链表存储结构加上线索的过程称为<strong>线索化</strong>二叉树。这个过程可通过对二叉树进行相应次序的遍历来实现。根据遍历方法的不同，线索二叉树一般分<strong>前序线索二叉树</strong>、<strong>中序线索二叉树</strong>和<strong>后序线索二叉树</strong>三种。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171906944.png" alt="image-20220222202712310"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThrTreeNode</span> &#123;</span></span><br><span class="line">   	<span class="comment">// 线索二叉树中每个结点的结构 </span></span><br><span class="line">   	TElemType data;</span><br><span class="line">   	ThrTreeNode *lchild,*rchild;</span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>先序线索二叉树</strong>和<strong>先序线索二叉树链</strong> （先序遍历序列：$abcdfge$）</p>
<p>前驱和后继是按先序的规则来确定的，如图中的$g$前驱指向$f$，后继指向$e$，对应顺序$gfe$</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171906489.png" alt="image-20220222203008574"></p>
<ul>
<li>以上结构构成的二叉链表作为二叉树的存储结构，叫做<strong>线索二叉链</strong></li>
<li>指向结点前驱或后继的指针叫做<strong>线索</strong> </li>
<li>加上线索的二叉树叫<strong>线索二叉树</strong></li>
<li>对二叉树以某种次序遍历使其变为线索二叉树的过程叫做<strong>线索化</strong></li>
</ul>
<p><strong>中序线索二叉树</strong>（中序遍历序列：DGBAEHCF）</p>
<p>前驱和后继是按中序的规则来确定的，如图中的$H$前驱指向$E$，后继指向$C$，对应顺序$EHC$</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171906051.png" alt="image-20220222203352488"></p>
<p><strong>先序遍历</strong>伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(struct ThrTreeNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先序遍历以p为根的线索二叉树</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        visite(p-&gt;data);	<span class="comment">//访问根结点</span></span><br><span class="line">        p = p-&gt;lchild;		<span class="comment">//p指向左孩子或前驱结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>中序遍历</strong>伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(struct ThrTreeNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历以p为根的线索二叉树</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild;	<span class="comment">//从根开始找到一个无前驱的结点p</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     	visite(p-&gt;data);	<span class="comment">// 访问根结点</span></span><br><span class="line">        p = p-&gt;rchild;		<span class="comment">// p指向右孩子或后继结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态线索二叉链</strong>：$+$：左、右孩子；$-$：前驱、后继线索</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171906374.png" alt="image-20220222210752113"></p>
<h3 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h3><p><strong>二叉树的带权路径长度</strong>：$WPL=\sum_{k=1}^nw_kl_k$ ，其中:</p>
<ul>
<li>$n$：树叶结点的个</li>
<li>$w_k$：第$k$个结点的权</li>
<li>$l_k$：第$k$个叶子到根的路径长度</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171907706.png" alt="image-20220222161238235"></p>
<p><strong>Huffman树</strong>是一个带权路径长度最小的二叉树，又称<strong>最优二叉树</strong>。构建方法：</p>
<ul>
<li>将$\{w_1,w_2,…,w_n\}$看成$n$个二叉树</li>
<li>选择2个根结点最小的二叉树，构造新的二叉树，重复至剩1个树</li>
</ul>
<p>例：$Z:2,K:7,M:24,C:32,U:37,D:42,L:42,E:120$ </p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171908575.png" alt="image-20220222162202306"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171909519.png" alt="image-20220222162223523"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171909031.png" alt="image-20220222162328619"></p>
<p><strong>静态三叉链</strong>：</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171909737.png" alt="image-20220222195332551"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 5</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">htnode</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> weight;</span><br><span class="line">    <span class="keyword">int</span> llink, rlink, plink; <span class="comment">// 左孩子 右孩子 双亲</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Huffman编码</strong></p>
<p>Huffman编码是广泛地用于数据文件压缩的十分有效的编码方法。其压缩率通常在20%~90%之间。Huffman编码算法用字符在文件中出现的频率表来建立一个用0,1串表示各字符的最优表示方式。给出现频率高的字符较短的编码，出现频率较低的字符以较长的编码，可以大大缩短总码长。</p>
<p><strong>前缀码</strong>：对每一个字符规定一个0,1串作为其代码，并要求任一字符的代码都不是其它字符代码的前缀，这种编码称为前缀码。</p>
<p>二叉树C的Huffman编码是：$E:0,U:100,D:101,L:110,C:1110,Z:111100,K:111101,F:11111$ </p>
<h3 id="树、森林转换二叉树"><a href="#树、森林转换二叉树" class="headerlink" title="树、森林转换二叉树"></a>树、森林转换二叉树</h3><p><strong>树转换成二叉树</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171909051.png" alt="image-20220222153139457"  /></p>
<p><strong>森林转换成二叉树</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171910072.png" alt="image-20220222154146235"></p>
<p>树A的先序遍历：oabcdfeg   对应   二叉树B的先序遍历：oabcdfeg</p>
<p>树A的后序遍历：bafdecgo   对应   二叉树B的中序遍历：bafdecgo</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>图(Graph)</strong>是一种较线性结构和树更为复杂的数据结构。对于图来说，图中任意两个结点之间都可以直接相关。</p>
<p>图是一个二元组，$G=(V,E)$。其中，  $V$：顶点的有限集, $E$：关系(边)的有限集。</p>
<p>例：<img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171910614.png" alt="image-20220222214654118"></p>
<p>无向图  $G1=(V,E)\quad V＝\{v_1, v_2, v_3, v_4, v_5\}\quad E＝\{(v_1,v_2), (v_1,v_4),  (v_2,v_3), (v_2,v_5),  (v_3,v_4), (v_3,v_5)\}$ </p>
<p>有向图  $G2=(V,E)\quad V＝\{v_1, v_2, v_3, v_4\}\quad E＝\{<v_1,v_2>, <v_1,v_3>,  <v_3,v_4>, <v_4,v_1>\}$ </p>
<p>图是一种网状的数据结构，其中的结点之间的关系是任意的，即图中任何两个结点之间都可能直接相关。</p>
<p><strong>顶点</strong>：图中的数据元素</p>
<p><strong>边</strong>：两个顶点之间的关系。</p>
<ul>
<li>对于无向图，图中的顶点偶对（边）是无序的</li>
<li>而对于有向图，图中的顶点偶对（弧）是有序的<img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171910780.png" alt="image-20220222215421328" style="zoom: 67%;" /></li>
</ul>
<p><strong>完全图</strong>：有$n(n-1)/2$条边的无向图，即每个结点之间都有且只有一条边。</p>
<p><strong>有向完全图</strong>：有$n(n-1)$条边的有向图。</p>
<p><strong>稠密图</strong>：有很少的边或弧的图。</p>
<p><strong>稀疏图</strong>：有很多的边或弧的图。</p>
<p><strong>权</strong>：与图的边相关的数值。</p>
<p><strong>网</strong>：带权的图。</p>
<p><strong>子图</strong>：设两个图$G＝(V, E)$和$G’=(V’,E’)$，如果$V’\subseteq V$且$E’\subseteq  E$，则称$G’$为$G$的子图。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171910228.png" alt="image-20220222222143650" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171910510.png" alt="image-20220222220552674"></p>
<p><strong>邻接点</strong>：</p>
<ul>
<li>对于无向图$G＝(V,E)$，若存在顶点对$(x,y)\in E$，则称顶点$x$和$y$互为邻接顶点。即$x$和$y$相邻接（相关联）。</li>
<li>对于有向图$G＝(V,E)$，若存在顶点对$<x,y>\in E$，则称顶点$x$邻接到顶点$y$，顶点$y$邻接于到顶点$x$。</li>
</ul>
<p><strong>顶点的度</strong>：</p>
<ul>
<li>在无向图中，和该顶点相关联的边的数目称为顶点的度。</li>
<li>在有向图中，若$<x,y>$是一条弧，以$x$为尾的弧的数目称为顶点$x$的<strong>出度</strong>；以$x$为头的弧的数目称为顶点$x$<br>的<strong>入度</strong>。<strong>顶点的度等于该顶点的入度与出度之和</strong>。</li>
</ul>
<p><strong>路径</strong>：  在图$G＝( V, E )$中, 若从顶点 $x$ 出发，经过一些顶点 $v_1, v_2, … , v_m$ 到达顶点$y$。则称顶点序列 $(x,v_1,v_2, … ,V_m, y)$ 为从顶点 $x$ 到顶点 $y$ 的路径。</p>
<p><strong>路径长度</strong>：</p>
<ul>
<li>非带权图的路径长度是指此路径上边的条数。</li>
<li>带权图的路径长度是指路径上各边的权之和。</li>
</ul>
<p><strong>简单路径</strong>：序列中顶点不重复出现的路径。</p>
<p><strong>回路(环)</strong>：第一个顶点和最后一个顶点相同的路径。</p>
<p><strong>简单回路(环)</strong>：除第一个和最后一个顶点，其余顶点不重复出现的路径。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171911339.png" alt="image-20220222230204252"></p>
<p><strong>连通</strong>：在无向图中，如果从$x$到$y$存在路径，则称$x$和$y$是连通的。</p>
<p><strong>连通图</strong>：无向图$G$中如果任意两个顶点$x,y$之间都是连通的，则称图$G$是连通图。</p>
<p><strong>强连通图</strong>：有向图$G$中任意两个顶点$x,y$之间都是相互可达的。称图$G$是强连通图。</p>
<p><strong>连通分量</strong>：无向图中的<strong>极大连通子图</strong>（即把原图中任意一个不在子图中顶点加进去，子图从连通变为不连通，则为极大连通子图）。</p>
<p><strong>强连通分量</strong>：有向图中的极大连通子图。</p>
<p><strong>树图</strong>：极小连通子图（无环图），在$n$个顶点的情形下，有$n-1$条边。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171911892.png" alt="image-20220222232125649"></p>
<h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>数组表示法（邻接矩阵）</strong></p>
<p>图需要存储的信息：顶点和边。</p>
<p><strong>邻接矩阵</strong>：表示顶点之间相邻关系的矩阵。$a_{ij}=\begin{cases}1\quad <v_i,v_j>\in E \\ 0\quad others \end{cases}$ </p>
<p><strong>网的邻接矩阵</strong>：$A[i][j]=\begin{cases}W_{i,j}\quad <v_i,v_j>\in E \\ 0\quad i=j \\ \infty \quad others \end{cases}$</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171912797.png" alt="image-20220222234321262"></p>
<p>邻接矩阵的特点：</p>
<ul>
<li>无向图的邻接矩阵一定是一个对称矩阵。</li>
<li>无向图的邻接矩阵的第$i$行（或第$i$列）非零元素（或非$\infty$元素）个数为第$i$个顶点的度$D(v_i)$。</li>
<li>有向图的邻接矩阵的第$i$行非零元素（或非$\infty$元素）个数为第$i$个顶点的出度$OD(v_i)$，第$i$列非零元素（或非$\infty$元素）个数就是第$i$个顶点的入度$ID(v_i)$。</li>
</ul>
<p><strong>邻接表（邻接链表）</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171912283.png" alt="image-20220223000152339"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171912535.png" alt="image-20220223001012587"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171913586.png" alt="image-20220223002436155"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171913456.png" alt="image-20220223001557967"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> info;</span><br><span class="line">    <span class="keyword">int</span> vertex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span>* <span class="title">nextarc</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> degree;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">acrnode</span>* <span class="title">firstarc</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历：从图中某一顶点出发访遍图中其余结点，使每一个结点被访问且仅被访问一次。</p>
<p>图的遍历通常有两种方法：<strong>深度优先搜索</strong>和<strong>广度优先搜索</strong>。它们对有向图和无向图都适用。</p>
<h4 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索(Depth First Search)"></a><strong>深度优先搜索(Depth First Search)</strong></h4><blockquote>
<p>类似于树的先根遍历，是树的先根遍历的推广。</p>
</blockquote>
<pre><code>  从图中某个顶点v出发，访问此顶点，然后依次从v的未被访问的邻接点出发深度优先遍历图,   直至所有与v有通路的顶点都被访问到；若此时图中还有顶点未被访问到，则另选图中未被访问的顶点作起点，重复上述过程，直到图中所有顶点都被访问到为止。
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(graph g, vtxptr v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从v0出发深度优先遍历图g,</span></span><br><span class="line">    <span class="comment">// g是连通图 或 非连通图中的一个连通分量访问v0;</span></span><br><span class="line">    w = v0的第一个连接点;</span><br><span class="line">    <span class="keyword">while</span>(当邻接点w存在时) &#123;</span><br><span class="line">        <span class="keyword">if</span>(w未访) dfs(g, w);</span><br><span class="line">        w = 下一邻接点;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="广度优先搜索-Breadth-First-Search"><a href="#广度优先搜索-Breadth-First-Search" class="headerlink" title="广度优先搜索(Breadth First Search)"></a><strong>广度优先搜索(Breadth First Search)</strong></h4><blockquote>
<p>类似于树的层次遍历。</p>
</blockquote>
<pre><code>  从图中某个顶点v出发，在访问了v之后，依次访问v的各个未曾访问过的邻接点(并保证先被访问的顶点的邻接点“要先于”后被访问的顶点的邻接点被访问),     直至图中所有已被访问的顶点的邻接点都被访问到。若此时图中还有未被访问的顶点，则任选其中之一作为起点，重新开始上述过程，直至图中所有顶点都被访问到。
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(graph g, vtxptr v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从v0出发广度优先遍历图g（g是连通图或连通分量）</span></span><br><span class="line">    visite(v0); mark[v0] = <span class="number">1</span>;</span><br><span class="line">    initqueue(Q);</span><br><span class="line">    enqueue(Q, v0); <span class="comment">// v0进队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!empty(Q)) &#123;</span><br><span class="line">        dequeue(Q, v);</span><br><span class="line">        w = v的第一个邻接点;</span><br><span class="line">        <span class="keyword">while</span>(w存在) &#123;</span><br><span class="line">            <span class="keyword">if</span>(w未访) &#123;</span><br><span class="line">            	visite(w); mark[w] = <span class="number">1</span>; enqueue(Q, w);</span><br><span class="line">                w = 下一邻接点;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171913653.png" alt="image-20220228104959785"></p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><strong>生成树</strong>：按深度遍历得到的生成树称为深度优先生成树；按广度遍历得到的生成树称为广度优先生成树。</p>
<p>连通图或有根有向图可以生成树。</p>
<p><strong>有根的图</strong>：存在一个顶点X,从该顶点出发可以沿着有向路径到达图中其余各顶点的有向图。顶点X为图的根。</p>
<p><strong>生成树林</strong>：从非连通图中任意一个顶点出发，或者从非强连通图中任意一个非根顶点出发，都不可能沿着边<br>访问到图中的所有顶点。</p>
<p><strong>最小生成树</strong>：生成树中边的权值（代价）之和最小的树。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171913802.png" alt="image-20220228110032759"></p>
<h4 id="Kruscal算法"><a href="#Kruscal算法" class="headerlink" title="Kruscal算法"></a><strong>Kruscal算法</strong></h4><p>基本思想：设$T=(U,TE)$是$G=(V,E)$的最小生成树，$U$的初值等于$V$，$TE$的初值为空集。将图中的<strong>边按权值从小到大的顺序依次选取</strong>，若选取的边使生成树$T$不形成回路，则把它并入$TE$中，保留作为$T$的一条边；若选取的边使生成树T形成回路，则将其舍去。如此进行下去，直到$TE$中包含有$n-1$条边为止。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171914006.png" alt="image-20220228111700867"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T = &#123;V, E&#125;;</span><br><span class="line"><span class="keyword">while</span>(T的边数 &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">    在E中选择代价最小的边(u, v);</span><br><span class="line">    并置 E = E - (u, v);</span><br><span class="line">    <span class="keyword">if</span>(不构成回路) &#123;</span><br><span class="line">        T = T + &#123;u, v&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a><strong>prim算法</strong></h4><p>从某一顶点开始，找$n-1$条不构成回路的最小边（顶点偶对）。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171915818.png" alt="image-20220228112316673"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minispantree_prim</span><span class="params">(graph g, <span class="keyword">int</span> u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从u出发构造网g的最小生成树</span></span><br><span class="line">	<span class="keyword">for</span>(v = <span class="number">1</span>; v &lt;= vtxnum; v++) &#123; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">if</span>(v != u) &#123;</span><br><span class="line">            closedge[v].vex = u;</span><br><span class="line">            closedge[v].lowcost = g[u][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= vtxnum - <span class="number">1</span>; ++i) &#123; </span><br><span class="line">        k=最小边所在下标位置;输出生成树的边;</span><br><span class="line">        closedge[k].lowcost = <span class="number">0</span>; <span class="comment">////顶点k并入U集</span></span><br><span class="line">        <span class="keyword">for</span>(v = <span class="number">1</span> ; v &lt;= vtxnum; ++v) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(g[k][v] &lt; closedge[v].lowcost) &#123; <span class="comment">// 选择具有最小代价的边</span></span><br><span class="line">   				closedge[v].lowcost=g[k][v]; </span><br><span class="line">                closedge[v].vex=k;  </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>用顶点边表示活动的网络，简称<strong>AOV网络(Activity On Vertices)</strong></p>
<p><strong>顶点</strong>：一个工程中的活动(Activity)</p>
<p><strong>边</strong>：活动的顶点间的优先关系(Relation)</p>
<p>可以用有向图表示一个工程。在这种有向图中，用顶点表示活动。有向边$<V_i,V_j>$表示：$V_i$必须先于活动$V_j$进行。这种有向图叫做顶点表示活动的<strong>AOV网络(Activity On Vertices)</strong></p>
<p>在AOV网络中，如果活动$V_i$，必须在活动$V_j$，之前进行，则存在有向边$<V_i,V_j>$，AOV网络中不能出现有向回路，即有向环。在AOV网络中如果出现了有向环，则意味着某项活动应以自己作为先决条件。因此，对给定的AOV网络，必须先判断它是否存在有向环。</p>
<p>将各个顶点（代表各个活动）排列成一个线性有序的序列，使得AOV网络中所有应存在的前驱和后继关系<br>都能得到满足——<strong>拓扑序列</strong>。</p>
<p>这种构造AOV网络全部顶点的拓扑有序序列的运算就叫做<strong>拓扑排序</strong>。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171915291.png" alt="image-20220228165540390"></p>
<p><strong>存储结构（邻接表）：</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171916056.png" alt="image-20220228170107169"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;</span><br><span class="line">    arcnode *nextarc;</span><br><span class="line">&#125;* pointer;	<span class="comment">// 表结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> vexdata;</span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">// 顶点的入度</span></span><br><span class="line">    pointer firstarc;</span><br><span class="line">&#125;dig[<span class="number">100</span>];	<span class="comment">//一组头结点</span></span><br></pre></td></tr></table></figure>
<p><strong>拓扑排序的方法</strong>：</p>
<p>首先建立(n个顶点的)AOV网。</p>
<p>1、在AOV网络中选一个没有直接前驱的项点（入度为0的顶点），并输出之；</p>
<p>2、从图中删去该顶点，同时删去所有它发出的边；</p>
<p>重复(1)和(2)，直到全部顶点均已输出，</p>
<p>拓扑有序序列形成，拓扑排序完成：</p>
<p>若图中还有未输出的顶点，但已跳出处理循环。这说明图中存在环</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171916422.png" alt="image-20220228170619932"></p>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>用边表示活动的网络，简称 <strong>AOE网络 (Activity On Edges) </strong></p>
<p><strong>边</strong>：一个工程中的活动(Activity)</p>
<p><strong>边上权值</strong>：活动持续时间(Duration)</p>
<p><strong>顶点</strong>：事件 (Event)</p>
<p>完成整个工程所需的时间取决于从源点到汇点的最长路径长度，即在这条路径上所有活动的持续时间之和。这条路径长度最长的路径就叫做<strong>关键路径(Critical Path)</strong>。</p>
<p>1）先求所有事件的$Ve$ $\quad$  2）通过$Ve$反向求所有事件$Vl$</p>
<p>事件$V_j$的最早可能开始时间$Ve[j]$——从源点$V1$ 到顶点$V_j$的最长路径长度。</p>
<ul>
<li>$Ve(1)=0$                             </li>
<li>$Ve(j)=max\{Ve(i)+<i,j>的权\} $</li>
</ul>
<p>事件$V_i$ 的最迟允许开始时间$Vl[i]$ ——在保证汇点$Vn$ 在$Ve[n]$时刻完成的前提下，事件$V_i$的允许的最迟开始时间。</p>
<ul>
<li>$Vl(n)=Ve(n)$</li>
<li>$Vl(i)=min\{Vl(j)-<i,j>的权\}$</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171916865.png" alt="image-20220228172012931"></p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>最短路径问题：如果从图中某一顶点(称为源点)到达另一顶点（称为终点）的路径可能不止一条，如何找到一条路径使得<br>沿此路径上各边上的权值总和达到最小。</p>
<p>解法：</p>
<ul>
<li>单源最短路径问题——Dijkstra算法</li>
<li>所有顶点之间的最短路径——Floyd算法</li>
</ul>
<h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p><strong>单源最短路径问题</strong>：给定一个带权有向图D与源点v，求从v到D中其它顶点的最短路径（限定各边上的权值大于或等于0） 。</p>
<p>按路径长度的递增次序，逐步产生最短路径。首先求出长度最短的一条最短路径，再参照它求出长度次短的一条最短路径，依次类推，直到从顶点v到其它各顶点的最短路径全部求出为止。</p>
<ul>
<li>引入一个辅助数组$dist$。它的每一个分量$dist[i]$表示当前找到的从源点$v_0$到终点$v_i$的最短路径的长度。初始状态：<ul>
<li>若从源点$v_0$到顶点$v_i$有边，则$dist[i]$为该边上的权值</li>
<li>若从源点$v_0$到顶点$v_i$没有边，则$dist[i]$为$+\infty$</li>
</ul>
</li>
<li>假设 $S$ 是已求得的最短路径的终点的集合。</li>
<li>首先，在 $dist$ 数组中求最小值$v_k(v_k\in V-S)$ ，将$v_k$加入集合 $S$</li>
<li>然后，对所有的$v_i\in V-S$，修改其$dist[i]$值（$v_0-&gt;v_i$短，还是$v_0-&gt;v_k-&gt;v_i$更短）</li>
<li>重复上述过程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//a[i][j]:(vi,vj)的权，dist[j]:当前求到的从顶点v 到顶点j的最短路径长度, </span></span><br><span class="line">	<span class="comment">//同时用数组path[j]:存放求到的最短路径, 0 &lt;= j &lt; n</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dist[i] = a[v][i];	<span class="comment">// dist数组初始化</span></span><br><span class="line">        S[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i != v &amp;&amp; dist[i] &lt; MAXNUM) path[i] = v;</span><br><span class="line">        <span class="keyword">else</span> path[i] = <span class="number">-1</span>;	<span class="comment">//path数组初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    S[v] = <span class="number">1</span>; 	<span class="comment">// 顶点v加入顶点集合</span></span><br><span class="line">    dist[v] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ ) &#123;			</span><br><span class="line">		u = 当前不在集合S中且具有最短路径的顶点;</span><br><span class="line">		S[u] = <span class="number">1</span>;  <span class="comment">//将顶点u加入集合S</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++)  &#123;  <span class="comment">//修改 </span></span><br><span class="line">			<span class="keyword">if</span> ( !S[w] &amp;&amp; a[u][w] &lt; MAXNUM &amp;&amp; dist[u] + a[u][w] &lt; dist[w] ) &#123;</span><br><span class="line">				dist[w] = dist[u] + a[u][w]; </span><br><span class="line">				path[w] = u;</span><br><span class="line">            &#125; </span><br><span class="line">      	&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171917184.png" alt="image-20220228180249428"></p>
<h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><p><strong>所有顶点之间的最短路径</strong>：对每一对顶点$v_i\neq v_j$，要求求出$v_i$与$v_j$之间的最短路径和最短路径长度。</p>
<p><strong>Floyd算法的基本思想</strong>：</p>
<p>定义一个$n$阶方阵序列：$A^{(0)},A^{(1)},…,A^{(n)}$ </p>
<p>其中 $A^{(0)}[i][j] = a[i][j] \\ A^{(k)}[i][j] = min\{A^{(k-1)}[i][j],A^{(k-1)}[i][k] + A^{(k-1)}[k][j]\} \quad k = 1,2,…, n $   </p>
<p>$A^{(k)}[i][j]$是从顶点$v_i$到$v_j$，中间顶点的序号不大于$k$的最短路径的长度，$A^{(n)}[i][j]$是从顶点$v_i$到$v_j$的最短路径长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>, i &lt;= n; ++i) &#123;	<span class="comment">//矩阵a与path初始化</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != j &amp;&amp; a[i][j] &lt; MAXINT) &#123;</span><br><span class="line">                path[i][j] = i;	<span class="comment">// i到j有路径</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                path[i][j] = <span class="number">0</span>;	<span class="comment">// i到j无路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; ++k) &#123; <span class="comment">//产生a(k)及path(k)</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( a[i][k] + a[k][j] &lt; a[i][j] ) &#123; </span><br><span class="line">					a[i][j] = a[i][k] + a[k][j];</span><br><span class="line">		  			path[i][j] = k;</span><br><span class="line">                &#125;   <span class="comment">//缩短路径长度(i-- k -- j )</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171917790.png" alt="image-20220302104402103"></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><strong>查找表</strong>是由同一类型的数据元素（或记录）构成的集合。</p>
<p><strong>关键字</strong>：记录中某一数据项的值。</p>
<p><strong>主关键字</strong>：能唯一确定一个元素的关键字（如学号、商品号）。</p>
<p><strong>查找</strong>：根据给定的关键字，在查找表中确定一个其关键字等于给定值的数据元素（记录）的过程</p>
<p><strong>平均查找长度(ASL)</strong>：查找一个结点所作的平均比较次数（ASL是衡量一个查找算法优劣的主要标准）</p>
<h3 id="静态表的查找"><a href="#静态表的查找" class="headerlink" title="静态表的查找"></a>静态表的查找</h3><p>静态表——以顺序结构存储的表(顺序表)</p>
<p>在表上所作的操作—— 查询某个数据元素是否在查找表中</p>
<h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>算法思想：</p>
<ul>
<li>从表的一端开始，用给定值k与表中各个结点的关键字逐个比较。<ul>
<li>查找成功——找出相等的值；</li>
<li>查找失败——已到达表的另一端，即表中所有结点的关键字值都不等于k。</li>
</ul>
</li>
<li>可在此设置一个监视哨，作为下标越界的条件</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171917722.png" alt="image-20220302111152734"></p>
<p><strong>监视哨的作用</strong>：作为越界（即已查完）的检测条件省去在循环中每次均要判定是否越界，从而节省比较的时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    keytype key;</span><br><span class="line">    datatype info;</span><br><span class="line">&#125;sstable;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(elemtype r[], <span class="keyword">int</span> n, keytype k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在n个结点的顺序表r[1]..r[n]中查找关键字 k</span></span><br><span class="line">	<span class="keyword">int</span> i = n; <span class="comment">// 从表尾开始向前查找</span></span><br><span class="line">    r[<span class="number">0</span>].key = k;	<span class="comment">//设置监视哨</span></span><br><span class="line">    <span class="keyword">while</span>(r[i].key != k) i--;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">//若r[i].key==k , 则返回i （i≠0） , 否则返回0(未找到）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<ul>
<li>查找成功的平均查找长度（在等概率的前提下）$ASL=(1+2+……+n)/n =(n+1)/2$ </li>
<li>查找失败的平均查找长度 $n+1$  </li>
</ul>
<h4 id="二分-折半-查找"><a href="#二分-折半-查找" class="headerlink" title="二分(折半)查找"></a>二分(折半)查找</h4><p>二分查找的先决条件：表中结点按关键字有序，且顺序（一维数组）存储。</p>
<p>二分法思想：<strong>取中，比较</strong> </p>
<ul>
<li>求有序表的中间位置$mid$，若$r[mid].key==k$，查找成功； </li>
<li>若$r[mid].key&gt;k$，在左子表中继续进行二分查找；</li>
<li>若$r[mid].key&lt;k$，则在右子表中继续进 行二分查找。</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171918530.png" alt="image-20220302113132985"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171918576.png" alt="image-20220302113310417"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_bin</span><span class="params">(elemtype r[], <span class="keyword">int</span> n, keytype k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  r[1]..r[n] 是按key排序的n个元素，在表中查找 k</span></span><br><span class="line">    i = <span class="number">1</span>; j = n;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">        mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == r[mid].key) <span class="keyword">return</span> mid;	<span class="comment">//查找成功</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; r[mid].key) j = mid - <span class="number">1</span>;	<span class="comment">//在左半部分继续查找</span></span><br><span class="line">        <span class="keyword">else</span> i = mid + <span class="number">1</span>;	<span class="comment">//在右半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//k不在该有序表中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二分查找判定树</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171918605.png" alt="image-20220302114323609"></p>
<p>折半查找算法的执行时间为$O(log_2n)$，比顺序查找速度快。</p>
<p>与顺序查找方法相比，折半查找方法的缺点是需要对n个元素预先进行排序，而且只能用顺序方法存储这些元素。</p>
<h4 id="索引顺序表的查找"><a href="#索引顺序表的查找" class="headerlink" title="索引顺序表的查找"></a>索引顺序表的查找</h4><p><strong>分块查找</strong>，又称索引顺序查找。它是顺序查找的一种改进。在此查找方法中，需要建立一个“索引表”。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171918588.png" alt="image-20220302114743820"></p>
<p><strong>查找方法</strong>：先确定待查记录所在的块（子表）；然后在块中顺序查找。</p>
<h4 id="静态树表的查找"><a href="#静态树表的查找" class="headerlink" title="静态树表的查找"></a>静态树表的查找</h4><p><strong>建立静态树表</strong>：</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171918422.png" alt="image-20220302115007153"></p>
<h3 id="动态表的查找"><a href="#动态表的查找" class="headerlink" title="动态表的查找"></a>动态表的查找</h3><p>动态表的查找，也即树表的查找。一种以树的形式来组织查找表的方法，以实现动态高效率的查找</p>
<ul>
<li>二叉排序树 BST: Binary Sort(Seachar) Tree</li>
<li>平衡二叉树</li>
<li>B-树</li>
<li>B+树</li>
</ul>
<h4 id="二叉排序树BST"><a href="#二叉排序树BST" class="headerlink" title="二叉排序树BST"></a>二叉排序树BST</h4><p><strong>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree）</strong></p>
<p>二叉排序树或空，或满足如下性质：</p>
<ul>
<li>有一个根，若根的左子树非空，则左子树上所有结点的关键字值均小于根结点的值。若根的右子树非空，则右子树上的所有结点的关键字值均大于根结点的值。</li>
<li>左右子树同样是二叉排序树。</li>
</ul>
<p>二叉排序树的特点</p>
<ul>
<li>中序遍历得一有（升）序序列</li>
</ul>
<p>查找方法</p>
<ul>
<li>若根结点的关键字值等于查找的关键字，查找成功。</li>
<li>若小于根结点的关键字值，查其左子树。</li>
<li>若大于根结点的关键字的值，则查其右子树。</li>
<li>在左右子树上的操作类似。</li>
</ul>
<p>结点结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bnode</span> &#123;</span></span><br><span class="line">    keytype key;</span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bnode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bnode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bnode</span> <span class="title">bstnode</span>;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171919254.png" alt="image-20220302120937056"></p>
<p>算法伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bstnode *<span class="title">bstsearch</span><span class="params">(bstnode *t, keytype k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  t:指向根结点, k:待查找关键字</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span> || t-&gt;key == K) <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;key &gt; k) <span class="keyword">return</span> bstsearch(t-&gt;lchild, k); <span class="comment">// 在左子树上查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> bstsearch(t-&gt;rchild, k); <span class="comment">// 在右子树上查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二叉排序树的插入</p>
<ul>
<li>若二叉树为空。则生成根结点。</li>
<li>若二叉树非空<ul>
<li>首先找到被插结点的父结点。</li>
<li>判断被插结点是其父结点的左、右儿子，将其作为叶子结点插入。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171919878.png" alt="image-20220302121452066"></p>
<p>二叉排序树的删除</p>
<ul>
<li><p>删除叶子结点：直接删除。如删除24</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171919682.png" alt="image-20220302122725653" style="zoom:67%;" /></p>
</li>
<li><p>删除子树的根结点：若被删结点的左儿子为空或者右儿子为空。如删除100</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171919052.png" alt="image-20220302122932730" style="zoom:67%;" /></p>
</li>
<li><p>删除子树的根结点且被删结点的左子树和右子树均不空。如删除12</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171920180.png" alt="image-20220302141220666" style="zoom:67%;" /></p>
</li>
<li><p>一般情况</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171920402.png" alt="image-20220302141922103" style="zoom:80%;" /></p>
</li>
</ul>
<h4 id="平衡二叉树AVL"><a href="#平衡二叉树AVL" class="headerlink" title="平衡二叉树AVL"></a>平衡二叉树AVL</h4><p><strong>平衡二叉树(Balanced Binary Tree)又称AVL树</strong>。它或是空树，或是具有下列性质的二叉排序树。</p>
<ul>
<li>它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。</li>
</ul>
<p><strong>平衡因子(Balance Factor)</strong></p>
<ul>
<li>左子树的深度 - 右子树的深度</li>
<li>即平衡二叉树中每一结点的平衡因子为：0，1，-1。</li>
</ul>
<p>平衡二叉树的查找</p>
<ul>
<li>与二叉排序树查找方法相同。</li>
</ul>
<p>平衡二叉树的插入</p>
<ul>
<li>找插入位置并插入结点</li>
<li>若插入后导致不平衡，则进行调整</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171920649.png" alt="image-20220302143707289"></p>
<p><strong>平衡旋转</strong></p>
<ul>
<li><p><strong>LL旋转</strong>（LL：表示新插入的结点在危机结点的左子树的左子树上）</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171922611.png" alt="image-20220302144157948"></p>
</li>
<li><p><strong>LR旋转</strong>（LR：表示新插入的结点在为危机结点的左子树的右子树上）</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171922442.png" alt="image-20220302144811362"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171922648.png" alt="image-20220302145017958"></p>
</li>
<li><p><strong>RR旋转</strong>（RR：表示新插入的结点在为危机结点的右子树的右子树上）</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171922200.png" alt="image-20220302151745811"></p>
</li>
<li><p><strong>RL旋转</strong>（RL：表示新插入的结点在为危机结点的右子树的左子树上）</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171922652.png" alt="image-20220302151404708"></p>
</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171923322.png" alt="image-20220302152456758"></p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h4><p>$m$阶B-树或空，或满足</p>
<ul>
<li>树中每个结点最多有$m$个子树 ；</li>
<li>若根结点不是叶子结点，则至少有2个子树；       </li>
<li>除根结点外的所有非叶子结点至少有<code>ceil((double)m/2)</code> 个子树，<code>ceil</code>是向上取整，如：4阶则至少2个，5阶至少3个   </li>
<li>所有的非叶子结点中包含的数据信息为：$(n,A0,K1,R1,A1,K2,R2,A2, ………,Kn,Rn,An,parent)$，其中<ul>
<li>$n$：关键字的个数</li>
<li>$Ki$：关键字</li>
<li>$Ai$：$&gt; Ki$ 且 $&lt; Ki+1$ 的结点地址（A0： &lt;K1 的结点的地址）</li>
<li>$Ri$：关键字 $= Ki$ 的数据记录在硬盘中的地址 $K1 &lt;=K2 &lt;= …… &lt;= Kn$, </li>
<li>$Parent$：父结点的地址，这个可以没有</li>
</ul>
</li>
<li>所有的叶子结点都出现在同一层上，且不带信息</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171923828.png" alt="image-20220302154030624"></p>
<p>B-树是一个$m$叉平衡排序树</p>
<p><strong>B-树的查找</strong></p>
<ul>
<li><p>类似于二叉树的查找</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171923235.png" alt="image-20220302154540083"></p>
</li>
</ul>
<p><strong>B-树查找算法伪代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">result <span class="title">srch_mbtree</span><span class="params">(mblink t; keytype k)</span> <span class="comment">//在B-树中查找k</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p=t; q=<span class="literal">NULL</span>; i=<span class="number">0</span>;  <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        i = Search(p, k);</span><br><span class="line">        <span class="comment">//在p-&gt;key[1...n]中查找</span></span><br><span class="line">        <span class="comment">//直至p-&gt;key[i] &lt;= k &lt; p-&gt;key[i+1] 止, 0&lt;=i&lt;=n</span></span><br><span class="line">		<span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; p-&gt;key[i] = k ) <span class="keyword">return</span> (p, i, <span class="number">1</span>);	<span class="comment">//查找成功</span></span><br><span class="line">        <span class="keyword">else</span> &#123; q = p; p = p-&gt;ptr[i]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (q, i, <span class="number">0</span>);	<span class="comment">//查找不成功，返回插入位置信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>B-树的插入</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171923065.png" alt="image-20220302155419209"></p>
<p>问题：若插入一元素时，使得某一结点&gt;m叉？例如插入60</p>
<p>解决方法：分裂！将一个结点分成两个结点</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171924301.png" alt="image-20220302161846561"></p>
<p><strong>B-树的删除</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171924894.png" alt="image-20220302162714219"></p>
<h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h4><p>B+树是 B-树的变形树。</p>
<p>m 阶 B+树与m阶B-树的差异在于：</p>
<ul>
<li>有n个子树的结点中含有n个关键字</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171924785.png" alt="image-20220302163033512"></p>
<p><strong>B+树的查找</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171924931.png" alt="image-20220302170240833"></p>
<p><strong>B+树的插入</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171924874.png" alt="image-20220302170918508"></p>
<p><strong>B+树的删除</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171925090.png" alt="image-20220302171154195"></p>
<h3 id="hash-散列-查找"><a href="#hash-散列-查找" class="headerlink" title="hash(散列)查找"></a>hash(散列)查找</h3><p><strong>hash表</strong>：根据设定的散列函数和相应解决冲突的方法为一组结点建立的一张表，表中的结点的存储位置依赖于设定的散列函数和处理冲突的方法。</p>
<p><strong>hash（又称散列、杂凑）的基本思想</strong>：以结点的关键值$k$为自变量，通过一定的函数关系 $h$ 计算出对应的函数值 $h(k)$，把这个值解释为结点的存储地址（散列地址）， 将结点存入该地址中去。</p>
<p>设计1个hash函数，计算 Hash函数， 其函数值恰好是 key 在 hash 表中的地址 $hash(key)=i (0..m-1)$</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171925558.png" alt="image-20220302172909868"></p>
<p><strong>冲突</strong></p>
<p>若对于不同的键值$k1$和$k2$，且$k1\neq k2$，但$h(k1)=h(k2)$，即具有相同的散列地址，这种现象称为<strong>冲突</strong>。称 $k1$、$k2$称为同义词</p>
<p>例：$key=\{3,15,20,24\}$，$m=5$（表长），$hash(k)=k%5$<br>则：$hash(15)=hash(20)=0$ 产生冲突。</p>
<p><strong>表长m的选取</strong></p>
<p>参考：$n / m≈ 3 / 4$  </p>
<ul>
<li>m: hash表的表长</li>
<li>n: hash表中关键字个数</li>
</ul>
<p><strong>装填（负载）因子</strong></p>
<p>$\alpha=表中填入的记录数\div hash表的长度$</p>
<h4 id="构造hash函数"><a href="#构造hash函数" class="headerlink" title="构造hash函数"></a>构造hash函数</h4><p><strong>构造hash函数需要考虑的因素</strong></p>
<ul>
<li>计算hash函数的效率；</li>
<li>关键字的长度（包括是否等长）；</li>
<li>hash表的大小；</li>
<li>关键字的公布情况；</li>
<li>记录的查找频率。</li>
</ul>
<p>1、<strong>直接定址法</strong></p>
<p>哈希函数为关键字的线性函数。$H(key) = key$ 或者 $H(key) = a\times key+b$ </p>
<p>仅限于：地址集合的大小 = 关键字集合的大小。如：$H(key)=key-1949$ </p>
<p>2、<strong>数字分析法</strong></p>
<p>假设关键字集合中的每个关键字都是由$s$位数字组成$(k1, k2, …, kn)$，分析关键字集中的全体，并从中提取分布均匀的若干位或它们的组合作为地址。</p>
<p>仅限于：能预先估计出全体关键字的每一位上各种数字出现的频度。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171926257.png" alt="image-20220303103412677"></p>
<p>3、<strong>平方取中法</strong></p>
<p>若关键字的每一位都有某些数字重复出现频度很高的现象，则先求关键字的平方值，以通过“平方”扩大差别，同时平方值的中间几位受到整个关键字中各位的影响。</p>
<p>例如：$a=0100$, 则 $a^2=0010000$<br>            $i =1100$, 则 $i^2 =1210000$<br>            $j =1200$, 则 $j^2 =1440000$</p>
<p>若超出范围时，可再取模</p>
<p><strong>问题</strong>：在数字分析法和平方取中法，取哪几位作为hash地址？“中间几位”由表长决定。如表长为1000,Hash表的地址空间为000-999，所以取中间3位。</p>
<p>4、<strong>折叠法</strong></p>
<p>若关键字的位数比较长，则可将其分割成几部分，然后取它们的叠加和为哈希地址。</p>
<p>两种处理方法：<strong>移位叠加和间界叠加</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171926811.png" alt="image-20220302174432637"></p>
<p>5、<strong>除留余数法</strong></p>
<p>选择一个适当的正整数 $p$，用$p$去除关键值，取其余数作为散列地址，即：$hash(key)=key%p$    $p≤m(表长)$</p>
<p>$p$ 应为不大于$m$ 的最大质数</p>
<p>例：设表长 $m=8，16，32，64，128，1001$<br>               则 $p=7，13，31，61，127，1001$</p>
<p>6、<strong>随机数法</strong></p>
<p>$H(key) = Random(key)$ </p>
<p>采用何种构造哈希函数的方法取决于关键字集合的情况(包括关键字的范围和形)，总的原则是使产生冲突的可能性降到尽可能<br>的小。</p>
<h4 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h4><p>1、<strong>链地址法</strong></p>
<p>将具有相同散列地址的记录都存储在同一个线性链表中。</p>
<p>例：以$\{14,1,68,27,55,23,11,10,19,20,79,84\}$构造hash表。<br>分析： $n=12\quad n/m=3/4$ ,  所以 $m=16$ ,  则 $p=13 \quad hash(key)=key % 13$</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171926460.png" alt="image-20220303095239166"></p>
<p>2、<strong>开放定址法</strong></p>
<p>当冲突发生时，使用某种方法在散列表中形成一个探查序列，沿着此序列逐个地址去探查，直到找到一个开放的地址（空位置），将发生冲突的键值放到该地址中。$H_i=(H(key)+d_i)%m$</p>
<ul>
<li>线性探查法 $d_i = 1,2,3,…,m-1$</li>
<li>二次探查法 $d_i=1^2,-1^2,2^2,-2^2,…,k^2,-k^2$ </li>
<li>伪随机探测法 $d_i = 伪随机数序列$ </li>
<li>再散列探测法</li>
</ul>
<p>2.1 <strong>线性探测法</strong></p>
<p>对给定的关键值 $k$，若地址$d$ (即$h(k)=d$)的单元发生冲突，则依次探查下述地址单元（设$m$为表长）：$d+1,d+2,…,m-1, 0 ,1,…d-1$</p>
<p>设增量函数为$d(i)=1,2,3,……m-1$ （$i$: 为探测次数）</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171926993.png" alt="image-20220303100445354"></p>
<p>2.2 <strong>二次探测法</strong></p>
<p>对给定的关键值 $k$，若地址$d$ (即$h(k)=d$)的单元发生冲突，则探查下述地址单元：$d+1,d-1,d+4,d-4,d+9,d-9,…$</p>
<p>设增量函数为 $d(i)=1^2,-1^2,2^2,-2^2,……,k^2,-k^2\quad (k&lt;=m/2)$ </p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171926146.png" alt="image-20220303101203785" style="zoom:80%;" /></p>
<p>2.3 <strong>伪随机探测法</strong></p>
<p>2.4  <strong>再散列探测法</strong></p>
<p>设$m$为表长，当 $h1(k1)=h2(k2)=d$ 时，</p>
<p>使探查序列为： $(d+h2(k))%m \\ (d+2h2(k))%m \\ (d+3h2(k))%m \\ …… $</p>
<p>$h2$的选取方法为：</p>
<ul>
<li>若$m$为素数：$h2(k)=k%(m-2)+1$</li>
<li>若$m$为$2^i$：$h2(k)=1～m-1$之间的任一奇数。（这样总保证使$h2(k)$和$m$互质）</li>
</ul>
<p>3、<strong>公共溢出区法</strong></p>
<p>将关键字相同（即具有相同散列地址）的记录都存储在同一个溢出区中。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171927293.png" alt="image-20220303104613276" style="zoom:80%;" /></p>
<h4 id="hash表的查找"><a href="#hash表的查找" class="headerlink" title="hash表的查找"></a>hash表的查找</h4><p>查找过程和造表过程一致。</p>
<p>假设采用开放定址处理冲突，则查找过程为:</p>
<p>对于给定值$K$, 计算哈希地址 $j = H(K)$</p>
<ul>
<li><p>若$r[j] = NULL$ 则查找不成功</p>
</li>
<li><p>若$ r[i].key = K$ 则查找成功</p>
</li>
<li><p>否则 求下一地址$j$，直至$r[j] = NULL$ (查找不成功)或$r[j].key = K$ (查找成功)</p>
</li>
</ul>
<p><strong>用线性探测法解决冲突</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hashsize = &#123;<span class="number">997</span>, ...&#125; 	<span class="comment">// 哈希表容量递增表，一个合适的素数序列</span></span><br><span class="line"><span class="keyword">typedef</span> struct &#123;</span><br><span class="line">    ElemType *elem;	<span class="comment">//数据元素存储基址，动态分配数组</span></span><br><span class="line">    <span class="keyword">int</span> count;		<span class="comment">//当前数据元素个数</span></span><br><span class="line">    <span class="keyword">int</span> sizeindex;	<span class="comment">//hashsize[sizeindex]为当前容量</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUPLICATE -1</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">SearchHash</span><span class="params">(HashTable H, KeyType k, <span class="keyword">int</span> &amp;p, <span class="keyword">int</span> &amp;c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    j = Hash(k);</span><br><span class="line">    <span class="keyword">while</span>(shtable[j] != nullrecd &amp;&amp; shtable[j].key != k) j = (j + <span class="number">1</span>) % m;</span><br><span class="line">    <span class="keyword">if</span>(shtable[j] == nullrecd) <span class="keyword">return</span> nulladr;	<span class="comment">//未找到</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(shtable[j].key == k) <span class="keyword">return</span> j;		<span class="comment">//查找成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>用链地址法解决冲突</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">j = Hash(k);</span><br><span class="line">p = shtable[j];</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; p-&gt;key != k) p = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="literal">NULL</span>;		<span class="comment">//未找到</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;key == k) <span class="keyword">return</span> p;	<span class="comment">//查找成功</span></span><br></pre></td></tr></table></figure>
<p><strong>决定哈希表查找的ASL的因素：</strong></p>
<ul>
<li>选用的哈希函数;</li>
<li>选用的处理冲突的方法;</li>
<li><p>哈希表饱和的程度，装载因子$α=n/m$ 值的大小。</p>
</li>
<li><p>一般情况下，可以认为选用的哈希函数是“均匀”的，则在讨论ASL时，可以不考虑它的因素。</p>
</li>
</ul>
<p><strong>hash表的查找分析</strong>：</p>
<p>装填（负载）因子：$α=表中填入的记录数\div hash表的长度$ </p>
<p>查找成功</p>
<ul>
<li>线性探测再散列 $S_{nl}\approx \frac{1}{2}(1+\frac{1}{1-\alpha})$ </li>
<li>链地址法 $S_{nc}\approx 1+\frac{\alpha}{2}$ </li>
<li>随机探测再散列、二次探测再散列 $S_{nr}\approx -\frac{1}{\alpha}\ln(1-\alpha)$ </li>
</ul>
<p>查找失败</p>
<ul>
<li>线性探测再散列 $S_{nl}\approx \frac{1}{2}(1+\frac{1}{(1-\alpha)^2})$ </li>
<li>链地址法 $S_{nc}\approx \alpha + e^{-\alpha}$  </li>
<li>随机探测再散列、二次探测再散列 $S_{nr}\approx \frac{1}{1-\alpha}$ </li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="概念及分类"><a href="#概念及分类" class="headerlink" title="概念及分类"></a>概念及分类</h3><p><strong>排序</strong>：将一组任意顺序的数据，重新排列成按关键字有序的序列。</p>
<p> 一般情况下，假设含$n$个记录的序列为：$\{R_1, R_2,…,R_n\}$ </p>
<p>其相应的关键字序列为：$\{K_1,K_2,…,K_n\}$    </p>
<p>关键字相互之间可以进行比较，即存在关系：$K_{p1}≤K_{p2}≤…≤K_{pn}$（其中$p1, p2, ……, pn$ 为$1,2,……,n$的一种排列）</p>
<p>将$\{R_1,R_2,…,R_n\}$ 中的记录重新排列为 $\{R_{p1}, R_{p2}, …R_{pn}\}$的操作称为排序。</p>
<p>分类：</p>
<ul>
<li><strong>内部排序</strong>：待排序记录存放在计算机随机存储器中进行的排序过程<ul>
<li><strong>插入排序</strong><ul>
<li><strong>直接插入排序</strong></li>
<li><strong>希尔排序</strong></li>
</ul>
</li>
<li><strong>交换排序</strong><ul>
<li><strong>冒泡排序</strong></li>
<li><strong>快速排序</strong></li>
</ul>
</li>
<li><strong>选择排序</strong><ul>
<li><strong>简单选择排序</strong></li>
<li><strong>树形排序</strong></li>
<li><strong>堆排序</strong></li>
</ul>
</li>
<li><strong>归并排序</strong></li>
<li><strong>分配排序</strong></li>
</ul>
</li>
<li><strong>外部排序</strong>：待排序记录的数量很大，以致内存不能容纳全部记录</li>
</ul>
<p><strong>稳定性</strong>：若记录序列中的任意两个记录 $Rx、Ry$ 的关键字 $Kx = Ky$ ；如果在排序之前和排序之后，它们的相对位置保持不变，则这种排序方法是<strong>稳定</strong>的，否则是<strong>不稳定</strong>的</p>
<p><strong>存储结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE 10000	//一个用作示例的最大长度</span><br><span class="line">typedef int KeyType;	//	定义关键字类型为整数类型</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	KeyType key;</span><br><span class="line">	InfoType otherinfo;	//其它数据项</span><br><span class="line">&#125;RecordType;</span><br><span class="line">typedef struct &#123;	</span><br><span class="line">	RecordType r[MAXSIZE + 1];	//r[0]闲置或作监视哨</span><br><span class="line">	int length;					//顺序表长度</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p><strong>排序策略</strong>：基于有序插入</p>
<p>在有序表的恰当处插入一个新元素，并保持该有序表的有序性。也即，当第$i$个元素插入时，第$1$到第$i-1$个元素已按关键字排序</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171927781.png" alt="image-20220303115514137"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171933337.png" alt="image-20220303115955840"></p>
<p><strong>算法实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">()</span> </span>&#123;<span class="comment">//对记录序列r[1]..r[n]作直接插入排序</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; ++i) &#123; <span class="comment">//从第二个元素开始比较</span></span><br><span class="line">        r[<span class="number">0</span>] = r[i];		<span class="comment">//r[0]为监视哨</span></span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r[<span class="number">0</span>].key &lt; r[j].key) &#123;</span><br><span class="line">            r[j + <span class="number">1</span>] = r[j]; --j;	<span class="comment">//记录后移，边移动边找插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        r[j + <span class="number">1</span>] = r[<span class="number">0</span>];	<span class="comment">//插入到正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<p>时间复杂度：$T(n)=O(n^2)$ </p>
<p>空间复杂度：$S(n)=O(1)$ </p>
<p>稳定性：稳定</p>
<p>适用范围：$n$较小，局部有序</p>
<h4 id="希尔-shell-排序"><a href="#希尔-shell-排序" class="headerlink" title="希尔(shell)排序"></a>希尔(shell)排序</h4><p>希尔排序（Shell’s Sort）又叫“缩小增量排序”，是对直接插入排序所作的改进。</p>
<p><strong>排序策略</strong>：先将整个待排序的记录序列分割成为若干个子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171934986.png" alt="image-20220303121549613"></p>
<p><strong>算法设计</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shellsort</span><span class="params">()</span> </span>&#123;  <span class="comment">// 对记录序列r[1]..r[n]作shell排序,增量是 d </span></span><br><span class="line">	d = n / <span class="number">2</span>;		<span class="comment">// 取d = n / 2; d = d / 2; 分组排序</span></span><br><span class="line">    <span class="keyword">while</span>(d &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = d + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            r[<span class="number">0</span>] = r[i]; j = i - d;	<span class="comment">//r[0]是暂存单元</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; r[<span class="number">0</span>].key &lt; r[j].key) &#123;</span><br><span class="line">                r[j + d] = r[j]; </span><br><span class="line">                j = i - d;</span><br><span class="line">            &#125;	<span class="comment">////记录后移，查找插入位置</span></span><br><span class="line">            r[j + d] = r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        d = d / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<p>时间复杂度：$T(n)=O(nlog2n)$ </p>
<p>空间复杂度：$S(n)=O(1)$ </p>
<p>稳定性：不稳定</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>排序方法</strong>：相邻的两个元素的关键字进行比较，小的元素向上冒，大的元素向下沉。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171934885.png" alt="image-20220304095532892"></p>
<p><strong>排序算法</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对r[1]..r[n] 进行冒泡排序</span></span><br><span class="line">    <span class="comment">// 策略：从上至下逐个进行两两比较</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n - i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[j].key &gt; r[j + <span class="number">1.</span>key]) &#123;</span><br><span class="line">                r[<span class="number">0</span>] = r[j + <span class="number">1</span>]; r[j + <span class="number">1</span>] = r[j]; r[j] = r[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法改进</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 对r[1]..r[n] 进行冒泡排序，策略：从上至下逐个进行两两比较</span></span><br><span class="line">    <span class="keyword">int</span> swap = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n &amp;&amp; swap; ++i) &#123; <span class="comment">// 进行n-1趟冒泡排序 或 某趟无交换止</span></span><br><span class="line">        swap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n - i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[j].key &gt; r[j + <span class="number">1.</span>key]) &#123;</span><br><span class="line">                r[<span class="number">0</span>] = r[j + <span class="number">1</span>]; r[j + <span class="number">1</span>] = r[j]; r[j] = r[<span class="number">0</span>];</span><br><span class="line">                swap = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析</strong>：</p>
<p>时间复杂度分析：$T(n)=O(n^2)$</p>
<p>空间复杂度分析：$S(n)=O(1)$</p>
<p>稳定性：稳定的</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>排序策略</strong>：任选一个元素的关键字（如[1].key）作为标准，将序列分成两部分。其中左半部分的结点的关键字小于等于该元素的关键字，右半部分的结点的关键字大于等于该元素的关键字。然后, 对左右两部分分别进行类似的处理，直至排好序为止</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171935199.png" alt="image-20220303163804332"></p>
<p><strong>算法实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一趟快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对r[i]..r[j]中的记录进行一趟排序，将它们分成两部分</span></span><br><span class="line">    <span class="comment">// 使：[…这部分的值&lt;=x…] x […这部分的值&gt;=x…]</span></span><br><span class="line">    r[<span class="number">0</span>] = r[i]; x = r[i].key;	<span class="comment">//用子表的第一个记录作为界点记录</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;	 <span class="comment">// 从表的两端交替地向中间扫描</span></span><br><span class="line">        <span class="keyword">while</span>(r[j].key &gt; x &amp;&amp; i &lt; j) --j;</span><br><span class="line">        r[i] = r[j];	<span class="comment">// 将比界点记录小的记录交换到低端</span></span><br><span class="line">        <span class="keyword">while</span>(r[i].key &lt; x &amp;&amp; i &lt; j) ++i;</span><br><span class="line">        r[j] = r[i];	<span class="comment">// 将比界点记录大的记录交换到高端</span></span><br><span class="line">    &#125;</span><br><span class="line">    r[i] = r[<span class="number">0</span>];	</span><br><span class="line">    <span class="keyword">return</span> i;		<span class="comment">//返回界点所在位置</span></span><br><span class="line">&#125;<span class="comment">//Partition</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对记录序列r[low]..r[high]进行快速排序</span></span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;	<span class="comment">// 长度小于1</span></span><br><span class="line">    <span class="keyword">int</span> mid = Partition(low, high);</span><br><span class="line">    QuickSort(low, mid - <span class="number">1</span>);</span><br><span class="line">    QuickSort(mid + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<p>时间复杂度：$T(n)=O(log_2n)$ </p>
<p>空间复杂度：$S(n)=O(log_2n)$ </p>
<p>稳定性：不稳定</p>
<p>适用范围：n较大且表无序时</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p><strong>排序策略</strong>：在待排序的数据中选择最小值。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171935282.png" alt="image-20220304100054253"></p>
<p><strong>算法实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对记录序列r[1]..r[n]进行简单选择排序</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; ++i) &#123;	<span class="comment">//进行n-1趟</span></span><br><span class="line">     	k = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[j] &lt; r[k]) k = j; <span class="comment">// 保持r[k]的关键字最小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != k) &#123;</span><br><span class="line">            r[<span class="number">0</span>] = r[i]; r[i] = r[k]; r[k] = r[<span class="number">0</span>]; <span class="comment">//在待排序的数据中选择最小值，并存入r[i]处</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<p>时间分析：$T(n)=O(n^2)$</p>
<p>空间分析：$S(n)=O(1)$</p>
<p>稳定性：不稳定</p>
<p>适用范围：1）$n$较小时，2）在$n$个待排序的数据中选择前$k(k&lt;&lt;n)$个最小值时</p>
<h4 id="树形排序"><a href="#树形排序" class="headerlink" title="树形排序"></a>树形排序</h4><p><strong>树形选择排序(Tree Selection Sort)</strong>又称<strong>锦标赛排序(Tournament Sort)</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171935573.png" alt="image-20220304102306909"></p>
<h4 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h4><p><strong>堆的定义</strong>：$n$个元素的序列$\{k_1,k_2,…k_n\}$，满足： <script type="math/tex">\begin{cases} k_i >= k_{2i} \\ k_i >=k_{2i+1} \end{cases} 或 \begin{cases} k_i <= k_{2i} \\ k_i <=k_{2i+1} \end{cases}</script> </p>
<p>堆是一个完全二叉树。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171935891.png" alt="image-20220304104438730" style="zoom: 67%;" /></p>
<p><strong>堆排序</strong>：输出堆顶的最小值（最大值）后，将剩下的$n-1$个元素序列重新建成一个堆，得到次小值（次大值）。反复执行，得到一个有序序列。</p>
<p><strong>构造堆</strong>：按堆的定义将$r[1]…r[n]$调整为堆</p>
<p>$r[n]$与$r[1]$互换，将$r[1]…r[n-1]$调整为堆。再将$r[n-1]$与$r[1]$互换，将$r[1]…r[n-2]$调整为堆。……，直至排序完成。</p>
<p><strong>堆的调整</strong>：在选出某段序列最大（小）值后，要将剩下的序列调整</p>
<ul>
<li>左右孩子比较</li>
<li>父子比较</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171936716.png" alt="image-20220304120225824"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171936625.png" alt="image-20220304123205678"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171936006.png" alt="image-20220304123234392"></p>
<p><strong>算法实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> m)</span> </span>&#123;  <span class="comment">//堆的调整，也是建堆</span></span><br><span class="line">    <span class="comment">//把以 t 为根的完全二叉树r[i]..r[m]调整成一个堆 </span></span><br><span class="line"> 	<span class="comment">//初值：i的左右子树均是堆</span></span><br><span class="line">    <span class="keyword">int</span> j = i * <span class="number">2</span>;	<span class="comment">//j指向左孩子</span></span><br><span class="line">    r[<span class="number">0</span>] = r[i];	<span class="comment">//将r[i]暂存在r[0]中</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; m &amp;&amp; r[j].key &lt; r[j + <span class="number">1</span>].key) ++j; <span class="comment">//左孩子与右孩子进行比较，找较大孩子，确定筛选方向</span></span><br><span class="line">        <span class="keyword">if</span>(r[<span class="number">0</span>].key &lt; r[j].key) &#123;</span><br><span class="line">            r[i] = r[j]; i = j; j = <span class="number">2</span> * i;	<span class="comment">// 继续筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = m + <span class="number">1</span>;	<span class="comment">//筛选完毕</span></span><br><span class="line">        r[i] = r[<span class="number">0</span>];</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">()</span> </span>&#123;	<span class="comment">//将r[1]...r[n]进行堆排序</span></span><br><span class="line">    <span class="keyword">for</span>(j = n / <span class="number">2</span>; j &gt;= <span class="number">1</span>; --j) sift(j, n);	<span class="comment">//建堆，得最大值r[1]</span></span><br><span class="line">    <span class="keyword">for</span>(j = n; j &gt;= <span class="number">2</span>; --j) &#123;</span><br><span class="line">        r[<span class="number">0</span>] = r[<span class="number">1</span>]; r[<span class="number">1</span>] = r[j]; r[j] = r[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//堆顶（根）结点与最后结点的值对换</span></span><br><span class="line">        sift(<span class="number">1</span>, j - <span class="number">1</span>);	<span class="comment">//调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<p>时间分析：$T(n)=O (nlog2n)$</p>
<p>空间分析：$S(n)=O(1)$</p>
<p>稳定性：不稳定</p>
<p>适用范围：1）$n$较大。2）选取前$k(K&lt;&lt;n)$个最小（大）元素时</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>归并排序（Merging Sort）</strong>就是将两个或两个以上的有序表合并成一个有序表的过程。将两个有序表合并成一个有序表的过程称为<strong>2-路归并</strong>，2-路归并最为简单和常用。</p>
<p><strong>排序示例：</strong> </p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171936821.png" alt="image-20220304141031376" style="zoom:80%;" /></p>
<p><strong>二路归并算法</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(RedType R[], RedType T[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将两个有序表R[low]..R[mid]和R[mid+1]..r[high]归并为一个新的有序表T[low]..r[high]</span></span><br><span class="line">    i = low; j = mid + <span class="number">1</span>; k = low;	<span class="comment">//初值i,j,k为指示器</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span>(R[i].key &lt;= R[j].key) T[k++] = R[i++];</span><br><span class="line">        <span class="keyword">else</span> T[k++] = R[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) T[k++] = R[i++];	<span class="comment">//将剩余的R[i]..R[mid]放入T中</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) T[k++] = R[i++];	<span class="comment">//将剩余的R[j]..R[high]放入T中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(RedType R[], RedType &amp;T[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//R[low]..R[high]归并排序后放入T[low]..T[high]中</span></span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;		<span class="comment">//将当前序列一分为二，分裂点mid</span></span><br><span class="line">        mergeSort(R, S, low, mid);		<span class="comment">//对子序列R[low..mid]递归归并排序</span></span><br><span class="line">        mergeSort(R, S, mid + <span class="number">1</span>, high);	<span class="comment">//对子序列R[mid+1..high]递归归并排序</span></span><br><span class="line">        Merge(R, T, low, mid, high);	<span class="comment">//将S[low..mid]和S[mid+1..high]归并到T[low..high]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<p>时间复杂度：$T(n)=O(nlog_2n)$ </p>
<p>空间复杂度：$S(n) = O(n)$ </p>
<p>稳定性：稳定</p>
<p>适用范围：$n$较大时</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><strong>基数排序（Radix Sorting）</strong>是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。</p>
<p><strong>多关键字的排序</strong></p>
<p>假设$n$个记录的序列$\{R_1,R_2,…R_n\}$，且每个记录$R_i$含有$d$个关键字$(K_i^0,K_i^1,…,K_i^{d-1})$</p>
<p>序列$\{R_1,R_2,…R_n\}$对关键字$(K_i^0,K_i^1,…,K_i^{d-1})$有序：对于序列中任意两个记录$R_i$和$R_j(1&lt;=i&lt;j&lt;=n)$满足：<script type="math/tex">(K_i^0,K_i^1,...,K_i^{d-1}) < (K_j^0,K_j^1,...,K_j^{d-1})</script>其中$K^0$称为最主位关键字，$K^{d-1}$称为最次位关键字。</p>
<p>法一：<strong>最高位优先法（Most Significant Digit first）MSD</strong></p>
<ul>
<li>对最主位关键字$K^0$排序，将序列分成若干个子序列，每个子序列中的记录有相同的$K^0$值</li>
<li>对每个子序列按$K^1$排序，每个序列再分成更小的序列，依次重复至对每个序列进行$K^{d-1}$排序后</li>
<li>将所有子序列依次联接称为一个有序序列</li>
</ul>
<p>法二：<strong>最低位优先法（Least Significant Digit first）LSD</strong></p>
<ul>
<li>和MSD相反</li>
</ul>
<p><strong>示例：10进制数排序</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171941688.png" alt="image-20220304150324750"></p>
<p><strong>队列的表示</strong></p>
<ul>
<li><p>顺序队列</p>
<p>问题：每一个队列的长度是多少？<br>缺点：空间开销大。</p>
</li>
<li><p>链式队列</p>
<p>需设 2rd 个指针，rd：基数。如10进制数，rd=10</p>
</li>
</ul>
<p><strong>存储结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_NUM	10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key[KEY_NUM];	<span class="comment">//d: 关键字的位数</span></span><br><span class="line">    infoType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>算法实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">distribute</span><span class="params">(struct node *head, <span class="keyword">int</span> i, )</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分配算法，考察每一个元素的第i个关键字，并放入相应的队列中</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; KEY_NUM; ++j) f[j] = <span class="literal">NULL</span>;	<span class="comment">//队列初始化，f保存每个子序列的头</span></span><br><span class="line">    p = head-&gt;next;	<span class="comment">//头指针不存储数据</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        j = p-&gt;key[i];	<span class="comment">//考察p所指结点的第i位</span></span><br><span class="line">        <span class="keyword">if</span>(f[j] == <span class="literal">NULL</span>) f[j] = p;</span><br><span class="line">        <span class="keyword">else</span> r[j]-&gt;next = p;</span><br><span class="line">        r[j] = p;		<span class="comment">//r记录每个子序列的尾</span></span><br><span class="line">        p = p-&gt;next;	<span class="comment">//p后移</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">collect</span><span class="params">(struct node &amp;head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//收集算法：从队列0到队列9进行收集</span></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(f[j] == <span class="literal">NULL</span>) ++j;	<span class="comment">//找第一个非空队列</span></span><br><span class="line">    head-&gt;next = f[j]; t = r[j]; <span class="comment">//head:收集后链表的头指针，t:尾指针</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; <span class="number">9</span>) &#123;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(f[j] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            t-&gt;next = f[j];</span><br><span class="line">            t = r[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(struct node *head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基数排序：从低位开始</span></span><br><span class="line">    <span class="function">create <span class="title">link_list</span><span class="params">(head)</span></span>;	<span class="comment">//建立链表，head:头指针</span></span><br><span class="line">    <span class="keyword">for</span>(i = KEY_NUM - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;	<span class="comment">//进行KEY_NUM趟分配和收集</span></span><br><span class="line">    	distribute(head, i);</span><br><span class="line">        collect(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<p>时间复杂度：$T(n)=O(d(n+rd))=O(n)$ 关键码$d$位，对 rd 个队列收集</p>
<p>空间复杂度：$S(n)=O(n+2rd)$ </p>
<p>稳定性：稳定</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><div class="table-container">
<table>
<thead>
<tr>
<th>排序方法</th>
<th>平均时间</th>
<th>最坏情况</th>
<th>辅助存储空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>Y</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>Y</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>Y</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(nlog_2n)$</td>
<td>$O(n^2)$</td>
<td>$O(log_2n)$</td>
<td>N</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(nlog_2n)$</td>
<td>$O(nlog_2n)$</td>
<td>$O(1)$</td>
<td>N</td>
</tr>
<tr>
<td>归并排序</td>
<td>$O(nlog2n)$</td>
<td>$O(nlog_2n)$</td>
<td>$O(n)$</td>
<td>Y</td>
</tr>
<tr>
<td>基数排序</td>
<td>$O(n)$</td>
<td>$O(n)$</td>
<td>$O(rd)$</td>
<td>Y</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171941465.png" alt="image-20220306113737759"></p>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><h3 id="内存和外存"><a href="#内存和外存" class="headerlink" title="内存和外存"></a>内存和外存</h3><p>计算机存储器主要有两种：</p>
<ul>
<li><strong>主存储器 ( primary memory 或者 main memory ，简称“内存”，或者“主存”) </strong><ul>
<li><strong>随机访问存储器 ( Random Access Memory, 即 RAM )</strong></li>
<li><strong>高速缓存 ( cache )</strong></li>
<li><strong>视频存储器 ( video memory ) </strong></li>
</ul>
</li>
<li><strong>外存储器 ( peripheral storage 或者 secondary storage，简称“外存”，或“辅存”) </strong><ul>
<li><strong>硬盘 (几百$G$ - 几百$T$， $10^{12B} $)</strong></li>
<li><strong>磁带 (几个$P$， $10^{15}B$ )</strong></li>
<li><strong>磁盘</strong></li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171942584.png" alt="image-20220305134327171"></p>
<p><strong>内存的优缺点</strong></p>
<ul>
<li>优点：访问速度快</li>
<li>缺点：造价高，存储容量小，断电丢数据</li>
<li>CPU 直接与主存沟通，对存储在内存地址的数据进行访问时，所需要的时间可以看作是一个很小的常数，看作随机存取</li>
</ul>
<p><strong>外存的优缺点</strong></p>
<ul>
<li>优点：价格低、信息不易失 、便携性 </li>
<li>缺点：存取速度慢<ul>
<li>一般的内存访问存取时间的单位是 纳秒 （1 纳秒 = $10^{-9}$ 秒）</li>
<li>外存一次访问时间则以 毫秒（1 毫秒 = $10^{-3}$ 秒）或秒为数量级</li>
</ul>
</li>
<li>牵扯到外存的计算机程序应当尽量<strong>减少外存的访问次数</strong>， 从而减少程序执行的时间</li>
</ul>
<p><strong>单位</strong></p>
<ul>
<li>$KB$ (kilo byte)​ $10^3B$ (页块)</li>
<li>$MB$ (mega byte) $10^6B$ (高速缓存)</li>
<li>$GB$ (giga) $10^9B$ (内存、硬盘)</li>
<li>$TB$ (tera) $10^{12}B$ (磁盘阵列)</li>
<li>$PB$ (peta) $10^{15}B$ (磁带库)</li>
<li>$EB = 10^{18}B；ZB = 10^{21}B；YB = 10^{24}B$ </li>
<li>$Googol$ 是 10 的 100 次方</li>
</ul>
<h3 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h3><p>磁带大约1/2英寸宽，绕在一个卷盘上。使用时，将磁带盘放在磁带机上，驱动器控制磁带盘转动，带动磁带向前移动。通过读/写头就可以读出磁带上的信息或把信息写入磁带中。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171942714.jpg" style="zoom: 15%;" /></p>
<p>磁带不是连续转动的设备，而是一种启停设备（启停时间约5毫秒）。由于读写信息应在旋转稳定时进行，而磁带从静止转态启动后，需经历加速阶段；读/写结束后，需经历减速阶段。因此，在磁带上相邻两个字符组（记录）之间要留有一空白区，叫做<strong>间隙IRG(Inter Record Gap)</strong>。</p>
<p>为有效利用磁带，常常用组成块的长度的方法来减少 $IRG$ 的个数。在每次写信息时，不是按用户给出的字符组记入磁带，而是将若干个字符组合并成一块后一次写入磁带。字符组间没有了 $IRG$ ，变成块间的间隙 $IBG$ (Inter Block Gap) 。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171943649.png" alt="image-20220305150014325"></p>
<p>成块的好处和限制：</p>
<ul>
<li><p>减少 $IRG$，提高磁带利用率</p>
</li>
<li><p>减少 I/O 操作</p>
</li>
<li>物理块不能太大，通常 1K~8K 字节。太大容易出错，内存开辟的缓冲区也越大。</li>
</ul>
<p>磁带上读取一块信息所需时间由两部分组成：$T_{I/O}=t_a+n\times t_w$  </p>
<ul>
<li>$t_a$ 为延迟时间，读/写头到达传输信息所在物理块起始位置所需时间</li>
<li>$t_w$ 传输一个字符的时间</li>
</ul>
<p>顺序存储设备的主要缺点是检索和修改信息不方便。因此主要用于处理变化少，只进行顺序存取的大量数据。</p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘是一种 直接存取的存储设备（DASD）。可以直接存取任何字符组，容量大，存取速度比磁带快得多。</p>
<p>磁盘是一个扁平的圆盘，盘面有许多磁道记载信息。磁盘可以是单片，也可以是若干个盘片组成盘组。每一片有两个面，最顶上和最底下盘片的外侧面不存信息。</p>
<p>磁盘可分为<strong>固定头盘</strong>和<strong>活动头盘</strong>。</p>
<ul>
<li><p>固定头盘的每一道上都有独立的磁头，固定不动，专负责读/写某一道上的信息。</p>
</li>
<li><p>活动头盘的磁头可移动，盘组可变。一个面上只有一个磁头，可以从该面上的一道移到另一道。</p>
<ul>
<li>磁头装在动臂上，不同面的磁头是同时移到的，并处于同一圆柱面。</li>
<li>各面上半径相同的磁道组成一个圆柱面。</li>
<li>磁盘是上表面一个具体信息必须用一个三维地址：柱面号、盘面号、块号。</li>
<li>柱面号确定读/写头的径向运动，块号确定信息在盘片圆圈上的位置。</li>
</ul>
</li>
</ul>
<p>访问信息：</p>
<ul>
<li>先找柱面，磁头移动到所需柱面上（称为定位或寻查）</li>
<li>等待要访问的信息转到磁头下</li>
<li>读/写信息</li>
</ul>
<p>读写信息所需时间：$T_{I/O}=t_{seek}+t_{la}+n\times t_{wm}$ </p>
<ul>
<li>$t_{seek}$ <strong>寻查时间(seek time)</strong>：读/写头定位的时间</li>
<li>$t_{la}$ <strong>等待时间(latency time)</strong>：等待信息块的初始位置旋转到读写头下的时间</li>
<li>$t_{wm}$ <strong>传输时间(transmission time)</strong></li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171943567.png" alt="image-20220305141308482"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171943712.png" alt="image-20220305141333510"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171943321.png" alt="image-20220305141452329"></p>
<h3 id="外部排序的方法"><a href="#外部排序的方法" class="headerlink" title="外部排序的方法"></a>外部排序的方法</h3><p>外部排序基本由两个相对独立的阶段组成。</p>
<p>1）按可用内存大小，将外存上含 $n$ 个记录的文件分成若干长度为 $l$ 的子文件或<strong>段（segment）</strong>，依次读入内存并利用有效的内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写入外存。通常称这些<strong>有序子文件</strong>为<strong>归并段</strong>或<strong>顺串（run）</strong></p>
<p>2）对这些归并段逐趟归并，使归并段逐渐由小至大，直至得到整个有序文件为止。</p>
<p>第一阶段是内部排序的内容，主要是第二阶段即归并的过程。</p>
<p>示例：<strong>2-路平衡归并</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171943937.png" alt="image-20220305163752665"></p>
<p>在内存中将两个有序段归并成一个有序段很简单。但是，在外部排序中实现两两归并时，要进行外存的读／写，因为不可能将两个有序段及归并结果段同时存放在内存中的缘故。假设在上例中毎个物理块可以容纳200个记录，则每一趟归并需进行50次“读”和50次“写”,4趟归并加上内部排序时所需进行的读／写使得在外排中总共需进行500次的读 / 写。</p>
<p>一般情况下，$外部排序所需总的时间＝$$内部排序（产生初始归并段）所需的时间 (m\times t_{IS})+ \\ 外存信息读写的时间 (d\times t_{IO})+ \\ 内部归并所需的时间 (s\times ut_{mg})$</p>
<ul>
<li>$t_{IS}$ 是为得到一个初始归并段进行内部排序所需时间的均值</li>
<li>$t_{IO}$ 是进行一次外存读／写时间的均值</li>
<li>$ut_{mg}$ 是对 $u$ 个记录进行内部归并所需时间</li>
<li>$m$ 为经过内部排序之后得到的初始归并段的个数</li>
<li>$s$ 为归并的趟数</li>
<li>$d$ 为总的读／写次数</li>
</ul>
<p>由此，上例10000个记录利用2﹣路归并进行外排所需总的时间为：$10\times t_{IS}+500\times t_{IO}+4\times 10000t_{mg}$  </p>
<p>$t_{IO}$ 取决于所用的外存设备，比 $t_{mg}$ 大得多。<strong>提高外排效率主要是减少外存信息读写的次数 $d$ 。 </strong></p>
<p>若对上例采取<strong>5-路平衡归并</strong>，仅需两趟归并，外排时总的读写次数便减至 $2\times 100+100=300$ ，比2-路平衡归并少了200次读写。</p>
<p>一般情况下：对 $m$ 个起始归并段进行 <strong>k-路平衡归并</strong> 时，归并趟数：$s=$ int $(log_km)$  即 $log_km$向下取整</p>
<h3 id="多路平衡归并"><a href="#多路平衡归并" class="headerlink" title="多路平衡归并"></a>多路平衡归并</h3><p>增加 $k$ 可以减少 $s$ ，从而减少外存读／写的次数。但单纯增加 $k$ 将导致增加内部归并的时间 $ut_{mg}$ 。</p>
<p>在2﹣路归并中，令 $u$ 个记录分布在两个归并段上。每得到归并后的一个记录，仅需一次比较即可，则得到含 $u$ 个记录的归并段需进行 $u-1$ （不应该是 $u$ 次比较吗）次比较。</p>
<p>再看 k﹣路归并。令 $u$ 个记录分布在 E 个归并段上，显然，归并后的第一个记录应是 $k$ 个归并段中关键字最小的记录，即应从毎个归并段的第一个记录的相互比较中选出最小者，这需要进行 $k-1$次比较。同理，每得到归并后的有序段中的一个记录，都要进行  $k-1$ 用次比较。显然，为得到含 $u$ 个记录的归并段需进行 $(u -1)(k-1)$ 次比较。由此，对 $n$ 个记录的文件进行外排时，在内部归并过程中进行的总的比较次数为 $s(k-1)(n-1)$ 。</p>
<p>假设所得初始归并段为 $m$ 个，则内部归并过程中进行比较的总的次数为<img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171944624.png" alt="image-20220305180603563" style="zoom: 50%;" /></p>
<p>内部归并时间亦随 $k$ 的增长而增长。这将抵消由于增大 $k$ 而减少外存信息读写时间所得效益。然而，若在进行 k﹣路归并时用 <strong>败者树( Tree of Loser )</strong>，则可使在 $k$ 个记录中选出关键字最小的记录时仅需进行 $[log_2k]$ 次比较。</p>
<p><strong>败者树( Tree of Loser )</strong>：类似于堆排序里面的完全二叉树，只不过败者树非叶子结点保存的是子孙比较中的败者。</p>
<p><strong>胜者树( Tree of Winner )</strong>：和败者树相反</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171944838.png" alt="image-20220305181301909"></p>
<p>$k$ 值的选择并非越大越好，如何选择合适的 $k$ 是一个需要综合考虑的问题。</p>
<p><strong>算法实现</strong></p>
<p><code>K_Merge</code>简单描述利用败者树进行 K-路平衡排序归并 的过程，避开了外存信息存取的细节，可认为归并段已读入内存。</p>
<p><code>Adjust</code>描述在从败者树选得最小关键字的记录之后，如何从叶到根调整败者树选得下一个最小关键字。</p>
<p><code>CreateLoserTree</code>初建败者树的过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> LoserTree[k];	<span class="comment">//败者树是完全二叉树且不含叶子，可采用顺序存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;ExNode, External[k + <span class="number">1</span>];	<span class="comment">//外结点，只存放待归并记录的关键字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">K_Merge</span><span class="params">(LoserTree &amp;ls, External &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//利用败者树 ls 将编号从 0 到 k-1 的 k 个输入归并段中的记录归并到输出归并段</span></span><br><span class="line">    <span class="comment">//b[0]至b[k-1]为败者树上的k个叶子结点，分别存放k个输入归并段中当前记录的关键字</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; K; ++i) input(b[i].key);	<span class="comment">//分别从k个输入归并段读入该段当前第一个记录的关键字到外接点</span></span><br><span class="line">    CreateLoserTree(ls);	<span class="comment">//建败者树ls，选得最小关键字为 b[ls[0]].key</span></span><br><span class="line">    <span class="keyword">while</span>(b[ls[<span class="number">0</span>]].key != MAXKEY) &#123;</span><br><span class="line">        q = ls[<span class="number">0</span>];	<span class="comment">//q指示当前最小关键字所在归并段</span></span><br><span class="line">        output(q);	<span class="comment">//将编号为q的归并段中当前（关键字为b[q].key）的记录写至输出归并段</span></span><br><span class="line">        input(b[q].key, q);	<span class="comment">//从编号为q的输入归并段读入下一个记录的关键字</span></span><br><span class="line">        Adjust(ls, q);		<span class="comment">//调整败者树，选择新的最小关键字</span></span><br><span class="line">    &#125;</span><br><span class="line">    output(ls[<span class="number">0</span>]);	<span class="comment">//将含最大关键字MAXKEY的记录写至输出归并段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Adjust</span><span class="params">(LoserTree &amp;ls, <span class="keyword">int</span> s)</span> </span>&#123;	</span><br><span class="line">    <span class="comment">//沿从叶子结点b[s]到根结点ls[0]的路径调整败者树</span></span><br><span class="line">    t = (s + k) / <span class="number">2</span>;	<span class="comment">//ls[t]是b[s]的双亲结点</span></span><br><span class="line">    <span class="keyword">while</span>(t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[s].key &gt; b[ls[t]].key) s&lt;--&gt;ls[t];      <span class="comment">//s指向新的胜者                           </span></span><br><span class="line">        t = t / <span class="number">2</span>;                                                                    </span><br><span class="line">    &#125;</span><br><span class="line">    ls[<span class="number">0</span>] = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateLoserTree</span><span class="params">(LoserTree &amp;ls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 已知b[0]到b[k-1]为完全二叉树ls的叶子结点存有k个关键字，沿叶子到根的k条路径将ls调整成败者树</span></span><br><span class="line">    b[k].key = MINKEY;	<span class="comment">//设MINKEY为关键字可能的最小值</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; ++i) ls[i] = k;	<span class="comment">//设置ls中“败者”的初值</span></span><br><span class="line">    <span class="keyword">for</span>(i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) Adjust(ls, i);	<span class="comment">//依次从b[k-1]...b[0]出发调整败者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h3><p>归并的趟数和 $k$ 成反比，也和 $m$ 成正比。因此，减少 $m$ 是减少 $s$ 的另一条途径。</p>
<p>$m$ 是外部文件经过内部排序之后得到的初始归并段的个数，显然，$m=ceil(n/l)$(向上取整)，其中 $n$ 为外部文件中的记录数，$l$ 为初始归并段中的记录数。但这依赖于进行内部排序时可用内存工作区的大小，则 $m$ 也随其而限定。若要减小 $m$，即增加 $l$，就必须探索新的排序方法。</p>
<p><strong>置换-选择排序（Replacement-Selection Sorting）</strong>是在树形选择排序的基础上得来的，它的特点是：在整个排序（得到所有初始归并段）的过程中，选择最小（或最大）关键字和输入、输出交叉或平行进行。</p>
<p><strong>例子</strong>：已知初始文件含有24个记录，它们的关键字分别为：51,49,39,46,38,29,14,61,15,30,1,48,52,3,63,27,4,13,89,24,46,58,33,76</p>
<p>假设内存工作区可容纳6个记录，则按前面讨论的选择排序可求得如下4个初始归并段：</p>
<ul>
<li>RUN1：29,38,39,46,49,51</li>
<li>RUN2：1,14,15,30,48,61</li>
<li>RUN3：3,4,13,27,52,63</li>
<li>RUN4：24,33,46,58,76,89</li>
</ul>
<p>若按置换-选择排序进行排序，则可求得如下3个初始归并段：（过程见下文）</p>
<ul>
<li>RUN1：29,38,39,46,49,51,61</li>
<li>RUN2：1,3,14,15,27,30,48,52,63,89</li>
<li>RUN3：4,13,24,33,46,58,76</li>
</ul>
<p>假设初始待排文件为输入文件$FI$,初始归并段文件为输出文件$FO$，内存工作区为$WA$，$FO$和$WA$的初始状态为空，并设内存工作区的容量可容纳 $w$ 个记录，则置换-选择排序的操作过程为：</p>
<ul>
<li>① 从FI输入w个记录到工作区WA。</li>
<li>② 从WA中选出其中关键字取最小值的记录，记为MINIMAX记录。</li>
<li>③ 将MINIMAX记录输入到FO中去。</li>
<li>④ 若FI不空，则从FI输入下一个记录到WA中。</li>
<li>⑤ 从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。</li>
<li>⑥ 重复③～⑤，直至WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。</li>
<li>⑦ 重复②～⑥，直至WA为空。由此得到所有初始归并段。</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171944276.jpeg" alt="置换-选择过程"></p>
<p>在$WA$中选择MINIMAX记录的过程需利用<strong>败者树</strong>来实现。</p>
<p><strong>说明</strong>：</p>
<p>（1）内存工作区中的记录作为败者树的外部结点，而败者树中根结点的双亲结点指示工作区中关键字最小的记录。</p>
<p>（2）为了便于选出MINIMAX记录，为每个记录附设一个所在归并段的序号，在进行关键字的比较时，先比较段号，段号小者为胜者；段号相同的则关键字小的为胜者。</p>
<p>（3）败者树的建立可从设工作区中所有记录的段号均为 $0$ 开始，然后从$FI$逐个输入$w$个记录到工作区时，自上而下调整败者树。由于这些记录的段号为 $1$，则它们对于 $0$ 段的记录而言均为败者，从而逐个填充到败者树的各结点中去。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171944651.jpeg" alt=""></p>
<p><strong>算法实现</strong>：</p>
<p><code>Replacd_selection</code>是置换﹣选择排序的简单描述，其中，求得一个初始归并段的过程如算法11.5所述。算法11.6和算法<br>11.7分别描述了置换﹣选择排序中的败者树的调整和初建的过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   RedType rec;                 <span class="comment">//记录</span></span><br><span class="line">   KeyType key;                 <span class="comment">//从记录中抽取的关键字</span></span><br><span class="line">   <span class="keyword">int</span> rnum;                    <span class="comment">//所属归并段的段号</span></span><br><span class="line">&#125;RcdNode,WorkArea[w];           <span class="comment">//内存工作区，容量为w</span></span><br><span class="line">WorkArea wa;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Construct_Loser</span><span class="params">(LoserTree &amp;ls, WorkArea &amp;wa)</span> </span>&#123; <span class="comment">//初建败者树</span></span><br><span class="line">    <span class="comment">//输入w个记录到内存工作区wa，建立败者树ls，选出关键字最小的记录并由s指示其在wa中的位置</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; w; ++i) &#123;</span><br><span class="line">        wa[i].rnum = wa[i].key = ls[i] = <span class="number">0</span>;	<span class="comment">//工作区初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = w - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        freed(&amp;wa[i].rec, <span class="keyword">sizeof</span>(RcdType), <span class="number">1</span>, fi);	<span class="comment">//输入一个记录</span></span><br><span class="line">        wa[i].key = wa[i].rec.key;					<span class="comment">//保存该记录的关键字</span></span><br><span class="line">        wa[i].rnum = <span class="number">1</span>;								<span class="comment">//其段号为 1 </span></span><br><span class="line">        Select_MiniMax(ls, wa, i);					<span class="comment">//调整败者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="function">yu</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Select_MiniMax</span><span class="params">(LoserTree &amp;ls, WorkArea wa, <span class="keyword">int</span> q)</span> </span>&#123;	<span class="comment">//选出MINIMAX</span></span><br><span class="line">    <span class="comment">//从wa[q]起到败者树的根比较选择MINIMAX记录，并由q指示它所在的归并段</span></span><br><span class="line">    t = (w + q) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = ls[t]; t &gt; <span class="number">0</span>; t = t / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(wa[p].rnum &lt; wa[q].rnum || (wa[p].rnum == wa[q].rnum &amp;&amp; wa[p].key &lt; wa[q].key)) &#123;</span><br><span class="line">            q &lt;--&gt; ls[t];	<span class="comment">//q指向新的胜利者</span></span><br><span class="line">        &#125;</span><br><span class="line">        ls[<span class="number">0</span>] = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Replacd_selection</span><span class="params">(LoserTree &amp;ls, WorkArea &amp;wa, FILE *fi, FILE *fo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在败者树ls和内存工作区wa上用置换-选择排序求初始归并段，fi为输入文件（只读文件）指针</span></span><br><span class="line">    <span class="comment">//fo为输出文件（只写文件指针）</span></span><br><span class="line">    Construct_Loser(ls, wa);	<span class="comment">//创建败者树</span></span><br><span class="line">    rc = rmax = <span class="number">1</span>;	<span class="comment">//rc指示当前生成的初始归并段的段号，rmax指示wa中关键字所属初始归并段的最大段号</span></span><br><span class="line">    <span class="keyword">while</span>(rc &lt;= rmax) &#123; <span class="comment">// rc = rmax + 1 表示输入文件的置换-选择排序已完成</span></span><br><span class="line">    	get_run(ls, wa); <span class="comment">//求得一个初始归并段</span></span><br><span class="line">        fwrite(&amp;RUNEND_SYMBOL, <span class="keyword">sizeof</span>(struct RcdNode), <span class="number">1</span>, fo);	<span class="comment">//将段结束标志写入输出文件</span></span><br><span class="line">        rc = wa[ls[<span class="number">0</span>]].rnum;	<span class="comment">//设置下一段的段号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_run</span><span class="params">(LoserTree &amp;ls, WorkArea &amp;wa)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//求得一个初始归并段，fi为输入文件指针，fo为输出文件指针</span></span><br><span class="line">    <span class="keyword">while</span>(wa[ls[<span class="number">0</span>]].rnum == rc) &#123; 	<span class="comment">//选得的MINIMAX记录属当前段时</span></span><br><span class="line">        q = ls[<span class="number">0</span>];			<span class="comment">//q指示MINIMAX记录在wa中的位置</span></span><br><span class="line">        minimax = wa[q].key;	</span><br><span class="line">        fwrite(&amp;wa[q].rec, <span class="keyword">sizeof</span>(RcdType), <span class="number">1</span>, fo); 	<span class="comment">//将刚选好的MINIMAX记录写入输出文件</span></span><br><span class="line">        <span class="keyword">if</span>(feof(fi)) &#123;	<span class="comment">//输入文件结束，虚设记录（属rmax+1段）</span></span><br><span class="line">            wa[q].rnum = rmax + <span class="number">1</span>;</span><br><span class="line">            wa[q].key = MAXKEY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;			<span class="comment">//输出文件非空时</span></span><br><span class="line">            fread(&amp;wa[q].rec, <span class="keyword">sizeof</span>(RcdType), <span class="number">1</span>, fi);	<span class="comment">//从输入文件读入下一记录</span></span><br><span class="line">            wa[q].key = wa[q].rec.key;	<span class="comment">//提取关键字</span></span><br><span class="line">            <span class="keyword">if</span>(wa[q].key &lt; minimax) &#123;	<span class="comment">//新读入的记录属下一段</span></span><br><span class="line">                rmax = rc + <span class="number">1</span>;</span><br><span class="line">                wa[q].rnum = rmax;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> wa[q].rnum = rc;	<span class="comment">//新读入的记录属当前段</span></span><br><span class="line">        &#125;</span><br><span class="line">        Select_MiniMax(ls, wa, q);	<span class="comment">//选出新的MINIMAX记录</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;<span class="comment">//get_run</span></span><br></pre></td></tr></table></figure>
<p>置换-选择排序所得初始归并段的长度不等。且可证明，当输入文件中记录的关键字为随机数时，所得初始归并段的平均长度为内存工作区大小 $w$ 的两倍。</p>
<p>假设一台扫雪机在环形路上等速进行扫雪，又下雪的速度也是均衡的（即每小时落到地面上的雪量相等），雪均匀地落在扫雪机的前、后路面上，边下雪边扫雪。显然，在某个时刻之后，整个系统达到平衡状态，路面上的积雪总量不变。且在任何时刻，整个路面上的积雪都形成一个均匀的斜面，紧靠扫雪机前端的积雪最厚，其深度为$h$，而在扫雪机刚扫过的路面上的积雪深度为零。若将环形路伸展开来，路面积雪状态如图所示。假设此刻路面积雪的总体积为$w$，环形路一圈的长度为$l$，由于扫雪机在任何时刻扫走的雪的深度为$h$，则扫雪机在环形路上走一圈扫掉的积雪体积为$lh$即$2w$。<br><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171944825.jpeg" style="zoom: 33%;" /></p>
<h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><p>假设由置换-选择得到9个初始归并段，其长度（即记录数）依次为9，30，12，18，3，17，2，6，24。现作3-路平衡归并，其归并树（表示归并过程的图）如图(b)所示，图中每个圆圈表示一个初始归并段，圆圈中数字表示归并段的长度。假设每个记录占一个物理块，则两趟归并所需对外存进行读/写次数为 $(9+30+12+18+3+17+2+6+24)×2×2=484$。若将初始归并段的长度看成是归并树中叶子结点的权，则此3叉树的带权路径长度的两倍恰为484。<strong>若对长度不等的$m$个初始归并段，构造一棵哈夫曼树作为归并树，便可使在进行外部归并时所需对外存进行读/写次数达最少</strong>。对上述9个初始归并段可构造一棵如图(a)所示的归并树，按此树进行归并，仅需对外存进行446次读/写，这棵归并树便称做<strong>最佳归并树</strong>。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171945003.png" alt="image-20220306112724047"></p>
<p>如何判断附加虚段的数目？当3叉树中只有度为3或0的结点时，必有$n3=(n0-1)/2$。$n$ 是度为3的结点数，$n0$ 是度为0的结点数。由于$n3$必为整数，则$(n0-1)$ $MOD$ $2=0$。也就是说，对3-路归并而言，只有当初始归并段的个数为偶数时，才需加1个虚段。</p>
<p>一般情况下，对 k-路归并而言，容易推算得到</p>
<ul>
<li>若$(m-1)$ $MOD$ $(k-1)=0$，则不需加虚段</li>
<li>否则附加 $k-(m-1)$ $MOD$ $(k-1)-1$ 个虚段。换句话说，第一次归并为 $(m-1)$ $MOD$ $(k-1)+1$路归并。</li>
</ul>
<p>若按最佳归并树的归并方案进行磁盘归并排序，需在内存建立一张载有归并段的长度和它在磁盘上的物理位置的索引表。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h3><ul>
<li>主要应用<ul>
<li>信息检索 (information retrieval) </li>
<li>自然语言大规模的英文词典</li>
</ul>
</li>
<li>字符树——26叉Trie</li>
<li>二叉Trie树 <ul>
<li>用每个字母（或数值）的二进制编码来代表</li>
<li>编码只有0和1</li>
</ul>
</li>
</ul>
<p><strong>26叉Trie</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171945553.png" alt="image-20220306141203947"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171947752.png" alt="image-20220306141644927"></p>
<p><strong>二叉Trie</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171947889.png" alt="image-20220306142001259"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171947725.png" alt="image-20220306142538994"></p>
<p><strong>后缀树（Suffix Trees）</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171947490.png" alt="image-20220306142857276"></p>
<p><strong>后缀数组 (Suffix Array)</strong></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171948286.png" alt="image-20220306143836110"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171948166.png" alt="image-20220306143850665"></p>
<h3 id="伸展树Splay"><a href="#伸展树Splay" class="headerlink" title="伸展树Splay"></a>伸展树Splay</h3><p>一种自组织数据结构</p>
<ul>
<li>数据随检索而调整位置</li>
<li>汉字输入法的词表，如：输入法输入<code>ss</code>出来第一个是<code>生生</code>(原先可能不是)，就是根据你使用次数调整的</li>
</ul>
<p>伸展树不是一个新数据结构，而只是改进 BST 性能的一组规则</p>
<ul>
<li>保证访问的总代价不高，达到最令人满意的性能</li>
<li>不能保证最终树高平衡</li>
</ul>
<p>访问一次结点 (例如结点 x) ，完成一次称为展开的过程</p>
<ul>
<li>x 被插入、检索时，把结点 x 移到 BST 的根结点</li>
<li>删除结点 x 时，把结点 x 的父结点移到根结点</li>
</ul>
<p>像在 AVL 树中一样，结点x的一次展开包括一组旋转(rotation) </p>
<ul>
<li>调整结点 x、父结点、祖父结点的位置</li>
<li>把 x 移到树结构中的更高层</li>
</ul>
<p><strong>单旋转 (single rotation) </strong></p>
<p>x 是根结点的直接子结点时</p>
<ul>
<li>把结点 x 与它的父结点交换位置</li>
<li>保持 BST 特性</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171948789.png" alt="image-20220306151223735"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171949370.png" alt="image-20220306153407987"></p>
<p><strong>双旋转 (double rotation) </strong></p>
<p>双旋转涉及到</p>
<ul>
<li>结点 x</li>
<li>结点 x 的父结点 (称为 y) </li>
<li>结点 x 的祖父结点 (称为 z) </li>
</ul>
<p>把结点 x 在树结构中向上移两层</p>
<p>一字形旋转 (zigzig rotation) 也称为同构调整 (homogeneous configuration) </p>
<p>之字形旋转 (zigzag rotation) 也称为异构调整 (heterogeneous configuration) </p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171949351.png" alt="image-20220306154212520"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171949277.png" alt="image-20220306153313634"></p>
<p><strong>两种旋转的不同作用</strong></p>
<p>之字形旋转</p>
<ul>
<li>把新访问的记录向根结点移动</li>
<li>使子树结构的高度减1</li>
<li>趋向于使树结构更加平衡</li>
</ul>
<p>一字形提升</p>
<ul>
<li>一般不会降低树结构的高度</li>
<li>只是把新访问的记录向根结点移动</li>
</ul>
<p><strong>伸展树的调整过程</strong></p>
<ul>
<li>一系列双旋转，直到结点 x 到达根结点或者根结点的子结点</li>
<li>如果结点x到达根结点的子结点进行一次单旋转使结点 x 成为根结点</li>
<li>这个过程趋向于使树结构重新平衡，使访问最频繁的结点靠近树结构的根层，从而减少访问代价</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171949652.png" alt="image-20220306152402718"></p>
<p><strong>与AVL树的差别</strong></p>
<p>伸展树与结点被访问的频率相关根据插入、删除、检索动态地调整。</p>
<p>而 AVL 树的结构与访问频率无关只与插入、删除的顺序有关。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171949327.png" alt="image-20220306154340706"></p>
<h3 id="红黑树RBT"><a href="#红黑树RBT" class="headerlink" title="红黑树RBT"></a>红黑树RBT</h3><p>红黑树<strong>（red-black tree）</strong>：平衡的 扩充 二叉搜索树</p>
<p>颜色特征：结点是 红色 或 黑色；</p>
<ul>
<li>根特征 ：根结点永远是 黑色 的；</li>
<li>外部特征：扩充外部叶结点都是空的 黑色结点；</li>
<li>内部特征：红色结点的两个子结点都是黑色的，不允许两个连续的红色结点；</li>
<li>深度特征：任何结点到其子孙外部结点的每条简单路径都包含相同数目的“黑色”结点</li>
</ul>
<p><strong>红黑树的阶</strong></p>
<p>结点$X$的阶（rank，也称“黑色高度”）</p>
<ul>
<li>从该结点到外部结点的黑色结点数量</li>
<li>不包括 $X$ 结点本身，包括叶结点</li>
</ul>
<p>外部结点的阶是零，根的阶称为该树的阶。</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171949489.png" alt="image-20220306155715286"></p>
<p><strong>红黑树的性质</strong></p>
<p>红黑树是满二叉树，空叶结点也看作结点</p>
<p>阶为 $k$ 的红黑树路径长度 最短是 $k$，最长是 $2k$ ，从根到叶的简单路径长度</p>
<p>阶为 $k$ 的红黑树树高最小是 $k+1$，最高是 $2k+1$</p>
<p>阶为$k$的红黑树的内部结点最少是一棵完全满二叉树，内部结点数最少是 $2^k-1$</p>
<p>$n$ 个内部结点的红黑树树高最大是 $2\log_2(n+1)+1$</p>
<p><strong>红黑树的插入</strong></p>
<p>先调用 BST 的插入算法</p>
<ul>
<li>把新记录着色为红色</li>
<li><p>若父结点是黑色，则算法结束</p>
</li>
<li><p>否则，双红调整</p>
</li>
</ul>
<p>调整方法一：重构</p>
<p>情况：新增结点$X$的叔父$C$节点是黑色</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171950601.png" alt="image-20220306161526842"></p>
<p>调整方法二：换色</p>
<p>情况：新增结点 $X$ 的叔父结点$C$也是红色</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171950004.png" alt="image-20220306161629875"></p>
<p>示例：</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171950516.png" alt="image-20220306162037828"></p>
<p><strong>红黑树的删除</strong></p>
<p>先调用 BST 的删除算法</p>
<ul>
<li>待删除的结点有一个以上的外部空指针，则直接删除</li>
<li>否则在右子树中找到其后继结点进行值交换（着色不变）删除</li>
</ul>
<p>$v$ 是被删除的内结点, $w$ 是被删外结点, $X$ 是 $w$ 的兄弟</p>
<ul>
<li>如果 $v$ 或者 $X$ 是红色, 则把 $X$ 标记为黑色即可</li>
<li>否则, $X$ 需要标记为双黑（即承担两层黑色）, 根据其兄弟结点 $C$ 进行重构调整 </li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171951821.png" alt="image-20220306163200522"></p>
<p><strong>双黑调整</strong></p>
<p>假设 $X$ 是左子结点（若$X$为右孩子，则对称）</p>
<ul>
<li>情况 1： $C$ 是黑色，且子结点有红色<ul>
<li>重构，完成操作</li>
</ul>
</li>
<li>情况 2：$C$ 是黑色, 且有两个黑子结点<ul>
<li>换色</li>
<li>若父结点 $B$ 原为黑色，可能需要从 $B$ 继续向上调整</li>
</ul>
</li>
<li>情况 3： $C$ 是红色<ul>
<li>转换状态</li>
<li>$C$ 转为父结点，调整为情况 1 或 2 继续处理</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171951241.png" alt="image-20220306164319716"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171951301.png" alt="image-20220306164413715"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171951404.png" alt="image-20220306164540180"></p>
<p>示例：</p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171952589.png" alt="image-20220306165510731"></p>
<p><img src="https://gitee.com/yanglinqi107/Images/raw/master/res/202205171953516.png" alt="image-20220306170037324"></p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      
      
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">什么是数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.2.</span> <span class="nav-text">术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">1.3.</span> <span class="nav-text">算法和算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">顺序表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">2.2.</span> <span class="nav-text">链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">栈和队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2"><span class="nav-number">4.</span> <span class="nav-text">串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">串的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.</span> <span class="nav-text">串的存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">4.3.</span> <span class="nav-text">模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BF%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.1.</span> <span class="nav-text">BF算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.2.</span> <span class="nav-text">KMP算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">5.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">5.1.</span> <span class="nav-text">数组的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-number">5.2.</span> <span class="nav-text">数组的顺序存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-number">5.3.</span> <span class="nav-text">矩阵的压缩存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-number">5.3.1.</span> <span class="nav-text">特殊矩阵的压缩存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-number">5.3.2.</span> <span class="nav-text">稀疏矩阵的压缩存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-number">6.</span> <span class="nav-text">广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">6.1.</span> <span class="nav-text">广义表的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.</span> <span class="nav-text">广义表的存储结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">7.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-number">7.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">7.2.</span> <span class="nav-text">存储结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">8.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%86%E7%B1%BB"><span class="nav-number">8.1.</span> <span class="nav-text">二叉树分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">8.2.</span> <span class="nav-text">二叉树的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-number">8.3.</span> <span class="nav-text">二叉树的存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">8.4.</span> <span class="nav-text">二叉树的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.5.</span> <span class="nav-text">遍历算法实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">8.6.</span> <span class="nav-text">线索二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Huffman%E6%A0%91"><span class="nav-number">8.7.</span> <span class="nav-text">Huffman树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">8.8.</span> <span class="nav-text">树、森林转换二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">9.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="nav-number">9.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-1"><span class="nav-number">9.2.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">9.3.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-Depth-First-Search"><span class="nav-number">9.3.1.</span> <span class="nav-text">深度优先搜索(Depth First Search)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-Breadth-First-Search"><span class="nav-number">9.3.2.</span> <span class="nav-text">广度优先搜索(Breadth First Search)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">9.4.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruscal%E7%AE%97%E6%B3%95"><span class="nav-number">9.4.1.</span> <span class="nav-text">Kruscal算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prim%E7%AE%97%E6%B3%95"><span class="nav-number">9.4.2.</span> <span class="nav-text">prim算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">9.5.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-number">9.6.</span> <span class="nav-text">关键路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">9.7.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">9.7.1.</span> <span class="nav-text">Dijkstra算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Floyd%E7%AE%97%E6%B3%95"><span class="nav-number">9.7.2.</span> <span class="nav-text">Floyd算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-number">10.</span> <span class="nav-text">查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">10.1.</span> <span class="nav-text">静态表的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-number">10.1.1.</span> <span class="nav-text">顺序查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86-%E6%8A%98%E5%8D%8A-%E6%9F%A5%E6%89%BE"><span class="nav-number">10.1.2.</span> <span class="nav-text">二分(折半)查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">10.1.3.</span> <span class="nav-text">索引顺序表的查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">10.1.4.</span> <span class="nav-text">静态树表的查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">10.2.</span> <span class="nav-text">动态表的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91BST"><span class="nav-number">10.2.1.</span> <span class="nav-text">二叉排序树BST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL"><span class="nav-number">10.2.2.</span> <span class="nav-text">平衡二叉树AVL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91"><span class="nav-number">10.2.3.</span> <span class="nav-text">B-树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91-1"><span class="nav-number">10.2.4.</span> <span class="nav-text">B+树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash-%E6%95%A3%E5%88%97-%E6%9F%A5%E6%89%BE"><span class="nav-number">10.3.</span> <span class="nav-text">hash(散列)查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0hash%E5%87%BD%E6%95%B0"><span class="nav-number">10.3.1.</span> <span class="nav-text">构造hash函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86"><span class="nav-number">10.3.2.</span> <span class="nav-text">冲突处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hash%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">10.3.3.</span> <span class="nav-text">hash表的查找</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">11.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%88%86%E7%B1%BB"><span class="nav-number">11.1.</span> <span class="nav-text">概念及分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="nav-number">12.</span> <span class="nav-text">内部排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">12.1.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">12.1.1.</span> <span class="nav-text">直接插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94-shell-%E6%8E%92%E5%BA%8F"><span class="nav-number">12.1.2.</span> <span class="nav-text">希尔(shell)排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="nav-number">12.2.</span> <span class="nav-text">交换排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">12.2.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">12.2.2.</span> <span class="nav-text">快速排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">12.3.</span> <span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">12.3.1.</span> <span class="nav-text">简单选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2%E6%8E%92%E5%BA%8F"><span class="nav-number">12.3.2.</span> <span class="nav-text">树形排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F-Heap-Sort"><span class="nav-number">12.3.3.</span> <span class="nav-text">堆排序(Heap Sort)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">12.4.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">12.5.</span> <span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">12.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="nav-number">13.</span> <span class="nav-text">外部排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%92%8C%E5%A4%96%E5%AD%98"><span class="nav-number">13.1.</span> <span class="nav-text">内存和外存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E5%B8%A6"><span class="nav-number">13.2.</span> <span class="nav-text">磁带</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98"><span class="nav-number">13.3.</span> <span class="nav-text">磁盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">13.4.</span> <span class="nav-text">外部排序的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E5%BD%92%E5%B9%B6"><span class="nav-number">13.5.</span> <span class="nav-text">多路平衡归并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">13.6.</span> <span class="nav-text">置换-选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="nav-number">13.7.</span> <span class="nav-text">最佳归并树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">14.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Trie-%E6%A0%91"><span class="nav-number">14.1.</span> <span class="nav-text">Trie 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%B8%E5%B1%95%E6%A0%91Splay"><span class="nav-number">14.2.</span> <span class="nav-text">伸展树Splay</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91RBT"><span class="nav-number">14.3.</span> <span class="nav-text">红黑树RBT</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yanglinqi"
      src="/images/headpic.jpg">
  <p class="site-author-name" itemprop="name">yanglinqi</p>
  <div class="site-description" itemprop="description">用于做笔记，对学过的知识总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">100</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yanglinqi107" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanglinqi107" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yanglinqi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


  <script async src="/js/cursor/fireworks.js"></script>


</body>
</html>
